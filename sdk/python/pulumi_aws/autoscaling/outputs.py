# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GroupInitialLifecycleHook',
    'GroupInstanceRefresh',
    'GroupInstanceRefreshPreferences',
    'GroupLaunchTemplate',
    'GroupMixedInstancesPolicy',
    'GroupMixedInstancesPolicyInstancesDistribution',
    'GroupMixedInstancesPolicyLaunchTemplate',
    'GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification',
    'GroupMixedInstancesPolicyLaunchTemplateOverride',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification',
    'GroupTag',
    'GroupTrafficSource',
    'GroupWarmPool',
    'GroupWarmPoolInstanceReusePolicy',
    'PolicyPredictiveScalingConfiguration',
    'PolicyPredictiveScalingConfigurationMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification',
    'PolicyStepAdjustment',
    'PolicyTargetTrackingConfiguration',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecification',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension',
    'PolicyTargetTrackingConfigurationPredefinedMetricSpecification',
    'TagTag',
    'TrafficSourceAttachmentTrafficSource',
    'GetAmiIdsFilterResult',
    'GetGroupLaunchTemplateResult',
    'GetGroupMixedInstancesPolicyResult',
    'GetGroupMixedInstancesPolicyInstancesDistributionResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult',
    'GetGroupTagResult',
    'GetGroupTrafficSourceResult',
    'GetGroupWarmPoolResult',
    'GetGroupWarmPoolInstanceReusePolicyResult',
]

@pulumi.output_type
class GroupInitialLifecycleHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecycleTransition":
            suggest = "lifecycle_transition"
        elif key == "defaultResult":
            suggest = "default_result"
        elif key == "heartbeatTimeout":
            suggest = "heartbeat_timeout"
        elif key == "notificationMetadata":
            suggest = "notification_metadata"
        elif key == "notificationTargetArn":
            suggest = "notification_target_arn"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInitialLifecycleHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInitialLifecycleHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInitialLifecycleHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_transition: str,
                 name: str,
                 default_result: Optional[str] = None,
                 heartbeat_timeout: Optional[int] = None,
                 notification_metadata: Optional[str] = None,
                 notification_target_arn: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        :param str name: Name of the Auto Scaling Group. By default generated by Pulumi. Conflicts with `name_prefix`.
        """
        pulumi.set(__self__, "lifecycle_transition", lifecycle_transition)
        pulumi.set(__self__, "name", name)
        if default_result is not None:
            pulumi.set(__self__, "default_result", default_result)
        if heartbeat_timeout is not None:
            pulumi.set(__self__, "heartbeat_timeout", heartbeat_timeout)
        if notification_metadata is not None:
            pulumi.set(__self__, "notification_metadata", notification_metadata)
        if notification_target_arn is not None:
            pulumi.set(__self__, "notification_target_arn", notification_target_arn)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="lifecycleTransition")
    def lifecycle_transition(self) -> str:
        return pulumi.get(self, "lifecycle_transition")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Auto Scaling Group. By default generated by Pulumi. Conflicts with `name_prefix`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> Optional[str]:
        return pulumi.get(self, "default_result")

    @property
    @pulumi.getter(name="heartbeatTimeout")
    def heartbeat_timeout(self) -> Optional[int]:
        return pulumi.get(self, "heartbeat_timeout")

    @property
    @pulumi.getter(name="notificationMetadata")
    def notification_metadata(self) -> Optional[str]:
        return pulumi.get(self, "notification_metadata")

    @property
    @pulumi.getter(name="notificationTargetArn")
    def notification_target_arn(self) -> Optional[str]:
        return pulumi.get(self, "notification_target_arn")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GroupInstanceRefresh(dict):
    def __init__(__self__, *,
                 strategy: str,
                 preferences: Optional['outputs.GroupInstanceRefreshPreferences'] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str strategy: Strategy to use for instance refresh. The only allowed value is `Rolling`. See [StartInstanceRefresh Action](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_StartInstanceRefresh.html#API_StartInstanceRefresh_RequestParameters) for more information.
        :param 'GroupInstanceRefreshPreferencesArgs' preferences: Override default parameters for Instance Refresh.
        :param Sequence[str] triggers: Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of `launch_configuration`, `launch_template`, or `mixed_instances_policy`.
               
               > **NOTE:** A refresh is started when any of the following Auto Scaling Group properties change: `launch_configuration`, `launch_template`, `mixed_instances_policy`. Additional properties can be specified in the `triggers` property of `instance_refresh`.
               
               > **NOTE:** A refresh will not start when `version = "$Latest"` is configured in the `launch_template` block. To trigger the instance refresh when a launch template is changed, configure `version` to use the `latest_version` attribute of the `ec2.LaunchTemplate` resource.
               
               > **NOTE:** Auto Scaling Groups support up to one active instance refresh at a time. When this resource is updated, any existing refresh is cancelled.
               
               > **NOTE:** Depending on health check settings and group size, an instance refresh may take a long time or fail. This resource does not wait for the instance refresh to complete.
        """
        pulumi.set(__self__, "strategy", strategy)
        if preferences is not None:
            pulumi.set(__self__, "preferences", preferences)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Strategy to use for instance refresh. The only allowed value is `Rolling`. See [StartInstanceRefresh Action](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_StartInstanceRefresh.html#API_StartInstanceRefresh_RequestParameters) for more information.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def preferences(self) -> Optional['outputs.GroupInstanceRefreshPreferences']:
        """
        Override default parameters for Instance Refresh.
        """
        return pulumi.get(self, "preferences")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of `launch_configuration`, `launch_template`, or `mixed_instances_policy`.

        > **NOTE:** A refresh is started when any of the following Auto Scaling Group properties change: `launch_configuration`, `launch_template`, `mixed_instances_policy`. Additional properties can be specified in the `triggers` property of `instance_refresh`.

        > **NOTE:** A refresh will not start when `version = "$Latest"` is configured in the `launch_template` block. To trigger the instance refresh when a launch template is changed, configure `version` to use the `latest_version` attribute of the `ec2.LaunchTemplate` resource.

        > **NOTE:** Auto Scaling Groups support up to one active instance refresh at a time. When this resource is updated, any existing refresh is cancelled.

        > **NOTE:** Depending on health check settings and group size, an instance refresh may take a long time or fail. This resource does not wait for the instance refresh to complete.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GroupInstanceRefreshPreferences(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRollback":
            suggest = "auto_rollback"
        elif key == "checkpointDelay":
            suggest = "checkpoint_delay"
        elif key == "checkpointPercentages":
            suggest = "checkpoint_percentages"
        elif key == "instanceWarmup":
            suggest = "instance_warmup"
        elif key == "minHealthyPercentage":
            suggest = "min_healthy_percentage"
        elif key == "scaleInProtectedInstances":
            suggest = "scale_in_protected_instances"
        elif key == "skipMatching":
            suggest = "skip_matching"
        elif key == "standbyInstances":
            suggest = "standby_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInstanceRefreshPreferences. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInstanceRefreshPreferences.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInstanceRefreshPreferences.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_rollback: Optional[bool] = None,
                 checkpoint_delay: Optional[str] = None,
                 checkpoint_percentages: Optional[Sequence[int]] = None,
                 instance_warmup: Optional[str] = None,
                 min_healthy_percentage: Optional[int] = None,
                 scale_in_protected_instances: Optional[str] = None,
                 skip_matching: Optional[bool] = None,
                 standby_instances: Optional[str] = None):
        """
        :param bool auto_rollback: Automatically rollback if instance refresh fails. Defaults to `false`. This option may only be set to `true` when specifying a `launch_template` or `mixed_instances_policy`.
        :param str checkpoint_delay: Number of seconds to wait after a checkpoint. Defaults to `3600`.
        :param Sequence[int] checkpoint_percentages: List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be `100`.
        :param str instance_warmup: Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
        :param int min_healthy_percentage: Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to `90`.
        :param str scale_in_protected_instances: Behavior when encountering instances protected from scale in are found. Available behaviors are `Refresh`, `Ignore`, and `Wait`. Default is `Ignore`.
        :param bool skip_matching: Replace instances that already have your desired configuration. Defaults to `false`.
        :param str standby_instances: Behavior when encountering instances in the `Standby` state in are found. Available behaviors are `Terminate`, `Ignore`, and `Wait`. Default is `Ignore`.
        """
        if auto_rollback is not None:
            pulumi.set(__self__, "auto_rollback", auto_rollback)
        if checkpoint_delay is not None:
            pulumi.set(__self__, "checkpoint_delay", checkpoint_delay)
        if checkpoint_percentages is not None:
            pulumi.set(__self__, "checkpoint_percentages", checkpoint_percentages)
        if instance_warmup is not None:
            pulumi.set(__self__, "instance_warmup", instance_warmup)
        if min_healthy_percentage is not None:
            pulumi.set(__self__, "min_healthy_percentage", min_healthy_percentage)
        if scale_in_protected_instances is not None:
            pulumi.set(__self__, "scale_in_protected_instances", scale_in_protected_instances)
        if skip_matching is not None:
            pulumi.set(__self__, "skip_matching", skip_matching)
        if standby_instances is not None:
            pulumi.set(__self__, "standby_instances", standby_instances)

    @property
    @pulumi.getter(name="autoRollback")
    def auto_rollback(self) -> Optional[bool]:
        """
        Automatically rollback if instance refresh fails. Defaults to `false`. This option may only be set to `true` when specifying a `launch_template` or `mixed_instances_policy`.
        """
        return pulumi.get(self, "auto_rollback")

    @property
    @pulumi.getter(name="checkpointDelay")
    def checkpoint_delay(self) -> Optional[str]:
        """
        Number of seconds to wait after a checkpoint. Defaults to `3600`.
        """
        return pulumi.get(self, "checkpoint_delay")

    @property
    @pulumi.getter(name="checkpointPercentages")
    def checkpoint_percentages(self) -> Optional[Sequence[int]]:
        """
        List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be `100`.
        """
        return pulumi.get(self, "checkpoint_percentages")

    @property
    @pulumi.getter(name="instanceWarmup")
    def instance_warmup(self) -> Optional[str]:
        """
        Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
        """
        return pulumi.get(self, "instance_warmup")

    @property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> Optional[int]:
        """
        Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to `90`.
        """
        return pulumi.get(self, "min_healthy_percentage")

    @property
    @pulumi.getter(name="scaleInProtectedInstances")
    def scale_in_protected_instances(self) -> Optional[str]:
        """
        Behavior when encountering instances protected from scale in are found. Available behaviors are `Refresh`, `Ignore`, and `Wait`. Default is `Ignore`.
        """
        return pulumi.get(self, "scale_in_protected_instances")

    @property
    @pulumi.getter(name="skipMatching")
    def skip_matching(self) -> Optional[bool]:
        """
        Replace instances that already have your desired configuration. Defaults to `false`.
        """
        return pulumi.get(self, "skip_matching")

    @property
    @pulumi.getter(name="standbyInstances")
    def standby_instances(self) -> Optional[str]:
        """
        Behavior when encountering instances in the `Standby` state in are found. Available behaviors are `Terminate`, `Ignore`, and `Wait`. Default is `Ignore`.
        """
        return pulumi.get(self, "standby_instances")


@pulumi.output_type
class GroupLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: ID of the launch template. Conflicts with `name`.
        :param str name: Name of the launch template. Conflicts with `id`.
        :param str version: Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupMixedInstancesPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplate":
            suggest = "launch_template"
        elif key == "instancesDistribution":
            suggest = "instances_distribution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template: 'outputs.GroupMixedInstancesPolicyLaunchTemplate',
                 instances_distribution: Optional['outputs.GroupMixedInstancesPolicyInstancesDistribution'] = None):
        """
        :param 'GroupMixedInstancesPolicyLaunchTemplateArgs' launch_template: Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        :param 'GroupMixedInstancesPolicyInstancesDistributionArgs' instances_distribution: Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
        """
        pulumi.set(__self__, "launch_template", launch_template)
        if instances_distribution is not None:
            pulumi.set(__self__, "instances_distribution", instances_distribution)

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> 'outputs.GroupMixedInstancesPolicyLaunchTemplate':
        """
        Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        """
        return pulumi.get(self, "launch_template")

    @property
    @pulumi.getter(name="instancesDistribution")
    def instances_distribution(self) -> Optional['outputs.GroupMixedInstancesPolicyInstancesDistribution']:
        """
        Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
        """
        return pulumi.get(self, "instances_distribution")


@pulumi.output_type
class GroupMixedInstancesPolicyInstancesDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyInstancesDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyInstancesDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyInstancesDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_base_capacity: Optional[int] = None,
                 on_demand_percentage_above_base_capacity: Optional[int] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 spot_instance_pools: Optional[int] = None,
                 spot_max_price: Optional[str] = None):
        """
        :param str on_demand_allocation_strategy: Strategy to use when launching on-demand instances. Valid values: `prioritized`, `lowest-price`. Default: `prioritized`.
        :param int on_demand_base_capacity: Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
        :param int on_demand_percentage_above_base_capacity: Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
        :param str spot_allocation_strategy: How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`, `capacity-optimized-prioritized`, and `price-capacity-optimized`. Default: `lowest-price`.
        :param int spot_instance_pools: Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Only available with `spot_allocation_strategy` set to `lowest-price`. Otherwise it must be set to `0`, if it has been defined before. Default: `2`.
        :param str spot_max_price: Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
        """
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_base_capacity is not None:
            pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if spot_instance_pools is not None:
            pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        """
        Strategy to use when launching on-demand instances. Valid values: `prioritized`, `lowest-price`. Default: `prioritized`.
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[int]:
        """
        Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
        """
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[int]:
        """
        Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
        """
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        """
        How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`, `capacity-optimized-prioritized`, and `price-capacity-optimized`. Default: `lowest-price`.
        """
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> Optional[int]:
        """
        Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Only available with `spot_allocation_strategy` set to `lowest-price`. Otherwise it must be set to `0`, if it has been defined before. Default: `2`.
        """
        return pulumi.get(self, "spot_instance_pools")

    @property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[str]:
        """
        Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
        """
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.GroupMixedInstancesPolicyLaunchTemplateOverride']] = None):
        """
        :param 'GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs' launch_template_specification: Override the instance launch template specification in the Launch Template.
        :param Sequence['GroupMixedInstancesPolicyLaunchTemplateOverrideArgs'] overrides: List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
        """
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification':
        """
        Override the instance launch template specification in the Launch Template.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.GroupMixedInstancesPolicyLaunchTemplateOverride']]:
        """
        List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str launch_template_id: ID of the launch template. Conflicts with `launch_template_name`.
        :param str launch_template_name: Name of the launch template. Conflicts with `launch_template_id`.
        :param str version: Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        ID of the launch template. Conflicts with `launch_template_name`.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        Name of the launch template. Conflicts with `launch_template_id`.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "launchTemplateSpecification":
            suggest = "launch_template_specification"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_requirements: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 launch_template_specification: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification'] = None,
                 weighted_capacity: Optional[str] = None):
        """
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsArgs' instance_requirements: Override the instance type in the Launch Template with instance types that satisfy the requirements.
        :param str instance_type: Override the instance type in the Launch Template.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationArgs' launch_template_specification: Override the instance launch template specification in the Launch Template.
        :param str weighted_capacity: Number of capacity units, which gives the instance type a proportional weight to other instance types.
        """
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements']:
        """
        Override the instance type in the Launch Template with instance types that satisfy the requirements.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Override the instance type in the Launch Template.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification']:
        """
        Override the instance launch template specification in the Launch Template.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[str]:
        """
        Number of capacity units, which gives the instance type a proportional weight to other instance types.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "memoryMib":
            suggest = "memory_mib"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vcpuCount":
            suggest = "vcpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 memory_mib: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib'] = None,
                 network_bandwidth_gbps: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
                 vcpu_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount'] = None):
        """
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        :param Sequence[str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] accelerator_names: List of accelerator names. Default is any acclerator.
               
               ```python
               import pulumi
               ```
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[str] accelerator_types: List of accelerator types. Default is any accelerator type.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] allowed_instance_types: List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
               
               > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        :param str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param str burstable_performance: Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[str] cpu_manufacturers: List of CPU manufacturer names. Default is any manufacturer.
               
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] excluded_instance_types: List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        :param Sequence[str] instance_generations: List of instance generation names. Default is any generation.
               
               ```python
               import pulumi
               ```
        :param str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[str] local_storage_types: List of local storage type names. Default any storage type.
               
               ```python
               import pulumi
               ```
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMibArgs' memory_mib: Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param int on_demand_max_price_percentage_over_lowest_price: Price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param int spot_max_price_percentage_over_lowest_price: Price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        :param 'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if vcpu_count is not None:
            pulumi.set(__self__, "vcpu_count", vcpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        List of accelerator names. Default is any acclerator.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        List of accelerator types. Default is any accelerator type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.

        > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of CPU manufacturer names. Default is any manufacturer.

        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        List of instance generation names. Default is any generation.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        List of local storage type names. Default any storage type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib']:
        """
        Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        """
        return pulumi.get(self, "memory_mib")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps']:
        """
        Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        Price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        Price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount']:
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str launch_template_id: ID of the launch template. Conflicts with `launch_template_name`.
        :param str launch_template_name: Name of the launch template. Conflicts with `launch_template_id`.
        :param str version: Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        ID of the launch template. Conflicts with `launch_template_name`.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        Name of the launch template. Conflicts with `launch_template_id`.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 propagate_at_launch: bool,
                 value: str):
        """
        :param str key: Key
        :param bool propagate_at_launch: Enables propagation of the tag to
               Amazon EC2 instances launched via this ASG
               
               To declare multiple tags, additional `tag` blocks can be specified.
               
               > **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so the provider does not attempt to remove them and so if the `min_size` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service.
        :param str value: Value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> bool:
        """
        Enables propagation of the tag to
        Amazon EC2 instances launched via this ASG

        To declare multiple tags, additional `tag` blocks can be specified.

        > **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so the provider does not attempt to remove them and so if the `min_size` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service.
        """
        return pulumi.get(self, "propagate_at_launch")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupTrafficSource(dict):
    def __init__(__self__, *,
                 identifier: str,
                 type: Optional[str] = None):
        """
        :param str identifier: Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        :param str type: Provides additional context for the value of Identifier.
               The following lists the valid values:
               `elb` if `identifier` is the name of a Classic Load Balancer.
               `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
               `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
        """
        pulumi.set(__self__, "identifier", identifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Provides additional context for the value of Identifier.
        The following lists the valid values:
        `elb` if `identifier` is the name of a Classic Load Balancer.
        `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
        `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GroupWarmPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceReusePolicy":
            suggest = "instance_reuse_policy"
        elif key == "maxGroupPreparedCapacity":
            suggest = "max_group_prepared_capacity"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "poolState":
            suggest = "pool_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupWarmPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupWarmPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupWarmPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_reuse_policy: Optional['outputs.GroupWarmPoolInstanceReusePolicy'] = None,
                 max_group_prepared_capacity: Optional[int] = None,
                 min_size: Optional[int] = None,
                 pool_state: Optional[str] = None):
        """
        :param 'GroupWarmPoolInstanceReusePolicyArgs' instance_reuse_policy: Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
        :param int max_group_prepared_capacity: Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
        :param int min_size: Minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
        :param str pool_state: Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
        """
        if instance_reuse_policy is not None:
            pulumi.set(__self__, "instance_reuse_policy", instance_reuse_policy)
        if max_group_prepared_capacity is not None:
            pulumi.set(__self__, "max_group_prepared_capacity", max_group_prepared_capacity)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if pool_state is not None:
            pulumi.set(__self__, "pool_state", pool_state)

    @property
    @pulumi.getter(name="instanceReusePolicy")
    def instance_reuse_policy(self) -> Optional['outputs.GroupWarmPoolInstanceReusePolicy']:
        """
        Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
        """
        return pulumi.get(self, "instance_reuse_policy")

    @property
    @pulumi.getter(name="maxGroupPreparedCapacity")
    def max_group_prepared_capacity(self) -> Optional[int]:
        """
        Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
        """
        return pulumi.get(self, "max_group_prepared_capacity")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        """
        Minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="poolState")
    def pool_state(self) -> Optional[str]:
        """
        Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
        """
        return pulumi.get(self, "pool_state")


@pulumi.output_type
class GroupWarmPoolInstanceReusePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reuseOnScaleIn":
            suggest = "reuse_on_scale_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupWarmPoolInstanceReusePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupWarmPoolInstanceReusePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupWarmPoolInstanceReusePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reuse_on_scale_in: Optional[bool] = None):
        """
        :param bool reuse_on_scale_in: Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
        """
        if reuse_on_scale_in is not None:
            pulumi.set(__self__, "reuse_on_scale_in", reuse_on_scale_in)

    @property
    @pulumi.getter(name="reuseOnScaleIn")
    def reuse_on_scale_in(self) -> Optional[bool]:
        """
        Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
        """
        return pulumi.get(self, "reuse_on_scale_in")


@pulumi.output_type
class PolicyPredictiveScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSpecification":
            suggest = "metric_specification"
        elif key == "maxCapacityBreachBehavior":
            suggest = "max_capacity_breach_behavior"
        elif key == "maxCapacityBuffer":
            suggest = "max_capacity_buffer"
        elif key == "schedulingBufferTime":
            suggest = "scheduling_buffer_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_specification: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecification',
                 max_capacity_breach_behavior: Optional[str] = None,
                 max_capacity_buffer: Optional[str] = None,
                 mode: Optional[str] = None,
                 scheduling_buffer_time: Optional[str] = None):
        """
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationArgs' metric_specification: This structure includes the metrics and target utilization to use for predictive scaling.
        :param str max_capacity_breach_behavior: Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are `HonorMaxCapacity` or `IncreaseMaxCapacity`. Default is `HonorMaxCapacity`.
        :param str max_capacity_buffer: Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is `0` to `100`. If set to `0`, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
        :param str mode: Predictive scaling mode. Valid values are `ForecastAndScale` and `ForecastOnly`. Default is `ForecastOnly`.
        :param str scheduling_buffer_time: Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is `0`.
        """
        pulumi.set(__self__, "metric_specification", metric_specification)
        if max_capacity_breach_behavior is not None:
            pulumi.set(__self__, "max_capacity_breach_behavior", max_capacity_breach_behavior)
        if max_capacity_buffer is not None:
            pulumi.set(__self__, "max_capacity_buffer", max_capacity_buffer)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scheduling_buffer_time is not None:
            pulumi.set(__self__, "scheduling_buffer_time", scheduling_buffer_time)

    @property
    @pulumi.getter(name="metricSpecification")
    def metric_specification(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecification':
        """
        This structure includes the metrics and target utilization to use for predictive scaling.
        """
        return pulumi.get(self, "metric_specification")

    @property
    @pulumi.getter(name="maxCapacityBreachBehavior")
    def max_capacity_breach_behavior(self) -> Optional[str]:
        """
        Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are `HonorMaxCapacity` or `IncreaseMaxCapacity`. Default is `HonorMaxCapacity`.
        """
        return pulumi.get(self, "max_capacity_breach_behavior")

    @property
    @pulumi.getter(name="maxCapacityBuffer")
    def max_capacity_buffer(self) -> Optional[str]:
        """
        Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is `0` to `100`. If set to `0`, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
        """
        return pulumi.get(self, "max_capacity_buffer")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Predictive scaling mode. Valid values are `ForecastAndScale` and `ForecastOnly`. Default is `ForecastOnly`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="schedulingBufferTime")
    def scheduling_buffer_time(self) -> Optional[str]:
        """
        Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is `0`.
        """
        return pulumi.get(self, "scheduling_buffer_time")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedCapacityMetricSpecification":
            suggest = "customized_capacity_metric_specification"
        elif key == "customizedLoadMetricSpecification":
            suggest = "customized_load_metric_specification"
        elif key == "customizedScalingMetricSpecification":
            suggest = "customized_scaling_metric_specification"
        elif key == "predefinedLoadMetricSpecification":
            suggest = "predefined_load_metric_specification"
        elif key == "predefinedMetricPairSpecification":
            suggest = "predefined_metric_pair_specification"
        elif key == "predefinedScalingMetricSpecification":
            suggest = "predefined_scaling_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float,
                 customized_capacity_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification'] = None,
                 customized_load_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification'] = None,
                 customized_scaling_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification'] = None,
                 predefined_load_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification'] = None,
                 predefined_metric_pair_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification'] = None,
                 predefined_scaling_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification'] = None):
        """
        :param float target_value: Target value for the metric.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationArgs' customized_capacity_metric_specification: Customized capacity metric specification. The field is only valid when you use `customized_load_metric_specification`
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationArgs' customized_load_metric_specification: Customized load metric specification.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationArgs' customized_scaling_metric_specification: Customized scaling metric specification.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecificationArgs' predefined_load_metric_specification: Predefined load metric specification.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecificationArgs' predefined_metric_pair_specification: Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecificationArgs' predefined_scaling_metric_specification: Predefined scaling metric specification.
        """
        pulumi.set(__self__, "target_value", target_value)
        if customized_capacity_metric_specification is not None:
            pulumi.set(__self__, "customized_capacity_metric_specification", customized_capacity_metric_specification)
        if customized_load_metric_specification is not None:
            pulumi.set(__self__, "customized_load_metric_specification", customized_load_metric_specification)
        if customized_scaling_metric_specification is not None:
            pulumi.set(__self__, "customized_scaling_metric_specification", customized_scaling_metric_specification)
        if predefined_load_metric_specification is not None:
            pulumi.set(__self__, "predefined_load_metric_specification", predefined_load_metric_specification)
        if predefined_metric_pair_specification is not None:
            pulumi.set(__self__, "predefined_metric_pair_specification", predefined_metric_pair_specification)
        if predefined_scaling_metric_specification is not None:
            pulumi.set(__self__, "predefined_scaling_metric_specification", predefined_scaling_metric_specification)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        """
        Target value for the metric.
        """
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter(name="customizedCapacityMetricSpecification")
    def customized_capacity_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification']:
        """
        Customized capacity metric specification. The field is only valid when you use `customized_load_metric_specification`
        """
        return pulumi.get(self, "customized_capacity_metric_specification")

    @property
    @pulumi.getter(name="customizedLoadMetricSpecification")
    def customized_load_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification']:
        """
        Customized load metric specification.
        """
        return pulumi.get(self, "customized_load_metric_specification")

    @property
    @pulumi.getter(name="customizedScalingMetricSpecification")
    def customized_scaling_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification']:
        """
        Customized scaling metric specification.
        """
        return pulumi.get(self, "customized_scaling_metric_specification")

    @property
    @pulumi.getter(name="predefinedLoadMetricSpecification")
    def predefined_load_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification']:
        """
        Predefined load metric specification.
        """
        return pulumi.get(self, "predefined_load_metric_specification")

    @property
    @pulumi.getter(name="predefinedMetricPairSpecification")
    def predefined_metric_pair_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification']:
        """
        Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
        """
        return pulumi.get(self, "predefined_metric_pair_specification")

    @property
    @pulumi.getter(name="predefinedScalingMetricSpecification")
    def predefined_scaling_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification']:
        """
        Predefined scaling metric specification.
        """
        return pulumi.get(self, "predefined_scaling_metric_specification")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery']):
        """
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryArgs'] metric_data_queries: List of up to 10 structures that defines custom capacity metric in predictive scaling policy
        """
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery']:
        """
        List of up to 10 structures that defines custom capacity metric in predictive scaling policy
        """
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expression: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[bool] = None):
        """
        :param str id: Short name for the metric used in predictive scaling policy.
        :param str expression: Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        :param str label: Human-readable label for this metric or expression.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatArgs' metric_stat: Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        :param bool return_data: Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Short name for the metric used in predictive scaling policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Human-readable label for this metric or expression.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat']:
        """
        Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        """
        Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: str,
                 unit: Optional[str] = None):
        """
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricArgs' metric: Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        :param str stat: Statistic of the metrics to return.
        :param str unit: Unit of the metrics to return.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric':
        """
        Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        Statistic of the metrics to return.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit of the metrics to return.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        """
        :param str metric_name: Name of the metric.
        :param str namespace: Namespace of the metric.
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimensionArgs'] dimensions: Dimensions of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        """
        Dimensions of the metric.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery']):
        """
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryArgs'] metric_data_queries: List of up to 10 structures that defines custom load metric in predictive scaling policy
        """
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery']:
        """
        List of up to 10 structures that defines custom load metric in predictive scaling policy
        """
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expression: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[bool] = None):
        """
        :param str id: Short name for the metric used in predictive scaling policy.
        :param str expression: Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        :param str label: Human-readable label for this metric or expression.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatArgs' metric_stat: Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        :param bool return_data: Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Short name for the metric used in predictive scaling policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Human-readable label for this metric or expression.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat']:
        """
        Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        """
        Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: str,
                 unit: Optional[str] = None):
        """
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricArgs' metric: Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        :param str stat: Statistic of the metrics to return.
        :param str unit: Unit of the metrics to return.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric':
        """
        Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        Statistic of the metrics to return.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit of the metrics to return.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        """
        :param str metric_name: Name of the metric.
        :param str namespace: Namespace of the metric.
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimensionArgs'] dimensions: Dimensions of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        """
        Dimensions of the metric.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery']):
        """
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryArgs'] metric_data_queries: List of up to 10 structures that defines custom scaling metric in predictive scaling policy
        """
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery']:
        """
        List of up to 10 structures that defines custom scaling metric in predictive scaling policy
        """
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expression: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[bool] = None):
        """
        :param str id: Short name for the metric used in predictive scaling policy.
        :param str expression: Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        :param str label: Human-readable label for this metric or expression.
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatArgs' metric_stat: Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        :param bool return_data: Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Short name for the metric used in predictive scaling policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Human-readable label for this metric or expression.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat']:
        """
        Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        """
        Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: str,
                 unit: Optional[str] = None):
        """
        :param 'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricArgs' metric: Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        :param str stat: Statistic of the metrics to return.
        :param str unit: Unit of the metrics to return.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric':
        """
        Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        Statistic of the metrics to return.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit of the metrics to return.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        """
        :param str metric_name: Name of the metric.
        :param str namespace: Namespace of the metric.
        :param Sequence['PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimensionArgs'] dimensions: Dimensions of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        """
        Dimensions of the metric.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        """
        :param str predefined_metric_type: Metric type. Valid values are `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`, or `ALBTargetGroupRequestCount`.
        :param str resource_label: Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        """
        Metric type. Valid values are `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`, or `ALBTargetGroupRequestCount`.
        """
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        """
        Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        """
        :param str predefined_metric_type: Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is `ASGCPUUtilization`, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are `ASGCPUUtilization`, `ASGNetworkIn`, `ASGNetworkOut`, or `ALBRequestCount`.
        :param str resource_label: Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        """
        Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is `ASGCPUUtilization`, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are `ASGCPUUtilization`, `ASGNetworkIn`, `ASGNetworkOut`, or `ALBRequestCount`.
        """
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        """
        Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        """
        :param str predefined_metric_type: Describes a scaling metric for a predictive scaling policy. Valid values are `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, or `ALBRequestCountPerTarget`.
        :param str resource_label: Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        """
        Describes a scaling metric for a predictive scaling policy. Valid values are `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, or `ALBRequestCountPerTarget`.
        """
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        """
        Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
        """
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyStepAdjustment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "metricIntervalLowerBound":
            suggest = "metric_interval_lower_bound"
        elif key == "metricIntervalUpperBound":
            suggest = "metric_interval_upper_bound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyStepAdjustment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyStepAdjustment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyStepAdjustment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: int,
                 metric_interval_lower_bound: Optional[str] = None,
                 metric_interval_upper_bound: Optional[str] = None):
        """
        :param int scaling_adjustment: Number of members by which to
               scale, when the adjustment bounds are breached. A positive value scales
               up. A negative value scales down.
        :param str metric_interval_lower_bound: Lower bound for the
               difference between the alarm threshold and the CloudWatch metric.
               Without a value, AWS will treat this bound as negative infinity.
        :param str metric_interval_upper_bound: Upper bound for the
               difference between the alarm threshold and the CloudWatch metric.
               Without a value, AWS will treat this bound as positive infinity. The upper bound
               must be greater than the lower bound.
               
               Notice the bounds are **relative** to the alarm threshold, meaning that the starting point is not 0%, but the alarm threshold. Check the official [docs](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-steps) for a detailed example.
               
               The following arguments are only available to "TargetTrackingScaling" type policies:
        """
        pulumi.set(__self__, "scaling_adjustment", scaling_adjustment)
        if metric_interval_lower_bound is not None:
            pulumi.set(__self__, "metric_interval_lower_bound", metric_interval_lower_bound)
        if metric_interval_upper_bound is not None:
            pulumi.set(__self__, "metric_interval_upper_bound", metric_interval_upper_bound)

    @property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> int:
        """
        Number of members by which to
        scale, when the adjustment bounds are breached. A positive value scales
        up. A negative value scales down.
        """
        return pulumi.get(self, "scaling_adjustment")

    @property
    @pulumi.getter(name="metricIntervalLowerBound")
    def metric_interval_lower_bound(self) -> Optional[str]:
        """
        Lower bound for the
        difference between the alarm threshold and the CloudWatch metric.
        Without a value, AWS will treat this bound as negative infinity.
        """
        return pulumi.get(self, "metric_interval_lower_bound")

    @property
    @pulumi.getter(name="metricIntervalUpperBound")
    def metric_interval_upper_bound(self) -> Optional[str]:
        """
        Upper bound for the
        difference between the alarm threshold and the CloudWatch metric.
        Without a value, AWS will treat this bound as positive infinity. The upper bound
        must be greater than the lower bound.

        Notice the bounds are **relative** to the alarm threshold, meaning that the starting point is not 0%, but the alarm threshold. Check the official [docs](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-steps) for a detailed example.

        The following arguments are only available to "TargetTrackingScaling" type policies:
        """
        return pulumi.get(self, "metric_interval_upper_bound")


@pulumi.output_type
class PolicyTargetTrackingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedMetricSpecification":
            suggest = "customized_metric_specification"
        elif key == "disableScaleIn":
            suggest = "disable_scale_in"
        elif key == "predefinedMetricSpecification":
            suggest = "predefined_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float,
                 customized_metric_specification: Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecification'] = None,
                 disable_scale_in: Optional[bool] = None,
                 predefined_metric_specification: Optional['outputs.PolicyTargetTrackingConfigurationPredefinedMetricSpecification'] = None):
        """
        :param float target_value: Target value for the metric.
        :param 'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationArgs' customized_metric_specification: Customized metric. Conflicts with `predefined_metric_specification`.
        :param bool disable_scale_in: Whether scale in by the target tracking policy is disabled.
        :param 'PolicyTargetTrackingConfigurationPredefinedMetricSpecificationArgs' predefined_metric_specification: Predefined metric. Conflicts with `customized_metric_specification`.
        """
        pulumi.set(__self__, "target_value", target_value)
        if customized_metric_specification is not None:
            pulumi.set(__self__, "customized_metric_specification", customized_metric_specification)
        if disable_scale_in is not None:
            pulumi.set(__self__, "disable_scale_in", disable_scale_in)
        if predefined_metric_specification is not None:
            pulumi.set(__self__, "predefined_metric_specification", predefined_metric_specification)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        """
        Target value for the metric.
        """
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter(name="customizedMetricSpecification")
    def customized_metric_specification(self) -> Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecification']:
        """
        Customized metric. Conflicts with `predefined_metric_specification`.
        """
        return pulumi.get(self, "customized_metric_specification")

    @property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[bool]:
        """
        Whether scale in by the target tracking policy is disabled.
        """
        return pulumi.get(self, "disable_scale_in")

    @property
    @pulumi.getter(name="predefinedMetricSpecification")
    def predefined_metric_specification(self) -> Optional['outputs.PolicyTargetTrackingConfigurationPredefinedMetricSpecification']:
        """
        Predefined metric. Conflicts with `customized_metric_specification`.
        """
        return pulumi.get(self, "predefined_metric_specification")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDimensions":
            suggest = "metric_dimensions"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_dimensions: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension']] = None,
                 metric_name: Optional[str] = None,
                 metrics: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric']] = None,
                 namespace: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param Sequence['PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimensionArgs'] metric_dimensions: Dimensions of the metric.
        :param str metric_name: Name of the metric.
        :param Sequence['PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricArgs'] metrics: Metrics to include, as a metric data query.
        :param str namespace: Namespace of the metric.
        :param str statistic: Statistic of the metric.
        :param str unit: Unit of the metric.
        """
        if metric_dimensions is not None:
            pulumi.set(__self__, "metric_dimensions", metric_dimensions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricDimensions")
    def metric_dimensions(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension']]:
        """
        Dimensions of the metric.
        """
        return pulumi.get(self, "metric_dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric']]:
        """
        Metrics to include, as a metric data query.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        Statistic of the metric.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit of the metric.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expression: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat'] = None,
                 return_data: Optional[bool] = None):
        """
        :param str id: Short name for the metric used in target tracking scaling policy.
        :param str expression: Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        :param str label: Human-readable label for this metric or expression.
        :param 'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatArgs' metric_stat: Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        :param bool return_data: Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Short name for the metric used in target tracking scaling policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Math expression used on the returned metric. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Human-readable label for this metric or expression.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat']:
        """
        Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metric_stat`, but not both.
        """
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        """
        Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
        """
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric',
                 stat: str,
                 unit: Optional[str] = None):
        """
        :param 'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricArgs' metric: Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        :param str stat: Statistic of the metrics to return.
        :param str unit: Unit of the metrics to return.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric':
        """
        Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        Statistic of the metrics to return.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit of the metrics to return.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 dimensions: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension']] = None):
        """
        :param str metric_name: Name of the metric.
        :param str namespace: Namespace of the metric.
        :param Sequence['PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimensionArgs'] dimensions: Dimensions of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension']]:
        """
        Dimensions of the metric.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyTargetTrackingConfigurationPredefinedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationPredefinedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        """
        :param str predefined_metric_type: Metric type.
        :param str resource_label: Identifies the resource associated with the metric type.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        """
        Metric type.
        """
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        """
        Identifies the resource associated with the metric type.
        """
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class TagTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 propagate_at_launch: bool,
                 value: str):
        """
        :param str key: Tag name.
        :param bool propagate_at_launch: Whether to propagate the tags to instances launched by the ASG.
        :param str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag name.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> bool:
        """
        Whether to propagate the tags to instances launched by the ASG.
        """
        return pulumi.get(self, "propagate_at_launch")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficSourceAttachmentTrafficSource(dict):
    def __init__(__self__, *,
                 identifier: str,
                 type: str):
        """
        :param str identifier: Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        :param str type: Provides additional context for the value of `identifier`.
               The following lists the valid values:
               `elb` if `identifier` is the name of a Classic Load Balancer.
               `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
               `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Provides additional context for the value of `identifier`.
        The following lists the valid values:
        `elb` if `identifier` is the name of a Classic Load Balancer.
        `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
        `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAmiIdsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the DescribeAutoScalingGroup filter. The recommended values are: `tag-key`, `tag-value`, and `tag:<tag name>`
        :param Sequence[str] values: Value of the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the DescribeAutoScalingGroup filter. The recommended values are: `tag-key`, `tag-value`, and `tag:<tag name>`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Value of the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGroupLaunchTemplateResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 version: str):
        """
        :param str id: ID of the launch template.
        :param str name: Specify the exact name of the desired autoscaling group.
        :param str version: Template version.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the launch template.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the exact name of the desired autoscaling group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Template version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupMixedInstancesPolicyResult(dict):
    def __init__(__self__, *,
                 instances_distributions: Sequence['outputs.GetGroupMixedInstancesPolicyInstancesDistributionResult'],
                 launch_templates: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateResult']):
        """
        :param Sequence['GetGroupMixedInstancesPolicyInstancesDistributionArgs'] instances_distributions: List of instances distribution objects.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateArgs'] launch_templates: List of launch templates along with the overrides.
        """
        pulumi.set(__self__, "instances_distributions", instances_distributions)
        pulumi.set(__self__, "launch_templates", launch_templates)

    @property
    @pulumi.getter(name="instancesDistributions")
    def instances_distributions(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyInstancesDistributionResult']:
        """
        List of instances distribution objects.
        """
        return pulumi.get(self, "instances_distributions")

    @property
    @pulumi.getter(name="launchTemplates")
    def launch_templates(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateResult']:
        """
        List of launch templates along with the overrides.
        """
        return pulumi.get(self, "launch_templates")


@pulumi.output_type
class GetGroupMixedInstancesPolicyInstancesDistributionResult(dict):
    def __init__(__self__, *,
                 on_demand_allocation_strategy: str,
                 on_demand_base_capacity: int,
                 on_demand_percentage_above_base_capacity: int,
                 spot_allocation_strategy: str,
                 spot_instance_pools: int,
                 spot_max_price: str):
        """
        :param str on_demand_allocation_strategy: Strategy used when launching on-demand instances.
        :param int on_demand_base_capacity: Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances.
        :param str spot_allocation_strategy: Strategy used when launching Spot instances.
        :param int spot_instance_pools: Number of Spot pools per availability zone to allocate capacity.
        :param str spot_max_price: Maximum price per unit hour that the user is willing to pay for the Spot instances.
        """
        pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        pulumi.set(__self__, "spot_max_price", spot_max_price)

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> str:
        """
        Strategy used when launching on-demand instances.
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> int:
        """
        Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances.
        """
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> int:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> str:
        """
        Strategy used when launching Spot instances.
        """
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> int:
        """
        Number of Spot pools per availability zone to allocate capacity.
        """
        return pulumi.get(self, "spot_instance_pools")

    @property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> str:
        """
        Maximum price per unit hour that the user is willing to pay for the Spot instances.
        """
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateResult(dict):
    def __init__(__self__, *,
                 launch_template_specifications: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult'],
                 overrides: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult']):
        """
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs'] launch_template_specifications: List of overriding launch template specification objects.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideArgs'] overrides: List of properties overriding the same properties in the launch template.
        """
        pulumi.set(__self__, "launch_template_specifications", launch_template_specifications)
        pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecifications")
    def launch_template_specifications(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult']:
        """
        List of overriding launch template specification objects.
        """
        return pulumi.get(self, "launch_template_specifications")

    @property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult']:
        """
        List of properties overriding the same properties in the launch template.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult(dict):
    def __init__(__self__, *,
                 launch_template_id: str,
                 launch_template_name: str,
                 version: str):
        """
        :param str launch_template_id: ID of the launch template.
        :param str launch_template_name: Name of the launch template.
        :param str version: Template version.
        """
        pulumi.set(__self__, "launch_template_id", launch_template_id)
        pulumi.set(__self__, "launch_template_name", launch_template_name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> str:
        """
        ID of the launch template.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> str:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Template version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult(dict):
    def __init__(__self__, *,
                 instance_requirements: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult'],
                 instance_type: str,
                 launch_template_specifications: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult'],
                 weighted_capacity: str):
        """
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementArgs'] instance_requirements: List of instance requirements objects.
               * `accelerator_count - List of objects describing the minimum and maximum number of accelerators for an instance type.
        :param str instance_type: Overriding instance type.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationArgs'] launch_template_specifications: List of overriding launch template specification objects.
        :param str weighted_capacity: Number of capacity units, which gives the instance type a proportional weight to other instance types.
        """
        pulumi.set(__self__, "instance_requirements", instance_requirements)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "launch_template_specifications", launch_template_specifications)
        pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult']:
        """
        List of instance requirements objects.
        * `accelerator_count - List of objects describing the minimum and maximum number of accelerators for an instance type.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Overriding instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="launchTemplateSpecifications")
    def launch_template_specifications(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult']:
        """
        List of overriding launch template specification objects.
        """
        return pulumi.get(self, "launch_template_specifications")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> str:
        """
        Number of capacity units, which gives the instance type a proportional weight to other instance types.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 accelerator_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult'],
                 accelerator_manufacturers: Sequence[str],
                 accelerator_names: Sequence[str],
                 accelerator_total_memory_mibs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult'],
                 accelerator_types: Sequence[str],
                 allowed_instance_types: Sequence[str],
                 bare_metal: str,
                 baseline_ebs_bandwidth_mbps: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult'],
                 burstable_performance: str,
                 cpu_manufacturers: Sequence[str],
                 excluded_instance_types: Sequence[str],
                 instance_generations: Sequence[str],
                 local_storage: str,
                 local_storage_types: Sequence[str],
                 memory_gib_per_vcpus: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult'],
                 memory_mibs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult'],
                 network_bandwidth_gbps: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult'],
                 network_interface_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult'],
                 on_demand_max_price_percentage_over_lowest_price: int,
                 require_hibernate_support: bool,
                 spot_max_price_percentage_over_lowest_price: int,
                 total_local_storage_gbs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult'],
                 vcpu_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult']):
        """
        :param Sequence[str] accelerator_manufacturers: List of accelerator manufacturer names.
        :param Sequence[str] accelerator_names: List of accelerator names.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibArgs'] accelerator_total_memory_mibs: List of objects describing the minimum and maximum total memory of the accelerators.
        :param Sequence[str] accelerator_types: List of accelerator types.
        :param Sequence[str] allowed_instance_types: List of instance types to apply the specified attributes against.
        :param str bare_metal: Indicates whether bare metal instances are included, excluded, or required.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpArgs'] baseline_ebs_bandwidth_mbps: List of objects describing the minimum and maximum baseline EBS bandwidth (Mbps).
        :param str burstable_performance: Indicates whether burstable performance instance types are included, excluded, or required.
        :param Sequence[str] cpu_manufacturers: List of CPU manufacturer names.
        :param Sequence[str] excluded_instance_types: List of excluded instance types.
        :param Sequence[str] instance_generations: List of instance generation names.
        :param str local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required.
        :param Sequence[str] local_storage_types: List of local storage type names.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusArgs'] memory_gib_per_vcpus: List of objects describing the minimum and maximum amount of memory (GiB) per vCPU.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibArgs'] memory_mibs: List of objects describing the minimum and maximum amount of memory (MiB).
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpArgs'] network_bandwidth_gbps: List of objects describing the minimum and maximum amount of network bandwidth (Gbps).
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountArgs'] network_interface_counts: List of objects describing the minimum and maximum amount of network interfaces.
        :param int on_demand_max_price_percentage_over_lowest_price: Price protection threshold for On-Demand Instances.
        :param bool require_hibernate_support: Indicates whether instance types must support On-Demand Instance Hibernation.
        :param int spot_max_price_percentage_over_lowest_price: Price protection threshold for Spot Instances.
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbArgs'] total_local_storage_gbs: List of objects describing the minimum and maximum total storage (GB).
        :param Sequence['GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountArgs'] vcpu_counts: List of objects describing the minimum and maximum number of vCPUs.
        """
        pulumi.set(__self__, "accelerator_counts", accelerator_counts)
        pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        pulumi.set(__self__, "accelerator_names", accelerator_names)
        pulumi.set(__self__, "accelerator_total_memory_mibs", accelerator_total_memory_mibs)
        pulumi.set(__self__, "accelerator_types", accelerator_types)
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "bare_metal", bare_metal)
        pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        pulumi.set(__self__, "burstable_performance", burstable_performance)
        pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        pulumi.set(__self__, "instance_generations", instance_generations)
        pulumi.set(__self__, "local_storage", local_storage)
        pulumi.set(__self__, "local_storage_types", local_storage_types)
        pulumi.set(__self__, "memory_gib_per_vcpus", memory_gib_per_vcpus)
        pulumi.set(__self__, "memory_mibs", memory_mibs)
        pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        pulumi.set(__self__, "network_interface_counts", network_interface_counts)
        pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "total_local_storage_gbs", total_local_storage_gbs)
        pulumi.set(__self__, "vcpu_counts", vcpu_counts)

    @property
    @pulumi.getter(name="acceleratorCounts")
    def accelerator_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult']:
        return pulumi.get(self, "accelerator_counts")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Sequence[str]:
        """
        List of accelerator manufacturer names.
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Sequence[str]:
        """
        List of accelerator names.
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMibs")
    def accelerator_total_memory_mibs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult']:
        """
        List of objects describing the minimum and maximum total memory of the accelerators.
        """
        return pulumi.get(self, "accelerator_total_memory_mibs")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Sequence[str]:
        """
        List of accelerator types.
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[str]:
        """
        List of instance types to apply the specified attributes against.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> str:
        """
        Indicates whether bare metal instances are included, excluded, or required.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult']:
        """
        List of objects describing the minimum and maximum baseline EBS bandwidth (Mbps).
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> str:
        """
        Indicates whether burstable performance instance types are included, excluded, or required.
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Sequence[str]:
        """
        List of CPU manufacturer names.
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[str]:
        """
        List of excluded instance types.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Sequence[str]:
        """
        List of instance generation names.
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> str:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Sequence[str]:
        """
        List of local storage type names.
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpus")
    def memory_gib_per_vcpus(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult']:
        """
        List of objects describing the minimum and maximum amount of memory (GiB) per vCPU.
        """
        return pulumi.get(self, "memory_gib_per_vcpus")

    @property
    @pulumi.getter(name="memoryMibs")
    def memory_mibs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult']:
        """
        List of objects describing the minimum and maximum amount of memory (MiB).
        """
        return pulumi.get(self, "memory_mibs")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult']:
        """
        List of objects describing the minimum and maximum amount of network bandwidth (Gbps).
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCounts")
    def network_interface_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult']:
        """
        List of objects describing the minimum and maximum amount of network interfaces.
        """
        return pulumi.get(self, "network_interface_counts")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> int:
        """
        Price protection threshold for On-Demand Instances.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> bool:
        """
        Indicates whether instance types must support On-Demand Instance Hibernation.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> int:
        """
        Price protection threshold for Spot Instances.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGbs")
    def total_local_storage_gbs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult']:
        """
        List of objects describing the minimum and maximum total storage (GB).
        """
        return pulumi.get(self, "total_local_storage_gbs")

    @property
    @pulumi.getter(name="vcpuCounts")
    def vcpu_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult']:
        """
        List of objects describing the minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "vcpu_counts")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult(dict):
    def __init__(__self__, *,
                 launch_template_id: str,
                 launch_template_name: str,
                 version: str):
        """
        :param str launch_template_id: ID of the launch template.
        :param str launch_template_name: Name of the launch template.
        :param str version: Template version.
        """
        pulumi.set(__self__, "launch_template_id", launch_template_id)
        pulumi.set(__self__, "launch_template_name", launch_template_name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> str:
        """
        ID of the launch template.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> str:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Template version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 propagate_at_launch: bool,
                 value: str):
        """
        :param str key: Key.
        :param bool propagate_at_launch: Whether the tag is propagated to Amazon EC2 instances launched via this ASG.
        :param str value: Value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> bool:
        """
        Whether the tag is propagated to Amazon EC2 instances launched via this ASG.
        """
        return pulumi.get(self, "propagate_at_launch")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGroupTrafficSourceResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 type: str):
        """
        :param str identifier: Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        :param str type: Traffic source type.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Traffic source type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGroupWarmPoolResult(dict):
    def __init__(__self__, *,
                 instance_reuse_policies: Sequence['outputs.GetGroupWarmPoolInstanceReusePolicyResult'],
                 max_group_prepared_capacity: int,
                 min_size: int,
                 pool_state: str):
        """
        :param Sequence['GetGroupWarmPoolInstanceReusePolicyArgs'] instance_reuse_policies: List of instance reuse policy objects.
        :param int min_size: Minimum number of instances to maintain in the warm pool.
        :param str pool_state: Instance state to transition to after the lifecycle actions are complete.
        """
        pulumi.set(__self__, "instance_reuse_policies", instance_reuse_policies)
        pulumi.set(__self__, "max_group_prepared_capacity", max_group_prepared_capacity)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "pool_state", pool_state)

    @property
    @pulumi.getter(name="instanceReusePolicies")
    def instance_reuse_policies(self) -> Sequence['outputs.GetGroupWarmPoolInstanceReusePolicyResult']:
        """
        List of instance reuse policy objects.
        """
        return pulumi.get(self, "instance_reuse_policies")

    @property
    @pulumi.getter(name="maxGroupPreparedCapacity")
    def max_group_prepared_capacity(self) -> int:
        return pulumi.get(self, "max_group_prepared_capacity")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> int:
        """
        Minimum number of instances to maintain in the warm pool.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="poolState")
    def pool_state(self) -> str:
        """
        Instance state to transition to after the lifecycle actions are complete.
        """
        return pulumi.get(self, "pool_state")


@pulumi.output_type
class GetGroupWarmPoolInstanceReusePolicyResult(dict):
    def __init__(__self__, *,
                 reuse_on_scale_in: bool):
        """
        :param bool reuse_on_scale_in: Indicates whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
        """
        pulumi.set(__self__, "reuse_on_scale_in", reuse_on_scale_in)

    @property
    @pulumi.getter(name="reuseOnScaleIn")
    def reuse_on_scale_in(self) -> bool:
        """
        Indicates whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
        """
        return pulumi.get(self, "reuse_on_scale_in")


