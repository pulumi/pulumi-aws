# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AwsLogSourceSource',
    'DataLakeConfiguration',
    'DataLakeConfigurationLifecycleConfiguration',
    'DataLakeConfigurationLifecycleConfigurationExpiration',
    'DataLakeConfigurationLifecycleConfigurationTransition',
    'DataLakeConfigurationReplicationConfiguration',
    'DataLakeTimeouts',
]

@pulumi.output_type
class AwsLogSourceSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceName":
            suggest = "source_name"
        elif key == "sourceVersion":
            suggest = "source_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLogSourceSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLogSourceSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLogSourceSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Sequence[str],
                 source_name: str,
                 accounts: Optional[Sequence[str]] = None,
                 source_version: Optional[str] = None):
        """
        :param Sequence[str] regions: Specify the Regions where you want to enable Security Lake.
        :param str source_name: The name for a AWS source. This must be a Regionally unique value. Valid values: `ROUTE53`, `VPC_FLOW`, `SH_FINDINGS`, `CLOUD_TRAIL_MGMT`, `LAMBDA_EXECUTION`, `S3_DATA`.
        :param Sequence[str] accounts: Specify the AWS account information where you want to enable Security Lake.
        :param str source_version: The version for a AWS source. This must be a Regionally unique value.
        """
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "source_name", source_name)
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Specify the Regions where you want to enable Security Lake.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name for a AWS source. This must be a Regionally unique value. Valid values: `ROUTE53`, `VPC_FLOW`, `SH_FINDINGS`, `CLOUD_TRAIL_MGMT`, `LAMBDA_EXECUTION`, `S3_DATA`.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def accounts(self) -> Optional[Sequence[str]]:
        """
        Specify the AWS account information where you want to enable Security Lake.
        """
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[str]:
        """
        The version for a AWS source. This must be a Regionally unique value.
        """
        return pulumi.get(self, "source_version")


@pulumi.output_type
class DataLakeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionConfigurations":
            suggest = "encryption_configurations"
        elif key == "lifecycleConfiguration":
            suggest = "lifecycle_configuration"
        elif key == "replicationConfiguration":
            suggest = "replication_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 encryption_configurations: Optional[Sequence[Mapping[str, Any]]] = None,
                 lifecycle_configuration: Optional['outputs.DataLakeConfigurationLifecycleConfiguration'] = None,
                 replication_configuration: Optional['outputs.DataLakeConfigurationReplicationConfiguration'] = None):
        """
        :param str region: The AWS Regions where Security Lake is automatically enabled.
        :param Sequence[Mapping[str, Any]] encryption_configurations: Provides encryption details of Amazon Security Lake object.
        :param 'DataLakeConfigurationLifecycleConfigurationArgs' lifecycle_configuration: Provides lifecycle details of Amazon Security Lake object.
        :param 'DataLakeConfigurationReplicationConfigurationArgs' replication_configuration: Provides replication details of Amazon Security Lake object.
        """
        pulumi.set(__self__, "region", region)
        if encryption_configurations is not None:
            pulumi.set(__self__, "encryption_configurations", encryption_configurations)
        if lifecycle_configuration is not None:
            pulumi.set(__self__, "lifecycle_configuration", lifecycle_configuration)
        if replication_configuration is not None:
            pulumi.set(__self__, "replication_configuration", replication_configuration)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS Regions where Security Lake is automatically enabled.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="encryptionConfigurations")
    def encryption_configurations(self) -> Optional[Sequence[Mapping[str, Any]]]:
        """
        Provides encryption details of Amazon Security Lake object.
        """
        return pulumi.get(self, "encryption_configurations")

    @property
    @pulumi.getter(name="lifecycleConfiguration")
    def lifecycle_configuration(self) -> Optional['outputs.DataLakeConfigurationLifecycleConfiguration']:
        """
        Provides lifecycle details of Amazon Security Lake object.
        """
        return pulumi.get(self, "lifecycle_configuration")

    @property
    @pulumi.getter(name="replicationConfiguration")
    def replication_configuration(self) -> Optional['outputs.DataLakeConfigurationReplicationConfiguration']:
        """
        Provides replication details of Amazon Security Lake object.
        """
        return pulumi.get(self, "replication_configuration")


@pulumi.output_type
class DataLakeConfigurationLifecycleConfiguration(dict):
    def __init__(__self__, *,
                 expiration: Optional['outputs.DataLakeConfigurationLifecycleConfigurationExpiration'] = None,
                 transitions: Optional[Sequence['outputs.DataLakeConfigurationLifecycleConfigurationTransition']] = None):
        """
        :param 'DataLakeConfigurationLifecycleConfigurationExpirationArgs' expiration: Provides data expiration details of Amazon Security Lake object.
        :param Sequence['DataLakeConfigurationLifecycleConfigurationTransitionArgs'] transitions: Provides data storage transition details of Amazon Security Lake object.
        """
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.DataLakeConfigurationLifecycleConfigurationExpiration']:
        """
        Provides data expiration details of Amazon Security Lake object.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.DataLakeConfigurationLifecycleConfigurationTransition']]:
        """
        Provides data storage transition details of Amazon Security Lake object.
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class DataLakeConfigurationLifecycleConfigurationExpiration(dict):
    def __init__(__self__, *,
                 days: Optional[int] = None):
        """
        :param int days: Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class DataLakeConfigurationLifecycleConfigurationTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeConfigurationLifecycleConfigurationTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeConfigurationLifecycleConfigurationTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeConfigurationLifecycleConfigurationTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[int] = None,
                 storage_class: Optional[str] = None):
        """
        :param int days: Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
        :param str storage_class: The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class DataLakeConfigurationReplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeConfigurationReplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeConfigurationReplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeConfigurationReplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 role_arn: Optional[str] = None):
        """
        :param Sequence[str] regions: Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same AWS account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different AWS Regions or within the same Region as the source bucket.
        :param str role_arn: Replication settings for the Amazon S3 buckets. This parameter uses the AWS Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct.
        """
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        """
        Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same AWS account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different AWS Regions or within the same Region as the source bucket.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Replication settings for the Amazon S3 buckets. This parameter uses the AWS Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class DataLakeTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        return pulumi.get(self, "update")


