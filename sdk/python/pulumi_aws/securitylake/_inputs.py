# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AwsLogSourceSourceArgs',
    'AwsLogSourceSourceArgsDict',
    'CustomLogSourceAttributeArgs',
    'CustomLogSourceAttributeArgsDict',
    'CustomLogSourceConfigurationArgs',
    'CustomLogSourceConfigurationArgsDict',
    'CustomLogSourceConfigurationCrawlerConfigurationArgs',
    'CustomLogSourceConfigurationCrawlerConfigurationArgsDict',
    'CustomLogSourceConfigurationProviderIdentityArgs',
    'CustomLogSourceConfigurationProviderIdentityArgsDict',
    'CustomLogSourceProviderDetailArgs',
    'CustomLogSourceProviderDetailArgsDict',
    'DataLakeConfigurationArgs',
    'DataLakeConfigurationArgsDict',
    'DataLakeConfigurationEncryptionConfigurationArgs',
    'DataLakeConfigurationEncryptionConfigurationArgsDict',
    'DataLakeConfigurationLifecycleConfigurationArgs',
    'DataLakeConfigurationLifecycleConfigurationArgsDict',
    'DataLakeConfigurationLifecycleConfigurationExpirationArgs',
    'DataLakeConfigurationLifecycleConfigurationExpirationArgsDict',
    'DataLakeConfigurationLifecycleConfigurationTransitionArgs',
    'DataLakeConfigurationLifecycleConfigurationTransitionArgsDict',
    'DataLakeConfigurationReplicationConfigurationArgs',
    'DataLakeConfigurationReplicationConfigurationArgsDict',
    'DataLakeTimeoutsArgs',
    'DataLakeTimeoutsArgsDict',
    'SubscriberNotificationConfigurationArgs',
    'SubscriberNotificationConfigurationArgsDict',
    'SubscriberNotificationConfigurationHttpsNotificationConfigurationArgs',
    'SubscriberNotificationConfigurationHttpsNotificationConfigurationArgsDict',
    'SubscriberNotificationConfigurationSqsNotificationConfigurationArgs',
    'SubscriberNotificationConfigurationSqsNotificationConfigurationArgsDict',
    'SubscriberSourceArgs',
    'SubscriberSourceArgsDict',
    'SubscriberSourceAwsLogSourceResourceArgs',
    'SubscriberSourceAwsLogSourceResourceArgsDict',
    'SubscriberSourceCustomLogSourceResourceArgs',
    'SubscriberSourceCustomLogSourceResourceArgsDict',
    'SubscriberSourceCustomLogSourceResourceAttributeArgs',
    'SubscriberSourceCustomLogSourceResourceAttributeArgsDict',
    'SubscriberSourceCustomLogSourceResourceProviderArgs',
    'SubscriberSourceCustomLogSourceResourceProviderArgsDict',
    'SubscriberSubscriberIdentityArgs',
    'SubscriberSubscriberIdentityArgsDict',
    'SubscriberTimeoutsArgs',
    'SubscriberTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class AwsLogSourceSourceArgsDict(TypedDict):
        regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        source_name: pulumi.Input[_builtins.str]
        accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        source_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AwsLogSourceSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsLogSourceSourceArgs:
    def __init__(__self__, *,
                 regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 source_name: pulumi.Input[_builtins.str],
                 accounts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "source_name", source_name)
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_name", value)

    @_builtins.property
    @pulumi.getter
    def accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accounts", value)

    @_builtins.property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_version")

    @source_version.setter
    def source_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_version", value)


if not MYPY:
    class CustomLogSourceAttributeArgsDict(TypedDict):
        crawler_arn: pulumi.Input[_builtins.str]
        database_arn: pulumi.Input[_builtins.str]
        table_arn: pulumi.Input[_builtins.str]
elif False:
    CustomLogSourceAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomLogSourceAttributeArgs:
    def __init__(__self__, *,
                 crawler_arn: pulumi.Input[_builtins.str],
                 database_arn: pulumi.Input[_builtins.str],
                 table_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "crawler_arn", crawler_arn)
        pulumi.set(__self__, "database_arn", database_arn)
        pulumi.set(__self__, "table_arn", table_arn)

    @_builtins.property
    @pulumi.getter(name="crawlerArn")
    def crawler_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "crawler_arn")

    @crawler_arn.setter
    def crawler_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "crawler_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseArn")
    def database_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_arn")

    @database_arn.setter
    def database_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_arn", value)


if not MYPY:
    class CustomLogSourceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['CustomLogSourceConfigurationCrawlerConfigurationArgsDict']]
        provider_identity: NotRequired[pulumi.Input['CustomLogSourceConfigurationProviderIdentityArgsDict']]
elif False:
    CustomLogSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomLogSourceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['CustomLogSourceConfigurationCrawlerConfigurationArgs']] = None,
                 provider_identity: Optional[pulumi.Input['CustomLogSourceConfigurationProviderIdentityArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if provider_identity is not None:
            pulumi.set(__self__, "provider_identity", provider_identity)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['CustomLogSourceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['CustomLogSourceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="providerIdentity")
    def provider_identity(self) -> Optional[pulumi.Input['CustomLogSourceConfigurationProviderIdentityArgs']]:
        return pulumi.get(self, "provider_identity")

    @provider_identity.setter
    def provider_identity(self, value: Optional[pulumi.Input['CustomLogSourceConfigurationProviderIdentityArgs']]):
        pulumi.set(self, "provider_identity", value)


if not MYPY:
    class CustomLogSourceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
elif False:
    CustomLogSourceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomLogSourceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class CustomLogSourceConfigurationProviderIdentityArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        principal: pulumi.Input[_builtins.str]
elif False:
    CustomLogSourceConfigurationProviderIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomLogSourceConfigurationProviderIdentityArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class CustomLogSourceProviderDetailArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
elif False:
    CustomLogSourceProviderDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomLogSourceProviderDetailArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class DataLakeConfigurationArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        encryption_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationEncryptionConfigurationArgsDict']]]]
        lifecycle_configuration: NotRequired[pulumi.Input['DataLakeConfigurationLifecycleConfigurationArgsDict']]
        replication_configuration: NotRequired[pulumi.Input['DataLakeConfigurationReplicationConfigurationArgsDict']]
elif False:
    DataLakeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 encryption_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationEncryptionConfigurationArgs']]]] = None,
                 lifecycle_configuration: Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationArgs']] = None,
                 replication_configuration: Optional[pulumi.Input['DataLakeConfigurationReplicationConfigurationArgs']] = None):
        pulumi.set(__self__, "region", region)
        if encryption_configurations is not None:
            pulumi.set(__self__, "encryption_configurations", encryption_configurations)
        if lifecycle_configuration is not None:
            pulumi.set(__self__, "lifecycle_configuration", lifecycle_configuration)
        if replication_configuration is not None:
            pulumi.set(__self__, "replication_configuration", replication_configuration)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfigurations")
    def encryption_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationEncryptionConfigurationArgs']]]]:
        return pulumi.get(self, "encryption_configurations")

    @encryption_configurations.setter
    def encryption_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationEncryptionConfigurationArgs']]]]):
        pulumi.set(self, "encryption_configurations", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleConfiguration")
    def lifecycle_configuration(self) -> Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationArgs']]:
        return pulumi.get(self, "lifecycle_configuration")

    @lifecycle_configuration.setter
    def lifecycle_configuration(self, value: Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationArgs']]):
        pulumi.set(self, "lifecycle_configuration", value)

    @_builtins.property
    @pulumi.getter(name="replicationConfiguration")
    def replication_configuration(self) -> Optional[pulumi.Input['DataLakeConfigurationReplicationConfigurationArgs']]:
        return pulumi.get(self, "replication_configuration")

    @replication_configuration.setter
    def replication_configuration(self, value: Optional[pulumi.Input['DataLakeConfigurationReplicationConfigurationArgs']]):
        pulumi.set(self, "replication_configuration", value)


if not MYPY:
    class DataLakeConfigurationEncryptionConfigurationArgsDict(TypedDict):
        kms_key_id: pulumi.Input[_builtins.str]
elif False:
    DataLakeConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class DataLakeConfigurationLifecycleConfigurationArgsDict(TypedDict):
        expiration: NotRequired[pulumi.Input['DataLakeConfigurationLifecycleConfigurationExpirationArgsDict']]
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationLifecycleConfigurationTransitionArgsDict']]]]
elif False:
    DataLakeConfigurationLifecycleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationLifecycleConfigurationArgs:
    def __init__(__self__, *,
                 expiration: Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationExpirationArgs']] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationLifecycleConfigurationTransitionArgs']]]] = None):
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationExpirationArgs']]:
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['DataLakeConfigurationLifecycleConfigurationExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationLifecycleConfigurationTransitionArgs']]]]:
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeConfigurationLifecycleConfigurationTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class DataLakeConfigurationLifecycleConfigurationExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DataLakeConfigurationLifecycleConfigurationExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationLifecycleConfigurationExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class DataLakeConfigurationLifecycleConfigurationTransitionArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataLakeConfigurationLifecycleConfigurationTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationLifecycleConfigurationTransitionArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        if days is not None:
            pulumi.set(__self__, "days", days)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class DataLakeConfigurationReplicationConfigurationArgsDict(TypedDict):
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataLakeConfigurationReplicationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeConfigurationReplicationConfigurationArgs:
    def __init__(__self__, *,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class DataLakeTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DataLakeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class SubscriberNotificationConfigurationArgsDict(TypedDict):
        https_notification_configuration: NotRequired[pulumi.Input['SubscriberNotificationConfigurationHttpsNotificationConfigurationArgsDict']]
        sqs_notification_configuration: NotRequired[pulumi.Input['SubscriberNotificationConfigurationSqsNotificationConfigurationArgsDict']]
elif False:
    SubscriberNotificationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberNotificationConfigurationArgs:
    def __init__(__self__, *,
                 https_notification_configuration: Optional[pulumi.Input['SubscriberNotificationConfigurationHttpsNotificationConfigurationArgs']] = None,
                 sqs_notification_configuration: Optional[pulumi.Input['SubscriberNotificationConfigurationSqsNotificationConfigurationArgs']] = None):
        if https_notification_configuration is not None:
            pulumi.set(__self__, "https_notification_configuration", https_notification_configuration)
        if sqs_notification_configuration is not None:
            pulumi.set(__self__, "sqs_notification_configuration", sqs_notification_configuration)

    @_builtins.property
    @pulumi.getter(name="httpsNotificationConfiguration")
    def https_notification_configuration(self) -> Optional[pulumi.Input['SubscriberNotificationConfigurationHttpsNotificationConfigurationArgs']]:
        return pulumi.get(self, "https_notification_configuration")

    @https_notification_configuration.setter
    def https_notification_configuration(self, value: Optional[pulumi.Input['SubscriberNotificationConfigurationHttpsNotificationConfigurationArgs']]):
        pulumi.set(self, "https_notification_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sqsNotificationConfiguration")
    def sqs_notification_configuration(self) -> Optional[pulumi.Input['SubscriberNotificationConfigurationSqsNotificationConfigurationArgs']]:
        return pulumi.get(self, "sqs_notification_configuration")

    @sqs_notification_configuration.setter
    def sqs_notification_configuration(self, value: Optional[pulumi.Input['SubscriberNotificationConfigurationSqsNotificationConfigurationArgs']]):
        pulumi.set(self, "sqs_notification_configuration", value)


if not MYPY:
    class SubscriberNotificationConfigurationHttpsNotificationConfigurationArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        target_role_arn: pulumi.Input[_builtins.str]
        authorization_api_key_name: NotRequired[pulumi.Input[_builtins.str]]
        authorization_api_key_value: NotRequired[pulumi.Input[_builtins.str]]
        http_method: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SubscriberNotificationConfigurationHttpsNotificationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberNotificationConfigurationHttpsNotificationConfigurationArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 target_role_arn: pulumi.Input[_builtins.str],
                 authorization_api_key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_api_key_value: Optional[pulumi.Input[_builtins.str]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "target_role_arn", target_role_arn)
        if authorization_api_key_name is not None:
            pulumi.set(__self__, "authorization_api_key_name", authorization_api_key_name)
        if authorization_api_key_value is not None:
            pulumi.set(__self__, "authorization_api_key_value", authorization_api_key_value)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="targetRoleArn")
    def target_role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_role_arn")

    @target_role_arn.setter
    def target_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="authorizationApiKeyName")
    def authorization_api_key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authorization_api_key_name")

    @authorization_api_key_name.setter
    def authorization_api_key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_api_key_name", value)

    @_builtins.property
    @pulumi.getter(name="authorizationApiKeyValue")
    def authorization_api_key_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authorization_api_key_value")

    @authorization_api_key_value.setter
    def authorization_api_key_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_api_key_value", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)


if not MYPY:
    class SubscriberNotificationConfigurationSqsNotificationConfigurationArgsDict(TypedDict):
        pass
elif False:
    SubscriberNotificationConfigurationSqsNotificationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberNotificationConfigurationSqsNotificationConfigurationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class SubscriberSourceArgsDict(TypedDict):
        aws_log_source_resource: NotRequired[pulumi.Input['SubscriberSourceAwsLogSourceResourceArgsDict']]
        custom_log_source_resource: NotRequired[pulumi.Input['SubscriberSourceCustomLogSourceResourceArgsDict']]
elif False:
    SubscriberSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSourceArgs:
    def __init__(__self__, *,
                 aws_log_source_resource: Optional[pulumi.Input['SubscriberSourceAwsLogSourceResourceArgs']] = None,
                 custom_log_source_resource: Optional[pulumi.Input['SubscriberSourceCustomLogSourceResourceArgs']] = None):
        if aws_log_source_resource is not None:
            pulumi.set(__self__, "aws_log_source_resource", aws_log_source_resource)
        if custom_log_source_resource is not None:
            pulumi.set(__self__, "custom_log_source_resource", custom_log_source_resource)

    @_builtins.property
    @pulumi.getter(name="awsLogSourceResource")
    def aws_log_source_resource(self) -> Optional[pulumi.Input['SubscriberSourceAwsLogSourceResourceArgs']]:
        return pulumi.get(self, "aws_log_source_resource")

    @aws_log_source_resource.setter
    def aws_log_source_resource(self, value: Optional[pulumi.Input['SubscriberSourceAwsLogSourceResourceArgs']]):
        pulumi.set(self, "aws_log_source_resource", value)

    @_builtins.property
    @pulumi.getter(name="customLogSourceResource")
    def custom_log_source_resource(self) -> Optional[pulumi.Input['SubscriberSourceCustomLogSourceResourceArgs']]:
        return pulumi.get(self, "custom_log_source_resource")

    @custom_log_source_resource.setter
    def custom_log_source_resource(self, value: Optional[pulumi.Input['SubscriberSourceCustomLogSourceResourceArgs']]):
        pulumi.set(self, "custom_log_source_resource", value)


if not MYPY:
    class SubscriberSourceAwsLogSourceResourceArgsDict(TypedDict):
        source_name: pulumi.Input[_builtins.str]
        source_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SubscriberSourceAwsLogSourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSourceAwsLogSourceResourceArgs:
    def __init__(__self__, *,
                 source_name: pulumi.Input[_builtins.str],
                 source_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "source_name", source_name)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_version")

    @source_version.setter
    def source_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_version", value)


if not MYPY:
    class SubscriberSourceCustomLogSourceResourceArgsDict(TypedDict):
        source_name: pulumi.Input[_builtins.str]
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceAttributeArgsDict']]]]
        providers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceProviderArgsDict']]]]
        source_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SubscriberSourceCustomLogSourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSourceCustomLogSourceResourceArgs:
    def __init__(__self__, *,
                 source_name: pulumi.Input[_builtins.str],
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceAttributeArgs']]]] = None,
                 providers: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceProviderArgs']]]] = None,
                 source_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "source_name", source_name)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if providers is not None:
            pulumi.set(__self__, "providers", providers)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_name", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceAttributeArgs']]]]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def providers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceProviderArgs']]]]:
        return pulumi.get(self, "providers")

    @providers.setter
    def providers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberSourceCustomLogSourceResourceProviderArgs']]]]):
        pulumi.set(self, "providers", value)

    @_builtins.property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_version")

    @source_version.setter
    def source_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_version", value)


if not MYPY:
    class SubscriberSourceCustomLogSourceResourceAttributeArgsDict(TypedDict):
        crawler_arn: pulumi.Input[_builtins.str]
        database_arn: pulumi.Input[_builtins.str]
        table_arn: pulumi.Input[_builtins.str]
elif False:
    SubscriberSourceCustomLogSourceResourceAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSourceCustomLogSourceResourceAttributeArgs:
    def __init__(__self__, *,
                 crawler_arn: pulumi.Input[_builtins.str],
                 database_arn: pulumi.Input[_builtins.str],
                 table_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "crawler_arn", crawler_arn)
        pulumi.set(__self__, "database_arn", database_arn)
        pulumi.set(__self__, "table_arn", table_arn)

    @_builtins.property
    @pulumi.getter(name="crawlerArn")
    def crawler_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "crawler_arn")

    @crawler_arn.setter
    def crawler_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "crawler_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseArn")
    def database_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_arn")

    @database_arn.setter
    def database_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_arn", value)


if not MYPY:
    class SubscriberSourceCustomLogSourceResourceProviderArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
elif False:
    SubscriberSourceCustomLogSourceResourceProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSourceCustomLogSourceResourceProviderArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class SubscriberSubscriberIdentityArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        principal: pulumi.Input[_builtins.str]
elif False:
    SubscriberSubscriberIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberSubscriberIdentityArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class SubscriberTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    SubscriberTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


