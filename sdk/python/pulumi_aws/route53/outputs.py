# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ProfilesAssociationTimeouts',
    'ProfilesProfileTimeouts',
    'ProfilesResourceAssociationTimeouts',
    'RecordAlias',
    'RecordCidrRoutingPolicy',
    'RecordFailoverRoutingPolicy',
    'RecordGeolocationRoutingPolicy',
    'RecordGeoproximityRoutingPolicy',
    'RecordGeoproximityRoutingPolicyCoordinate',
    'RecordLatencyRoutingPolicy',
    'RecordWeightedRoutingPolicy',
    'RecordsExclusiveResourceRecordSet',
    'RecordsExclusiveResourceRecordSetAliasTarget',
    'RecordsExclusiveResourceRecordSetCidrRoutingConfig',
    'RecordsExclusiveResourceRecordSetGeolocation',
    'RecordsExclusiveResourceRecordSetGeoproximityLocation',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinates',
    'RecordsExclusiveResourceRecordSetResourceRecord',
    'RecordsExclusiveTimeouts',
    'ResolverEndpointIpAddress',
    'ResolverRuleTargetIp',
    'ZoneVpc',
    'GetProfilesProfilesProfileResult',
    'GetQueryLogConfigFilterResult',
    'GetRecordsResourceRecordSetResult',
    'GetRecordsResourceRecordSetAliasTargetResult',
    'GetRecordsResourceRecordSetCidrRoutingConfigResult',
    'GetRecordsResourceRecordSetGeolocationResult',
    'GetRecordsResourceRecordSetGeoproximityLocationResult',
    'GetRecordsResourceRecordSetGeoproximityLocationCoordinatesResult',
    'GetRecordsResourceRecordSetResourceRecordResult',
    'GetResolverEndpointFilterResult',
    'GetResolverFirewallRulesFirewallRuleResult',
    'GetTrafficPolicyDocumentEndpointResult',
    'GetTrafficPolicyDocumentRuleResult',
    'GetTrafficPolicyDocumentRuleGeoProximityLocationResult',
    'GetTrafficPolicyDocumentRuleItemResult',
    'GetTrafficPolicyDocumentRuleLocationResult',
    'GetTrafficPolicyDocumentRulePrimaryResult',
    'GetTrafficPolicyDocumentRuleRegionResult',
    'GetTrafficPolicyDocumentRuleSecondaryResult',
]

@pulumi.output_type
class ProfilesAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ProfilesProfileTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 read: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class ProfilesResourceAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 read: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class RecordAlias(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateTargetHealth":
            suggest = "evaluate_target_health"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordAlias. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordAlias.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordAlias.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluate_target_health: _builtins.bool,
                 name: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.bool evaluate_target_health: Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
        :param _builtins.str name: DNS domain name for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or another resource record set in this hosted zone.
        :param _builtins.str zone_id: Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
        """
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> _builtins.bool:
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        DNS domain name for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or another resource record set in this hosted zone.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class RecordCidrRoutingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionId":
            suggest = "collection_id"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordCidrRoutingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordCidrRoutingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordCidrRoutingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_id: _builtins.str,
                 location_name: _builtins.str):
        """
        :param _builtins.str collection_id: The CIDR collection ID. See the `route53.CidrCollection` resource for more details.
        :param _builtins.str location_name: The CIDR collection location name. See the `route53.CidrLocation` resource for more details. A `location_name` with an asterisk `"*"` can be used to create a default CIDR record. `collection_id` is still required for default record.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> _builtins.str:
        """
        The CIDR collection ID. See the `route53.CidrCollection` resource for more details.
        """
        return pulumi.get(self, "collection_id")

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        The CIDR collection location name. See the `route53.CidrLocation` resource for more details. A `location_name` with an asterisk `"*"` can be used to create a default CIDR record. `collection_id` is still required for default record.
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class RecordFailoverRoutingPolicy(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RecordGeolocationRoutingPolicy(dict):
    def __init__(__self__, *,
                 continent: Optional[_builtins.str] = None,
                 country: Optional[_builtins.str] = None,
                 subdivision: Optional[_builtins.str] = None):
        """
        :param _builtins.str continent: A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
        :param _builtins.str country: A two-character country code or `*` to indicate a default resource record set.
        :param _builtins.str subdivision: A subdivision code for a country.
        """
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[_builtins.str]:
        """
        A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        A two-character country code or `*` to indicate a default resource record set.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def subdivision(self) -> Optional[_builtins.str]:
        """
        A subdivision code for a country.
        """
        return pulumi.get(self, "subdivision")


@pulumi.output_type
class RecordGeoproximityRoutingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsRegion":
            suggest = "aws_region"
        elif key == "localZoneGroup":
            suggest = "local_zone_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordGeoproximityRoutingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordGeoproximityRoutingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordGeoproximityRoutingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_region: Optional[_builtins.str] = None,
                 bias: Optional[_builtins.int] = None,
                 coordinates: Optional[Sequence['outputs.RecordGeoproximityRoutingPolicyCoordinate']] = None,
                 local_zone_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str aws_region: A AWS region where the resource is present.
        :param _builtins.int bias: Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
        :param Sequence['RecordGeoproximityRoutingPolicyCoordinateArgs'] coordinates: Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
        :param _builtins.str local_zone_group: A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
        """
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[_builtins.str]:
        """
        A AWS region where the resource is present.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[_builtins.int]:
        """
        Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
        """
        return pulumi.get(self, "bias")

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> Optional[Sequence['outputs.RecordGeoproximityRoutingPolicyCoordinate']]:
        """
        Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
        """
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[_builtins.str]:
        """
        A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
        """
        return pulumi.get(self, "local_zone_group")


@pulumi.output_type
class RecordGeoproximityRoutingPolicyCoordinate(dict):
    def __init__(__self__, *,
                 latitude: _builtins.str,
                 longitude: _builtins.str):
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.str:
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.str:
        return pulumi.get(self, "longitude")


@pulumi.output_type
class RecordLatencyRoutingPolicy(dict):
    def __init__(__self__, *,
                 region: _builtins.str):
        """
        :param _builtins.str region: An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
        """
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class RecordWeightedRoutingPolicy(dict):
    def __init__(__self__, *,
                 weight: _builtins.int):
        """
        :param _builtins.int weight: A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
        """
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RecordsExclusiveResourceRecordSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasTarget":
            suggest = "alias_target"
        elif key == "cidrRoutingConfig":
            suggest = "cidr_routing_config"
        elif key == "geoproximityLocation":
            suggest = "geoproximity_location"
        elif key == "healthCheckId":
            suggest = "health_check_id"
        elif key == "multiValueAnswer":
            suggest = "multi_value_answer"
        elif key == "resourceRecords":
            suggest = "resource_records"
        elif key == "setIdentifier":
            suggest = "set_identifier"
        elif key == "trafficPolicyInstanceId":
            suggest = "traffic_policy_instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordsExclusiveResourceRecordSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordsExclusiveResourceRecordSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordsExclusiveResourceRecordSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alias_target: Optional['outputs.RecordsExclusiveResourceRecordSetAliasTarget'] = None,
                 cidr_routing_config: Optional['outputs.RecordsExclusiveResourceRecordSetCidrRoutingConfig'] = None,
                 failover: Optional[_builtins.str] = None,
                 geolocation: Optional['outputs.RecordsExclusiveResourceRecordSetGeolocation'] = None,
                 geoproximity_location: Optional['outputs.RecordsExclusiveResourceRecordSetGeoproximityLocation'] = None,
                 health_check_id: Optional[_builtins.str] = None,
                 multi_value_answer: Optional[_builtins.bool] = None,
                 region: Optional[_builtins.str] = None,
                 resource_records: Optional[Sequence['outputs.RecordsExclusiveResourceRecordSetResourceRecord']] = None,
                 set_identifier: Optional[_builtins.str] = None,
                 traffic_policy_instance_id: Optional[_builtins.str] = None,
                 ttl: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the record.
        :param 'RecordsExclusiveResourceRecordSetAliasTargetArgs' alias_target: Alias target block.
               See `alias_target` below.
        :param _builtins.str failover: Type of failover resource record.
               Valid values are `PRIMARY` and `SECONDARY`.
               See the [AWS documentation on DNS failover](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html) for additional details.
        :param 'RecordsExclusiveResourceRecordSetGeolocationArgs' geolocation: Geolocation block to control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
               See `geolocation` below.
        :param 'RecordsExclusiveResourceRecordSetGeoproximityLocationArgs' geoproximity_location: Geoproximity location block.
               See `geoproximity_location` below.
        :param _builtins.str health_check_id: Health check the record should be associated with.
        :param _builtins.str region: AWS region of the resource this record set refers to.
               Must be a valid AWS region name.
               See the [AWS documentation](http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency) on latency based routing for additional details.
        :param Sequence['RecordsExclusiveResourceRecordSetResourceRecordArgs'] resource_records: Information about the resource records to act upon.
               See `resource_records` below.
        :param _builtins.str set_identifier: An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
               Required if using `cidr_routing_config`, `failover`, `geolocation`,`geoproximity_location`, `multivalue_answer`, `region`, or `weight`.
        :param _builtins.int ttl: Resource record cache time to live (TTL), in seconds.
        :param _builtins.str type: Record type.
               Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `TXT`, `TLSA`, `SSHFP`, `SVCB`, and `HTTPS`.
               
               The following arguments are optional:
               
               > Exactly one of `resource_records` or `alias_target` must be specified.
        :param _builtins.int weight: Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        pulumi.set(__self__, "name", name)
        if alias_target is not None:
            pulumi.set(__self__, "alias_target", alias_target)
        if cidr_routing_config is not None:
            pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if geolocation is not None:
            pulumi.set(__self__, "geolocation", geolocation)
        if geoproximity_location is not None:
            pulumi.set(__self__, "geoproximity_location", geoproximity_location)
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if multi_value_answer is not None:
            pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_records is not None:
            pulumi.set(__self__, "resource_records", resource_records)
        if set_identifier is not None:
            pulumi.set(__self__, "set_identifier", set_identifier)
        if traffic_policy_instance_id is not None:
            pulumi.set(__self__, "traffic_policy_instance_id", traffic_policy_instance_id)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the record.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional['outputs.RecordsExclusiveResourceRecordSetAliasTarget']:
        """
        Alias target block.
        See `alias_target` below.
        """
        return pulumi.get(self, "alias_target")

    @_builtins.property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional['outputs.RecordsExclusiveResourceRecordSetCidrRoutingConfig']:
        return pulumi.get(self, "cidr_routing_config")

    @_builtins.property
    @pulumi.getter
    def failover(self) -> Optional[_builtins.str]:
        """
        Type of failover resource record.
        Valid values are `PRIMARY` and `SECONDARY`.
        See the [AWS documentation on DNS failover](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html) for additional details.
        """
        return pulumi.get(self, "failover")

    @_builtins.property
    @pulumi.getter
    def geolocation(self) -> Optional['outputs.RecordsExclusiveResourceRecordSetGeolocation']:
        """
        Geolocation block to control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        See `geolocation` below.
        """
        return pulumi.get(self, "geolocation")

    @_builtins.property
    @pulumi.getter(name="geoproximityLocation")
    def geoproximity_location(self) -> Optional['outputs.RecordsExclusiveResourceRecordSetGeoproximityLocation']:
        """
        Geoproximity location block.
        See `geoproximity_location` below.
        """
        return pulumi.get(self, "geoproximity_location")

    @_builtins.property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[_builtins.str]:
        """
        Health check the record should be associated with.
        """
        return pulumi.get(self, "health_check_id")

    @_builtins.property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "multi_value_answer")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        AWS region of the resource this record set refers to.
        Must be a valid AWS region name.
        See the [AWS documentation](http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency) on latency based routing for additional details.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[Sequence['outputs.RecordsExclusiveResourceRecordSetResourceRecord']]:
        """
        Information about the resource records to act upon.
        See `resource_records` below.
        """
        return pulumi.get(self, "resource_records")

    @_builtins.property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[_builtins.str]:
        """
        An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
        Required if using `cidr_routing_config`, `failover`, `geolocation`,`geoproximity_location`, `multivalue_answer`, `region`, or `weight`.
        """
        return pulumi.get(self, "set_identifier")

    @_builtins.property
    @pulumi.getter(name="trafficPolicyInstanceId")
    def traffic_policy_instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "traffic_policy_instance_id")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        Resource record cache time to live (TTL), in seconds.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Record type.
        Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `TXT`, `TLSA`, `SSHFP`, `SVCB`, and `HTTPS`.

        The following arguments are optional:

        > Exactly one of `resource_records` or `alias_target` must be specified.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetAliasTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "evaluateTargetHealth":
            suggest = "evaluate_target_health"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordsExclusiveResourceRecordSetAliasTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordsExclusiveResourceRecordSetAliasTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordsExclusiveResourceRecordSetAliasTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 evaluate_target_health: _builtins.bool,
                 hosted_zone_id: _builtins.str):
        """
        :param _builtins.str dns_name: DNS domain name for another resource record set in this hosted zone.
        :param _builtins.bool evaluate_target_health: Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [the AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health) for additional details.
        :param _builtins.str hosted_zone_id: Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for an example.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        DNS domain name for another resource record set in this hosted zone.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> _builtins.bool:
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [the AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health) for additional details.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for an example.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetCidrRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionId":
            suggest = "collection_id"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordsExclusiveResourceRecordSetCidrRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordsExclusiveResourceRecordSetCidrRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordsExclusiveResourceRecordSetCidrRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_id: _builtins.str,
                 location_name: _builtins.str):
        """
        :param _builtins.str collection_id: CIDR collection ID.
               See the `route53.CidrCollection` resource for more details.
        :param _builtins.str location_name: CIDR collection location name.
               See the `route53.CidrLocation` resource for more details.
               A `location_name` with an asterisk `"*"` can be used to create a default CIDR record.
               `collection_id` is still required for a default record.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> _builtins.str:
        """
        CIDR collection ID.
        See the `route53.CidrCollection` resource for more details.
        """
        return pulumi.get(self, "collection_id")

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        CIDR collection location name.
        See the `route53.CidrLocation` resource for more details.
        A `location_name` with an asterisk `"*"` can be used to create a default CIDR record.
        `collection_id` is still required for a default record.
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetGeolocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continentCode":
            suggest = "continent_code"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "subdivisionCode":
            suggest = "subdivision_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordsExclusiveResourceRecordSetGeolocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordsExclusiveResourceRecordSetGeolocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordsExclusiveResourceRecordSetGeolocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent_code: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 subdivision_code: Optional[_builtins.str] = None):
        if continent_code is not None:
            pulumi.set(__self__, "continent_code", continent_code)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if subdivision_code is not None:
            pulumi.set(__self__, "subdivision_code", subdivision_code)

    @_builtins.property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "continent_code")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subdivision_code")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetGeoproximityLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsRegion":
            suggest = "aws_region"
        elif key == "localZoneGroup":
            suggest = "local_zone_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordsExclusiveResourceRecordSetGeoproximityLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordsExclusiveResourceRecordSetGeoproximityLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordsExclusiveResourceRecordSetGeoproximityLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_region: Optional[_builtins.str] = None,
                 bias: Optional[_builtins.int] = None,
                 coordinates: Optional['outputs.RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinates'] = None,
                 local_zone_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str aws_region: AWS region of the resource where DNS traffic is directed to.
        :param _builtins.int bias: Increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
               To expand the size of the geographic region from which Route 53 routes traffic to a resource, specify a positive integer from `1` to `99`.
               To shrink the size of the geographic region from which Route 53 routes traffic to a resource, specify a negative bias of `-1` to `-99`.
               See the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html) for additional details.
        :param 'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs' coordinates: Coordinates for a geoproximity resource record.
               See `coordinates` below.
        :param _builtins.str local_zone_group: AWS local zone group.
               Identify the Local Zones Group for a specific Local Zone by using the [`describe-availability-zones` CLI command](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html).
        """
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[_builtins.str]:
        """
        AWS region of the resource where DNS traffic is directed to.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[_builtins.int]:
        """
        Increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
        To expand the size of the geographic region from which Route 53 routes traffic to a resource, specify a positive integer from `1` to `99`.
        To shrink the size of the geographic region from which Route 53 routes traffic to a resource, specify a negative bias of `-1` to `-99`.
        See the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html) for additional details.
        """
        return pulumi.get(self, "bias")

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> Optional['outputs.RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinates']:
        """
        Coordinates for a geoproximity resource record.
        See `coordinates` below.
        """
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[_builtins.str]:
        """
        AWS local zone group.
        Identify the Local Zones Group for a specific Local Zone by using the [`describe-availability-zones` CLI command](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html).
        """
        return pulumi.get(self, "local_zone_group")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinates(dict):
    def __init__(__self__, *,
                 latitude: _builtins.str,
                 longitude: _builtins.str):
        """
        :param _builtins.str latitude: A coordinate of the north–south position of a geographic point on the surface of the Earth (`-90` - `90`).
        :param _builtins.str longitude: A coordinate of the east–west position of a geographic point on the surface of the Earth (`-180` - `180`).
        """
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.str:
        """
        A coordinate of the north–south position of a geographic point on the surface of the Earth (`-90` - `90`).
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.str:
        """
        A coordinate of the east–west position of a geographic point on the surface of the Earth (`-180` - `180`).
        """
        return pulumi.get(self, "longitude")


@pulumi.output_type
class RecordsExclusiveResourceRecordSetResourceRecord(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: DNS record value.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        DNS record value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecordsExclusiveTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ResolverEndpointIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipId":
            suggest = "ip_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResolverEndpointIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResolverEndpointIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResolverEndpointIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 ip: Optional[_builtins.str] = None,
                 ip_id: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet that contains the IP address.
        :param _builtins.str ip: IPv4 address in the subnet that you want to use for DNS queries.
        :param _builtins.str ipv6: IPv6 address in the subnet that you want to use for DNS queries.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_id is not None:
            pulumi.set(__self__, "ip_id", ip_id)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that contains the IP address.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        IPv4 address in the subnet that you want to use for DNS queries.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ipId")
    def ip_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_id")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        """
        IPv6 address in the subnet that you want to use for DNS queries.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class ResolverRuleTargetIp(dict):
    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip: One IPv4 address that you want to forward DNS queries to.
        :param _builtins.str ipv6: One IPv6 address that you want to forward DNS queries to.
        :param _builtins.int port: Port at `ip` that you want to forward DNS queries to. Default value is `53`.
        :param _builtins.str protocol: Protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        One IPv4 address that you want to forward DNS queries to.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        """
        One IPv6 address that you want to forward DNS queries to.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port at `ip` that you want to forward DNS queries to. Default value is `53`.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ZoneVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"
        elif key == "vpcRegion":
            suggest = "vpc_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_id: _builtins.str,
                 vpc_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str vpc_id: ID of the VPC to associate.
        :param _builtins.str vpc_region: Region of the VPC to associate. Defaults to AWS provider region.
        """
        pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_region is not None:
            pulumi.set(__self__, "vpc_region", vpc_region)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        ID of the VPC to associate.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vpcRegion")
    def vpc_region(self) -> Optional[_builtins.str]:
        """
        Region of the VPC to associate. Defaults to AWS provider region.
        """
        return pulumi.get(self, "vpc_region")


@pulumi.output_type
class GetProfilesProfilesProfileResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 share_status: _builtins.str):
        """
        :param _builtins.str arn: ARN of the Profile.
        :param _builtins.str id: ID of the Profile.
        :param _builtins.str name: Name of the Profile.
        :param _builtins.str share_status: Share status of the Profile. Valid values [AWS docs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53profiles_Profile.html)
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_status", share_status)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Profile.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the Profile.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="shareStatus")
    def share_status(self) -> _builtins.str:
        """
        Share status of the Profile. Valid values [AWS docs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53profiles_Profile.html)
        """
        return pulumi.get(self, "share_status")


@pulumi.output_type
class GetQueryLogConfigFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the query logging configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the query logging configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRecordsResourceRecordSetResult(dict):
    def __init__(__self__, *,
                 alias_target: 'outputs.GetRecordsResourceRecordSetAliasTargetResult',
                 cidr_routing_config: 'outputs.GetRecordsResourceRecordSetCidrRoutingConfigResult',
                 failover: _builtins.str,
                 geolocation: 'outputs.GetRecordsResourceRecordSetGeolocationResult',
                 geoproximity_location: 'outputs.GetRecordsResourceRecordSetGeoproximityLocationResult',
                 health_check_id: _builtins.str,
                 multi_value_answer: _builtins.bool,
                 name: _builtins.str,
                 region: _builtins.str,
                 resource_records: Sequence['outputs.GetRecordsResourceRecordSetResourceRecordResult'],
                 set_identifier: _builtins.str,
                 traffic_policy_instance_id: _builtins.str,
                 ttl: _builtins.int,
                 type: _builtins.str,
                 weight: _builtins.int):
        """
        :param 'GetRecordsResourceRecordSetAliasTargetArgs' alias_target: Information about the AWS resource traffic is routed to.
        :param 'GetRecordsResourceRecordSetCidrRoutingConfigArgs' cidr_routing_config: Information about the CIDR location traffic is routed to.
        :param _builtins.str failover: `PRIMARY` or `SECONDARY`.
        :param 'GetRecordsResourceRecordSetGeolocationArgs' geolocation: Information about how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        :param 'GetRecordsResourceRecordSetGeoproximityLocationArgs' geoproximity_location: Information about how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        :param _builtins.str health_check_id: ID of any applicable health check.
        :param _builtins.bool multi_value_answer: Traffic is routed approximately randomly to multiple resources.
        :param _builtins.str name: The name of the record.
        :param _builtins.str region: The Amazon EC2 Region of the resource that this resource record set refers to.
        :param Sequence['GetRecordsResourceRecordSetResourceRecordArgs'] resource_records: The resource records.
        :param _builtins.str set_identifier: An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
        :param _builtins.str traffic_policy_instance_id: The ID of any traffic policy instance that Route 53 created this resource record set for.
        :param _builtins.int ttl: The resource record cache time to live (TTL), in seconds.
        :param _builtins.str type: The DNS record type.
        :param _builtins.int weight: Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        pulumi.set(__self__, "alias_target", alias_target)
        pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        pulumi.set(__self__, "failover", failover)
        pulumi.set(__self__, "geolocation", geolocation)
        pulumi.set(__self__, "geoproximity_location", geoproximity_location)
        pulumi.set(__self__, "health_check_id", health_check_id)
        pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resource_records", resource_records)
        pulumi.set(__self__, "set_identifier", set_identifier)
        pulumi.set(__self__, "traffic_policy_instance_id", traffic_policy_instance_id)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> 'outputs.GetRecordsResourceRecordSetAliasTargetResult':
        """
        Information about the AWS resource traffic is routed to.
        """
        return pulumi.get(self, "alias_target")

    @_builtins.property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> 'outputs.GetRecordsResourceRecordSetCidrRoutingConfigResult':
        """
        Information about the CIDR location traffic is routed to.
        """
        return pulumi.get(self, "cidr_routing_config")

    @_builtins.property
    @pulumi.getter
    def failover(self) -> _builtins.str:
        """
        `PRIMARY` or `SECONDARY`.
        """
        return pulumi.get(self, "failover")

    @_builtins.property
    @pulumi.getter
    def geolocation(self) -> 'outputs.GetRecordsResourceRecordSetGeolocationResult':
        """
        Information about how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        """
        return pulumi.get(self, "geolocation")

    @_builtins.property
    @pulumi.getter(name="geoproximityLocation")
    def geoproximity_location(self) -> 'outputs.GetRecordsResourceRecordSetGeoproximityLocationResult':
        """
        Information about how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        """
        return pulumi.get(self, "geoproximity_location")

    @_builtins.property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> _builtins.str:
        """
        ID of any applicable health check.
        """
        return pulumi.get(self, "health_check_id")

    @_builtins.property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> _builtins.bool:
        """
        Traffic is routed approximately randomly to multiple resources.
        """
        return pulumi.get(self, "multi_value_answer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the record.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The Amazon EC2 Region of the resource that this resource record set refers to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Sequence['outputs.GetRecordsResourceRecordSetResourceRecordResult']:
        """
        The resource records.
        """
        return pulumi.get(self, "resource_records")

    @_builtins.property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> _builtins.str:
        """
        An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
        """
        return pulumi.get(self, "set_identifier")

    @_builtins.property
    @pulumi.getter(name="trafficPolicyInstanceId")
    def traffic_policy_instance_id(self) -> _builtins.str:
        """
        The ID of any traffic policy instance that Route 53 created this resource record set for.
        """
        return pulumi.get(self, "traffic_policy_instance_id")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The resource record cache time to live (TTL), in seconds.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The DNS record type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRecordsResourceRecordSetAliasTargetResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 evaluate_target_health: _builtins.bool,
                 hosted_zone_id: _builtins.str):
        """
        :param _builtins.str dns_name: Target DNS name.
        :param _builtins.bool evaluate_target_health: Whether an alias resource record set inherits the health of the referenced AWS resource.
        :param _builtins.str hosted_zone_id: Target hosted zone ID.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        Target DNS name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> _builtins.bool:
        """
        Whether an alias resource record set inherits the health of the referenced AWS resource.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        Target hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class GetRecordsResourceRecordSetCidrRoutingConfigResult(dict):
    def __init__(__self__, *,
                 collection_id: _builtins.str,
                 location_name: _builtins.str):
        """
        :param _builtins.str collection_id: The CIDR collection ID.
        :param _builtins.str location_name: The CIDR collection location name.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> _builtins.str:
        """
        The CIDR collection ID.
        """
        return pulumi.get(self, "collection_id")

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        The CIDR collection location name.
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class GetRecordsResourceRecordSetGeolocationResult(dict):
    def __init__(__self__, *,
                 continent_code: _builtins.str,
                 country_code: _builtins.str,
                 subdivision_code: _builtins.str):
        """
        :param _builtins.str continent_code: The two-letter code for the continent.
        :param _builtins.str country_code: The two-letter code for a country.
        :param _builtins.str subdivision_code: The two-letter code for a state of the United States.
        """
        pulumi.set(__self__, "continent_code", continent_code)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "subdivision_code", subdivision_code)

    @_builtins.property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> _builtins.str:
        """
        The two-letter code for the continent.
        """
        return pulumi.get(self, "continent_code")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The two-letter code for a country.
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> _builtins.str:
        """
        The two-letter code for a state of the United States.
        """
        return pulumi.get(self, "subdivision_code")


@pulumi.output_type
class GetRecordsResourceRecordSetGeoproximityLocationResult(dict):
    def __init__(__self__, *,
                 aws_region: _builtins.str,
                 bias: _builtins.int,
                 coordinates: 'outputs.GetRecordsResourceRecordSetGeoproximityLocationCoordinatesResult',
                 local_zone_group: _builtins.str):
        """
        :param _builtins.str aws_region: The AWS Region the resource you are directing DNS traffic to, is in.
        :param _builtins.int bias: The bias increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
        :param 'GetRecordsResourceRecordSetGeoproximityLocationCoordinatesArgs' coordinates: Contains the longitude and latitude for a geographic region.
        :param _builtins.str local_zone_group: An AWS Local Zone Group.
        """
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "bias", bias)
        pulumi.set(__self__, "coordinates", coordinates)
        pulumi.set(__self__, "local_zone_group", local_zone_group)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> _builtins.str:
        """
        The AWS Region the resource you are directing DNS traffic to, is in.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter
    def bias(self) -> _builtins.int:
        """
        The bias increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
        """
        return pulumi.get(self, "bias")

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> 'outputs.GetRecordsResourceRecordSetGeoproximityLocationCoordinatesResult':
        """
        Contains the longitude and latitude for a geographic region.
        """
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> _builtins.str:
        """
        An AWS Local Zone Group.
        """
        return pulumi.get(self, "local_zone_group")


@pulumi.output_type
class GetRecordsResourceRecordSetGeoproximityLocationCoordinatesResult(dict):
    def __init__(__self__, *,
                 latitude: _builtins.str,
                 longitude: _builtins.str):
        """
        :param _builtins.str latitude: Latitude.
        :param _builtins.str longitude: Longitude.
        """
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.str:
        """
        Latitude.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.str:
        """
        Longitude.
        """
        return pulumi.get(self, "longitude")


@pulumi.output_type
class GetRecordsResourceRecordSetResourceRecordResult(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: The DNS record value.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The DNS record value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResolverEndpointFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetResolverFirewallRulesFirewallRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 block_override_dns_type: _builtins.str,
                 block_override_domain: _builtins.str,
                 block_override_ttl: _builtins.int,
                 block_response: _builtins.str,
                 creation_time: _builtins.str,
                 creator_request_id: _builtins.str,
                 firewall_domain_list_id: _builtins.str,
                 firewall_rule_group_id: _builtins.str,
                 modification_time: _builtins.str,
                 name: _builtins.str,
                 priority: _builtins.int):
        """
        :param _builtins.str action: The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list.
        :param _builtins.str block_override_dns_type: The DNS record's type.
        :param _builtins.str block_override_domain: The custom DNS record to send back in response to the query.
        :param _builtins.int block_override_ttl: The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record.
        :param _builtins.str block_response: The way that you want DNS Firewall to block the request.
        :param _builtins.str creation_time: The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
        :param _builtins.str creator_request_id: A unique string defined by you to identify the request.
        :param _builtins.str firewall_domain_list_id: The ID of the domain list that's used in the rule.
        :param _builtins.str firewall_rule_group_id: The unique identifier of the firewall rule group that you want to retrieve the rules for.
        :param _builtins.str modification_time: The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
        :param _builtins.str name: The name of the rule.
        :param _builtins.int priority: The setting that determines the processing order of the rules in a rule group.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "block_override_dns_type", block_override_dns_type)
        pulumi.set(__self__, "block_override_domain", block_override_domain)
        pulumi.set(__self__, "block_override_ttl", block_override_ttl)
        pulumi.set(__self__, "block_response", block_response)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "creator_request_id", creator_request_id)
        pulumi.set(__self__, "firewall_domain_list_id", firewall_domain_list_id)
        pulumi.set(__self__, "firewall_rule_group_id", firewall_rule_group_id)
        pulumi.set(__self__, "modification_time", modification_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="blockOverrideDnsType")
    def block_override_dns_type(self) -> _builtins.str:
        """
        The DNS record's type.
        """
        return pulumi.get(self, "block_override_dns_type")

    @_builtins.property
    @pulumi.getter(name="blockOverrideDomain")
    def block_override_domain(self) -> _builtins.str:
        """
        The custom DNS record to send back in response to the query.
        """
        return pulumi.get(self, "block_override_domain")

    @_builtins.property
    @pulumi.getter(name="blockOverrideTtl")
    def block_override_ttl(self) -> _builtins.int:
        """
        The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record.
        """
        return pulumi.get(self, "block_override_ttl")

    @_builtins.property
    @pulumi.getter(name="blockResponse")
    def block_response(self) -> _builtins.str:
        """
        The way that you want DNS Firewall to block the request.
        """
        return pulumi.get(self, "block_response")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter(name="creatorRequestId")
    def creator_request_id(self) -> _builtins.str:
        """
        A unique string defined by you to identify the request.
        """
        return pulumi.get(self, "creator_request_id")

    @_builtins.property
    @pulumi.getter(name="firewallDomainListId")
    def firewall_domain_list_id(self) -> _builtins.str:
        """
        The ID of the domain list that's used in the rule.
        """
        return pulumi.get(self, "firewall_domain_list_id")

    @_builtins.property
    @pulumi.getter(name="firewallRuleGroupId")
    def firewall_rule_group_id(self) -> _builtins.str:
        """
        The unique identifier of the firewall rule group that you want to retrieve the rules for.
        """
        return pulumi.get(self, "firewall_rule_group_id")

    @_builtins.property
    @pulumi.getter(name="modificationTime")
    def modification_time(self) -> _builtins.str:
        """
        The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
        """
        return pulumi.get(self, "modification_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The setting that determines the processing order of the rules in a rule group.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetTrafficPolicyDocumentEndpointResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of an endpoint you want to assign.
        :param _builtins.str region: To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
        :param _builtins.str type: Type of the endpoint. Valid values are `value`, `cloudfront`, `elastic-load-balancer`, `s3-website`, `application-load-balancer`, `network-load-balancer` and `elastic-beanstalk`
        :param _builtins.str value: Value of the `type`.
        """
        pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of an endpoint you want to assign.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the endpoint. Valid values are `value`, `cloudfront`, `elastic-load-balancer`, `s3-website`, `application-load-balancer`, `network-load-balancer` and `elastic-beanstalk`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the `type`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 geo_proximity_locations: Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleGeoProximityLocationResult']] = None,
                 items: Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleItemResult']] = None,
                 locations: Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleLocationResult']] = None,
                 primary: Optional['outputs.GetTrafficPolicyDocumentRulePrimaryResult'] = None,
                 regions: Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleRegionResult']] = None,
                 secondary: Optional['outputs.GetTrafficPolicyDocumentRuleSecondaryResult'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of a rule you want to assign.
        :param Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs'] geo_proximity_locations: Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
        :param Sequence['GetTrafficPolicyDocumentRuleItemArgs'] items: Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
        :param Sequence['GetTrafficPolicyDocumentRuleLocationArgs'] locations: Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
        :param 'GetTrafficPolicyDocumentRulePrimaryArgs' primary: Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
        :param 'GetTrafficPolicyDocumentRuleSecondaryArgs' secondary: Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
        :param _builtins.str type: Type of the rule.
        """
        pulumi.set(__self__, "id", id)
        if geo_proximity_locations is not None:
            pulumi.set(__self__, "geo_proximity_locations", geo_proximity_locations)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of a rule you want to assign.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="geoProximityLocations")
    def geo_proximity_locations(self) -> Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleGeoProximityLocationResult']]:
        """
        Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
        """
        return pulumi.get(self, "geo_proximity_locations")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleItemResult']]:
        """
        Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleLocationResult']]:
        """
        Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.GetTrafficPolicyDocumentRulePrimaryResult']:
        """
        Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence['outputs.GetTrafficPolicyDocumentRuleRegionResult']]:
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.GetTrafficPolicyDocumentRuleSecondaryResult']:
        """
        Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
        """
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleGeoProximityLocationResult(dict):
    def __init__(__self__, *,
                 bias: Optional[_builtins.str] = None,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 latitude: Optional[_builtins.str] = None,
                 longitude: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        """
        :param _builtins.str bias: Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
        :param _builtins.str endpoint_reference: References to an endpoint.
        :param _builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param _builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param _builtins.str latitude: Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
        :param _builtins.str longitude: Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
        :param _builtins.str region: If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
        :param _builtins.str rule_reference: References to a rule.
        """
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[_builtins.str]:
        """
        Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
        """
        return pulumi.get(self, "bias")

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> Optional[_builtins.str]:
        """
        Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> Optional[_builtins.str]:
        """
        Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleItemResult(dict):
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 health_check: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleLocationResult(dict):
    def __init__(__self__, *,
                 continent: Optional[_builtins.str] = None,
                 country: Optional[_builtins.str] = None,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 rule_reference: Optional[_builtins.str] = None,
                 subdivision: Optional[_builtins.str] = None):
        """
        :param _builtins.str continent: Value of a continent.
        :param _builtins.str country: Value of a country.
        :param _builtins.str endpoint_reference: References to an endpoint.
        :param _builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param _builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param _builtins.bool is_default: Indicates whether this set of values represents the default location.
        :param _builtins.str rule_reference: References to a rule.
        :param _builtins.str subdivision: Value of a subdivision.
        """
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[_builtins.str]:
        """
        Value of a continent.
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        Value of a country.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates whether this set of values represents the default location.
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")

    @_builtins.property
    @pulumi.getter
    def subdivision(self) -> Optional[_builtins.str]:
        """
        Value of a subdivision.
        """
        return pulumi.get(self, "subdivision")


@pulumi.output_type
class GetTrafficPolicyDocumentRulePrimaryResult(dict):
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint_reference: References to an endpoint.
        :param _builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param _builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param _builtins.str rule_reference: References to a rule.
        """
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleRegionResult(dict):
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint_reference: References to an endpoint.
        :param _builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param _builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param _builtins.str region: Region code for the AWS Region that you created the resource in.
        :param _builtins.str rule_reference: References to a rule.
        """
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region code for the AWS Region that you created the resource in.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")


@pulumi.output_type
class GetTrafficPolicyDocumentRuleSecondaryResult(dict):
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")


