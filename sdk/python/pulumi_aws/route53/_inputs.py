# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ProfilesAssociationTimeoutsArgs',
    'ProfilesAssociationTimeoutsArgsDict',
    'ProfilesProfileTimeoutsArgs',
    'ProfilesProfileTimeoutsArgsDict',
    'ProfilesResourceAssociationTimeoutsArgs',
    'ProfilesResourceAssociationTimeoutsArgsDict',
    'RecordAliasArgs',
    'RecordAliasArgsDict',
    'RecordCidrRoutingPolicyArgs',
    'RecordCidrRoutingPolicyArgsDict',
    'RecordFailoverRoutingPolicyArgs',
    'RecordFailoverRoutingPolicyArgsDict',
    'RecordGeolocationRoutingPolicyArgs',
    'RecordGeolocationRoutingPolicyArgsDict',
    'RecordGeoproximityRoutingPolicyArgs',
    'RecordGeoproximityRoutingPolicyArgsDict',
    'RecordGeoproximityRoutingPolicyCoordinateArgs',
    'RecordGeoproximityRoutingPolicyCoordinateArgsDict',
    'RecordLatencyRoutingPolicyArgs',
    'RecordLatencyRoutingPolicyArgsDict',
    'RecordWeightedRoutingPolicyArgs',
    'RecordWeightedRoutingPolicyArgsDict',
    'RecordsExclusiveResourceRecordSetArgs',
    'RecordsExclusiveResourceRecordSetArgsDict',
    'RecordsExclusiveResourceRecordSetAliasTargetArgs',
    'RecordsExclusiveResourceRecordSetAliasTargetArgsDict',
    'RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs',
    'RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict',
    'RecordsExclusiveResourceRecordSetGeolocationArgs',
    'RecordsExclusiveResourceRecordSetGeolocationArgsDict',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationArgs',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict',
    'RecordsExclusiveResourceRecordSetResourceRecordArgs',
    'RecordsExclusiveResourceRecordSetResourceRecordArgsDict',
    'RecordsExclusiveTimeoutsArgs',
    'RecordsExclusiveTimeoutsArgsDict',
    'ResolverEndpointIpAddressArgs',
    'ResolverEndpointIpAddressArgsDict',
    'ResolverRuleTargetIpArgs',
    'ResolverRuleTargetIpArgsDict',
    'ZoneVpcArgs',
    'ZoneVpcArgsDict',
    'GetQueryLogConfigFilterArgs',
    'GetQueryLogConfigFilterArgsDict',
    'GetResolverEndpointFilterArgs',
    'GetResolverEndpointFilterArgsDict',
    'GetTrafficPolicyDocumentEndpointArgs',
    'GetTrafficPolicyDocumentEndpointArgsDict',
    'GetTrafficPolicyDocumentRuleArgs',
    'GetTrafficPolicyDocumentRuleArgsDict',
    'GetTrafficPolicyDocumentRuleGeoProximityLocationArgs',
    'GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict',
    'GetTrafficPolicyDocumentRuleItemArgs',
    'GetTrafficPolicyDocumentRuleItemArgsDict',
    'GetTrafficPolicyDocumentRuleLocationArgs',
    'GetTrafficPolicyDocumentRuleLocationArgsDict',
    'GetTrafficPolicyDocumentRulePrimaryArgs',
    'GetTrafficPolicyDocumentRulePrimaryArgsDict',
    'GetTrafficPolicyDocumentRuleRegionArgs',
    'GetTrafficPolicyDocumentRuleRegionArgsDict',
    'GetTrafficPolicyDocumentRuleSecondaryArgs',
    'GetTrafficPolicyDocumentRuleSecondaryArgsDict',
]

MYPY = False

if not MYPY:
    class ProfilesAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProfilesAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ProfilesProfileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    ProfilesProfileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesProfileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class ProfilesResourceAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    ProfilesResourceAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesResourceAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class RecordAliasArgsDict(TypedDict):
        evaluate_target_health: pulumi.Input[_builtins.bool]
        name: pulumi.Input[_builtins.str]
        zone_id: pulumi.Input[_builtins.str]
elif False:
    RecordAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordAliasArgs:
    def __init__(__self__, *,
                 evaluate_target_health: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 zone_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class RecordCidrRoutingPolicyArgsDict(TypedDict):
        collection_id: pulumi.Input[_builtins.str]
        location_name: pulumi.Input[_builtins.str]
elif False:
    RecordCidrRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordCidrRoutingPolicyArgs:
    def __init__(__self__, *,
                 collection_id: pulumi.Input[_builtins.str],
                 location_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_id", value)

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class RecordFailoverRoutingPolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
elif False:
    RecordFailoverRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordFailoverRoutingPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RecordGeolocationRoutingPolicyArgsDict(TypedDict):
        continent: NotRequired[pulumi.Input[_builtins.str]]
        country: NotRequired[pulumi.Input[_builtins.str]]
        subdivision: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecordGeolocationRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeolocationRoutingPolicyArgs:
    def __init__(__self__, *,
                 continent: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 subdivision: Optional[pulumi.Input[_builtins.str]] = None):
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "continent", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def subdivision(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subdivision")

    @subdivision.setter
    def subdivision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdivision", value)


if not MYPY:
    class RecordGeoproximityRoutingPolicyArgsDict(TypedDict):
        aws_region: NotRequired[pulumi.Input[_builtins.str]]
        bias: NotRequired[pulumi.Input[_builtins.int]]
        coordinates: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgsDict']]]]
        local_zone_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecordGeoproximityRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeoproximityRoutingPolicyArgs:
    def __init__(__self__, *,
                 aws_region: Optional[pulumi.Input[_builtins.str]] = None,
                 bias: Optional[pulumi.Input[_builtins.int]] = None,
                 coordinates: Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]] = None,
                 local_zone_group: Optional[pulumi.Input[_builtins.str]] = None):
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aws_region", value)

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bias", value)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]]):
        pulumi.set(self, "coordinates", value)

    @_builtins.property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_zone_group")

    @local_zone_group.setter
    def local_zone_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_zone_group", value)


if not MYPY:
    class RecordGeoproximityRoutingPolicyCoordinateArgsDict(TypedDict):
        latitude: pulumi.Input[_builtins.str]
        longitude: pulumi.Input[_builtins.str]
elif False:
    RecordGeoproximityRoutingPolicyCoordinateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeoproximityRoutingPolicyCoordinateArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[_builtins.str],
                 longitude: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class RecordLatencyRoutingPolicyArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
elif False:
    RecordLatencyRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordLatencyRoutingPolicyArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class RecordWeightedRoutingPolicyArgsDict(TypedDict):
        weight: pulumi.Input[_builtins.int]
elif False:
    RecordWeightedRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordWeightedRoutingPolicyArgs:
    def __init__(__self__, *,
                 weight: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        alias_target: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgsDict']]
        cidr_routing_config: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict']]
        failover: NotRequired[pulumi.Input[_builtins.str]]
        geolocation: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgsDict']]
        geoproximity_location: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict']]
        health_check_id: NotRequired[pulumi.Input[_builtins.str]]
        multi_value_answer: NotRequired[pulumi.Input[_builtins.bool]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        resource_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgsDict']]]]
        set_identifier: NotRequired[pulumi.Input[_builtins.str]]
        traffic_policy_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    RecordsExclusiveResourceRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alias_target: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']] = None,
                 cidr_routing_config: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']] = None,
                 failover: Optional[pulumi.Input[_builtins.str]] = None,
                 geolocation: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']] = None,
                 geoproximity_location: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']] = None,
                 health_check_id: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_value_answer: Optional[pulumi.Input[_builtins.bool]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_records: Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]] = None,
                 set_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_policy_instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        if alias_target is not None:
            pulumi.set(__self__, "alias_target", alias_target)
        if cidr_routing_config is not None:
            pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if geolocation is not None:
            pulumi.set(__self__, "geolocation", geolocation)
        if geoproximity_location is not None:
            pulumi.set(__self__, "geoproximity_location", geoproximity_location)
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if multi_value_answer is not None:
            pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_records is not None:
            pulumi.set(__self__, "resource_records", resource_records)
        if set_identifier is not None:
            pulumi.set(__self__, "set_identifier", set_identifier)
        if traffic_policy_instance_id is not None:
            pulumi.set(__self__, "traffic_policy_instance_id", traffic_policy_instance_id)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']]:
        return pulumi.get(self, "alias_target")

    @alias_target.setter
    def alias_target(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']]):
        pulumi.set(self, "alias_target", value)

    @_builtins.property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']]:
        return pulumi.get(self, "cidr_routing_config")

    @cidr_routing_config.setter
    def cidr_routing_config(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']]):
        pulumi.set(self, "cidr_routing_config", value)

    @_builtins.property
    @pulumi.getter
    def failover(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "failover")

    @failover.setter
    def failover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failover", value)

    @_builtins.property
    @pulumi.getter
    def geolocation(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']]:
        return pulumi.get(self, "geolocation")

    @geolocation.setter
    def geolocation(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']]):
        pulumi.set(self, "geolocation", value)

    @_builtins.property
    @pulumi.getter(name="geoproximityLocation")
    def geoproximity_location(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']]:
        return pulumi.get(self, "geoproximity_location")

    @geoproximity_location.setter
    def geoproximity_location(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']]):
        pulumi.set(self, "geoproximity_location", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "health_check_id")

    @health_check_id.setter
    def health_check_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_id", value)

    @_builtins.property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "multi_value_answer")

    @multi_value_answer.setter
    def multi_value_answer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_value_answer", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]]:
        return pulumi.get(self, "resource_records")

    @resource_records.setter
    def resource_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]]):
        pulumi.set(self, "resource_records", value)

    @_builtins.property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "set_identifier")

    @set_identifier.setter
    def set_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "set_identifier", value)

    @_builtins.property
    @pulumi.getter(name="trafficPolicyInstanceId")
    def traffic_policy_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "traffic_policy_instance_id")

    @traffic_policy_instance_id.setter
    def traffic_policy_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic_policy_instance_id", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetAliasTargetArgsDict(TypedDict):
        dns_name: pulumi.Input[_builtins.str]
        evaluate_target_health: pulumi.Input[_builtins.bool]
        hosted_zone_id: pulumi.Input[_builtins.str]
elif False:
    RecordsExclusiveResourceRecordSetAliasTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetAliasTargetArgs:
    def __init__(__self__, *,
                 dns_name: pulumi.Input[_builtins.str],
                 evaluate_target_health: pulumi.Input[_builtins.bool],
                 hosted_zone_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict(TypedDict):
        collection_id: pulumi.Input[_builtins.str]
        location_name: pulumi.Input[_builtins.str]
elif False:
    RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs:
    def __init__(__self__, *,
                 collection_id: pulumi.Input[_builtins.str],
                 location_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_id", value)

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeolocationArgsDict(TypedDict):
        continent_code: NotRequired[pulumi.Input[_builtins.str]]
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        subdivision_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecordsExclusiveResourceRecordSetGeolocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeolocationArgs:
    def __init__(__self__, *,
                 continent_code: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 subdivision_code: Optional[pulumi.Input[_builtins.str]] = None):
        if continent_code is not None:
            pulumi.set(__self__, "continent_code", continent_code)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if subdivision_code is not None:
            pulumi.set(__self__, "subdivision_code", subdivision_code)

    @_builtins.property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "continent_code")

    @continent_code.setter
    def continent_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "continent_code", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subdivision_code")

    @subdivision_code.setter
    def subdivision_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdivision_code", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict(TypedDict):
        aws_region: NotRequired[pulumi.Input[_builtins.str]]
        bias: NotRequired[pulumi.Input[_builtins.int]]
        coordinates: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict']]
        local_zone_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeoproximityLocationArgs:
    def __init__(__self__, *,
                 aws_region: Optional[pulumi.Input[_builtins.str]] = None,
                 bias: Optional[pulumi.Input[_builtins.int]] = None,
                 coordinates: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']] = None,
                 local_zone_group: Optional[pulumi.Input[_builtins.str]] = None):
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aws_region", value)

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bias", value)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']]):
        pulumi.set(self, "coordinates", value)

    @_builtins.property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_zone_group")

    @local_zone_group.setter
    def local_zone_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_zone_group", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict(TypedDict):
        latitude: pulumi.Input[_builtins.str]
        longitude: pulumi.Input[_builtins.str]
elif False:
    RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[_builtins.str],
                 longitude: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetResourceRecordArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    RecordsExclusiveResourceRecordSetResourceRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetResourceRecordArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecordsExclusiveTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RecordsExclusiveTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ResolverEndpointIpAddressArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        ip: NotRequired[pulumi.Input[_builtins.str]]
        ip_id: NotRequired[pulumi.Input[_builtins.str]]
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResolverEndpointIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResolverEndpointIpAddressArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_id is not None:
            pulumi.set(__self__, "ip_id", ip_id)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipId")
    def ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_id")

    @ip_id.setter
    def ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_id", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ResolverRuleTargetIpArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResolverRuleTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResolverRuleTargetIpArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ZoneVpcArgsDict(TypedDict):
        vpc_id: pulumi.Input[_builtins.str]
        vpc_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ZoneVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneVpcArgs:
    def __init__(__self__, *,
                 vpc_id: pulumi.Input[_builtins.str],
                 vpc_region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_region is not None:
            pulumi.set(__self__, "vpc_region", vpc_region)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcRegion")
    def vpc_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_region")

    @vpc_region.setter
    def vpc_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_region", value)


if not MYPY:
    class GetQueryLogConfigFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetQueryLogConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQueryLogConfigFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetResolverEndpointFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetResolverEndpointFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResolverEndpointFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTrafficPolicyDocumentEndpointArgsDict(TypedDict):
        id: _builtins.str
        region: NotRequired[_builtins.str]
        type: NotRequired[_builtins.str]
        value: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentEndpointArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleArgsDict(TypedDict):
        id: _builtins.str
        geo_proximity_locations: NotRequired[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict']]
        items: NotRequired[Sequence['GetTrafficPolicyDocumentRuleItemArgsDict']]
        locations: NotRequired[Sequence['GetTrafficPolicyDocumentRuleLocationArgsDict']]
        primary: NotRequired['GetTrafficPolicyDocumentRulePrimaryArgsDict']
        regions: NotRequired[Sequence['GetTrafficPolicyDocumentRuleRegionArgsDict']]
        secondary: NotRequired['GetTrafficPolicyDocumentRuleSecondaryArgsDict']
        type: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 geo_proximity_locations: Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']] = None,
                 items: Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']] = None,
                 locations: Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']] = None,
                 primary: Optional['GetTrafficPolicyDocumentRulePrimaryArgs'] = None,
                 regions: Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']] = None,
                 secondary: Optional['GetTrafficPolicyDocumentRuleSecondaryArgs'] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "id", id)
        if geo_proximity_locations is not None:
            pulumi.set(__self__, "geo_proximity_locations", geo_proximity_locations)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="geoProximityLocations")
    def geo_proximity_locations(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']]:
        return pulumi.get(self, "geo_proximity_locations")

    @geo_proximity_locations.setter
    def geo_proximity_locations(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']]):
        pulumi.set(self, "geo_proximity_locations", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['GetTrafficPolicyDocumentRulePrimaryArgs']:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional['GetTrafficPolicyDocumentRulePrimaryArgs']):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['GetTrafficPolicyDocumentRuleSecondaryArgs']:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional['GetTrafficPolicyDocumentRuleSecondaryArgs']):
        pulumi.set(self, "secondary", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict(TypedDict):
        bias: NotRequired[_builtins.str]
        endpoint_reference: NotRequired[_builtins.str]
        evaluate_target_health: NotRequired[_builtins.bool]
        health_check: NotRequired[_builtins.str]
        latitude: NotRequired[_builtins.str]
        longitude: NotRequired[_builtins.str]
        region: NotRequired[_builtins.str]
        rule_reference: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleGeoProximityLocationArgs:
    def __init__(__self__, *,
                 bias: Optional[_builtins.str] = None,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 latitude: Optional[_builtins.str] = None,
                 longitude: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter
    def bias(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[_builtins.str]):
        pulumi.set(self, "bias", value)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: Optional[_builtins.str]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: Optional[_builtins.str]):
        pulumi.set(self, "longitude", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleItemArgsDict(TypedDict):
        endpoint_reference: NotRequired[_builtins.str]
        health_check: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleItemArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 health_check: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleLocationArgsDict(TypedDict):
        continent: NotRequired[_builtins.str]
        country: NotRequired[_builtins.str]
        endpoint_reference: NotRequired[_builtins.str]
        evaluate_target_health: NotRequired[_builtins.bool]
        health_check: NotRequired[_builtins.str]
        is_default: NotRequired[_builtins.bool]
        rule_reference: NotRequired[_builtins.str]
        subdivision: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleLocationArgs:
    def __init__(__self__, *,
                 continent: Optional[_builtins.str] = None,
                 country: Optional[_builtins.str] = None,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 rule_reference: Optional[_builtins.str] = None,
                 subdivision: Optional[_builtins.str] = None):
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "continent", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[_builtins.str]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rule_reference", value)

    @_builtins.property
    @pulumi.getter
    def subdivision(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subdivision")

    @subdivision.setter
    def subdivision(self, value: Optional[_builtins.str]):
        pulumi.set(self, "subdivision", value)


if not MYPY:
    class GetTrafficPolicyDocumentRulePrimaryArgsDict(TypedDict):
        endpoint_reference: NotRequired[_builtins.str]
        evaluate_target_health: NotRequired[_builtins.bool]
        health_check: NotRequired[_builtins.str]
        rule_reference: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRulePrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRulePrimaryArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleRegionArgsDict(TypedDict):
        endpoint_reference: NotRequired[_builtins.str]
        evaluate_target_health: NotRequired[_builtins.bool]
        health_check: NotRequired[_builtins.str]
        region: NotRequired[_builtins.str]
        rule_reference: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleRegionArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleSecondaryArgsDict(TypedDict):
        endpoint_reference: NotRequired[_builtins.str]
        evaluate_target_health: NotRequired[_builtins.bool]
        health_check: NotRequired[_builtins.str]
        rule_reference: NotRequired[_builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleSecondaryArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[_builtins.str] = None,
                 evaluate_target_health: Optional[_builtins.bool] = None,
                 health_check: Optional[_builtins.str] = None,
                 rule_reference: Optional[_builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @_builtins.property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @_builtins.property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[_builtins.str]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rule_reference", value)


