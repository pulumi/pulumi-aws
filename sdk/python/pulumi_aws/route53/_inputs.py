# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ProfilesAssociationTimeoutsArgs',
    'ProfilesAssociationTimeoutsArgsDict',
    'ProfilesProfileTimeoutsArgs',
    'ProfilesProfileTimeoutsArgsDict',
    'ProfilesResourceAssociationTimeoutsArgs',
    'ProfilesResourceAssociationTimeoutsArgsDict',
    'RecordAliasArgs',
    'RecordAliasArgsDict',
    'RecordCidrRoutingPolicyArgs',
    'RecordCidrRoutingPolicyArgsDict',
    'RecordFailoverRoutingPolicyArgs',
    'RecordFailoverRoutingPolicyArgsDict',
    'RecordGeolocationRoutingPolicyArgs',
    'RecordGeolocationRoutingPolicyArgsDict',
    'RecordGeoproximityRoutingPolicyArgs',
    'RecordGeoproximityRoutingPolicyArgsDict',
    'RecordGeoproximityRoutingPolicyCoordinateArgs',
    'RecordGeoproximityRoutingPolicyCoordinateArgsDict',
    'RecordLatencyRoutingPolicyArgs',
    'RecordLatencyRoutingPolicyArgsDict',
    'RecordWeightedRoutingPolicyArgs',
    'RecordWeightedRoutingPolicyArgsDict',
    'RecordsExclusiveResourceRecordSetArgs',
    'RecordsExclusiveResourceRecordSetArgsDict',
    'RecordsExclusiveResourceRecordSetAliasTargetArgs',
    'RecordsExclusiveResourceRecordSetAliasTargetArgsDict',
    'RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs',
    'RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict',
    'RecordsExclusiveResourceRecordSetGeolocationArgs',
    'RecordsExclusiveResourceRecordSetGeolocationArgsDict',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationArgs',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs',
    'RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict',
    'RecordsExclusiveResourceRecordSetResourceRecordArgs',
    'RecordsExclusiveResourceRecordSetResourceRecordArgsDict',
    'RecordsExclusiveTimeoutsArgs',
    'RecordsExclusiveTimeoutsArgsDict',
    'ResolverEndpointIpAddressArgs',
    'ResolverEndpointIpAddressArgsDict',
    'ResolverRuleTargetIpArgs',
    'ResolverRuleTargetIpArgsDict',
    'ZoneVpcArgs',
    'ZoneVpcArgsDict',
    'GetQueryLogConfigFilterArgs',
    'GetQueryLogConfigFilterArgsDict',
    'GetResolverEndpointFilterArgs',
    'GetResolverEndpointFilterArgsDict',
    'GetTrafficPolicyDocumentEndpointArgs',
    'GetTrafficPolicyDocumentEndpointArgsDict',
    'GetTrafficPolicyDocumentRuleArgs',
    'GetTrafficPolicyDocumentRuleArgsDict',
    'GetTrafficPolicyDocumentRuleGeoProximityLocationArgs',
    'GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict',
    'GetTrafficPolicyDocumentRuleItemArgs',
    'GetTrafficPolicyDocumentRuleItemArgsDict',
    'GetTrafficPolicyDocumentRuleLocationArgs',
    'GetTrafficPolicyDocumentRuleLocationArgsDict',
    'GetTrafficPolicyDocumentRulePrimaryArgs',
    'GetTrafficPolicyDocumentRulePrimaryArgsDict',
    'GetTrafficPolicyDocumentRuleRegionArgs',
    'GetTrafficPolicyDocumentRuleRegionArgsDict',
    'GetTrafficPolicyDocumentRuleSecondaryArgs',
    'GetTrafficPolicyDocumentRuleSecondaryArgsDict',
]

MYPY = False

if not MYPY:
    class ProfilesAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProfilesAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ProfilesProfileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    ProfilesProfileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesProfileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class ProfilesResourceAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    ProfilesResourceAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfilesResourceAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class RecordAliasArgsDict(TypedDict):
        evaluate_target_health: pulumi.Input[builtins.bool]
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
        """
        name: pulumi.Input[builtins.str]
        """
        DNS domain name for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or another resource record set in this hosted zone.
        """
        zone_id: pulumi.Input[builtins.str]
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
        """
elif False:
    RecordAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordAliasArgs:
    def __init__(__self__, *,
                 evaluate_target_health: pulumi.Input[builtins.bool],
                 name: pulumi.Input[builtins.str],
                 zone_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.bool] evaluate_target_health: Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
        :param pulumi.Input[builtins.str] name: DNS domain name for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or another resource record set in this hosted zone.
        :param pulumi.Input[builtins.str] zone_id: Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
        """
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> pulumi.Input[builtins.bool]:
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        DNS domain name for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or another resource record set in this hosted zone.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[builtins.str]:
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class RecordCidrRoutingPolicyArgsDict(TypedDict):
        collection_id: pulumi.Input[builtins.str]
        """
        The CIDR collection ID. See the `route53.CidrCollection` resource for more details.
        """
        location_name: pulumi.Input[builtins.str]
        """
        The CIDR collection location name. See the `route53.CidrLocation` resource for more details. A `location_name` with an asterisk `"*"` can be used to create a default CIDR record. `collection_id` is still required for default record.
        """
elif False:
    RecordCidrRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordCidrRoutingPolicyArgs:
    def __init__(__self__, *,
                 collection_id: pulumi.Input[builtins.str],
                 location_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] collection_id: The CIDR collection ID. See the `route53.CidrCollection` resource for more details.
        :param pulumi.Input[builtins.str] location_name: The CIDR collection location name. See the `route53.CidrLocation` resource for more details. A `location_name` with an asterisk `"*"` can be used to create a default CIDR record. `collection_id` is still required for default record.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[builtins.str]:
        """
        The CIDR collection ID. See the `route53.CidrCollection` resource for more details.
        """
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "collection_id", value)

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> pulumi.Input[builtins.str]:
        """
        The CIDR collection location name. See the `route53.CidrLocation` resource for more details. A `location_name` with an asterisk `"*"` can be used to create a default CIDR record. `collection_id` is still required for default record.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class RecordFailoverRoutingPolicyArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
        """
elif False:
    RecordFailoverRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordFailoverRoutingPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] type: `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RecordGeolocationRoutingPolicyArgsDict(TypedDict):
        continent: NotRequired[pulumi.Input[builtins.str]]
        """
        A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
        """
        country: NotRequired[pulumi.Input[builtins.str]]
        """
        A two-character country code or `*` to indicate a default resource record set.
        """
        subdivision: NotRequired[pulumi.Input[builtins.str]]
        """
        A subdivision code for a country.
        """
elif False:
    RecordGeolocationRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeolocationRoutingPolicyArgs:
    def __init__(__self__, *,
                 continent: Optional[pulumi.Input[builtins.str]] = None,
                 country: Optional[pulumi.Input[builtins.str]] = None,
                 subdivision: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] continent: A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
        :param pulumi.Input[builtins.str] country: A two-character country code or `*` to indicate a default resource record set.
        :param pulumi.Input[builtins.str] subdivision: A subdivision code for a country.
        """
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @property
    @pulumi.getter
    def continent(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "continent", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A two-character country code or `*` to indicate a default resource record set.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def subdivision(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A subdivision code for a country.
        """
        return pulumi.get(self, "subdivision")

    @subdivision.setter
    def subdivision(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subdivision", value)


if not MYPY:
    class RecordGeoproximityRoutingPolicyArgsDict(TypedDict):
        aws_region: NotRequired[pulumi.Input[builtins.str]]
        """
        A AWS region where the resource is present.
        """
        bias: NotRequired[pulumi.Input[builtins.int]]
        """
        Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
        """
        coordinates: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgsDict']]]]
        """
        Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
        """
        local_zone_group: NotRequired[pulumi.Input[builtins.str]]
        """
        A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
        """
elif False:
    RecordGeoproximityRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeoproximityRoutingPolicyArgs:
    def __init__(__self__, *,
                 aws_region: Optional[pulumi.Input[builtins.str]] = None,
                 bias: Optional[pulumi.Input[builtins.int]] = None,
                 coordinates: Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]] = None,
                 local_zone_group: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aws_region: A AWS region where the resource is present.
        :param pulumi.Input[builtins.int] bias: Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
        :param pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]] coordinates: Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
        :param pulumi.Input[builtins.str] local_zone_group: A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
        """
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A AWS region where the resource is present.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
        """
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bias", value)

    @property
    @pulumi.getter
    def coordinates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]]:
        """
        Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
        """
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordGeoproximityRoutingPolicyCoordinateArgs']]]]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
        """
        return pulumi.get(self, "local_zone_group")

    @local_zone_group.setter
    def local_zone_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_zone_group", value)


if not MYPY:
    class RecordGeoproximityRoutingPolicyCoordinateArgsDict(TypedDict):
        latitude: pulumi.Input[builtins.str]
        longitude: pulumi.Input[builtins.str]
elif False:
    RecordGeoproximityRoutingPolicyCoordinateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordGeoproximityRoutingPolicyCoordinateArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[builtins.str],
                 longitude: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class RecordLatencyRoutingPolicyArgsDict(TypedDict):
        region: pulumi.Input[builtins.str]
        """
        An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
        """
elif False:
    RecordLatencyRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordLatencyRoutingPolicyArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] region: An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
        """
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class RecordWeightedRoutingPolicyArgsDict(TypedDict):
        weight: pulumi.Input[builtins.int]
        """
        A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
        """
elif False:
    RecordWeightedRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordWeightedRoutingPolicyArgs:
    def __init__(__self__, *,
                 weight: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] weight: A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
        """
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[builtins.int]:
        """
        A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the record.
        """
        alias_target: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgsDict']]
        """
        Alias target block.
        See `alias_target` below.
        """
        cidr_routing_config: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict']]
        failover: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of failover resource record.
        Valid values are `PRIMARY` and `SECONDARY`.
        See the [AWS documentation on DNS failover](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html) for additional details.
        """
        geolocation: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgsDict']]
        """
        Geolocation block to control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        See `geolocation` below.
        """
        geoproximity_location: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict']]
        """
        Geoproximity location block.
        See `geoproximity_location` below.
        """
        health_check_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Health check the record should be associated with.
        """
        multi_value_answer: NotRequired[pulumi.Input[builtins.bool]]
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS region of the resource this record set refers to.
        Must be a valid AWS region name.
        See the [AWS documentation](http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency) on latency based routing for additional details.
        """
        resource_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgsDict']]]]
        """
        Information about the resource records to act upon.
        See `resource_records` below.
        """
        set_identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
        Required if using `cidr_routing_config`, `failover`, `geolocation`,`geoproximity_location`, `multivalue_answer`, `region`, or `weight`.
        """
        traffic_policy_instance_id: NotRequired[pulumi.Input[builtins.str]]
        ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Resource record cache time to live (TTL), in seconds.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Record type.
        Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `TXT`, `TLSA`, `SSHFP`, `SVCB`, and `HTTPS`.

        The following arguments are optional:

        > Exactly one of `resource_records` or `alias_target` must be specified.
        """
        weight: NotRequired[pulumi.Input[builtins.int]]
        """
        Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
elif False:
    RecordsExclusiveResourceRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 alias_target: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']] = None,
                 cidr_routing_config: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']] = None,
                 failover: Optional[pulumi.Input[builtins.str]] = None,
                 geolocation: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']] = None,
                 geoproximity_location: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']] = None,
                 health_check_id: Optional[pulumi.Input[builtins.str]] = None,
                 multi_value_answer: Optional[pulumi.Input[builtins.bool]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 resource_records: Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]] = None,
                 set_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_policy_instance_id: Optional[pulumi.Input[builtins.str]] = None,
                 ttl: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the record.
        :param pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs'] alias_target: Alias target block.
               See `alias_target` below.
        :param pulumi.Input[builtins.str] failover: Type of failover resource record.
               Valid values are `PRIMARY` and `SECONDARY`.
               See the [AWS documentation on DNS failover](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html) for additional details.
        :param pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs'] geolocation: Geolocation block to control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
               See `geolocation` below.
        :param pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs'] geoproximity_location: Geoproximity location block.
               See `geoproximity_location` below.
        :param pulumi.Input[builtins.str] health_check_id: Health check the record should be associated with.
        :param pulumi.Input[builtins.str] region: AWS region of the resource this record set refers to.
               Must be a valid AWS region name.
               See the [AWS documentation](http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency) on latency based routing for additional details.
        :param pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]] resource_records: Information about the resource records to act upon.
               See `resource_records` below.
        :param pulumi.Input[builtins.str] set_identifier: An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
               Required if using `cidr_routing_config`, `failover`, `geolocation`,`geoproximity_location`, `multivalue_answer`, `region`, or `weight`.
        :param pulumi.Input[builtins.int] ttl: Resource record cache time to live (TTL), in seconds.
        :param pulumi.Input[builtins.str] type: Record type.
               Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `TXT`, `TLSA`, `SSHFP`, `SVCB`, and `HTTPS`.
               
               The following arguments are optional:
               
               > Exactly one of `resource_records` or `alias_target` must be specified.
        :param pulumi.Input[builtins.int] weight: Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        pulumi.set(__self__, "name", name)
        if alias_target is not None:
            pulumi.set(__self__, "alias_target", alias_target)
        if cidr_routing_config is not None:
            pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if geolocation is not None:
            pulumi.set(__self__, "geolocation", geolocation)
        if geoproximity_location is not None:
            pulumi.set(__self__, "geoproximity_location", geoproximity_location)
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if multi_value_answer is not None:
            pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_records is not None:
            pulumi.set(__self__, "resource_records", resource_records)
        if set_identifier is not None:
            pulumi.set(__self__, "set_identifier", set_identifier)
        if traffic_policy_instance_id is not None:
            pulumi.set(__self__, "traffic_policy_instance_id", traffic_policy_instance_id)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the record.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']]:
        """
        Alias target block.
        See `alias_target` below.
        """
        return pulumi.get(self, "alias_target")

    @alias_target.setter
    def alias_target(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetAliasTargetArgs']]):
        pulumi.set(self, "alias_target", value)

    @property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']]:
        return pulumi.get(self, "cidr_routing_config")

    @cidr_routing_config.setter
    def cidr_routing_config(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs']]):
        pulumi.set(self, "cidr_routing_config", value)

    @property
    @pulumi.getter
    def failover(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of failover resource record.
        Valid values are `PRIMARY` and `SECONDARY`.
        See the [AWS documentation on DNS failover](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html) for additional details.
        """
        return pulumi.get(self, "failover")

    @failover.setter
    def failover(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "failover", value)

    @property
    @pulumi.getter
    def geolocation(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']]:
        """
        Geolocation block to control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query.
        See `geolocation` below.
        """
        return pulumi.get(self, "geolocation")

    @geolocation.setter
    def geolocation(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeolocationArgs']]):
        pulumi.set(self, "geolocation", value)

    @property
    @pulumi.getter(name="geoproximityLocation")
    def geoproximity_location(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']]:
        """
        Geoproximity location block.
        See `geoproximity_location` below.
        """
        return pulumi.get(self, "geoproximity_location")

    @geoproximity_location.setter
    def geoproximity_location(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationArgs']]):
        pulumi.set(self, "geoproximity_location", value)

    @property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Health check the record should be associated with.
        """
        return pulumi.get(self, "health_check_id")

    @health_check_id.setter
    def health_check_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_id", value)

    @property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "multi_value_answer")

    @multi_value_answer.setter
    def multi_value_answer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "multi_value_answer", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS region of the resource this record set refers to.
        Must be a valid AWS region name.
        See the [AWS documentation](http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency) on latency based routing for additional details.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]]:
        """
        Information about the resource records to act upon.
        See `resource_records` below.
        """
        return pulumi.get(self, "resource_records")

    @resource_records.setter
    def resource_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordsExclusiveResourceRecordSetResourceRecordArgs']]]]):
        pulumi.set(self, "resource_records", value)

    @property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An identifier that differentiates among multiple resource record sets that have the same combination of name and type.
        Required if using `cidr_routing_config`, `failover`, `geolocation`,`geoproximity_location`, `multivalue_answer`, `region`, or `weight`.
        """
        return pulumi.get(self, "set_identifier")

    @set_identifier.setter
    def set_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "set_identifier", value)

    @property
    @pulumi.getter(name="trafficPolicyInstanceId")
    def traffic_policy_instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "traffic_policy_instance_id")

    @traffic_policy_instance_id.setter
    def traffic_policy_instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "traffic_policy_instance_id", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Resource record cache time to live (TTL), in seconds.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Record type.
        Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `TXT`, `TLSA`, `SSHFP`, `SVCB`, and `HTTPS`.

        The following arguments are optional:

        > Exactly one of `resource_records` or `alias_target` must be specified.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetAliasTargetArgsDict(TypedDict):
        dns_name: pulumi.Input[builtins.str]
        """
        DNS domain name for another resource record set in this hosted zone.
        """
        evaluate_target_health: pulumi.Input[builtins.bool]
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [the AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health) for additional details.
        """
        hosted_zone_id: pulumi.Input[builtins.str]
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for an example.
        """
elif False:
    RecordsExclusiveResourceRecordSetAliasTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetAliasTargetArgs:
    def __init__(__self__, *,
                 dns_name: pulumi.Input[builtins.str],
                 evaluate_target_health: pulumi.Input[builtins.bool],
                 hosted_zone_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] dns_name: DNS domain name for another resource record set in this hosted zone.
        :param pulumi.Input[builtins.bool] evaluate_target_health: Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [the AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health) for additional details.
        :param pulumi.Input[builtins.str] hosted_zone_id: Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for an example.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> pulumi.Input[builtins.str]:
        """
        DNS domain name for another resource record set in this hosted zone.
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> pulumi.Input[builtins.bool]:
        """
        Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [the AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health) for additional details.
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[builtins.str]:
        """
        Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, AWS Global Accelerator, or Route 53 hosted zone. See `resource_elb.zone_id` for an example.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict(TypedDict):
        collection_id: pulumi.Input[builtins.str]
        """
        CIDR collection ID.
        See the `route53.CidrCollection` resource for more details.
        """
        location_name: pulumi.Input[builtins.str]
        """
        CIDR collection location name.
        See the `route53.CidrLocation` resource for more details.
        A `location_name` with an asterisk `"*"` can be used to create a default CIDR record.
        `collection_id` is still required for a default record.
        """
elif False:
    RecordsExclusiveResourceRecordSetCidrRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetCidrRoutingConfigArgs:
    def __init__(__self__, *,
                 collection_id: pulumi.Input[builtins.str],
                 location_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] collection_id: CIDR collection ID.
               See the `route53.CidrCollection` resource for more details.
        :param pulumi.Input[builtins.str] location_name: CIDR collection location name.
               See the `route53.CidrLocation` resource for more details.
               A `location_name` with an asterisk `"*"` can be used to create a default CIDR record.
               `collection_id` is still required for a default record.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[builtins.str]:
        """
        CIDR collection ID.
        See the `route53.CidrCollection` resource for more details.
        """
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "collection_id", value)

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> pulumi.Input[builtins.str]:
        """
        CIDR collection location name.
        See the `route53.CidrLocation` resource for more details.
        A `location_name` with an asterisk `"*"` can be used to create a default CIDR record.
        `collection_id` is still required for a default record.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeolocationArgsDict(TypedDict):
        continent_code: NotRequired[pulumi.Input[builtins.str]]
        country_code: NotRequired[pulumi.Input[builtins.str]]
        subdivision_code: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RecordsExclusiveResourceRecordSetGeolocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeolocationArgs:
    def __init__(__self__, *,
                 continent_code: Optional[pulumi.Input[builtins.str]] = None,
                 country_code: Optional[pulumi.Input[builtins.str]] = None,
                 subdivision_code: Optional[pulumi.Input[builtins.str]] = None):
        if continent_code is not None:
            pulumi.set(__self__, "continent_code", continent_code)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if subdivision_code is not None:
            pulumi.set(__self__, "subdivision_code", subdivision_code)

    @property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "continent_code")

    @continent_code.setter
    def continent_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "continent_code", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "subdivision_code")

    @subdivision_code.setter
    def subdivision_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subdivision_code", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict(TypedDict):
        aws_region: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS region of the resource where DNS traffic is directed to.
        """
        bias: NotRequired[pulumi.Input[builtins.int]]
        """
        Increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
        To expand the size of the geographic region from which Route 53 routes traffic to a resource, specify a positive integer from `1` to `99`.
        To shrink the size of the geographic region from which Route 53 routes traffic to a resource, specify a negative bias of `-1` to `-99`.
        See the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html) for additional details.
        """
        coordinates: NotRequired[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict']]
        """
        Coordinates for a geoproximity resource record.
        See `coordinates` below.
        """
        local_zone_group: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS local zone group.
        Identify the Local Zones Group for a specific Local Zone by using the [`describe-availability-zones` CLI command](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html).
        """
elif False:
    RecordsExclusiveResourceRecordSetGeoproximityLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeoproximityLocationArgs:
    def __init__(__self__, *,
                 aws_region: Optional[pulumi.Input[builtins.str]] = None,
                 bias: Optional[pulumi.Input[builtins.int]] = None,
                 coordinates: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']] = None,
                 local_zone_group: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aws_region: AWS region of the resource where DNS traffic is directed to.
        :param pulumi.Input[builtins.int] bias: Increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
               To expand the size of the geographic region from which Route 53 routes traffic to a resource, specify a positive integer from `1` to `99`.
               To shrink the size of the geographic region from which Route 53 routes traffic to a resource, specify a negative bias of `-1` to `-99`.
               See the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html) for additional details.
        :param pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs'] coordinates: Coordinates for a geoproximity resource record.
               See `coordinates` below.
        :param pulumi.Input[builtins.str] local_zone_group: AWS local zone group.
               Identify the Local Zones Group for a specific Local Zone by using the [`describe-availability-zones` CLI command](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html).
        """
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS region of the resource where DNS traffic is directed to.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource.
        To expand the size of the geographic region from which Route 53 routes traffic to a resource, specify a positive integer from `1` to `99`.
        To shrink the size of the geographic region from which Route 53 routes traffic to a resource, specify a negative bias of `-1` to `-99`.
        See the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html) for additional details.
        """
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bias", value)

    @property
    @pulumi.getter
    def coordinates(self) -> Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']]:
        """
        Coordinates for a geoproximity resource record.
        See `coordinates` below.
        """
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: Optional[pulumi.Input['RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs']]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS local zone group.
        Identify the Local Zones Group for a specific Local Zone by using the [`describe-availability-zones` CLI command](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html).
        """
        return pulumi.get(self, "local_zone_group")

    @local_zone_group.setter
    def local_zone_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_zone_group", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict(TypedDict):
        latitude: pulumi.Input[builtins.str]
        """
        A coordinate of the northsouth position of a geographic point on the surface of the Earth (`-90` - `90`).
        """
        longitude: pulumi.Input[builtins.str]
        """
        A coordinate of the eastwest position of a geographic point on the surface of the Earth (`-180` - `180`).
        """
elif False:
    RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetGeoproximityLocationCoordinatesArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[builtins.str],
                 longitude: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] latitude: A coordinate of the northsouth position of a geographic point on the surface of the Earth (`-90` - `90`).
        :param pulumi.Input[builtins.str] longitude: A coordinate of the eastwest position of a geographic point on the surface of the Earth (`-180` - `180`).
        """
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[builtins.str]:
        """
        A coordinate of the northsouth position of a geographic point on the surface of the Earth (`-90` - `90`).
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[builtins.str]:
        """
        A coordinate of the eastwest position of a geographic point on the surface of the Earth (`-180` - `180`).
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class RecordsExclusiveResourceRecordSetResourceRecordArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        DNS record value.
        """
elif False:
    RecordsExclusiveResourceRecordSetResourceRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveResourceRecordSetResourceRecordArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] value: DNS record value.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        DNS record value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecordsExclusiveTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RecordsExclusiveTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordsExclusiveTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ResolverEndpointIpAddressArgsDict(TypedDict):
        subnet_id: pulumi.Input[builtins.str]
        """
        ID of the subnet that contains the IP address.
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        IPv4 address in the subnet that you want to use for DNS queries.
        """
        ip_id: NotRequired[pulumi.Input[builtins.str]]
        ipv6: NotRequired[pulumi.Input[builtins.str]]
        """
        IPv6 address in the subnet that you want to use for DNS queries.
        """
elif False:
    ResolverEndpointIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResolverEndpointIpAddressArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[builtins.str],
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 ip_id: Optional[pulumi.Input[builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] subnet_id: ID of the subnet that contains the IP address.
        :param pulumi.Input[builtins.str] ip: IPv4 address in the subnet that you want to use for DNS queries.
        :param pulumi.Input[builtins.str] ipv6: IPv6 address in the subnet that you want to use for DNS queries.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_id is not None:
            pulumi.set(__self__, "ip_id", ip_id)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[builtins.str]:
        """
        ID of the subnet that contains the IP address.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IPv4 address in the subnet that you want to use for DNS queries.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipId")
    def ip_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip_id")

    @ip_id.setter
    def ip_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_id", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IPv6 address in the subnet that you want to use for DNS queries.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ResolverRuleTargetIpArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        One IPv4 address that you want to forward DNS queries to.
        """
        ipv6: NotRequired[pulumi.Input[builtins.str]]
        """
        One IPv6 address that you want to forward DNS queries to.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port at `ip` that you want to forward DNS queries to. Default value is `53`.
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        Protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
        """
elif False:
    ResolverRuleTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResolverRuleTargetIpArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ip: One IPv4 address that you want to forward DNS queries to.
        :param pulumi.Input[builtins.str] ipv6: One IPv6 address that you want to forward DNS queries to.
        :param pulumi.Input[builtins.int] port: Port at `ip` that you want to forward DNS queries to. Default value is `53`.
        :param pulumi.Input[builtins.str] protocol: Protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        One IPv4 address that you want to forward DNS queries to.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        One IPv6 address that you want to forward DNS queries to.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port at `ip` that you want to forward DNS queries to. Default value is `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ZoneVpcArgsDict(TypedDict):
        vpc_id: pulumi.Input[builtins.str]
        """
        ID of the VPC to associate.
        """
        vpc_region: NotRequired[pulumi.Input[builtins.str]]
        """
        Region of the VPC to associate. Defaults to AWS provider region.
        """
elif False:
    ZoneVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneVpcArgs:
    def __init__(__self__, *,
                 vpc_id: pulumi.Input[builtins.str],
                 vpc_region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] vpc_id: ID of the VPC to associate.
        :param pulumi.Input[builtins.str] vpc_region: Region of the VPC to associate. Defaults to AWS provider region.
        """
        pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_region is not None:
            pulumi.set(__self__, "vpc_region", vpc_region)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[builtins.str]:
        """
        ID of the VPC to associate.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="vpcRegion")
    def vpc_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Region of the VPC to associate. Defaults to AWS provider region.
        """
        return pulumi.get(self, "vpc_region")

    @vpc_region.setter
    def vpc_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_region", value)


if not MYPY:
    class GetQueryLogConfigFilterArgsDict(TypedDict):
        name: builtins.str
        """
        The name of the query logging configuration.
        """
        values: Sequence[builtins.str]
elif False:
    GetQueryLogConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQueryLogConfigFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str name: The name of the query logging configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the query logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetResolverEndpointFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
elif False:
    GetResolverEndpointFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResolverEndpointFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTrafficPolicyDocumentEndpointArgsDict(TypedDict):
        id: builtins.str
        """
        ID of an endpoint you want to assign.
        """
        region: NotRequired[builtins.str]
        """
        To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
        """
        type: NotRequired[builtins.str]
        """
        Type of the endpoint. Valid values are `value`, `cloudfront`, `elastic-load-balancer`, `s3-website`, `application-load-balancer`, `network-load-balancer` and `elastic-beanstalk`
        """
        value: NotRequired[builtins.str]
        """
        Value of the `type`.
        """
elif False:
    GetTrafficPolicyDocumentEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentEndpointArgs:
    def __init__(__self__, *,
                 id: builtins.str,
                 region: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of an endpoint you want to assign.
        :param builtins.str region: To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
        :param builtins.str type: Type of the endpoint. Valid values are `value`, `cloudfront`, `elastic-load-balancer`, `s3-website`, `application-load-balancer`, `network-load-balancer` and `elastic-beanstalk`
        :param builtins.str value: Value of the `type`.
        """
        pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of an endpoint you want to assign.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the endpoint. Valid values are `value`, `cloudfront`, `elastic-load-balancer`, `s3-website`, `application-load-balancer`, `network-load-balancer` and `elastic-beanstalk`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value of the `type`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleArgsDict(TypedDict):
        id: builtins.str
        """
        ID of a rule you want to assign.
        """
        geo_proximity_locations: NotRequired[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict']]
        """
        Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
        """
        items: NotRequired[Sequence['GetTrafficPolicyDocumentRuleItemArgsDict']]
        """
        Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
        """
        locations: NotRequired[Sequence['GetTrafficPolicyDocumentRuleLocationArgsDict']]
        """
        Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
        """
        primary: NotRequired['GetTrafficPolicyDocumentRulePrimaryArgsDict']
        """
        Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
        """
        regions: NotRequired[Sequence['GetTrafficPolicyDocumentRuleRegionArgsDict']]
        secondary: NotRequired['GetTrafficPolicyDocumentRuleSecondaryArgsDict']
        """
        Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
        """
        type: NotRequired[builtins.str]
        """
        Type of the rule.
        """
elif False:
    GetTrafficPolicyDocumentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleArgs:
    def __init__(__self__, *,
                 id: builtins.str,
                 geo_proximity_locations: Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']] = None,
                 items: Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']] = None,
                 locations: Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']] = None,
                 primary: Optional['GetTrafficPolicyDocumentRulePrimaryArgs'] = None,
                 regions: Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']] = None,
                 secondary: Optional['GetTrafficPolicyDocumentRuleSecondaryArgs'] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of a rule you want to assign.
        :param Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs'] geo_proximity_locations: Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
        :param Sequence['GetTrafficPolicyDocumentRuleItemArgs'] items: Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
        :param Sequence['GetTrafficPolicyDocumentRuleLocationArgs'] locations: Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
        :param 'GetTrafficPolicyDocumentRulePrimaryArgs' primary: Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
        :param 'GetTrafficPolicyDocumentRuleSecondaryArgs' secondary: Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
        :param builtins.str type: Type of the rule.
        """
        pulumi.set(__self__, "id", id)
        if geo_proximity_locations is not None:
            pulumi.set(__self__, "geo_proximity_locations", geo_proximity_locations)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of a rule you want to assign.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="geoProximityLocations")
    def geo_proximity_locations(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']]:
        """
        Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
        """
        return pulumi.get(self, "geo_proximity_locations")

    @geo_proximity_locations.setter
    def geo_proximity_locations(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleGeoProximityLocationArgs']]):
        pulumi.set(self, "geo_proximity_locations", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']]:
        """
        Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleItemArgs']]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']]:
        """
        Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleLocationArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional['GetTrafficPolicyDocumentRulePrimaryArgs']:
        """
        Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional['GetTrafficPolicyDocumentRulePrimaryArgs']):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[Sequence['GetTrafficPolicyDocumentRuleRegionArgs']]):
        pulumi.set(self, "regions", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional['GetTrafficPolicyDocumentRuleSecondaryArgs']:
        """
        Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional['GetTrafficPolicyDocumentRuleSecondaryArgs']):
        pulumi.set(self, "secondary", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict(TypedDict):
        bias: NotRequired[builtins.str]
        """
        Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
        """
        endpoint_reference: NotRequired[builtins.str]
        """
        References to an endpoint.
        """
        evaluate_target_health: NotRequired[builtins.bool]
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        health_check: NotRequired[builtins.str]
        """
        If you want to associate a health check with the endpoint or rule.
        """
        latitude: NotRequired[builtins.str]
        """
        Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
        """
        longitude: NotRequired[builtins.str]
        """
        Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
        """
        region: NotRequired[builtins.str]
        """
        If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
        """
        rule_reference: NotRequired[builtins.str]
        """
        References to a rule.
        """
elif False:
    GetTrafficPolicyDocumentRuleGeoProximityLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleGeoProximityLocationArgs:
    def __init__(__self__, *,
                 bias: Optional[builtins.str] = None,
                 endpoint_reference: Optional[builtins.str] = None,
                 evaluate_target_health: Optional[builtins.bool] = None,
                 health_check: Optional[builtins.str] = None,
                 latitude: Optional[builtins.str] = None,
                 longitude: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 rule_reference: Optional[builtins.str] = None):
        """
        :param builtins.str bias: Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
        :param builtins.str endpoint_reference: References to an endpoint.
        :param builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param builtins.str latitude: Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
        :param builtins.str longitude: Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
        :param builtins.str region: If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
        :param builtins.str rule_reference: References to a rule.
        """
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @property
    @pulumi.getter
    def bias(self) -> Optional[builtins.str]:
        """
        Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
        """
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[builtins.str]):
        pulumi.set(self, "bias", value)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def latitude(self) -> Optional[builtins.str]:
        """
        Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: Optional[builtins.str]):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter
    def longitude(self) -> Optional[builtins.str]:
        """
        Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: Optional[builtins.str]):
        pulumi.set(self, "longitude", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleItemArgsDict(TypedDict):
        endpoint_reference: NotRequired[builtins.str]
        health_check: NotRequired[builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleItemArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[builtins.str] = None,
                 health_check: Optional[builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleLocationArgsDict(TypedDict):
        continent: NotRequired[builtins.str]
        """
        Value of a continent.
        """
        country: NotRequired[builtins.str]
        """
        Value of a country.
        """
        endpoint_reference: NotRequired[builtins.str]
        """
        References to an endpoint.
        """
        evaluate_target_health: NotRequired[builtins.bool]
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        health_check: NotRequired[builtins.str]
        """
        If you want to associate a health check with the endpoint or rule.
        """
        is_default: NotRequired[builtins.bool]
        """
        Indicates whether this set of values represents the default location.
        """
        rule_reference: NotRequired[builtins.str]
        """
        References to a rule.
        """
        subdivision: NotRequired[builtins.str]
        """
        Value of a subdivision.
        """
elif False:
    GetTrafficPolicyDocumentRuleLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleLocationArgs:
    def __init__(__self__, *,
                 continent: Optional[builtins.str] = None,
                 country: Optional[builtins.str] = None,
                 endpoint_reference: Optional[builtins.str] = None,
                 evaluate_target_health: Optional[builtins.bool] = None,
                 health_check: Optional[builtins.str] = None,
                 is_default: Optional[builtins.bool] = None,
                 rule_reference: Optional[builtins.str] = None,
                 subdivision: Optional[builtins.str] = None):
        """
        :param builtins.str continent: Value of a continent.
        :param builtins.str country: Value of a country.
        :param builtins.str endpoint_reference: References to an endpoint.
        :param builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param builtins.bool is_default: Indicates whether this set of values represents the default location.
        :param builtins.str rule_reference: References to a rule.
        :param builtins.str subdivision: Value of a subdivision.
        """
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)
        if subdivision is not None:
            pulumi.set(__self__, "subdivision", subdivision)

    @property
    @pulumi.getter
    def continent(self) -> Optional[builtins.str]:
        """
        Value of a continent.
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: Optional[builtins.str]):
        pulumi.set(self, "continent", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[builtins.str]:
        """
        Value of a country.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[builtins.str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[builtins.bool]:
        """
        Indicates whether this set of values represents the default location.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[builtins.bool]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "rule_reference", value)

    @property
    @pulumi.getter
    def subdivision(self) -> Optional[builtins.str]:
        """
        Value of a subdivision.
        """
        return pulumi.get(self, "subdivision")

    @subdivision.setter
    def subdivision(self, value: Optional[builtins.str]):
        pulumi.set(self, "subdivision", value)


if not MYPY:
    class GetTrafficPolicyDocumentRulePrimaryArgsDict(TypedDict):
        endpoint_reference: NotRequired[builtins.str]
        """
        References to an endpoint.
        """
        evaluate_target_health: NotRequired[builtins.bool]
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        health_check: NotRequired[builtins.str]
        """
        If you want to associate a health check with the endpoint or rule.
        """
        rule_reference: NotRequired[builtins.str]
        """
        References to a rule.
        """
elif False:
    GetTrafficPolicyDocumentRulePrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRulePrimaryArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[builtins.str] = None,
                 evaluate_target_health: Optional[builtins.bool] = None,
                 health_check: Optional[builtins.str] = None,
                 rule_reference: Optional[builtins.str] = None):
        """
        :param builtins.str endpoint_reference: References to an endpoint.
        :param builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param builtins.str rule_reference: References to a rule.
        """
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleRegionArgsDict(TypedDict):
        endpoint_reference: NotRequired[builtins.str]
        """
        References to an endpoint.
        """
        evaluate_target_health: NotRequired[builtins.bool]
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        health_check: NotRequired[builtins.str]
        """
        If you want to associate a health check with the endpoint or rule.
        """
        region: NotRequired[builtins.str]
        """
        Region code for the AWS Region that you created the resource in.
        """
        rule_reference: NotRequired[builtins.str]
        """
        References to a rule.
        """
elif False:
    GetTrafficPolicyDocumentRuleRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleRegionArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[builtins.str] = None,
                 evaluate_target_health: Optional[builtins.bool] = None,
                 health_check: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 rule_reference: Optional[builtins.str] = None):
        """
        :param builtins.str endpoint_reference: References to an endpoint.
        :param builtins.bool evaluate_target_health: Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        :param builtins.str health_check: If you want to associate a health check with the endpoint or rule.
        :param builtins.str region: Region code for the AWS Region that you created the resource in.
        :param builtins.str rule_reference: References to a rule.
        """
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        """
        References to an endpoint.
        """
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[builtins.bool]:
        """
        Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
        """
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        """
        If you want to associate a health check with the endpoint or rule.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Region code for the AWS Region that you created the resource in.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[builtins.str]:
        """
        References to a rule.
        """
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "rule_reference", value)


if not MYPY:
    class GetTrafficPolicyDocumentRuleSecondaryArgsDict(TypedDict):
        endpoint_reference: NotRequired[builtins.str]
        evaluate_target_health: NotRequired[builtins.bool]
        health_check: NotRequired[builtins.str]
        rule_reference: NotRequired[builtins.str]
elif False:
    GetTrafficPolicyDocumentRuleSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrafficPolicyDocumentRuleSecondaryArgs:
    def __init__(__self__, *,
                 endpoint_reference: Optional[builtins.str] = None,
                 evaluate_target_health: Optional[builtins.bool] = None,
                 health_check: Optional[builtins.str] = None,
                 rule_reference: Optional[builtins.str] = None):
        if endpoint_reference is not None:
            pulumi.set(__self__, "endpoint_reference", endpoint_reference)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if rule_reference is not None:
            pulumi.set(__self__, "rule_reference", rule_reference)

    @property
    @pulumi.getter(name="endpointReference")
    def endpoint_reference(self) -> Optional[builtins.str]:
        return pulumi.get(self, "endpoint_reference")

    @endpoint_reference.setter
    def endpoint_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "endpoint_reference", value)

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "evaluate_target_health")

    @evaluate_target_health.setter
    def evaluate_target_health(self, value: Optional[builtins.bool]):
        pulumi.set(self, "evaluate_target_health", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[builtins.str]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[builtins.str]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="ruleReference")
    def rule_reference(self) -> Optional[builtins.str]:
        return pulumi.get(self, "rule_reference")

    @rule_reference.setter
    def rule_reference(self, value: Optional[builtins.str]):
        pulumi.set(self, "rule_reference", value)


