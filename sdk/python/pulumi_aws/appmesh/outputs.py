# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GatewayRouteSpec',
    'GatewayRouteSpecGrpcRoute',
    'GatewayRouteSpecGrpcRouteAction',
    'GatewayRouteSpecGrpcRouteActionTarget',
    'GatewayRouteSpecGrpcRouteActionTargetVirtualService',
    'GatewayRouteSpecGrpcRouteMatch',
    'GatewayRouteSpecHttp2Route',
    'GatewayRouteSpecHttp2RouteAction',
    'GatewayRouteSpecHttp2RouteActionRewrite',
    'GatewayRouteSpecHttp2RouteActionRewriteHostname',
    'GatewayRouteSpecHttp2RouteActionRewritePath',
    'GatewayRouteSpecHttp2RouteActionRewritePrefix',
    'GatewayRouteSpecHttp2RouteActionTarget',
    'GatewayRouteSpecHttp2RouteActionTargetVirtualService',
    'GatewayRouteSpecHttp2RouteMatch',
    'GatewayRouteSpecHttp2RouteMatchHeader',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatch',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatchRange',
    'GatewayRouteSpecHttp2RouteMatchHostname',
    'GatewayRouteSpecHttp2RouteMatchPath',
    'GatewayRouteSpecHttp2RouteMatchQueryParameter',
    'GatewayRouteSpecHttp2RouteMatchQueryParameterMatch',
    'GatewayRouteSpecHttpRoute',
    'GatewayRouteSpecHttpRouteAction',
    'GatewayRouteSpecHttpRouteActionRewrite',
    'GatewayRouteSpecHttpRouteActionRewriteHostname',
    'GatewayRouteSpecHttpRouteActionRewritePath',
    'GatewayRouteSpecHttpRouteActionRewritePrefix',
    'GatewayRouteSpecHttpRouteActionTarget',
    'GatewayRouteSpecHttpRouteActionTargetVirtualService',
    'GatewayRouteSpecHttpRouteMatch',
    'GatewayRouteSpecHttpRouteMatchHeader',
    'GatewayRouteSpecHttpRouteMatchHeaderMatch',
    'GatewayRouteSpecHttpRouteMatchHeaderMatchRange',
    'GatewayRouteSpecHttpRouteMatchHostname',
    'GatewayRouteSpecHttpRouteMatchPath',
    'GatewayRouteSpecHttpRouteMatchQueryParameter',
    'GatewayRouteSpecHttpRouteMatchQueryParameterMatch',
    'MeshSpec',
    'MeshSpecEgressFilter',
    'RouteSpec',
    'RouteSpecGrpcRoute',
    'RouteSpecGrpcRouteAction',
    'RouteSpecGrpcRouteActionWeightedTarget',
    'RouteSpecGrpcRouteMatch',
    'RouteSpecGrpcRouteMatchMetadata',
    'RouteSpecGrpcRouteMatchMetadataMatch',
    'RouteSpecGrpcRouteMatchMetadataMatchRange',
    'RouteSpecGrpcRouteRetryPolicy',
    'RouteSpecGrpcRouteRetryPolicyPerRetryTimeout',
    'RouteSpecGrpcRouteTimeout',
    'RouteSpecGrpcRouteTimeoutIdle',
    'RouteSpecGrpcRouteTimeoutPerRequest',
    'RouteSpecHttp2Route',
    'RouteSpecHttp2RouteAction',
    'RouteSpecHttp2RouteActionWeightedTarget',
    'RouteSpecHttp2RouteMatch',
    'RouteSpecHttp2RouteMatchHeader',
    'RouteSpecHttp2RouteMatchHeaderMatch',
    'RouteSpecHttp2RouteMatchHeaderMatchRange',
    'RouteSpecHttp2RouteMatchPath',
    'RouteSpecHttp2RouteMatchQueryParameter',
    'RouteSpecHttp2RouteMatchQueryParameterMatch',
    'RouteSpecHttp2RouteRetryPolicy',
    'RouteSpecHttp2RouteRetryPolicyPerRetryTimeout',
    'RouteSpecHttp2RouteTimeout',
    'RouteSpecHttp2RouteTimeoutIdle',
    'RouteSpecHttp2RouteTimeoutPerRequest',
    'RouteSpecHttpRoute',
    'RouteSpecHttpRouteAction',
    'RouteSpecHttpRouteActionWeightedTarget',
    'RouteSpecHttpRouteMatch',
    'RouteSpecHttpRouteMatchHeader',
    'RouteSpecHttpRouteMatchHeaderMatch',
    'RouteSpecHttpRouteMatchHeaderMatchRange',
    'RouteSpecHttpRouteMatchPath',
    'RouteSpecHttpRouteMatchQueryParameter',
    'RouteSpecHttpRouteMatchQueryParameterMatch',
    'RouteSpecHttpRouteRetryPolicy',
    'RouteSpecHttpRouteRetryPolicyPerRetryTimeout',
    'RouteSpecHttpRouteTimeout',
    'RouteSpecHttpRouteTimeoutIdle',
    'RouteSpecHttpRouteTimeoutPerRequest',
    'RouteSpecTcpRoute',
    'RouteSpecTcpRouteAction',
    'RouteSpecTcpRouteActionWeightedTarget',
    'RouteSpecTcpRouteMatch',
    'RouteSpecTcpRouteTimeout',
    'RouteSpecTcpRouteTimeoutIdle',
    'VirtualGatewaySpec',
    'VirtualGatewaySpecBackendDefaults',
    'VirtualGatewaySpecBackendDefaultsClientPolicy',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTls',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds',
    'VirtualGatewaySpecListener',
    'VirtualGatewaySpecListenerConnectionPool',
    'VirtualGatewaySpecListenerConnectionPoolGrpc',
    'VirtualGatewaySpecListenerConnectionPoolHttp2',
    'VirtualGatewaySpecListenerConnectionPoolHttp',
    'VirtualGatewaySpecListenerHealthCheck',
    'VirtualGatewaySpecListenerPortMapping',
    'VirtualGatewaySpecListenerTls',
    'VirtualGatewaySpecListenerTlsCertificate',
    'VirtualGatewaySpecListenerTlsCertificateAcm',
    'VirtualGatewaySpecListenerTlsCertificateFile',
    'VirtualGatewaySpecListenerTlsCertificateSds',
    'VirtualGatewaySpecListenerTlsValidation',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch',
    'VirtualGatewaySpecListenerTlsValidationTrust',
    'VirtualGatewaySpecListenerTlsValidationTrustFile',
    'VirtualGatewaySpecListenerTlsValidationTrustSds',
    'VirtualGatewaySpecLogging',
    'VirtualGatewaySpecLoggingAccessLog',
    'VirtualGatewaySpecLoggingAccessLogFile',
    'VirtualGatewaySpecLoggingAccessLogFileFormat',
    'VirtualGatewaySpecLoggingAccessLogFileFormatJson',
    'VirtualNodeSpec',
    'VirtualNodeSpecBackend',
    'VirtualNodeSpecBackendDefaults',
    'VirtualNodeSpecBackendDefaultsClientPolicy',
    'VirtualNodeSpecBackendDefaultsClientPolicyTls',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds',
    'VirtualNodeSpecBackendVirtualService',
    'VirtualNodeSpecBackendVirtualServiceClientPolicy',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTls',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds',
    'VirtualNodeSpecListener',
    'VirtualNodeSpecListenerConnectionPool',
    'VirtualNodeSpecListenerConnectionPoolGrpc',
    'VirtualNodeSpecListenerConnectionPoolHttp2',
    'VirtualNodeSpecListenerConnectionPoolHttp',
    'VirtualNodeSpecListenerConnectionPoolTcp',
    'VirtualNodeSpecListenerHealthCheck',
    'VirtualNodeSpecListenerOutlierDetection',
    'VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration',
    'VirtualNodeSpecListenerOutlierDetectionInterval',
    'VirtualNodeSpecListenerPortMapping',
    'VirtualNodeSpecListenerTimeout',
    'VirtualNodeSpecListenerTimeoutGrpc',
    'VirtualNodeSpecListenerTimeoutGrpcIdle',
    'VirtualNodeSpecListenerTimeoutGrpcPerRequest',
    'VirtualNodeSpecListenerTimeoutHttp2',
    'VirtualNodeSpecListenerTimeoutHttp2Idle',
    'VirtualNodeSpecListenerTimeoutHttp2PerRequest',
    'VirtualNodeSpecListenerTimeoutHttp',
    'VirtualNodeSpecListenerTimeoutHttpIdle',
    'VirtualNodeSpecListenerTimeoutHttpPerRequest',
    'VirtualNodeSpecListenerTimeoutTcp',
    'VirtualNodeSpecListenerTimeoutTcpIdle',
    'VirtualNodeSpecListenerTls',
    'VirtualNodeSpecListenerTlsCertificate',
    'VirtualNodeSpecListenerTlsCertificateAcm',
    'VirtualNodeSpecListenerTlsCertificateFile',
    'VirtualNodeSpecListenerTlsCertificateSds',
    'VirtualNodeSpecListenerTlsValidation',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch',
    'VirtualNodeSpecListenerTlsValidationTrust',
    'VirtualNodeSpecListenerTlsValidationTrustFile',
    'VirtualNodeSpecListenerTlsValidationTrustSds',
    'VirtualNodeSpecLogging',
    'VirtualNodeSpecLoggingAccessLog',
    'VirtualNodeSpecLoggingAccessLogFile',
    'VirtualNodeSpecLoggingAccessLogFileFormat',
    'VirtualNodeSpecLoggingAccessLogFileFormatJson',
    'VirtualNodeSpecServiceDiscovery',
    'VirtualNodeSpecServiceDiscoveryAwsCloudMap',
    'VirtualNodeSpecServiceDiscoveryDns',
    'VirtualRouterSpec',
    'VirtualRouterSpecListener',
    'VirtualRouterSpecListenerPortMapping',
    'VirtualServiceSpec',
    'VirtualServiceSpecProvider',
    'VirtualServiceSpecProviderVirtualNode',
    'VirtualServiceSpecProviderVirtualRouter',
    'GetGatewayRouteSpecResult',
    'GetGatewayRouteSpecGrpcRouteResult',
    'GetGatewayRouteSpecGrpcRouteActionResult',
    'GetGatewayRouteSpecGrpcRouteActionTargetResult',
    'GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult',
    'GetGatewayRouteSpecGrpcRouteMatchResult',
    'GetGatewayRouteSpecHttp2RouteResult',
    'GetGatewayRouteSpecHttp2RouteActionResult',
    'GetGatewayRouteSpecHttp2RouteActionRewriteResult',
    'GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult',
    'GetGatewayRouteSpecHttp2RouteActionRewritePathResult',
    'GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult',
    'GetGatewayRouteSpecHttp2RouteActionTargetResult',
    'GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult',
    'GetGatewayRouteSpecHttp2RouteMatchResult',
    'GetGatewayRouteSpecHttp2RouteMatchHeaderResult',
    'GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult',
    'GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult',
    'GetGatewayRouteSpecHttp2RouteMatchHostnameResult',
    'GetGatewayRouteSpecHttp2RouteMatchPathResult',
    'GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult',
    'GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult',
    'GetGatewayRouteSpecHttpRouteResult',
    'GetGatewayRouteSpecHttpRouteActionResult',
    'GetGatewayRouteSpecHttpRouteActionRewriteResult',
    'GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult',
    'GetGatewayRouteSpecHttpRouteActionRewritePathResult',
    'GetGatewayRouteSpecHttpRouteActionRewritePrefixResult',
    'GetGatewayRouteSpecHttpRouteActionTargetResult',
    'GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult',
    'GetGatewayRouteSpecHttpRouteMatchResult',
    'GetGatewayRouteSpecHttpRouteMatchHeaderResult',
    'GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult',
    'GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult',
    'GetGatewayRouteSpecHttpRouteMatchHostnameResult',
    'GetGatewayRouteSpecHttpRouteMatchPathResult',
    'GetGatewayRouteSpecHttpRouteMatchQueryParameterResult',
    'GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult',
    'GetMeshSpecResult',
    'GetMeshSpecEgressFilterResult',
    'GetRouteSpecResult',
    'GetRouteSpecGrpcRouteResult',
    'GetRouteSpecGrpcRouteActionResult',
    'GetRouteSpecGrpcRouteActionWeightedTargetResult',
    'GetRouteSpecGrpcRouteMatchResult',
    'GetRouteSpecGrpcRouteMatchMetadataResult',
    'GetRouteSpecGrpcRouteMatchMetadataMatchResult',
    'GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult',
    'GetRouteSpecGrpcRouteRetryPolicyResult',
    'GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult',
    'GetRouteSpecGrpcRouteTimeoutResult',
    'GetRouteSpecGrpcRouteTimeoutIdleResult',
    'GetRouteSpecGrpcRouteTimeoutPerRequestResult',
    'GetRouteSpecHttp2RouteResult',
    'GetRouteSpecHttp2RouteActionResult',
    'GetRouteSpecHttp2RouteActionWeightedTargetResult',
    'GetRouteSpecHttp2RouteMatchResult',
    'GetRouteSpecHttp2RouteMatchHeaderResult',
    'GetRouteSpecHttp2RouteMatchHeaderMatchResult',
    'GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult',
    'GetRouteSpecHttp2RouteMatchPathResult',
    'GetRouteSpecHttp2RouteMatchQueryParameterResult',
    'GetRouteSpecHttp2RouteMatchQueryParameterMatchResult',
    'GetRouteSpecHttp2RouteRetryPolicyResult',
    'GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult',
    'GetRouteSpecHttp2RouteTimeoutResult',
    'GetRouteSpecHttp2RouteTimeoutIdleResult',
    'GetRouteSpecHttp2RouteTimeoutPerRequestResult',
    'GetRouteSpecHttpRouteResult',
    'GetRouteSpecHttpRouteActionResult',
    'GetRouteSpecHttpRouteActionWeightedTargetResult',
    'GetRouteSpecHttpRouteMatchResult',
    'GetRouteSpecHttpRouteMatchHeaderResult',
    'GetRouteSpecHttpRouteMatchHeaderMatchResult',
    'GetRouteSpecHttpRouteMatchHeaderMatchRangeResult',
    'GetRouteSpecHttpRouteMatchPathResult',
    'GetRouteSpecHttpRouteMatchQueryParameterResult',
    'GetRouteSpecHttpRouteMatchQueryParameterMatchResult',
    'GetRouteSpecHttpRouteRetryPolicyResult',
    'GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult',
    'GetRouteSpecHttpRouteTimeoutResult',
    'GetRouteSpecHttpRouteTimeoutIdleResult',
    'GetRouteSpecHttpRouteTimeoutPerRequestResult',
    'GetRouteSpecTcpRouteResult',
    'GetRouteSpecTcpRouteActionResult',
    'GetRouteSpecTcpRouteActionWeightedTargetResult',
    'GetRouteSpecTcpRouteMatchResult',
    'GetRouteSpecTcpRouteTimeoutResult',
    'GetRouteSpecTcpRouteTimeoutIdleResult',
    'GetVirtualGatewaySpecResult',
    'GetVirtualGatewaySpecBackendDefaultResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult',
    'GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult',
    'GetVirtualGatewaySpecListenerResult',
    'GetVirtualGatewaySpecListenerConnectionPoolResult',
    'GetVirtualGatewaySpecListenerConnectionPoolGrpcResult',
    'GetVirtualGatewaySpecListenerConnectionPoolHttp2Result',
    'GetVirtualGatewaySpecListenerConnectionPoolHttpResult',
    'GetVirtualGatewaySpecListenerHealthCheckResult',
    'GetVirtualGatewaySpecListenerPortMappingResult',
    'GetVirtualGatewaySpecListenerTlResult',
    'GetVirtualGatewaySpecListenerTlCertificateResult',
    'GetVirtualGatewaySpecListenerTlCertificateAcmResult',
    'GetVirtualGatewaySpecListenerTlCertificateFileResult',
    'GetVirtualGatewaySpecListenerTlCertificateSdResult',
    'GetVirtualGatewaySpecListenerTlValidationResult',
    'GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult',
    'GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult',
    'GetVirtualGatewaySpecListenerTlValidationTrustResult',
    'GetVirtualGatewaySpecListenerTlValidationTrustFileResult',
    'GetVirtualGatewaySpecListenerTlValidationTrustSdResult',
    'GetVirtualGatewaySpecLoggingResult',
    'GetVirtualGatewaySpecLoggingAccessLogResult',
    'GetVirtualGatewaySpecLoggingAccessLogFileResult',
    'GetVirtualGatewaySpecLoggingAccessLogFileFormatResult',
    'GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult',
    'GetVirtualNodeSpecResult',
    'GetVirtualNodeSpecBackendResult',
    'GetVirtualNodeSpecBackendDefaultResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult',
    'GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult',
    'GetVirtualNodeSpecBackendVirtualServiceResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult',
    'GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult',
    'GetVirtualNodeSpecListenerResult',
    'GetVirtualNodeSpecListenerConnectionPoolResult',
    'GetVirtualNodeSpecListenerConnectionPoolGrpcResult',
    'GetVirtualNodeSpecListenerConnectionPoolHttp2Result',
    'GetVirtualNodeSpecListenerConnectionPoolHttpResult',
    'GetVirtualNodeSpecListenerConnectionPoolTcpResult',
    'GetVirtualNodeSpecListenerHealthCheckResult',
    'GetVirtualNodeSpecListenerOutlierDetectionResult',
    'GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult',
    'GetVirtualNodeSpecListenerOutlierDetectionIntervalResult',
    'GetVirtualNodeSpecListenerPortMappingResult',
    'GetVirtualNodeSpecListenerTimeoutResult',
    'GetVirtualNodeSpecListenerTimeoutGrpcResult',
    'GetVirtualNodeSpecListenerTimeoutGrpcIdleResult',
    'GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult',
    'GetVirtualNodeSpecListenerTimeoutHttp2Result',
    'GetVirtualNodeSpecListenerTimeoutHttp2IdleResult',
    'GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult',
    'GetVirtualNodeSpecListenerTimeoutHttpResult',
    'GetVirtualNodeSpecListenerTimeoutHttpIdleResult',
    'GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult',
    'GetVirtualNodeSpecListenerTimeoutTcpResult',
    'GetVirtualNodeSpecListenerTimeoutTcpIdleResult',
    'GetVirtualNodeSpecListenerTlResult',
    'GetVirtualNodeSpecListenerTlCertificateResult',
    'GetVirtualNodeSpecListenerTlCertificateAcmResult',
    'GetVirtualNodeSpecListenerTlCertificateFileResult',
    'GetVirtualNodeSpecListenerTlCertificateSdResult',
    'GetVirtualNodeSpecListenerTlValidationResult',
    'GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult',
    'GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult',
    'GetVirtualNodeSpecListenerTlValidationTrustResult',
    'GetVirtualNodeSpecListenerTlValidationTrustFileResult',
    'GetVirtualNodeSpecListenerTlValidationTrustSdResult',
    'GetVirtualNodeSpecLoggingResult',
    'GetVirtualNodeSpecLoggingAccessLogResult',
    'GetVirtualNodeSpecLoggingAccessLogFileResult',
    'GetVirtualNodeSpecLoggingAccessLogFileFormatResult',
    'GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult',
    'GetVirtualNodeSpecServiceDiscoveryResult',
    'GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult',
    'GetVirtualNodeSpecServiceDiscoveryDnResult',
    'GetVirtualRouterSpecResult',
    'GetVirtualRouterSpecListenerResult',
    'GetVirtualRouterSpecListenerPortMappingResult',
    'GetVirtualServiceSpecResult',
    'GetVirtualServiceSpecProviderResult',
    'GetVirtualServiceSpecProviderVirtualNodeResult',
    'GetVirtualServiceSpecProviderVirtualRouterResult',
]

@pulumi.output_type
class GatewayRouteSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcRoute":
            suggest = "grpc_route"
        elif key == "http2Route":
            suggest = "http2_route"
        elif key == "httpRoute":
            suggest = "http_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_route: Optional['outputs.GatewayRouteSpecGrpcRoute'] = None,
                 http2_route: Optional['outputs.GatewayRouteSpecHttp2Route'] = None,
                 http_route: Optional['outputs.GatewayRouteSpecHttpRoute'] = None,
                 priority: Optional[int] = None):
        """
        :param 'GatewayRouteSpecGrpcRouteArgs' grpc_route: Specification of a gRPC gateway route.
        :param 'GatewayRouteSpecHttp2RouteArgs' http2_route: Specification of an HTTP/2 gateway route.
        :param 'GatewayRouteSpecHttpRouteArgs' http_route: Specification of an HTTP gateway route.
        :param int priority: Priority for the gateway route, between `0` and `1000`.
        """
        GatewayRouteSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc_route=grpc_route,
            http2_route=http2_route,
            http_route=http_route,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc_route: Optional['outputs.GatewayRouteSpecGrpcRoute'] = None,
             http2_route: Optional['outputs.GatewayRouteSpecHttp2Route'] = None,
             http_route: Optional['outputs.GatewayRouteSpecHttpRoute'] = None,
             priority: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpc_route is None and 'grpcRoute' in kwargs:
            grpc_route = kwargs['grpcRoute']
        if http2_route is None and 'http2Route' in kwargs:
            http2_route = kwargs['http2Route']
        if http_route is None and 'httpRoute' in kwargs:
            http_route = kwargs['httpRoute']

        if grpc_route is not None:
            _setter("grpc_route", grpc_route)
        if http2_route is not None:
            _setter("http2_route", http2_route)
        if http_route is not None:
            _setter("http_route", http_route)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional['outputs.GatewayRouteSpecGrpcRoute']:
        """
        Specification of a gRPC gateway route.
        """
        return pulumi.get(self, "grpc_route")

    @property
    @pulumi.getter(name="http2Route")
    def http2_route(self) -> Optional['outputs.GatewayRouteSpecHttp2Route']:
        """
        Specification of an HTTP/2 gateway route.
        """
        return pulumi.get(self, "http2_route")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional['outputs.GatewayRouteSpecHttpRoute']:
        """
        Specification of an HTTP gateway route.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority for the gateway route, between `0` and `1000`.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GatewayRouteSpecGrpcRoute(dict):
    def __init__(__self__, *,
                 action: 'outputs.GatewayRouteSpecGrpcRouteAction',
                 match: 'outputs.GatewayRouteSpecGrpcRouteMatch'):
        """
        :param 'GatewayRouteSpecGrpcRouteActionArgs' action: Action to take if a match is determined.
        :param 'GatewayRouteSpecGrpcRouteMatchArgs' match: Criteria for determining a request match.
        """
        GatewayRouteSpecGrpcRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.GatewayRouteSpecGrpcRouteAction'] = None,
             match: Optional['outputs.GatewayRouteSpecGrpcRouteMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("action", action)
        _setter("match", match)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.GatewayRouteSpecGrpcRouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.GatewayRouteSpecGrpcRouteMatch':
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecGrpcRouteAction(dict):
    def __init__(__self__, *,
                 target: 'outputs.GatewayRouteSpecGrpcRouteActionTarget'):
        """
        :param 'GatewayRouteSpecGrpcRouteActionTargetArgs' target: Target that traffic is routed to when a request matches the gateway route.
        """
        GatewayRouteSpecGrpcRouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional['outputs.GatewayRouteSpecGrpcRouteActionTarget'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target is None:
            raise TypeError("Missing 'target' argument")

        _setter("target", target)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.GatewayRouteSpecGrpcRouteActionTarget':
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GatewayRouteSpecGrpcRouteActionTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualService":
            suggest = "virtual_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecGrpcRouteActionTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecGrpcRouteActionTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecGrpcRouteActionTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service: 'outputs.GatewayRouteSpecGrpcRouteActionTargetVirtualService',
                 port: Optional[int] = None):
        """
        :param 'GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs' virtual_service: Virtual service gateway route target.
        :param int port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        GatewayRouteSpecGrpcRouteActionTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service=virtual_service,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service: Optional['outputs.GatewayRouteSpecGrpcRouteActionTargetVirtualService'] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service is None and 'virtualService' in kwargs:
            virtual_service = kwargs['virtualService']
        if virtual_service is None:
            raise TypeError("Missing 'virtual_service' argument")

        _setter("virtual_service", virtual_service)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> 'outputs.GatewayRouteSpecGrpcRouteActionTargetVirtualService':
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayRouteSpecGrpcRouteActionTargetVirtualService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualServiceName":
            suggest = "virtual_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecGrpcRouteActionTargetVirtualService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecGrpcRouteActionTargetVirtualService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecGrpcRouteActionTargetVirtualService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service_name: str):
        """
        :param str virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        GatewayRouteSpecGrpcRouteActionTargetVirtualService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GatewayRouteSpecGrpcRouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecGrpcRouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecGrpcRouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecGrpcRouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: str,
                 port: Optional[int] = None):
        """
        :param str service_name: Fully qualified domain name for the service to match from the request.
        :param int port: The port number to match from the request.
        """
        GatewayRouteSpecGrpcRouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_name=service_name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_name: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("service_name", service_name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Fully qualified domain name for the service to match from the request.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayRouteSpecHttp2Route(dict):
    def __init__(__self__, *,
                 action: 'outputs.GatewayRouteSpecHttp2RouteAction',
                 match: 'outputs.GatewayRouteSpecHttp2RouteMatch'):
        """
        :param 'GatewayRouteSpecHttp2RouteActionArgs' action: Action to take if a match is determined.
        :param 'GatewayRouteSpecHttp2RouteMatchArgs' match: Criteria for determining a request match.
        """
        GatewayRouteSpecHttp2Route._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.GatewayRouteSpecHttp2RouteAction'] = None,
             match: Optional['outputs.GatewayRouteSpecHttp2RouteMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("action", action)
        _setter("match", match)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.GatewayRouteSpecHttp2RouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.GatewayRouteSpecHttp2RouteMatch':
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteAction(dict):
    def __init__(__self__, *,
                 target: 'outputs.GatewayRouteSpecHttp2RouteActionTarget',
                 rewrite: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewrite'] = None):
        """
        :param 'GatewayRouteSpecHttp2RouteActionTargetArgs' target: Target that traffic is routed to when a request matches the gateway route.
        :param 'GatewayRouteSpecHttp2RouteActionRewriteArgs' rewrite: Gateway route action to rewrite.
        """
        GatewayRouteSpecHttp2RouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            rewrite=rewrite,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional['outputs.GatewayRouteSpecHttp2RouteActionTarget'] = None,
             rewrite: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewrite'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target is None:
            raise TypeError("Missing 'target' argument")

        _setter("target", target)
        if rewrite is not None:
            _setter("rewrite", rewrite)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.GatewayRouteSpecHttp2RouteActionTarget':
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def rewrite(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteActionRewrite']:
        """
        Gateway route action to rewrite.
        """
        return pulumi.get(self, "rewrite")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionRewrite(dict):
    def __init__(__self__, *,
                 hostname: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewriteHostname'] = None,
                 path: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePath'] = None,
                 prefix: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePrefix'] = None):
        """
        :param 'GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs' hostname: Host name to rewrite.
        :param 'GatewayRouteSpecHttp2RouteActionRewritePathArgs' path: Exact path to rewrite.
        :param 'GatewayRouteSpecHttp2RouteActionRewritePrefixArgs' prefix: Specified beginning characters to rewrite.
        """
        GatewayRouteSpecHttp2RouteActionRewrite._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            path=path,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewriteHostname'] = None,
             path: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePath'] = None,
             prefix: Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePrefix'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if hostname is not None:
            _setter("hostname", hostname)
        if path is not None:
            _setter("path", path)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def hostname(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteActionRewriteHostname']:
        """
        Host name to rewrite.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePath']:
        """
        Exact path to rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def prefix(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteActionRewritePrefix']:
        """
        Specified beginning characters to rewrite.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionRewriteHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTargetHostname":
            suggest = "default_target_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttp2RouteActionRewriteHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttp2RouteActionRewriteHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttp2RouteActionRewriteHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_target_hostname: str):
        """
        :param str default_target_hostname: Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        GatewayRouteSpecHttp2RouteActionRewriteHostname._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_target_hostname=default_target_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_target_hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_target_hostname is None and 'defaultTargetHostname' in kwargs:
            default_target_hostname = kwargs['defaultTargetHostname']
        if default_target_hostname is None:
            raise TypeError("Missing 'default_target_hostname' argument")

        _setter("default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> str:
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_target_hostname")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionRewritePath(dict):
    def __init__(__self__, *,
                 exact: str):
        """
        :param str exact: The exact path to match on.
        """
        GatewayRouteSpecHttp2RouteActionRewritePath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionRewritePrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPrefix":
            suggest = "default_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttp2RouteActionRewritePrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttp2RouteActionRewritePrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttp2RouteActionRewritePrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_prefix: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str default_prefix: Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        :param str value: Value used to replace the incoming route prefix when rewritten.
        """
        GatewayRouteSpecHttp2RouteActionRewritePrefix._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_prefix=default_prefix,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_prefix: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_prefix is None and 'defaultPrefix' in kwargs:
            default_prefix = kwargs['defaultPrefix']

        if default_prefix is not None:
            _setter("default_prefix", default_prefix)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> Optional[str]:
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_prefix")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value used to replace the incoming route prefix when rewritten.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualService":
            suggest = "virtual_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttp2RouteActionTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttp2RouteActionTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttp2RouteActionTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service: 'outputs.GatewayRouteSpecHttp2RouteActionTargetVirtualService',
                 port: Optional[int] = None):
        """
        :param 'GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs' virtual_service: Virtual service gateway route target.
        :param int port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        GatewayRouteSpecHttp2RouteActionTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service=virtual_service,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service: Optional['outputs.GatewayRouteSpecHttp2RouteActionTargetVirtualService'] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service is None and 'virtualService' in kwargs:
            virtual_service = kwargs['virtualService']
        if virtual_service is None:
            raise TypeError("Missing 'virtual_service' argument")

        _setter("virtual_service", virtual_service)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> 'outputs.GatewayRouteSpecHttp2RouteActionTargetVirtualService':
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteActionTargetVirtualService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualServiceName":
            suggest = "virtual_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttp2RouteActionTargetVirtualService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttp2RouteActionTargetVirtualService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttp2RouteActionTargetVirtualService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service_name: str):
        """
        :param str virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        GatewayRouteSpecHttp2RouteActionTargetVirtualService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttp2RouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttp2RouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttp2RouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchHeader']] = None,
                 hostname: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHostname'] = None,
                 path: Optional['outputs.GatewayRouteSpecHttp2RouteMatchPath'] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 query_parameters: Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameter']] = None):
        """
        :param Sequence['GatewayRouteSpecHttp2RouteMatchHeaderArgs'] headers: Client request headers to match on.
        :param 'GatewayRouteSpecHttp2RouteMatchHostnameArgs' hostname: Host name to match on.
        :param 'GatewayRouteSpecHttp2RouteMatchPathArgs' path: Client request path to match on.
        :param int port: The port number to match from the request.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param Sequence['GatewayRouteSpecHttp2RouteMatchQueryParameterArgs'] query_parameters: Client request query parameters to match on.
        """
        GatewayRouteSpecHttp2RouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            hostname=hostname,
            path=path,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchHeader']] = None,
             hostname: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHostname'] = None,
             path: Optional['outputs.GatewayRouteSpecHttp2RouteMatchPath'] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        if headers is not None:
            _setter("headers", headers)
        if hostname is not None:
            _setter("hostname", hostname)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if prefix is not None:
            _setter("prefix", prefix)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchHeader']]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hostname(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteMatchHostname']:
        """
        Host name to match on.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteMatchPath']:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameter']]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 invert: Optional[bool] = None,
                 match: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatch'] = None):
        """
        :param str name: Name for the HTTP header in the client request that will be matched on.
        :param bool invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param 'GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs' match: Method and value to match the header value sent with a request. Specify one match method.
        """
        GatewayRouteSpecHttp2RouteMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            invert=invert,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             invert: Optional[bool] = None,
             match: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if invert is not None:
            _setter("invert", invert)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatch']:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchHeaderMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None,
                 range: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange'] = None,
                 regex: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param 'GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs' range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param str regex: Header value sent by the client must include the specified characters.
        :param str suffix: Header value sent by the client must end with the specified characters.
        """
        GatewayRouteSpecHttp2RouteMatchHeaderMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            range=range,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             range: Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange'] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if prefix is not None:
            _setter("prefix", prefix)
        if range is not None:
            _setter("range", range)
        if regex is not None:
            _setter("regex", regex)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange']:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchHeaderMatchRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: End of the range.
        :param int start: Start of the range.
        """
        GatewayRouteSpecHttp2RouteMatchHeaderMatchRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchHostname(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: Exact host name to match on.
        :param str suffix: Specified ending characters of the host name to match on.
        """
        GatewayRouteSpecHttp2RouteMatchHostname._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact host name to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Specified ending characters of the host name to match on.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 regex: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        :param str regex: The regex used to match the path.
        """
        GatewayRouteSpecHttp2RouteMatchPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchQueryParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch'] = None):
        """
        :param str name: Name for the query parameter that will be matched on.
        :param 'GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs' match: The query parameter to match on.
        """
        GatewayRouteSpecHttp2RouteMatchQueryParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             match: Optional['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch']:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttp2RouteMatchQueryParameterMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        """
        GatewayRouteSpecHttp2RouteMatchQueryParameterMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class GatewayRouteSpecHttpRoute(dict):
    def __init__(__self__, *,
                 action: 'outputs.GatewayRouteSpecHttpRouteAction',
                 match: 'outputs.GatewayRouteSpecHttpRouteMatch'):
        """
        :param 'GatewayRouteSpecHttpRouteActionArgs' action: Action to take if a match is determined.
        :param 'GatewayRouteSpecHttpRouteMatchArgs' match: Criteria for determining a request match.
        """
        GatewayRouteSpecHttpRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.GatewayRouteSpecHttpRouteAction'] = None,
             match: Optional['outputs.GatewayRouteSpecHttpRouteMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("action", action)
        _setter("match", match)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.GatewayRouteSpecHttpRouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.GatewayRouteSpecHttpRouteMatch':
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttpRouteAction(dict):
    def __init__(__self__, *,
                 target: 'outputs.GatewayRouteSpecHttpRouteActionTarget',
                 rewrite: Optional['outputs.GatewayRouteSpecHttpRouteActionRewrite'] = None):
        """
        :param 'GatewayRouteSpecHttpRouteActionTargetArgs' target: Target that traffic is routed to when a request matches the gateway route.
        :param 'GatewayRouteSpecHttpRouteActionRewriteArgs' rewrite: Gateway route action to rewrite.
        """
        GatewayRouteSpecHttpRouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            rewrite=rewrite,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional['outputs.GatewayRouteSpecHttpRouteActionTarget'] = None,
             rewrite: Optional['outputs.GatewayRouteSpecHttpRouteActionRewrite'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target is None:
            raise TypeError("Missing 'target' argument")

        _setter("target", target)
        if rewrite is not None:
            _setter("rewrite", rewrite)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.GatewayRouteSpecHttpRouteActionTarget':
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def rewrite(self) -> Optional['outputs.GatewayRouteSpecHttpRouteActionRewrite']:
        """
        Gateway route action to rewrite.
        """
        return pulumi.get(self, "rewrite")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionRewrite(dict):
    def __init__(__self__, *,
                 hostname: Optional['outputs.GatewayRouteSpecHttpRouteActionRewriteHostname'] = None,
                 path: Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePath'] = None,
                 prefix: Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePrefix'] = None):
        """
        :param 'GatewayRouteSpecHttpRouteActionRewriteHostnameArgs' hostname: Host name to rewrite.
        :param 'GatewayRouteSpecHttpRouteActionRewritePathArgs' path: Exact path to rewrite.
        :param 'GatewayRouteSpecHttpRouteActionRewritePrefixArgs' prefix: Specified beginning characters to rewrite.
        """
        GatewayRouteSpecHttpRouteActionRewrite._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            path=path,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional['outputs.GatewayRouteSpecHttpRouteActionRewriteHostname'] = None,
             path: Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePath'] = None,
             prefix: Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePrefix'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if hostname is not None:
            _setter("hostname", hostname)
        if path is not None:
            _setter("path", path)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def hostname(self) -> Optional['outputs.GatewayRouteSpecHttpRouteActionRewriteHostname']:
        """
        Host name to rewrite.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePath']:
        """
        Exact path to rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def prefix(self) -> Optional['outputs.GatewayRouteSpecHttpRouteActionRewritePrefix']:
        """
        Specified beginning characters to rewrite.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionRewriteHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTargetHostname":
            suggest = "default_target_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttpRouteActionRewriteHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttpRouteActionRewriteHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttpRouteActionRewriteHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_target_hostname: str):
        """
        :param str default_target_hostname: Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        GatewayRouteSpecHttpRouteActionRewriteHostname._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_target_hostname=default_target_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_target_hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_target_hostname is None and 'defaultTargetHostname' in kwargs:
            default_target_hostname = kwargs['defaultTargetHostname']
        if default_target_hostname is None:
            raise TypeError("Missing 'default_target_hostname' argument")

        _setter("default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> str:
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_target_hostname")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionRewritePath(dict):
    def __init__(__self__, *,
                 exact: str):
        """
        :param str exact: The exact path to match on.
        """
        GatewayRouteSpecHttpRouteActionRewritePath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionRewritePrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPrefix":
            suggest = "default_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttpRouteActionRewritePrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttpRouteActionRewritePrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttpRouteActionRewritePrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_prefix: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str default_prefix: Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        :param str value: Value used to replace the incoming route prefix when rewritten.
        """
        GatewayRouteSpecHttpRouteActionRewritePrefix._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_prefix=default_prefix,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_prefix: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_prefix is None and 'defaultPrefix' in kwargs:
            default_prefix = kwargs['defaultPrefix']

        if default_prefix is not None:
            _setter("default_prefix", default_prefix)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> Optional[str]:
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_prefix")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value used to replace the incoming route prefix when rewritten.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualService":
            suggest = "virtual_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttpRouteActionTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttpRouteActionTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttpRouteActionTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service: 'outputs.GatewayRouteSpecHttpRouteActionTargetVirtualService',
                 port: Optional[int] = None):
        """
        :param 'GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs' virtual_service: Virtual service gateway route target.
        :param int port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        GatewayRouteSpecHttpRouteActionTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service=virtual_service,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service: Optional['outputs.GatewayRouteSpecHttpRouteActionTargetVirtualService'] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service is None and 'virtualService' in kwargs:
            virtual_service = kwargs['virtualService']
        if virtual_service is None:
            raise TypeError("Missing 'virtual_service' argument")

        _setter("virtual_service", virtual_service)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> 'outputs.GatewayRouteSpecHttpRouteActionTargetVirtualService':
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayRouteSpecHttpRouteActionTargetVirtualService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualServiceName":
            suggest = "virtual_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttpRouteActionTargetVirtualService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttpRouteActionTargetVirtualService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttpRouteActionTargetVirtualService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service_name: str):
        """
        :param str virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        GatewayRouteSpecHttpRouteActionTargetVirtualService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteSpecHttpRouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteSpecHttpRouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteSpecHttpRouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchHeader']] = None,
                 hostname: Optional['outputs.GatewayRouteSpecHttpRouteMatchHostname'] = None,
                 path: Optional['outputs.GatewayRouteSpecHttpRouteMatchPath'] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 query_parameters: Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchQueryParameter']] = None):
        """
        :param Sequence['GatewayRouteSpecHttpRouteMatchHeaderArgs'] headers: Client request headers to match on.
        :param 'GatewayRouteSpecHttpRouteMatchHostnameArgs' hostname: Host name to match on.
        :param 'GatewayRouteSpecHttpRouteMatchPathArgs' path: Client request path to match on.
        :param int port: The port number to match from the request.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param Sequence['GatewayRouteSpecHttpRouteMatchQueryParameterArgs'] query_parameters: Client request query parameters to match on.
        """
        GatewayRouteSpecHttpRouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            hostname=hostname,
            path=path,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchHeader']] = None,
             hostname: Optional['outputs.GatewayRouteSpecHttpRouteMatchHostname'] = None,
             path: Optional['outputs.GatewayRouteSpecHttpRouteMatchPath'] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchQueryParameter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        if headers is not None:
            _setter("headers", headers)
        if hostname is not None:
            _setter("hostname", hostname)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if prefix is not None:
            _setter("prefix", prefix)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchHeader']]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hostname(self) -> Optional['outputs.GatewayRouteSpecHttpRouteMatchHostname']:
        """
        Host name to match on.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.GatewayRouteSpecHttpRouteMatchPath']:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.GatewayRouteSpecHttpRouteMatchQueryParameter']]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 invert: Optional[bool] = None,
                 match: Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatch'] = None):
        """
        :param str name: Name for the HTTP header in the client request that will be matched on.
        :param bool invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param 'GatewayRouteSpecHttpRouteMatchHeaderMatchArgs' match: Method and value to match the header value sent with a request. Specify one match method.
        """
        GatewayRouteSpecHttpRouteMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            invert=invert,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             invert: Optional[bool] = None,
             match: Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if invert is not None:
            _setter("invert", invert)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatch']:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchHeaderMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None,
                 range: Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatchRange'] = None,
                 regex: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param 'GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs' range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param str regex: Header value sent by the client must include the specified characters.
        :param str suffix: Header value sent by the client must end with the specified characters.
        """
        GatewayRouteSpecHttpRouteMatchHeaderMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            range=range,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             range: Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatchRange'] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if prefix is not None:
            _setter("prefix", prefix)
        if range is not None:
            _setter("range", range)
        if regex is not None:
            _setter("regex", regex)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.GatewayRouteSpecHttpRouteMatchHeaderMatchRange']:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchHeaderMatchRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: End of the range.
        :param int start: Start of the range.
        """
        GatewayRouteSpecHttpRouteMatchHeaderMatchRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchHostname(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: Exact host name to match on.
        :param str suffix: Specified ending characters of the host name to match on.
        """
        GatewayRouteSpecHttpRouteMatchHostname._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact host name to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Specified ending characters of the host name to match on.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 regex: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        :param str regex: The regex used to match the path.
        """
        GatewayRouteSpecHttpRouteMatchPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchQueryParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional['outputs.GatewayRouteSpecHttpRouteMatchQueryParameterMatch'] = None):
        """
        :param str name: Name for the query parameter that will be matched on.
        :param 'GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs' match: The query parameter to match on.
        """
        GatewayRouteSpecHttpRouteMatchQueryParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             match: Optional['outputs.GatewayRouteSpecHttpRouteMatchQueryParameterMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.GatewayRouteSpecHttpRouteMatchQueryParameterMatch']:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class GatewayRouteSpecHttpRouteMatchQueryParameterMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        """
        GatewayRouteSpecHttpRouteMatchQueryParameterMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class MeshSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressFilter":
            suggest = "egress_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_filter: Optional['outputs.MeshSpecEgressFilter'] = None):
        """
        :param 'MeshSpecEgressFilterArgs' egress_filter: Egress filter rules for the service mesh.
        """
        MeshSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            egress_filter=egress_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             egress_filter: Optional['outputs.MeshSpecEgressFilter'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if egress_filter is None and 'egressFilter' in kwargs:
            egress_filter = kwargs['egressFilter']

        if egress_filter is not None:
            _setter("egress_filter", egress_filter)

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional['outputs.MeshSpecEgressFilter']:
        """
        Egress filter rules for the service mesh.
        """
        return pulumi.get(self, "egress_filter")


@pulumi.output_type
class MeshSpecEgressFilter(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: Egress filter type. By default, the type is `DROP_ALL`.
               Valid values are `ALLOW_ALL` and `DROP_ALL`.
        """
        MeshSpecEgressFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Egress filter type. By default, the type is `DROP_ALL`.
        Valid values are `ALLOW_ALL` and `DROP_ALL`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RouteSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcRoute":
            suggest = "grpc_route"
        elif key == "http2Route":
            suggest = "http2_route"
        elif key == "httpRoute":
            suggest = "http_route"
        elif key == "tcpRoute":
            suggest = "tcp_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_route: Optional['outputs.RouteSpecGrpcRoute'] = None,
                 http2_route: Optional['outputs.RouteSpecHttp2Route'] = None,
                 http_route: Optional['outputs.RouteSpecHttpRoute'] = None,
                 priority: Optional[int] = None,
                 tcp_route: Optional['outputs.RouteSpecTcpRoute'] = None):
        """
        :param 'RouteSpecGrpcRouteArgs' grpc_route: GRPC routing information for the route.
        :param 'RouteSpecHttp2RouteArgs' http2_route: HTTP/2 routing information for the route.
        :param 'RouteSpecHttpRouteArgs' http_route: HTTP routing information for the route.
        :param int priority: Priority for the route, between `0` and `1000`.
               Routes are matched based on the specified value, where `0` is the highest priority.
        :param 'RouteSpecTcpRouteArgs' tcp_route: TCP routing information for the route.
        """
        RouteSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc_route=grpc_route,
            http2_route=http2_route,
            http_route=http_route,
            priority=priority,
            tcp_route=tcp_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc_route: Optional['outputs.RouteSpecGrpcRoute'] = None,
             http2_route: Optional['outputs.RouteSpecHttp2Route'] = None,
             http_route: Optional['outputs.RouteSpecHttpRoute'] = None,
             priority: Optional[int] = None,
             tcp_route: Optional['outputs.RouteSpecTcpRoute'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpc_route is None and 'grpcRoute' in kwargs:
            grpc_route = kwargs['grpcRoute']
        if http2_route is None and 'http2Route' in kwargs:
            http2_route = kwargs['http2Route']
        if http_route is None and 'httpRoute' in kwargs:
            http_route = kwargs['httpRoute']
        if tcp_route is None and 'tcpRoute' in kwargs:
            tcp_route = kwargs['tcpRoute']

        if grpc_route is not None:
            _setter("grpc_route", grpc_route)
        if http2_route is not None:
            _setter("http2_route", http2_route)
        if http_route is not None:
            _setter("http_route", http_route)
        if priority is not None:
            _setter("priority", priority)
        if tcp_route is not None:
            _setter("tcp_route", tcp_route)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional['outputs.RouteSpecGrpcRoute']:
        """
        GRPC routing information for the route.
        """
        return pulumi.get(self, "grpc_route")

    @property
    @pulumi.getter(name="http2Route")
    def http2_route(self) -> Optional['outputs.RouteSpecHttp2Route']:
        """
        HTTP/2 routing information for the route.
        """
        return pulumi.get(self, "http2_route")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional['outputs.RouteSpecHttpRoute']:
        """
        HTTP routing information for the route.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority for the route, between `0` and `1000`.
        Routes are matched based on the specified value, where `0` is the highest priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="tcpRoute")
    def tcp_route(self) -> Optional['outputs.RouteSpecTcpRoute']:
        """
        TCP routing information for the route.
        """
        return pulumi.get(self, "tcp_route")


@pulumi.output_type
class RouteSpecGrpcRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryPolicy":
            suggest = "retry_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RouteSpecGrpcRouteAction',
                 match: Optional['outputs.RouteSpecGrpcRouteMatch'] = None,
                 retry_policy: Optional['outputs.RouteSpecGrpcRouteRetryPolicy'] = None,
                 timeout: Optional['outputs.RouteSpecGrpcRouteTimeout'] = None):
        """
        :param 'RouteSpecGrpcRouteActionArgs' action: Action to take if a match is determined.
        :param 'RouteSpecGrpcRouteMatchArgs' match: Criteria for determining an gRPC request match.
        :param 'RouteSpecGrpcRouteRetryPolicyArgs' retry_policy: Retry policy.
        :param 'RouteSpecGrpcRouteTimeoutArgs' timeout: Types of timeouts.
        """
        RouteSpecGrpcRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            retry_policy=retry_policy,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.RouteSpecGrpcRouteAction'] = None,
             match: Optional['outputs.RouteSpecGrpcRouteMatch'] = None,
             retry_policy: Optional['outputs.RouteSpecGrpcRouteRetryPolicy'] = None,
             timeout: Optional['outputs.RouteSpecGrpcRouteTimeout'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if retry_policy is None and 'retryPolicy' in kwargs:
            retry_policy = kwargs['retryPolicy']

        _setter("action", action)
        if match is not None:
            _setter("match", match)
        if retry_policy is not None:
            _setter("retry_policy", retry_policy)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.RouteSpecGrpcRouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecGrpcRouteMatch']:
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RouteSpecGrpcRouteRetryPolicy']:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RouteSpecGrpcRouteTimeout']:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RouteSpecGrpcRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weightedTargets":
            suggest = "weighted_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.RouteSpecGrpcRouteActionWeightedTarget']):
        """
        :param Sequence['RouteSpecGrpcRouteActionWeightedTargetArgs'] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        RouteSpecGrpcRouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.RouteSpecGrpcRouteActionWeightedTarget']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.RouteSpecGrpcRouteActionWeightedTarget']:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class RouteSpecGrpcRouteActionWeightedTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNode":
            suggest = "virtual_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRouteActionWeightedTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRouteActionWeightedTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRouteActionWeightedTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node: str,
                 weight: int,
                 port: Optional[int] = None):
        """
        :param str virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param int weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param int port: The targeted port of the weighted object.
        """
        RouteSpecGrpcRouteActionWeightedTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node=virtual_node,
            weight=weight,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("virtual_node", virtual_node)
        _setter("weight", weight)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RouteSpecGrpcRouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadatas: Optional[Sequence['outputs.RouteSpecGrpcRouteMatchMetadata']] = None,
                 method_name: Optional[str] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        :param Sequence['RouteSpecGrpcRouteMatchMetadataArgs'] metadatas: Data to match from the gRPC request.
        :param str method_name: Method name to match from the request. If you specify a name, you must also specify a `service_name`.
        :param int port: The port number to match from the request.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param str service_name: Fully qualified domain name for the service to match from the request.
        """
        RouteSpecGrpcRouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadatas=metadatas,
            method_name=method_name,
            port=port,
            prefix=prefix,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadatas: Optional[Sequence['outputs.RouteSpecGrpcRouteMatchMetadata']] = None,
             method_name: Optional[str] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if method_name is None and 'methodName' in kwargs:
            method_name = kwargs['methodName']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if metadatas is not None:
            _setter("metadatas", metadatas)
        if method_name is not None:
            _setter("method_name", method_name)
        if port is not None:
            _setter("port", port)
        if prefix is not None:
            _setter("prefix", prefix)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.RouteSpecGrpcRouteMatchMetadata']]:
        """
        Data to match from the gRPC request.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[str]:
        """
        Method name to match from the request. If you specify a name, you must also specify a `service_name`.
        """
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Fully qualified domain name for the service to match from the request.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class RouteSpecGrpcRouteMatchMetadata(dict):
    def __init__(__self__, *,
                 name: str,
                 invert: Optional[bool] = None,
                 match: Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatch'] = None):
        """
        :param str name: Name of the route. Must be between 1 and 50 characters in length.
        :param bool invert: If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
        :param 'RouteSpecGrpcRouteMatchMetadataMatchArgs' match: Data to match from the request.
        """
        RouteSpecGrpcRouteMatchMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            invert=invert,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             invert: Optional[bool] = None,
             match: Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if invert is not None:
            _setter("invert", invert)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route. Must be between 1 and 50 characters in length.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatch']:
        """
        Data to match from the request.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class RouteSpecGrpcRouteMatchMetadataMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None,
                 range: Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatchRange'] = None,
                 regex: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param 'RouteSpecGrpcRouteMatchMetadataMatchRangeArgs' range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param str regex: The regex used to match the path.
        :param str suffix: Header value sent by the client must end with the specified characters.
        """
        RouteSpecGrpcRouteMatchMetadataMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            range=range,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             range: Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatchRange'] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if prefix is not None:
            _setter("prefix", prefix)
        if range is not None:
            _setter("range", range)
        if regex is not None:
            _setter("regex", regex)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.RouteSpecGrpcRouteMatchMetadataMatchRange']:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class RouteSpecGrpcRouteMatchMetadataMatchRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: End of the range.
        :param int start: Start of the range.
        """
        RouteSpecGrpcRouteMatchMetadataMatchRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class RouteSpecGrpcRouteRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "perRetryTimeout":
            suggest = "per_retry_timeout"
        elif key == "grpcRetryEvents":
            suggest = "grpc_retry_events"
        elif key == "httpRetryEvents":
            suggest = "http_retry_events"
        elif key == "tcpRetryEvents":
            suggest = "tcp_retry_events"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRouteRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRouteRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRouteRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: int,
                 per_retry_timeout: 'outputs.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout',
                 grpc_retry_events: Optional[Sequence[str]] = None,
                 http_retry_events: Optional[Sequence[str]] = None,
                 tcp_retry_events: Optional[Sequence[str]] = None):
        """
        :param int max_retries: Maximum number of retries.
        :param 'RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs' per_retry_timeout: Per-retry timeout.
        :param Sequence[str] grpc_retry_events: List of gRPC retry events.
               Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
        :param Sequence[str] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param Sequence[str] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
        """
        RouteSpecGrpcRouteRetryPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_retries=max_retries,
            per_retry_timeout=per_retry_timeout,
            grpc_retry_events=grpc_retry_events,
            http_retry_events=http_retry_events,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_retries: Optional[int] = None,
             per_retry_timeout: Optional['outputs.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout'] = None,
             grpc_retry_events: Optional[Sequence[str]] = None,
             http_retry_events: Optional[Sequence[str]] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeout is None and 'perRetryTimeout' in kwargs:
            per_retry_timeout = kwargs['perRetryTimeout']
        if per_retry_timeout is None:
            raise TypeError("Missing 'per_retry_timeout' argument")
        if grpc_retry_events is None and 'grpcRetryEvents' in kwargs:
            grpc_retry_events = kwargs['grpcRetryEvents']
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']

        _setter("max_retries", max_retries)
        _setter("per_retry_timeout", per_retry_timeout)
        if grpc_retry_events is not None:
            _setter("grpc_retry_events", grpc_retry_events)
        if http_retry_events is not None:
            _setter("http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> 'outputs.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout':
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @property
    @pulumi.getter(name="grpcRetryEvents")
    def grpc_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of gRPC retry events.
        Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
        """
        return pulumi.get(self, "grpc_retry_events")

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.
        """
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class RouteSpecGrpcRouteRetryPolicyPerRetryTimeout(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Retry unit. Valid values: `ms`, `s`.
        :param int value: Retry value.
        """
        RouteSpecGrpcRouteRetryPolicyPerRetryTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Retry value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecGrpcRouteTimeout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecGrpcRouteTimeout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecGrpcRouteTimeout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecGrpcRouteTimeout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.RouteSpecGrpcRouteTimeoutIdle'] = None,
                 per_request: Optional['outputs.RouteSpecGrpcRouteTimeoutPerRequest'] = None):
        """
        :param 'RouteSpecGrpcRouteTimeoutIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'RouteSpecGrpcRouteTimeoutPerRequestArgs' per_request: Per request timeout.
        """
        RouteSpecGrpcRouteTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.RouteSpecGrpcRouteTimeoutIdle'] = None,
             per_request: Optional['outputs.RouteSpecGrpcRouteTimeoutPerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.RouteSpecGrpcRouteTimeoutIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.RouteSpecGrpcRouteTimeoutPerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class RouteSpecGrpcRouteTimeoutIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecGrpcRouteTimeoutIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecGrpcRouteTimeoutPerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecGrpcRouteTimeoutPerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttp2Route(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryPolicy":
            suggest = "retry_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2Route. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2Route.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2Route.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RouteSpecHttp2RouteAction',
                 match: 'outputs.RouteSpecHttp2RouteMatch',
                 retry_policy: Optional['outputs.RouteSpecHttp2RouteRetryPolicy'] = None,
                 timeout: Optional['outputs.RouteSpecHttp2RouteTimeout'] = None):
        """
        :param 'RouteSpecHttp2RouteActionArgs' action: Action to take if a match is determined.
        :param 'RouteSpecHttp2RouteMatchArgs' match: Criteria for determining an gRPC request match.
        :param 'RouteSpecHttp2RouteRetryPolicyArgs' retry_policy: Retry policy.
        :param 'RouteSpecHttp2RouteTimeoutArgs' timeout: Types of timeouts.
        """
        RouteSpecHttp2Route._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            retry_policy=retry_policy,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.RouteSpecHttp2RouteAction'] = None,
             match: Optional['outputs.RouteSpecHttp2RouteMatch'] = None,
             retry_policy: Optional['outputs.RouteSpecHttp2RouteRetryPolicy'] = None,
             timeout: Optional['outputs.RouteSpecHttp2RouteTimeout'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match is None:
            raise TypeError("Missing 'match' argument")
        if retry_policy is None and 'retryPolicy' in kwargs:
            retry_policy = kwargs['retryPolicy']

        _setter("action", action)
        _setter("match", match)
        if retry_policy is not None:
            _setter("retry_policy", retry_policy)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.RouteSpecHttp2RouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.RouteSpecHttp2RouteMatch':
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RouteSpecHttp2RouteRetryPolicy']:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RouteSpecHttp2RouteTimeout']:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RouteSpecHttp2RouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weightedTargets":
            suggest = "weighted_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2RouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2RouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2RouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.RouteSpecHttp2RouteActionWeightedTarget']):
        """
        :param Sequence['RouteSpecHttp2RouteActionWeightedTargetArgs'] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        RouteSpecHttp2RouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.RouteSpecHttp2RouteActionWeightedTarget']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.RouteSpecHttp2RouteActionWeightedTarget']:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class RouteSpecHttp2RouteActionWeightedTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNode":
            suggest = "virtual_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2RouteActionWeightedTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2RouteActionWeightedTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2RouteActionWeightedTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node: str,
                 weight: int,
                 port: Optional[int] = None):
        """
        :param str virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param int weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param int port: The targeted port of the weighted object.
        """
        RouteSpecHttp2RouteActionWeightedTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node=virtual_node,
            weight=weight,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("virtual_node", virtual_node)
        _setter("weight", weight)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RouteSpecHttp2RouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2RouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2RouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2RouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.RouteSpecHttp2RouteMatchHeader']] = None,
                 method: Optional[str] = None,
                 path: Optional['outputs.RouteSpecHttp2RouteMatchPath'] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 query_parameters: Optional[Sequence['outputs.RouteSpecHttp2RouteMatchQueryParameter']] = None,
                 scheme: Optional[str] = None):
        """
        :param Sequence['RouteSpecHttp2RouteMatchHeaderArgs'] headers: Client request headers to match on.
        :param str method: Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        :param 'RouteSpecHttp2RouteMatchPathArgs' path: Client request path to match on.
        :param int port: The port number to match from the request.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param Sequence['RouteSpecHttp2RouteMatchQueryParameterArgs'] query_parameters: Client request query parameters to match on.
        :param str scheme: Client request header scheme to match on. Valid values: `http`, `https`.
        """
        RouteSpecHttp2RouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            method=method,
            path=path,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.RouteSpecHttp2RouteMatchHeader']] = None,
             method: Optional[str] = None,
             path: Optional['outputs.RouteSpecHttp2RouteMatchPath'] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.RouteSpecHttp2RouteMatchQueryParameter']] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        if headers is not None:
            _setter("headers", headers)
        if method is not None:
            _setter("method", method)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if prefix is not None:
            _setter("prefix", prefix)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RouteSpecHttp2RouteMatchHeader']]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RouteSpecHttp2RouteMatchPath']:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.RouteSpecHttp2RouteMatchQueryParameter']]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class RouteSpecHttp2RouteMatchHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 invert: Optional[bool] = None,
                 match: Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatch'] = None):
        """
        :param str name: Name for the HTTP header in the client request that will be matched on.
        :param bool invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param 'RouteSpecHttp2RouteMatchHeaderMatchArgs' match: Method and value to match the header value sent with a request. Specify one match method.
        """
        RouteSpecHttp2RouteMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            invert=invert,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             invert: Optional[bool] = None,
             match: Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if invert is not None:
            _setter("invert", invert)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatch']:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class RouteSpecHttp2RouteMatchHeaderMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None,
                 range: Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatchRange'] = None,
                 regex: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param 'RouteSpecHttp2RouteMatchHeaderMatchRangeArgs' range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param str regex: The regex used to match the path.
        :param str suffix: Header value sent by the client must end with the specified characters.
        """
        RouteSpecHttp2RouteMatchHeaderMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            range=range,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             range: Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatchRange'] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if prefix is not None:
            _setter("prefix", prefix)
        if range is not None:
            _setter("range", range)
        if regex is not None:
            _setter("regex", regex)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.RouteSpecHttp2RouteMatchHeaderMatchRange']:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class RouteSpecHttp2RouteMatchHeaderMatchRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: End of the range.
        :param int start: Start of the range.
        """
        RouteSpecHttp2RouteMatchHeaderMatchRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class RouteSpecHttp2RouteMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 regex: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        :param str regex: Header value sent by the client must include the specified characters.
        """
        RouteSpecHttp2RouteMatchPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class RouteSpecHttp2RouteMatchQueryParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional['outputs.RouteSpecHttp2RouteMatchQueryParameterMatch'] = None):
        """
        :param str name: Name to use for the route. Must be between 1 and 255 characters in length.
        :param 'RouteSpecHttp2RouteMatchQueryParameterMatchArgs' match: Criteria for determining an gRPC request match.
        """
        RouteSpecHttp2RouteMatchQueryParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             match: Optional['outputs.RouteSpecHttp2RouteMatchQueryParameterMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name to use for the route. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecHttp2RouteMatchQueryParameterMatch']:
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class RouteSpecHttp2RouteMatchQueryParameterMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        """
        RouteSpecHttp2RouteMatchQueryParameterMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class RouteSpecHttp2RouteRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "perRetryTimeout":
            suggest = "per_retry_timeout"
        elif key == "httpRetryEvents":
            suggest = "http_retry_events"
        elif key == "tcpRetryEvents":
            suggest = "tcp_retry_events"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2RouteRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2RouteRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2RouteRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: int,
                 per_retry_timeout: 'outputs.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout',
                 http_retry_events: Optional[Sequence[str]] = None,
                 tcp_retry_events: Optional[Sequence[str]] = None):
        """
        :param int max_retries: Maximum number of retries.
        :param 'RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs' per_retry_timeout: Per-retry timeout.
        :param Sequence[str] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param Sequence[str] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
        """
        RouteSpecHttp2RouteRetryPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_retries=max_retries,
            per_retry_timeout=per_retry_timeout,
            http_retry_events=http_retry_events,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_retries: Optional[int] = None,
             per_retry_timeout: Optional['outputs.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout'] = None,
             http_retry_events: Optional[Sequence[str]] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeout is None and 'perRetryTimeout' in kwargs:
            per_retry_timeout = kwargs['perRetryTimeout']
        if per_retry_timeout is None:
            raise TypeError("Missing 'per_retry_timeout' argument")
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']

        _setter("max_retries", max_retries)
        _setter("per_retry_timeout", per_retry_timeout)
        if http_retry_events is not None:
            _setter("http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> 'outputs.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout':
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.
        """
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class RouteSpecHttp2RouteRetryPolicyPerRetryTimeout(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Retry unit. Valid values: `ms`, `s`.
        :param int value: Retry value.
        """
        RouteSpecHttp2RouteRetryPolicyPerRetryTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Retry value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttp2RouteTimeout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttp2RouteTimeout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttp2RouteTimeout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttp2RouteTimeout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.RouteSpecHttp2RouteTimeoutIdle'] = None,
                 per_request: Optional['outputs.RouteSpecHttp2RouteTimeoutPerRequest'] = None):
        """
        :param 'RouteSpecHttp2RouteTimeoutIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'RouteSpecHttp2RouteTimeoutPerRequestArgs' per_request: Per request timeout.
        """
        RouteSpecHttp2RouteTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.RouteSpecHttp2RouteTimeoutIdle'] = None,
             per_request: Optional['outputs.RouteSpecHttp2RouteTimeoutPerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.RouteSpecHttp2RouteTimeoutIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.RouteSpecHttp2RouteTimeoutPerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class RouteSpecHttp2RouteTimeoutIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecHttp2RouteTimeoutIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttp2RouteTimeoutPerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecHttp2RouteTimeoutPerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttpRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryPolicy":
            suggest = "retry_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RouteSpecHttpRouteAction',
                 match: 'outputs.RouteSpecHttpRouteMatch',
                 retry_policy: Optional['outputs.RouteSpecHttpRouteRetryPolicy'] = None,
                 timeout: Optional['outputs.RouteSpecHttpRouteTimeout'] = None):
        """
        :param 'RouteSpecHttpRouteActionArgs' action: Action to take if a match is determined.
        :param 'RouteSpecHttpRouteMatchArgs' match: Criteria for determining an HTTP request match.
        :param 'RouteSpecHttpRouteRetryPolicyArgs' retry_policy: Retry policy.
        :param 'RouteSpecHttpRouteTimeoutArgs' timeout: Types of timeouts.
        """
        RouteSpecHttpRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            retry_policy=retry_policy,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.RouteSpecHttpRouteAction'] = None,
             match: Optional['outputs.RouteSpecHttpRouteMatch'] = None,
             retry_policy: Optional['outputs.RouteSpecHttpRouteRetryPolicy'] = None,
             timeout: Optional['outputs.RouteSpecHttpRouteTimeout'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match is None:
            raise TypeError("Missing 'match' argument")
        if retry_policy is None and 'retryPolicy' in kwargs:
            retry_policy = kwargs['retryPolicy']

        _setter("action", action)
        _setter("match", match)
        if retry_policy is not None:
            _setter("retry_policy", retry_policy)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.RouteSpecHttpRouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.RouteSpecHttpRouteMatch':
        """
        Criteria for determining an HTTP request match.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RouteSpecHttpRouteRetryPolicy']:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RouteSpecHttpRouteTimeout']:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RouteSpecHttpRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weightedTargets":
            suggest = "weighted_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.RouteSpecHttpRouteActionWeightedTarget']):
        """
        :param Sequence['RouteSpecHttpRouteActionWeightedTargetArgs'] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        RouteSpecHttpRouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.RouteSpecHttpRouteActionWeightedTarget']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.RouteSpecHttpRouteActionWeightedTarget']:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class RouteSpecHttpRouteActionWeightedTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNode":
            suggest = "virtual_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRouteActionWeightedTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRouteActionWeightedTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRouteActionWeightedTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node: str,
                 weight: int,
                 port: Optional[int] = None):
        """
        :param str virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param int weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param int port: The targeted port of the weighted object.
        """
        RouteSpecHttpRouteActionWeightedTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node=virtual_node,
            weight=weight,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("virtual_node", virtual_node)
        _setter("weight", weight)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RouteSpecHttpRouteMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRouteMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRouteMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRouteMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.RouteSpecHttpRouteMatchHeader']] = None,
                 method: Optional[str] = None,
                 path: Optional['outputs.RouteSpecHttpRouteMatchPath'] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 query_parameters: Optional[Sequence['outputs.RouteSpecHttpRouteMatchQueryParameter']] = None,
                 scheme: Optional[str] = None):
        """
        :param Sequence['RouteSpecHttpRouteMatchHeaderArgs'] headers: Client request headers to match on.
        :param str method: Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        :param 'RouteSpecHttpRouteMatchPathArgs' path: Client request path to match on.
        :param int port: The port number to match from the request.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param Sequence['RouteSpecHttpRouteMatchQueryParameterArgs'] query_parameters: Client request query parameters to match on.
        :param str scheme: Client request header scheme to match on. Valid values: `http`, `https`.
        """
        RouteSpecHttpRouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            method=method,
            path=path,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.RouteSpecHttpRouteMatchHeader']] = None,
             method: Optional[str] = None,
             path: Optional['outputs.RouteSpecHttpRouteMatchPath'] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.RouteSpecHttpRouteMatchQueryParameter']] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        if headers is not None:
            _setter("headers", headers)
        if method is not None:
            _setter("method", method)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if prefix is not None:
            _setter("prefix", prefix)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RouteSpecHttpRouteMatchHeader']]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.RouteSpecHttpRouteMatchPath']:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.RouteSpecHttpRouteMatchQueryParameter']]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class RouteSpecHttpRouteMatchHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 invert: Optional[bool] = None,
                 match: Optional['outputs.RouteSpecHttpRouteMatchHeaderMatch'] = None):
        """
        :param str name: Name for the HTTP header in the client request that will be matched on.
        :param bool invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param 'RouteSpecHttpRouteMatchHeaderMatchArgs' match: Method and value to match the header value sent with a request. Specify one match method.
        """
        RouteSpecHttpRouteMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            invert=invert,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             invert: Optional[bool] = None,
             match: Optional['outputs.RouteSpecHttpRouteMatchHeaderMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if invert is not None:
            _setter("invert", invert)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecHttpRouteMatchHeaderMatch']:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class RouteSpecHttpRouteMatchHeaderMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None,
                 range: Optional['outputs.RouteSpecHttpRouteMatchHeaderMatchRange'] = None,
                 regex: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        :param str prefix: Header value sent by the client must begin with the specified characters.
        :param 'RouteSpecHttpRouteMatchHeaderMatchRangeArgs' range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param str regex: The regex used to match the path.
        :param str suffix: Header value sent by the client must end with the specified characters.
        """
        RouteSpecHttpRouteMatchHeaderMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            range=range,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             range: Optional['outputs.RouteSpecHttpRouteMatchHeaderMatchRange'] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if prefix is not None:
            _setter("prefix", prefix)
        if range is not None:
            _setter("range", range)
        if regex is not None:
            _setter("regex", regex)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.RouteSpecHttpRouteMatchHeaderMatchRange']:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class RouteSpecHttpRouteMatchHeaderMatchRange(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: End of the range.
        :param int start: Start of the range.
        """
        RouteSpecHttpRouteMatchHeaderMatchRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class RouteSpecHttpRouteMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 regex: Optional[str] = None):
        """
        :param str exact: Header value sent by the client must match the specified value exactly.
        :param str regex: Header value sent by the client must include the specified characters.
        """
        RouteSpecHttpRouteMatchPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class RouteSpecHttpRouteMatchQueryParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional['outputs.RouteSpecHttpRouteMatchQueryParameterMatch'] = None):
        """
        :param str name: Name to use for the route. Must be between 1 and 255 characters in length.
        :param 'RouteSpecHttpRouteMatchQueryParameterMatchArgs' match: Criteria for determining an gRPC request match.
        """
        RouteSpecHttpRouteMatchQueryParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             match: Optional['outputs.RouteSpecHttpRouteMatchQueryParameterMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if match is not None:
            _setter("match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name to use for the route. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecHttpRouteMatchQueryParameterMatch']:
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class RouteSpecHttpRouteMatchQueryParameterMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None):
        """
        :param str exact: The exact path to match on.
        """
        RouteSpecHttpRouteMatchQueryParameterMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class RouteSpecHttpRouteRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "perRetryTimeout":
            suggest = "per_retry_timeout"
        elif key == "httpRetryEvents":
            suggest = "http_retry_events"
        elif key == "tcpRetryEvents":
            suggest = "tcp_retry_events"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRouteRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRouteRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRouteRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: int,
                 per_retry_timeout: 'outputs.RouteSpecHttpRouteRetryPolicyPerRetryTimeout',
                 http_retry_events: Optional[Sequence[str]] = None,
                 tcp_retry_events: Optional[Sequence[str]] = None):
        """
        :param int max_retries: Maximum number of retries.
        :param 'RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs' per_retry_timeout: Per-retry timeout.
        :param Sequence[str] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param Sequence[str] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
        """
        RouteSpecHttpRouteRetryPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_retries=max_retries,
            per_retry_timeout=per_retry_timeout,
            http_retry_events=http_retry_events,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_retries: Optional[int] = None,
             per_retry_timeout: Optional['outputs.RouteSpecHttpRouteRetryPolicyPerRetryTimeout'] = None,
             http_retry_events: Optional[Sequence[str]] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeout is None and 'perRetryTimeout' in kwargs:
            per_retry_timeout = kwargs['perRetryTimeout']
        if per_retry_timeout is None:
            raise TypeError("Missing 'per_retry_timeout' argument")
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']

        _setter("max_retries", max_retries)
        _setter("per_retry_timeout", per_retry_timeout)
        if http_retry_events is not None:
            _setter("http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> 'outputs.RouteSpecHttpRouteRetryPolicyPerRetryTimeout':
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[Sequence[str]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.
        """
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class RouteSpecHttpRouteRetryPolicyPerRetryTimeout(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Retry unit. Valid values: `ms`, `s`.
        :param int value: Retry value.
        """
        RouteSpecHttpRouteRetryPolicyPerRetryTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Retry value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttpRouteTimeout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecHttpRouteTimeout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecHttpRouteTimeout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecHttpRouteTimeout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.RouteSpecHttpRouteTimeoutIdle'] = None,
                 per_request: Optional['outputs.RouteSpecHttpRouteTimeoutPerRequest'] = None):
        """
        :param 'RouteSpecHttpRouteTimeoutIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'RouteSpecHttpRouteTimeoutPerRequestArgs' per_request: Per request timeout.
        """
        RouteSpecHttpRouteTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.RouteSpecHttpRouteTimeoutIdle'] = None,
             per_request: Optional['outputs.RouteSpecHttpRouteTimeoutPerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.RouteSpecHttpRouteTimeoutIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.RouteSpecHttpRouteTimeoutPerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class RouteSpecHttpRouteTimeoutIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecHttpRouteTimeoutIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecHttpRouteTimeoutPerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecHttpRouteTimeoutPerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouteSpecTcpRoute(dict):
    def __init__(__self__, *,
                 action: 'outputs.RouteSpecTcpRouteAction',
                 match: Optional['outputs.RouteSpecTcpRouteMatch'] = None,
                 timeout: Optional['outputs.RouteSpecTcpRouteTimeout'] = None):
        """
        :param 'RouteSpecTcpRouteActionArgs' action: Action to take if a match is determined.
        :param 'RouteSpecTcpRouteMatchArgs' match: Criteria for determining an gRPC request match.
        :param 'RouteSpecTcpRouteTimeoutArgs' timeout: Types of timeouts.
        """
        RouteSpecTcpRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.RouteSpecTcpRouteAction'] = None,
             match: Optional['outputs.RouteSpecTcpRouteMatch'] = None,
             timeout: Optional['outputs.RouteSpecTcpRouteTimeout'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")

        _setter("action", action)
        if match is not None:
            _setter("match", match)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.RouteSpecTcpRouteAction':
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.RouteSpecTcpRouteMatch']:
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RouteSpecTcpRouteTimeout']:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RouteSpecTcpRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weightedTargets":
            suggest = "weighted_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecTcpRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecTcpRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecTcpRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.RouteSpecTcpRouteActionWeightedTarget']):
        """
        :param Sequence['RouteSpecTcpRouteActionWeightedTargetArgs'] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        RouteSpecTcpRouteAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.RouteSpecTcpRouteActionWeightedTarget']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.RouteSpecTcpRouteActionWeightedTarget']:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class RouteSpecTcpRouteActionWeightedTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNode":
            suggest = "virtual_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteSpecTcpRouteActionWeightedTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteSpecTcpRouteActionWeightedTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteSpecTcpRouteActionWeightedTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node: str,
                 weight: int,
                 port: Optional[int] = None):
        """
        :param str virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param int weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param int port: The targeted port of the weighted object.
        """
        RouteSpecTcpRouteActionWeightedTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node=virtual_node,
            weight=weight,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("virtual_node", virtual_node)
        _setter("weight", weight)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RouteSpecTcpRouteMatch(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        """
        :param int port: The port number to match from the request.
        """
        RouteSpecTcpRouteMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RouteSpecTcpRouteTimeout(dict):
    def __init__(__self__, *,
                 idle: Optional['outputs.RouteSpecTcpRouteTimeoutIdle'] = None):
        """
        :param 'RouteSpecTcpRouteTimeoutIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        RouteSpecTcpRouteTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.RouteSpecTcpRouteTimeoutIdle'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if idle is not None:
            _setter("idle", idle)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.RouteSpecTcpRouteTimeoutIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")


@pulumi.output_type
class RouteSpecTcpRouteTimeoutIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        RouteSpecTcpRouteTimeoutIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualGatewaySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDefaults":
            suggest = "backend_defaults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listeners: Sequence['outputs.VirtualGatewaySpecListener'],
                 backend_defaults: Optional['outputs.VirtualGatewaySpecBackendDefaults'] = None,
                 logging: Optional['outputs.VirtualGatewaySpecLogging'] = None):
        """
        :param Sequence['VirtualGatewaySpecListenerArgs'] listeners: Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        :param 'VirtualGatewaySpecBackendDefaultsArgs' backend_defaults: Defaults for backends.
        :param 'VirtualGatewaySpecLoggingArgs' logging: Inbound and outbound access logging information for the virtual gateway.
        """
        VirtualGatewaySpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            listeners=listeners,
            backend_defaults=backend_defaults,
            logging=logging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             listeners: Optional[Sequence['outputs.VirtualGatewaySpecListener']] = None,
             backend_defaults: Optional['outputs.VirtualGatewaySpecBackendDefaults'] = None,
             logging: Optional['outputs.VirtualGatewaySpecLogging'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if listeners is None:
            raise TypeError("Missing 'listeners' argument")
        if backend_defaults is None and 'backendDefaults' in kwargs:
            backend_defaults = kwargs['backendDefaults']

        _setter("listeners", listeners)
        if backend_defaults is not None:
            _setter("backend_defaults", backend_defaults)
        if logging is not None:
            _setter("logging", logging)

    @property
    @pulumi.getter
    def listeners(self) -> Sequence['outputs.VirtualGatewaySpecListener']:
        """
        Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        """
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaults']:
        """
        Defaults for backends.
        """
        return pulumi.get(self, "backend_defaults")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.VirtualGatewaySpecLogging']:
        """
        Inbound and outbound access logging information for the virtual gateway.
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientPolicy":
            suggest = "client_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_policy: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicy'] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyArgs' client_policy: Default client policy for virtual gateway backends.
        """
        VirtualGatewaySpecBackendDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_policy=client_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_policy: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicy'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_policy is None and 'clientPolicy' in kwargs:
            client_policy = kwargs['clientPolicy']

        if client_policy is not None:
            _setter("client_policy", client_policy)

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicy']:
        """
        Default client policy for virtual gateway backends.
        """
        return pulumi.get(self, "client_policy")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicy(dict):
    def __init__(__self__, *,
                 tls: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTls'] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs' tls: Transport Layer Security (TLS) client policy.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTls'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTls']:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTls(dict):
    def __init__(__self__, *,
                 validation: 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation',
                 certificate: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate'] = None,
                 enforce: Optional[bool] = None,
                 ports: Optional[Sequence[int]] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs' validation: Listener's Transport Layer Security (TLS) validation context.
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs' certificate: Listener's TLS certificate.
        :param bool enforce: Whether the policy is enforced. Default is `true`.
        :param Sequence[int] ports: One or more ports that the policy is enforced for.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validation=validation,
            certificate=certificate,
            enforce=enforce,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validation: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation'] = None,
             certificate: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate'] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation is None:
            raise TypeError("Missing 'validation' argument")

        _setter("validation", validation)
        if certificate is not None:
            _setter("certificate", certificate)
        if enforce is not None:
            _setter("enforce", enforce)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation':
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate']:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def enforce(self) -> Optional[bool]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile'] = None,
                 sds: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds'] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs' file: Local file certificate.
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs' sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile'] = None,
             sds: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile']:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds']:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param str private_key: Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust: 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust',
                 subject_alternative_names: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames'] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs' trust: TLS validation context trust.
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs' subject_alternative_names: SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust=trust,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust'] = None,
             subject_alternative_names: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trust is None:
            raise TypeError("Missing 'trust' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("trust", trust)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust':
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames']:
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(dict):
    def __init__(__self__, *,
                 match: 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch'):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs' match: Criteria for determining a SAN's match.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("match", match)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch':
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        """
        :param Sequence[str] exacts: Values sent must match the specified values exactly.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(dict):
    def __init__(__self__, *,
                 acm: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm'] = None,
                 file: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile'] = None,
                 sds: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds'] = None):
        """
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs' acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs' file: TLS validation context trust for a local file certificate.
        :param 'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs' sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acm=acm,
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acm: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm'] = None,
             file: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile'] = None,
             sds: Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if acm is not None:
            _setter("acm", acm)
        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm']:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile']:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds']:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorityArns":
            suggest = "certificate_authority_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        """
        :param Sequence[str] certificate_authority_arns: One or more ACM ARNs.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualGatewaySpecListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portMapping":
            suggest = "port_mapping"
        elif key == "connectionPool":
            suggest = "connection_pool"
        elif key == "healthCheck":
            suggest = "health_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_mapping: 'outputs.VirtualGatewaySpecListenerPortMapping',
                 connection_pool: Optional['outputs.VirtualGatewaySpecListenerConnectionPool'] = None,
                 health_check: Optional['outputs.VirtualGatewaySpecListenerHealthCheck'] = None,
                 tls: Optional['outputs.VirtualGatewaySpecListenerTls'] = None):
        """
        :param 'VirtualGatewaySpecListenerPortMappingArgs' port_mapping: Port mapping information for the listener.
        :param 'VirtualGatewaySpecListenerConnectionPoolArgs' connection_pool: Connection pool information for the listener.
        :param 'VirtualGatewaySpecListenerHealthCheckArgs' health_check: Health check information for the listener.
        :param 'VirtualGatewaySpecListenerTlsArgs' tls: Transport Layer Security (TLS) properties for the listener
        """
        VirtualGatewaySpecListener._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_mapping=port_mapping,
            connection_pool=connection_pool,
            health_check=health_check,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_mapping: Optional['outputs.VirtualGatewaySpecListenerPortMapping'] = None,
             connection_pool: Optional['outputs.VirtualGatewaySpecListenerConnectionPool'] = None,
             health_check: Optional['outputs.VirtualGatewaySpecListenerHealthCheck'] = None,
             tls: Optional['outputs.VirtualGatewaySpecListenerTls'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_mapping is None and 'portMapping' in kwargs:
            port_mapping = kwargs['portMapping']
        if port_mapping is None:
            raise TypeError("Missing 'port_mapping' argument")
        if connection_pool is None and 'connectionPool' in kwargs:
            connection_pool = kwargs['connectionPool']
        if health_check is None and 'healthCheck' in kwargs:
            health_check = kwargs['healthCheck']

        _setter("port_mapping", port_mapping)
        if connection_pool is not None:
            _setter("connection_pool", connection_pool)
        if health_check is not None:
            _setter("health_check", health_check)
        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> 'outputs.VirtualGatewaySpecListenerPortMapping':
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.VirtualGatewaySpecListenerConnectionPool']:
        """
        Connection pool information for the listener.
        """
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.VirtualGatewaySpecListenerHealthCheck']:
        """
        Health check information for the listener.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.VirtualGatewaySpecListenerTls']:
        """
        Transport Layer Security (TLS) properties for the listener
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualGatewaySpecListenerConnectionPool(dict):
    def __init__(__self__, *,
                 grpc: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolGrpc'] = None,
                 http: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp'] = None,
                 http2: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp2'] = None):
        """
        :param 'VirtualGatewaySpecListenerConnectionPoolGrpcArgs' grpc: Connection pool information for gRPC listeners.
        :param 'VirtualGatewaySpecListenerConnectionPoolHttpArgs' http: Connection pool information for HTTP listeners.
        :param 'VirtualGatewaySpecListenerConnectionPoolHttp2Args' http2: Connection pool information for HTTP2 listeners.
        """
        VirtualGatewaySpecListenerConnectionPool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc=grpc,
            http=http,
            http2=http2,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolGrpc'] = None,
             http: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp'] = None,
             http2: Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp2'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if grpc is not None:
            _setter("grpc", grpc)
        if http is not None:
            _setter("http", http)
        if http2 is not None:
            _setter("http2", http2)

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.VirtualGatewaySpecListenerConnectionPoolGrpc']:
        """
        Connection pool information for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp']:
        """
        Connection pool information for HTTP listeners.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def http2(self) -> Optional['outputs.VirtualGatewaySpecListenerConnectionPoolHttp2']:
        """
        Connection pool information for HTTP2 listeners.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class VirtualGatewaySpecListenerConnectionPoolGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequests":
            suggest = "max_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerConnectionPoolGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerConnectionPoolGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerConnectionPoolGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_requests: int):
        """
        :param int max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        VirtualGatewaySpecListenerConnectionPoolGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class VirtualGatewaySpecListenerConnectionPoolHttp2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequests":
            suggest = "max_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerConnectionPoolHttp2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerConnectionPoolHttp2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerConnectionPoolHttp2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_requests: int):
        """
        :param int max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        VirtualGatewaySpecListenerConnectionPoolHttp2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class VirtualGatewaySpecListenerConnectionPoolHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections: int,
                 max_pending_requests: Optional[int] = None):
        """
        :param int max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        :param int max_pending_requests: Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
               
               The `http2` connection pool object supports the following:
        """
        VirtualGatewaySpecListenerConnectionPoolHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
            max_pending_requests=max_pending_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             max_pending_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")
        if max_pending_requests is None and 'maxPendingRequests' in kwargs:
            max_pending_requests = kwargs['maxPendingRequests']

        _setter("max_connections", max_connections)
        if max_pending_requests is not None:
            _setter("max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[int]:
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.

        The `http2` connection pool object supports the following:
        """
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class VirtualGatewaySpecListenerHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "intervalMillis":
            suggest = "interval_millis"
        elif key == "timeoutMillis":
            suggest = "timeout_millis"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy_threshold: int,
                 interval_millis: int,
                 protocol: str,
                 timeout_millis: int,
                 unhealthy_threshold: int,
                 path: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param int healthy_threshold: Number of consecutive successful health checks that must occur before declaring listener healthy.
        :param int interval_millis: Time period in milliseconds between each health check execution.
        :param str protocol: Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
        :param int timeout_millis: Amount of time to wait when receiving a response from the health check, in milliseconds.
        :param int unhealthy_threshold: Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        :param str path: Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        :param int port: Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        VirtualGatewaySpecListenerHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy_threshold=healthy_threshold,
            interval_millis=interval_millis,
            protocol=protocol,
            timeout_millis=timeout_millis,
            unhealthy_threshold=unhealthy_threshold,
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy_threshold: Optional[int] = None,
             interval_millis: Optional[int] = None,
             protocol: Optional[str] = None,
             timeout_millis: Optional[int] = None,
             unhealthy_threshold: Optional[int] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if healthy_threshold is None:
            raise TypeError("Missing 'healthy_threshold' argument")
        if interval_millis is None and 'intervalMillis' in kwargs:
            interval_millis = kwargs['intervalMillis']
        if interval_millis is None:
            raise TypeError("Missing 'interval_millis' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if timeout_millis is None and 'timeoutMillis' in kwargs:
            timeout_millis = kwargs['timeoutMillis']
        if timeout_millis is None:
            raise TypeError("Missing 'timeout_millis' argument")
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']
        if unhealthy_threshold is None:
            raise TypeError("Missing 'unhealthy_threshold' argument")

        _setter("healthy_threshold", healthy_threshold)
        _setter("interval_millis", interval_millis)
        _setter("protocol", protocol)
        _setter("timeout_millis", timeout_millis)
        _setter("unhealthy_threshold", unhealthy_threshold)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> int:
        """
        Time period in milliseconds between each health check execution.
        """
        return pulumi.get(self, "interval_millis")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> int:
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        return pulumi.get(self, "timeout_millis")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class VirtualGatewaySpecListenerPortMapping(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        """
        :param int port: Port used for the port mapping.
        :param str protocol: Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        VirtualGatewaySpecListenerPortMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VirtualGatewaySpecListenerTls(dict):
    def __init__(__self__, *,
                 certificate: 'outputs.VirtualGatewaySpecListenerTlsCertificate',
                 mode: str,
                 validation: Optional['outputs.VirtualGatewaySpecListenerTlsValidation'] = None):
        """
        :param 'VirtualGatewaySpecListenerTlsCertificateArgs' certificate: Listener's TLS certificate.
        :param str mode: Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        :param 'VirtualGatewaySpecListenerTlsValidationArgs' validation: Listener's Transport Layer Security (TLS) validation context.
        """
        VirtualGatewaySpecListenerTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            mode=mode,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional['outputs.VirtualGatewaySpecListenerTlsCertificate'] = None,
             mode: Optional[str] = None,
             validation: Optional['outputs.VirtualGatewaySpecListenerTlsValidation'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate is None:
            raise TypeError("Missing 'certificate' argument")
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("certificate", certificate)
        _setter("mode", mode)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.VirtualGatewaySpecListenerTlsCertificate':
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsValidation']:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsCertificate(dict):
    def __init__(__self__, *,
                 acm: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateAcm'] = None,
                 file: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateFile'] = None,
                 sds: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateSds'] = None):
        """
        :param 'VirtualGatewaySpecListenerTlsCertificateAcmArgs' acm: An AWS Certificate Manager (ACM) certificate.
        :param 'VirtualGatewaySpecListenerTlsCertificateFileArgs' file: Local file certificate.
        :param 'VirtualGatewaySpecListenerTlsCertificateSdsArgs' sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualGatewaySpecListenerTlsCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acm=acm,
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acm: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateAcm'] = None,
             file: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateFile'] = None,
             sds: Optional['outputs.VirtualGatewaySpecListenerTlsCertificateSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if acm is not None:
            _setter("acm", acm)
        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsCertificateAcm']:
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsCertificateFile']:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsCertificateSds']:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsCertificateAcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateArn":
            suggest = "certificate_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsCertificateAcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsCertificateAcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsCertificateAcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_arn: str):
        """
        :param str certificate_arn: ARN for the certificate.
        """
        VirtualGatewaySpecListenerTlsCertificateAcm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_arn=certificate_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if certificate_arn is None:
            raise TypeError("Missing 'certificate_arn' argument")

        _setter("certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        """
        ARN for the certificate.
        """
        return pulumi.get(self, "certificate_arn")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsCertificateFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsCertificateFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsCertificateFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsCertificateFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param str private_key: Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualGatewaySpecListenerTlsCertificateFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsCertificateSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsCertificateSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsCertificateSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsCertificateSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualGatewaySpecListenerTlsCertificateSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust: 'outputs.VirtualGatewaySpecListenerTlsValidationTrust',
                 subject_alternative_names: Optional['outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames'] = None):
        """
        :param 'VirtualGatewaySpecListenerTlsValidationTrustArgs' trust: TLS validation context trust.
        :param 'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs' subject_alternative_names: SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        VirtualGatewaySpecListenerTlsValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust=trust,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust: Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrust'] = None,
             subject_alternative_names: Optional['outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trust is None:
            raise TypeError("Missing 'trust' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("trust", trust)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> 'outputs.VirtualGatewaySpecListenerTlsValidationTrust':
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames']:
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames(dict):
    def __init__(__self__, *,
                 match: 'outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch'):
        """
        :param 'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs' match: Criteria for determining a SAN's match.
        """
        VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional['outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("match", match)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch':
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        """
        :param Sequence[str] exacts: Values sent must match the specified values exactly.
        """
        VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidationTrust(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustFile'] = None,
                 sds: Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustSds'] = None):
        """
        :param 'VirtualGatewaySpecListenerTlsValidationTrustFileArgs' file: TLS validation context trust for a local file certificate.
        :param 'VirtualGatewaySpecListenerTlsValidationTrustSdsArgs' sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualGatewaySpecListenerTlsValidationTrust._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustFile'] = None,
             sds: Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustFile']:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualGatewaySpecListenerTlsValidationTrustSds']:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidationTrustFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsValidationTrustFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsValidationTrustFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsValidationTrustFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualGatewaySpecListenerTlsValidationTrustFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class VirtualGatewaySpecListenerTlsValidationTrustSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecListenerTlsValidationTrustSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecListenerTlsValidationTrustSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecListenerTlsValidationTrustSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualGatewaySpecListenerTlsValidationTrustSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualGatewaySpecLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLog":
            suggest = "access_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualGatewaySpecLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualGatewaySpecLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualGatewaySpecLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_log: Optional['outputs.VirtualGatewaySpecLoggingAccessLog'] = None):
        """
        :param 'VirtualGatewaySpecLoggingAccessLogArgs' access_log: Access log configuration for a virtual gateway.
        """
        VirtualGatewaySpecLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_log=access_log,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_log: Optional['outputs.VirtualGatewaySpecLoggingAccessLog'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_log is None and 'accessLog' in kwargs:
            access_log = kwargs['accessLog']

        if access_log is not None:
            _setter("access_log", access_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional['outputs.VirtualGatewaySpecLoggingAccessLog']:
        """
        Access log configuration for a virtual gateway.
        """
        return pulumi.get(self, "access_log")


@pulumi.output_type
class VirtualGatewaySpecLoggingAccessLog(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualGatewaySpecLoggingAccessLogFile'] = None):
        """
        :param 'VirtualGatewaySpecLoggingAccessLogFileArgs' file: File object to send virtual gateway access logs to.
        """
        VirtualGatewaySpecLoggingAccessLog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualGatewaySpecLoggingAccessLogFile'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualGatewaySpecLoggingAccessLogFile']:
        """
        File object to send virtual gateway access logs to.
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class VirtualGatewaySpecLoggingAccessLogFile(dict):
    def __init__(__self__, *,
                 path: str,
                 format: Optional['outputs.VirtualGatewaySpecLoggingAccessLogFileFormat'] = None):
        """
        :param str path: File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        :param 'VirtualGatewaySpecLoggingAccessLogFileFormatArgs' format: The specified format for the logs.
        """
        VirtualGatewaySpecLoggingAccessLogFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             format: Optional['outputs.VirtualGatewaySpecLoggingAccessLogFileFormat'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.VirtualGatewaySpecLoggingAccessLogFileFormat']:
        """
        The specified format for the logs.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class VirtualGatewaySpecLoggingAccessLogFileFormat(dict):
    def __init__(__self__, *,
                 jsons: Optional[Sequence['outputs.VirtualGatewaySpecLoggingAccessLogFileFormatJson']] = None,
                 text: Optional[str] = None):
        """
        :param Sequence['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs'] jsons: The logging format for JSON.
        :param str text: The logging format for text. Must be between 1 and 1000 characters in length.
        """
        VirtualGatewaySpecLoggingAccessLogFileFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsons=jsons,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsons: Optional[Sequence['outputs.VirtualGatewaySpecLoggingAccessLogFileFormatJson']] = None,
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if jsons is not None:
            _setter("jsons", jsons)
        if text is not None:
            _setter("text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence['outputs.VirtualGatewaySpecLoggingAccessLogFileFormatJson']]:
        """
        The logging format for JSON.
        """
        return pulumi.get(self, "jsons")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class VirtualGatewaySpecLoggingAccessLogFileFormatJson(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The specified key for the JSON. Must be between 1 and 100 characters in length.
        :param str value: The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        VirtualGatewaySpecLoggingAccessLogFileFormatJson._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDefaults":
            suggest = "backend_defaults"
        elif key == "serviceDiscovery":
            suggest = "service_discovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_defaults: Optional['outputs.VirtualNodeSpecBackendDefaults'] = None,
                 backends: Optional[Sequence['outputs.VirtualNodeSpecBackend']] = None,
                 listeners: Optional[Sequence['outputs.VirtualNodeSpecListener']] = None,
                 logging: Optional['outputs.VirtualNodeSpecLogging'] = None,
                 service_discovery: Optional['outputs.VirtualNodeSpecServiceDiscovery'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsArgs' backend_defaults: Defaults for backends.
        :param Sequence['VirtualNodeSpecBackendArgs'] backends: Backends to which the virtual node is expected to send outbound traffic.
        :param Sequence['VirtualNodeSpecListenerArgs'] listeners: Listeners from which the virtual node is expected to receive inbound traffic.
        :param 'VirtualNodeSpecLoggingArgs' logging: Inbound and outbound access logging information for the virtual node.
        :param 'VirtualNodeSpecServiceDiscoveryArgs' service_discovery: Service discovery information for the virtual node.
        """
        VirtualNodeSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_defaults=backend_defaults,
            backends=backends,
            listeners=listeners,
            logging=logging,
            service_discovery=service_discovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_defaults: Optional['outputs.VirtualNodeSpecBackendDefaults'] = None,
             backends: Optional[Sequence['outputs.VirtualNodeSpecBackend']] = None,
             listeners: Optional[Sequence['outputs.VirtualNodeSpecListener']] = None,
             logging: Optional['outputs.VirtualNodeSpecLogging'] = None,
             service_discovery: Optional['outputs.VirtualNodeSpecServiceDiscovery'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_defaults is None and 'backendDefaults' in kwargs:
            backend_defaults = kwargs['backendDefaults']
        if service_discovery is None and 'serviceDiscovery' in kwargs:
            service_discovery = kwargs['serviceDiscovery']

        if backend_defaults is not None:
            _setter("backend_defaults", backend_defaults)
        if backends is not None:
            _setter("backends", backends)
        if listeners is not None:
            _setter("listeners", listeners)
        if logging is not None:
            _setter("logging", logging)
        if service_discovery is not None:
            _setter("service_discovery", service_discovery)

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Optional['outputs.VirtualNodeSpecBackendDefaults']:
        """
        Defaults for backends.
        """
        return pulumi.get(self, "backend_defaults")

    @property
    @pulumi.getter
    def backends(self) -> Optional[Sequence['outputs.VirtualNodeSpecBackend']]:
        """
        Backends to which the virtual node is expected to send outbound traffic.
        """
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.VirtualNodeSpecListener']]:
        """
        Listeners from which the virtual node is expected to receive inbound traffic.
        """
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.VirtualNodeSpecLogging']:
        """
        Inbound and outbound access logging information for the virtual node.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional['outputs.VirtualNodeSpecServiceDiscovery']:
        """
        Service discovery information for the virtual node.
        """
        return pulumi.get(self, "service_discovery")


@pulumi.output_type
class VirtualNodeSpecBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualService":
            suggest = "virtual_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service: 'outputs.VirtualNodeSpecBackendVirtualService'):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceArgs' virtual_service: Virtual service to use as a backend for a virtual node.
        """
        VirtualNodeSpecBackend._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service=virtual_service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service: Optional['outputs.VirtualNodeSpecBackendVirtualService'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service is None and 'virtualService' in kwargs:
            virtual_service = kwargs['virtualService']
        if virtual_service is None:
            raise TypeError("Missing 'virtual_service' argument")

        _setter("virtual_service", virtual_service)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> 'outputs.VirtualNodeSpecBackendVirtualService':
        """
        Virtual service to use as a backend for a virtual node.
        """
        return pulumi.get(self, "virtual_service")


@pulumi.output_type
class VirtualNodeSpecBackendDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientPolicy":
            suggest = "client_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_policy: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicy'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyArgs' client_policy: Default client policy for virtual service backends. See above for details.
        """
        VirtualNodeSpecBackendDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_policy=client_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_policy: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicy'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_policy is None and 'clientPolicy' in kwargs:
            client_policy = kwargs['clientPolicy']

        if client_policy is not None:
            _setter("client_policy", client_policy)

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicy']:
        """
        Default client policy for virtual service backends. See above for details.
        """
        return pulumi.get(self, "client_policy")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicy(dict):
    def __init__(__self__, *,
                 tls: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTls'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs' tls: Transport Layer Security (TLS) client policy.
        """
        VirtualNodeSpecBackendDefaultsClientPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTls'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTls']:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTls(dict):
    def __init__(__self__, *,
                 validation: 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation',
                 certificate: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate'] = None,
                 enforce: Optional[bool] = None,
                 ports: Optional[Sequence[int]] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs' validation: Listener's Transport Layer Security (TLS) validation context.
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs' certificate: Listener's TLS certificate.
        :param bool enforce: Whether the policy is enforced. Default is `true`.
        :param Sequence[int] ports: One or more ports that the policy is enforced for.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validation=validation,
            certificate=certificate,
            enforce=enforce,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validation: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation'] = None,
             certificate: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate'] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation is None:
            raise TypeError("Missing 'validation' argument")

        _setter("validation", validation)
        if certificate is not None:
            _setter("certificate", certificate)
        if enforce is not None:
            _setter("enforce", enforce)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation':
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate']:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def enforce(self) -> Optional[bool]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs' file: Local file certificate.
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs' sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile']:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds']:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param str private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust: 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust',
                 subject_alternative_names: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs' trust: TLS validation context trust.
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs' subject_alternative_names: SANs for a TLS validation context.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust=trust,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust'] = None,
             subject_alternative_names: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trust is None:
            raise TypeError("Missing 'trust' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("trust", trust)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust':
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames']:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(dict):
    def __init__(__self__, *,
                 match: 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch'):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs' match: Criteria for determining a SAN's match.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("match", match)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch':
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        """
        :param Sequence[str] exacts: Values sent must match the specified values exactly.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(dict):
    def __init__(__self__, *,
                 acm: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm'] = None,
                 file: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds'] = None):
        """
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs' acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs' file: TLS validation context trust for a local file certificate.
        :param 'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs' sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acm=acm,
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acm: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm'] = None,
             file: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if acm is not None:
            _setter("acm", acm)
        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm']:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile']:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds']:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorityArns":
            suggest = "certificate_authority_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        """
        :param Sequence[str] certificate_authority_arns: One or more ACM ARNs.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualServiceName":
            suggest = "virtual_service_name"
        elif key == "clientPolicy":
            suggest = "client_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_service_name: str,
                 client_policy: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicy'] = None):
        """
        :param str virtual_service_name: Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyArgs' client_policy: Client policy for the backend.
        """
        VirtualNodeSpecBackendVirtualService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
            client_policy=client_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             client_policy: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicy'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")
        if client_policy is None and 'clientPolicy' in kwargs:
            client_policy = kwargs['clientPolicy']

        _setter("virtual_service_name", virtual_service_name)
        if client_policy is not None:
            _setter("client_policy", client_policy)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        """
        Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicy']:
        """
        Client policy for the backend.
        """
        return pulumi.get(self, "client_policy")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicy(dict):
    def __init__(__self__, *,
                 tls: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTls'] = None):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs' tls: Transport Layer Security (TLS) client policy.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTls'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTls']:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTls(dict):
    def __init__(__self__, *,
                 validation: 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation',
                 certificate: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate'] = None,
                 enforce: Optional[bool] = None,
                 ports: Optional[Sequence[int]] = None):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs' validation: Listener's Transport Layer Security (TLS) validation context.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs' certificate: Listener's TLS certificate.
        :param bool enforce: Whether the policy is enforced. Default is `true`.
        :param Sequence[int] ports: One or more ports that the policy is enforced for.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validation=validation,
            certificate=certificate,
            enforce=enforce,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validation: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation'] = None,
             certificate: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate'] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation is None:
            raise TypeError("Missing 'validation' argument")

        _setter("validation", validation)
        if certificate is not None:
            _setter("certificate", certificate)
        if enforce is not None:
            _setter("enforce", enforce)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation':
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate']:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def enforce(self) -> Optional[bool]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds'] = None):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs' file: Local file certificate.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs' sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile']:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds']:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param str private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust: 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust',
                 subject_alternative_names: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames'] = None):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs' trust: TLS validation context trust.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs' subject_alternative_names: SANs for a TLS validation context.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust=trust,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust'] = None,
             subject_alternative_names: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trust is None:
            raise TypeError("Missing 'trust' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("trust", trust)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust':
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames']:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames(dict):
    def __init__(__self__, *,
                 match: 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch'):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs' match: Criteria for determining a SAN's match.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("match", match)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch':
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        """
        :param Sequence[str] exacts: Values sent must match the specified values exactly.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust(dict):
    def __init__(__self__, *,
                 acm: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm'] = None,
                 file: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds'] = None):
        """
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs' acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs' file: TLS validation context trust for a local file certificate.
        :param 'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs' sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acm=acm,
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acm: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm'] = None,
             file: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if acm is not None:
            _setter("acm", acm)
        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm']:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile']:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds']:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorityArns":
            suggest = "certificate_authority_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        """
        :param Sequence[str] certificate_authority_arns: One or more ACM ARNs.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portMapping":
            suggest = "port_mapping"
        elif key == "connectionPool":
            suggest = "connection_pool"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "outlierDetection":
            suggest = "outlier_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_mapping: 'outputs.VirtualNodeSpecListenerPortMapping',
                 connection_pool: Optional['outputs.VirtualNodeSpecListenerConnectionPool'] = None,
                 health_check: Optional['outputs.VirtualNodeSpecListenerHealthCheck'] = None,
                 outlier_detection: Optional['outputs.VirtualNodeSpecListenerOutlierDetection'] = None,
                 timeout: Optional['outputs.VirtualNodeSpecListenerTimeout'] = None,
                 tls: Optional['outputs.VirtualNodeSpecListenerTls'] = None):
        """
        :param 'VirtualNodeSpecListenerPortMappingArgs' port_mapping: Port mapping information for the listener.
        :param 'VirtualNodeSpecListenerConnectionPoolArgs' connection_pool: Connection pool information for the listener.
        :param 'VirtualNodeSpecListenerHealthCheckArgs' health_check: Health check information for the listener.
        :param 'VirtualNodeSpecListenerOutlierDetectionArgs' outlier_detection: Outlier detection information for the listener.
        :param 'VirtualNodeSpecListenerTimeoutArgs' timeout: Timeouts for different protocols.
        :param 'VirtualNodeSpecListenerTlsArgs' tls: Transport Layer Security (TLS) properties for the listener
        """
        VirtualNodeSpecListener._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_mapping=port_mapping,
            connection_pool=connection_pool,
            health_check=health_check,
            outlier_detection=outlier_detection,
            timeout=timeout,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_mapping: Optional['outputs.VirtualNodeSpecListenerPortMapping'] = None,
             connection_pool: Optional['outputs.VirtualNodeSpecListenerConnectionPool'] = None,
             health_check: Optional['outputs.VirtualNodeSpecListenerHealthCheck'] = None,
             outlier_detection: Optional['outputs.VirtualNodeSpecListenerOutlierDetection'] = None,
             timeout: Optional['outputs.VirtualNodeSpecListenerTimeout'] = None,
             tls: Optional['outputs.VirtualNodeSpecListenerTls'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_mapping is None and 'portMapping' in kwargs:
            port_mapping = kwargs['portMapping']
        if port_mapping is None:
            raise TypeError("Missing 'port_mapping' argument")
        if connection_pool is None and 'connectionPool' in kwargs:
            connection_pool = kwargs['connectionPool']
        if health_check is None and 'healthCheck' in kwargs:
            health_check = kwargs['healthCheck']
        if outlier_detection is None and 'outlierDetection' in kwargs:
            outlier_detection = kwargs['outlierDetection']

        _setter("port_mapping", port_mapping)
        if connection_pool is not None:
            _setter("connection_pool", connection_pool)
        if health_check is not None:
            _setter("health_check", health_check)
        if outlier_detection is not None:
            _setter("outlier_detection", outlier_detection)
        if timeout is not None:
            _setter("timeout", timeout)
        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> 'outputs.VirtualNodeSpecListenerPortMapping':
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.VirtualNodeSpecListenerConnectionPool']:
        """
        Connection pool information for the listener.
        """
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.VirtualNodeSpecListenerHealthCheck']:
        """
        Health check information for the listener.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional['outputs.VirtualNodeSpecListenerOutlierDetection']:
        """
        Outlier detection information for the listener.
        """
        return pulumi.get(self, "outlier_detection")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.VirtualNodeSpecListenerTimeout']:
        """
        Timeouts for different protocols.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.VirtualNodeSpecListenerTls']:
        """
        Transport Layer Security (TLS) properties for the listener
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualNodeSpecListenerConnectionPool(dict):
    def __init__(__self__, *,
                 grpc: Optional['outputs.VirtualNodeSpecListenerConnectionPoolGrpc'] = None,
                 http2s: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp2']] = None,
                 https: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp']] = None,
                 tcps: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolTcp']] = None):
        """
        :param 'VirtualNodeSpecListenerConnectionPoolGrpcArgs' grpc: Connection pool information for gRPC listeners.
        :param Sequence['VirtualNodeSpecListenerConnectionPoolHttp2Args'] http2s: Connection pool information for HTTP2 listeners.
        :param Sequence['VirtualNodeSpecListenerConnectionPoolHttpArgs'] https: Connection pool information for HTTP listeners.
        :param Sequence['VirtualNodeSpecListenerConnectionPoolTcpArgs'] tcps: Connection pool information for TCP listeners.
        """
        VirtualNodeSpecListenerConnectionPool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc=grpc,
            http2s=http2s,
            https=https,
            tcps=tcps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc: Optional['outputs.VirtualNodeSpecListenerConnectionPoolGrpc'] = None,
             http2s: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp2']] = None,
             https: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp']] = None,
             tcps: Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolTcp']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if grpc is not None:
            _setter("grpc", grpc)
        if http2s is not None:
            _setter("http2s", http2s)
        if https is not None:
            _setter("https", https)
        if tcps is not None:
            _setter("tcps", tcps)

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.VirtualNodeSpecListenerConnectionPoolGrpc']:
        """
        Connection pool information for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter
    def http2s(self) -> Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp2']]:
        """
        Connection pool information for HTTP2 listeners.
        """
        return pulumi.get(self, "http2s")

    @property
    @pulumi.getter
    def https(self) -> Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolHttp']]:
        """
        Connection pool information for HTTP listeners.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def tcps(self) -> Optional[Sequence['outputs.VirtualNodeSpecListenerConnectionPoolTcp']]:
        """
        Connection pool information for TCP listeners.
        """
        return pulumi.get(self, "tcps")


@pulumi.output_type
class VirtualNodeSpecListenerConnectionPoolGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequests":
            suggest = "max_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerConnectionPoolGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerConnectionPoolGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerConnectionPoolGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_requests: int):
        """
        :param int max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        VirtualNodeSpecListenerConnectionPoolGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class VirtualNodeSpecListenerConnectionPoolHttp2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequests":
            suggest = "max_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerConnectionPoolHttp2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerConnectionPoolHttp2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerConnectionPoolHttp2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_requests: int):
        """
        :param int max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        VirtualNodeSpecListenerConnectionPoolHttp2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class VirtualNodeSpecListenerConnectionPoolHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections: int,
                 max_pending_requests: Optional[int] = None):
        """
        :param int max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        :param int max_pending_requests: Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
               
               The `http2` connection pool object supports the following:
        """
        VirtualNodeSpecListenerConnectionPoolHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
            max_pending_requests=max_pending_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             max_pending_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")
        if max_pending_requests is None and 'maxPendingRequests' in kwargs:
            max_pending_requests = kwargs['maxPendingRequests']

        _setter("max_connections", max_connections)
        if max_pending_requests is not None:
            _setter("max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[int]:
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.

        The `http2` connection pool object supports the following:
        """
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class VirtualNodeSpecListenerConnectionPoolTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnections":
            suggest = "max_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerConnectionPoolTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerConnectionPoolTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerConnectionPoolTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections: int):
        """
        :param int max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        VirtualNodeSpecListenerConnectionPoolTcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")

        _setter("max_connections", max_connections)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")


@pulumi.output_type
class VirtualNodeSpecListenerHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "intervalMillis":
            suggest = "interval_millis"
        elif key == "timeoutMillis":
            suggest = "timeout_millis"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy_threshold: int,
                 interval_millis: int,
                 protocol: str,
                 timeout_millis: int,
                 unhealthy_threshold: int,
                 path: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param int healthy_threshold: Number of consecutive successful health checks that must occur before declaring listener healthy.
        :param int interval_millis: Time period in milliseconds between each health check execution.
        :param str protocol: Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
        :param int timeout_millis: Amount of time to wait when receiving a response from the health check, in milliseconds.
        :param int unhealthy_threshold: Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        :param str path: Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        :param int port: Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        VirtualNodeSpecListenerHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy_threshold=healthy_threshold,
            interval_millis=interval_millis,
            protocol=protocol,
            timeout_millis=timeout_millis,
            unhealthy_threshold=unhealthy_threshold,
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy_threshold: Optional[int] = None,
             interval_millis: Optional[int] = None,
             protocol: Optional[str] = None,
             timeout_millis: Optional[int] = None,
             unhealthy_threshold: Optional[int] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if healthy_threshold is None:
            raise TypeError("Missing 'healthy_threshold' argument")
        if interval_millis is None and 'intervalMillis' in kwargs:
            interval_millis = kwargs['intervalMillis']
        if interval_millis is None:
            raise TypeError("Missing 'interval_millis' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if timeout_millis is None and 'timeoutMillis' in kwargs:
            timeout_millis = kwargs['timeoutMillis']
        if timeout_millis is None:
            raise TypeError("Missing 'timeout_millis' argument")
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']
        if unhealthy_threshold is None:
            raise TypeError("Missing 'unhealthy_threshold' argument")

        _setter("healthy_threshold", healthy_threshold)
        _setter("interval_millis", interval_millis)
        _setter("protocol", protocol)
        _setter("timeout_millis", timeout_millis)
        _setter("unhealthy_threshold", unhealthy_threshold)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> int:
        """
        Time period in milliseconds between each health check execution.
        """
        return pulumi.get(self, "interval_millis")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> int:
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        return pulumi.get(self, "timeout_millis")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class VirtualNodeSpecListenerOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionDuration":
            suggest = "base_ejection_duration"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "maxServerErrors":
            suggest = "max_server_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_duration: 'outputs.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration',
                 interval: 'outputs.VirtualNodeSpecListenerOutlierDetectionInterval',
                 max_ejection_percent: int,
                 max_server_errors: int):
        """
        :param 'VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs' base_ejection_duration: Base amount of time for which a host is ejected.
        :param 'VirtualNodeSpecListenerOutlierDetectionIntervalArgs' interval: Time interval between ejection sweep analysis.
        :param int max_ejection_percent: Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
               Minimum value of `0`. Maximum value of `100`.
        :param int max_server_errors: Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
        """
        VirtualNodeSpecListenerOutlierDetection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_ejection_duration=base_ejection_duration,
            interval=interval,
            max_ejection_percent=max_ejection_percent,
            max_server_errors=max_server_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_ejection_duration: Optional['outputs.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration'] = None,
             interval: Optional['outputs.VirtualNodeSpecListenerOutlierDetectionInterval'] = None,
             max_ejection_percent: Optional[int] = None,
             max_server_errors: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if base_ejection_duration is None and 'baseEjectionDuration' in kwargs:
            base_ejection_duration = kwargs['baseEjectionDuration']
        if base_ejection_duration is None:
            raise TypeError("Missing 'base_ejection_duration' argument")
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if max_ejection_percent is None and 'maxEjectionPercent' in kwargs:
            max_ejection_percent = kwargs['maxEjectionPercent']
        if max_ejection_percent is None:
            raise TypeError("Missing 'max_ejection_percent' argument")
        if max_server_errors is None and 'maxServerErrors' in kwargs:
            max_server_errors = kwargs['maxServerErrors']
        if max_server_errors is None:
            raise TypeError("Missing 'max_server_errors' argument")

        _setter("base_ejection_duration", base_ejection_duration)
        _setter("interval", interval)
        _setter("max_ejection_percent", max_ejection_percent)
        _setter("max_server_errors", max_server_errors)

    @property
    @pulumi.getter(name="baseEjectionDuration")
    def base_ejection_duration(self) -> 'outputs.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration':
        """
        Base amount of time for which a host is ejected.
        """
        return pulumi.get(self, "base_ejection_duration")

    @property
    @pulumi.getter
    def interval(self) -> 'outputs.VirtualNodeSpecListenerOutlierDetectionInterval':
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> int:
        """
        Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        Minimum value of `0`. Maximum value of `100`.
        """
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="maxServerErrors")
    def max_server_errors(self) -> int:
        """
        Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
        """
        return pulumi.get(self, "max_server_errors")


@pulumi.output_type
class VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerOutlierDetectionInterval(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerOutlierDetectionInterval._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerPortMapping(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        """
        :param int port: Port used for the port mapping.
        :param str protocol: Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        VirtualNodeSpecListenerPortMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VirtualNodeSpecListenerTimeout(dict):
    def __init__(__self__, *,
                 grpc: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpc'] = None,
                 http: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp'] = None,
                 http2: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2'] = None,
                 tcp: Optional['outputs.VirtualNodeSpecListenerTimeoutTcp'] = None):
        """
        :param 'VirtualNodeSpecListenerTimeoutGrpcArgs' grpc: Timeouts for gRPC listeners.
        :param 'VirtualNodeSpecListenerTimeoutHttpArgs' http: Timeouts for HTTP listeners.
        :param 'VirtualNodeSpecListenerTimeoutHttp2Args' http2: Timeouts for HTTP2 listeners.
        :param 'VirtualNodeSpecListenerTimeoutTcpArgs' tcp: Timeouts for TCP listeners.
        """
        VirtualNodeSpecListenerTimeout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc=grpc,
            http=http,
            http2=http2,
            tcp=tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpc'] = None,
             http: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp'] = None,
             http2: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2'] = None,
             tcp: Optional['outputs.VirtualNodeSpecListenerTimeoutTcp'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if grpc is not None:
            _setter("grpc", grpc)
        if http is not None:
            _setter("http", http)
        if http2 is not None:
            _setter("http2", http2)
        if tcp is not None:
            _setter("tcp", tcp)

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutGrpc']:
        """
        Timeouts for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttp']:
        """
        Timeouts for HTTP listeners.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def http2(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2']:
        """
        Timeouts for HTTP2 listeners.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutTcp']:
        """
        Timeouts for TCP listeners.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTimeoutGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTimeoutGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTimeoutGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcIdle'] = None,
                 per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcPerRequest'] = None):
        """
        :param 'VirtualNodeSpecListenerTimeoutGrpcIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs' per_request: Per request timeout.
        """
        VirtualNodeSpecListenerTimeoutGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcIdle'] = None,
             per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcPerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutGrpcPerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutGrpcIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutGrpcIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutGrpcPerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutGrpcPerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttp2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTimeoutHttp2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTimeoutHttp2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTimeoutHttp2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2Idle'] = None,
                 per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2PerRequest'] = None):
        """
        :param 'VirtualNodeSpecListenerTimeoutHttp2IdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs' per_request: Per request timeout.
        """
        VirtualNodeSpecListenerTimeoutHttp2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2Idle'] = None,
             per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2PerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2Idle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttp2PerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttp2Idle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutHttp2Idle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttp2PerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutHttp2PerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perRequest":
            suggest = "per_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTimeoutHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTimeoutHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTimeoutHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle: Optional['outputs.VirtualNodeSpecListenerTimeoutHttpIdle'] = None,
                 per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutHttpPerRequest'] = None):
        """
        :param 'VirtualNodeSpecListenerTimeoutHttpIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param 'VirtualNodeSpecListenerTimeoutHttpPerRequestArgs' per_request: Per request timeout.
        """
        VirtualNodeSpecListenerTimeoutHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
            per_request=per_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.VirtualNodeSpecListenerTimeoutHttpIdle'] = None,
             per_request: Optional['outputs.VirtualNodeSpecListenerTimeoutHttpPerRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if per_request is None and 'perRequest' in kwargs:
            per_request = kwargs['perRequest']

        if idle is not None:
            _setter("idle", idle)
        if per_request is not None:
            _setter("per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttpIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutHttpPerRequest']:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttpIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutHttpIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutHttpPerRequest(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutHttpPerRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutTcp(dict):
    def __init__(__self__, *,
                 idle: Optional['outputs.VirtualNodeSpecListenerTimeoutTcpIdle'] = None):
        """
        :param 'VirtualNodeSpecListenerTimeoutTcpIdleArgs' idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        VirtualNodeSpecListenerTimeoutTcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle=idle,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle: Optional['outputs.VirtualNodeSpecListenerTimeoutTcpIdle'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if idle is not None:
            _setter("idle", idle)

    @property
    @pulumi.getter
    def idle(self) -> Optional['outputs.VirtualNodeSpecListenerTimeoutTcpIdle']:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")


@pulumi.output_type
class VirtualNodeSpecListenerTimeoutTcpIdle(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time. Valid values: `ms`, `s`.
        :param int value: Number of time units. Minimum value of `0`.
        """
        VirtualNodeSpecListenerTimeoutTcpIdle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecListenerTls(dict):
    def __init__(__self__, *,
                 certificate: 'outputs.VirtualNodeSpecListenerTlsCertificate',
                 mode: str,
                 validation: Optional['outputs.VirtualNodeSpecListenerTlsValidation'] = None):
        """
        :param 'VirtualNodeSpecListenerTlsCertificateArgs' certificate: Listener's TLS certificate.
        :param str mode: Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        :param 'VirtualNodeSpecListenerTlsValidationArgs' validation: Listener's Transport Layer Security (TLS) validation context.
        """
        VirtualNodeSpecListenerTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            mode=mode,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional['outputs.VirtualNodeSpecListenerTlsCertificate'] = None,
             mode: Optional[str] = None,
             validation: Optional['outputs.VirtualNodeSpecListenerTlsValidation'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate is None:
            raise TypeError("Missing 'certificate' argument")
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("certificate", certificate)
        _setter("mode", mode)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def certificate(self) -> 'outputs.VirtualNodeSpecListenerTlsCertificate':
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.VirtualNodeSpecListenerTlsValidation']:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class VirtualNodeSpecListenerTlsCertificate(dict):
    def __init__(__self__, *,
                 acm: Optional['outputs.VirtualNodeSpecListenerTlsCertificateAcm'] = None,
                 file: Optional['outputs.VirtualNodeSpecListenerTlsCertificateFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecListenerTlsCertificateSds'] = None):
        """
        :param 'VirtualNodeSpecListenerTlsCertificateAcmArgs' acm: An AWS Certificate Manager (ACM) certificate.
        :param 'VirtualNodeSpecListenerTlsCertificateFileArgs' file: Local file certificate.
        :param 'VirtualNodeSpecListenerTlsCertificateSdsArgs' sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecListenerTlsCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acm=acm,
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acm: Optional['outputs.VirtualNodeSpecListenerTlsCertificateAcm'] = None,
             file: Optional['outputs.VirtualNodeSpecListenerTlsCertificateFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecListenerTlsCertificateSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if acm is not None:
            _setter("acm", acm)
        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional['outputs.VirtualNodeSpecListenerTlsCertificateAcm']:
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecListenerTlsCertificateFile']:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecListenerTlsCertificateSds']:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecListenerTlsCertificateAcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateArn":
            suggest = "certificate_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsCertificateAcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsCertificateAcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsCertificateAcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_arn: str):
        """
        :param str certificate_arn: ARN for the certificate.
        """
        VirtualNodeSpecListenerTlsCertificateAcm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_arn=certificate_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if certificate_arn is None:
            raise TypeError("Missing 'certificate_arn' argument")

        _setter("certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        """
        ARN for the certificate.
        """
        return pulumi.get(self, "certificate_arn")


@pulumi.output_type
class VirtualNodeSpecListenerTlsCertificateFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsCertificateFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsCertificateFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsCertificateFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param str private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecListenerTlsCertificateFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VirtualNodeSpecListenerTlsCertificateSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsCertificateSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsCertificateSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsCertificateSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecListenerTlsCertificateSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust: 'outputs.VirtualNodeSpecListenerTlsValidationTrust',
                 subject_alternative_names: Optional['outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames'] = None):
        """
        :param 'VirtualNodeSpecListenerTlsValidationTrustArgs' trust: TLS validation context trust.
        :param 'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs' subject_alternative_names: SANs for a TLS validation context.
        """
        VirtualNodeSpecListenerTlsValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust=trust,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust: Optional['outputs.VirtualNodeSpecListenerTlsValidationTrust'] = None,
             subject_alternative_names: Optional['outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trust is None:
            raise TypeError("Missing 'trust' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("trust", trust)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> 'outputs.VirtualNodeSpecListenerTlsValidationTrust':
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional['outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames']:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames(dict):
    def __init__(__self__, *,
                 match: 'outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch'):
        """
        :param 'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs' match: Criteria for determining a SAN's match.
        """
        VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional['outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match is None:
            raise TypeError("Missing 'match' argument")

        _setter("match", match)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch':
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        """
        :param Sequence[str] exacts: Values sent must match the specified values exactly.
        """
        VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidationTrust(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustFile'] = None,
                 sds: Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustSds'] = None):
        """
        :param 'VirtualNodeSpecListenerTlsValidationTrustFileArgs' file: TLS validation context trust for a local file certificate.
        :param 'VirtualNodeSpecListenerTlsValidationTrustSdsArgs' sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        VirtualNodeSpecListenerTlsValidationTrust._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustFile'] = None,
             sds: Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustSds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if sds is not None:
            _setter("sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustFile']:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def sds(self) -> Optional['outputs.VirtualNodeSpecListenerTlsValidationTrustSds']:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidationTrustFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsValidationTrustFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsValidationTrustFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsValidationTrustFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        VirtualNodeSpecListenerTlsValidationTrustFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class VirtualNodeSpecListenerTlsValidationTrustSds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecListenerTlsValidationTrustSds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecListenerTlsValidationTrustSds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecListenerTlsValidationTrustSds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str):
        """
        :param str secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        VirtualNodeSpecListenerTlsValidationTrustSds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class VirtualNodeSpecLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLog":
            suggest = "access_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_log: Optional['outputs.VirtualNodeSpecLoggingAccessLog'] = None):
        """
        :param 'VirtualNodeSpecLoggingAccessLogArgs' access_log: Access log configuration for a virtual node.
        """
        VirtualNodeSpecLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_log=access_log,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_log: Optional['outputs.VirtualNodeSpecLoggingAccessLog'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_log is None and 'accessLog' in kwargs:
            access_log = kwargs['accessLog']

        if access_log is not None:
            _setter("access_log", access_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional['outputs.VirtualNodeSpecLoggingAccessLog']:
        """
        Access log configuration for a virtual node.
        """
        return pulumi.get(self, "access_log")


@pulumi.output_type
class VirtualNodeSpecLoggingAccessLog(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.VirtualNodeSpecLoggingAccessLogFile'] = None):
        """
        :param 'VirtualNodeSpecLoggingAccessLogFileArgs' file: File object to send virtual node access logs to.
        """
        VirtualNodeSpecLoggingAccessLog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional['outputs.VirtualNodeSpecLoggingAccessLogFile'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if file is not None:
            _setter("file", file)

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.VirtualNodeSpecLoggingAccessLogFile']:
        """
        File object to send virtual node access logs to.
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class VirtualNodeSpecLoggingAccessLogFile(dict):
    def __init__(__self__, *,
                 path: str,
                 format: Optional['outputs.VirtualNodeSpecLoggingAccessLogFileFormat'] = None):
        """
        :param str path: File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        :param 'VirtualNodeSpecLoggingAccessLogFileFormatArgs' format: The specified format for the logs.
        """
        VirtualNodeSpecLoggingAccessLogFile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             format: Optional['outputs.VirtualNodeSpecLoggingAccessLogFileFormat'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.VirtualNodeSpecLoggingAccessLogFileFormat']:
        """
        The specified format for the logs.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class VirtualNodeSpecLoggingAccessLogFileFormat(dict):
    def __init__(__self__, *,
                 jsons: Optional[Sequence['outputs.VirtualNodeSpecLoggingAccessLogFileFormatJson']] = None,
                 text: Optional[str] = None):
        """
        :param Sequence['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs'] jsons: The logging format for JSON.
        :param str text: The logging format for text. Must be between 1 and 1000 characters in length.
        """
        VirtualNodeSpecLoggingAccessLogFileFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsons=jsons,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsons: Optional[Sequence['outputs.VirtualNodeSpecLoggingAccessLogFileFormatJson']] = None,
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if jsons is not None:
            _setter("jsons", jsons)
        if text is not None:
            _setter("text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence['outputs.VirtualNodeSpecLoggingAccessLogFileFormatJson']]:
        """
        The logging format for JSON.
        """
        return pulumi.get(self, "jsons")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class VirtualNodeSpecLoggingAccessLogFileFormatJson(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The specified key for the JSON. Must be between 1 and 100 characters in length.
        :param str value: The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        VirtualNodeSpecLoggingAccessLogFileFormatJson._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualNodeSpecServiceDiscovery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsCloudMap":
            suggest = "aws_cloud_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecServiceDiscovery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecServiceDiscovery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecServiceDiscovery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_cloud_map: Optional['outputs.VirtualNodeSpecServiceDiscoveryAwsCloudMap'] = None,
                 dns: Optional['outputs.VirtualNodeSpecServiceDiscoveryDns'] = None):
        """
        :param 'VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs' aws_cloud_map: Any AWS Cloud Map information for the virtual node.
        :param 'VirtualNodeSpecServiceDiscoveryDnsArgs' dns: DNS service name for the virtual node.
        """
        VirtualNodeSpecServiceDiscovery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_cloud_map=aws_cloud_map,
            dns=dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_cloud_map: Optional['outputs.VirtualNodeSpecServiceDiscoveryAwsCloudMap'] = None,
             dns: Optional['outputs.VirtualNodeSpecServiceDiscoveryDns'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_cloud_map is None and 'awsCloudMap' in kwargs:
            aws_cloud_map = kwargs['awsCloudMap']

        if aws_cloud_map is not None:
            _setter("aws_cloud_map", aws_cloud_map)
        if dns is not None:
            _setter("dns", dns)

    @property
    @pulumi.getter(name="awsCloudMap")
    def aws_cloud_map(self) -> Optional['outputs.VirtualNodeSpecServiceDiscoveryAwsCloudMap']:
        """
        Any AWS Cloud Map information for the virtual node.
        """
        return pulumi.get(self, "aws_cloud_map")

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.VirtualNodeSpecServiceDiscoveryDns']:
        """
        DNS service name for the virtual node.
        """
        return pulumi.get(self, "dns")


@pulumi.output_type
class VirtualNodeSpecServiceDiscoveryAwsCloudMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceName":
            suggest = "namespace_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecServiceDiscoveryAwsCloudMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecServiceDiscoveryAwsCloudMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecServiceDiscoveryAwsCloudMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_name: str,
                 service_name: str,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        :param str namespace_name: Name of the AWS Cloud Map namespace to use.
               Use the `servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
        :param str service_name: Name of the AWS Cloud Map service to use. Use the `servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
        :param Mapping[str, str] attributes: String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        """
        VirtualNodeSpecServiceDiscoveryAwsCloudMap._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace_name=namespace_name,
            service_name=service_name,
            attributes=attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace_name: Optional[str] = None,
             service_name: Optional[str] = None,
             attributes: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace_name is None and 'namespaceName' in kwargs:
            namespace_name = kwargs['namespaceName']
        if namespace_name is None:
            raise TypeError("Missing 'namespace_name' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("namespace_name", namespace_name)
        _setter("service_name", service_name)
        if attributes is not None:
            _setter("attributes", attributes)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        """
        Name of the AWS Cloud Map namespace to use.
        Use the `servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
        """
        return pulumi.get(self, "namespace_name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Name of the AWS Cloud Map service to use. Use the `servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class VirtualNodeSpecServiceDiscoveryDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipPreference":
            suggest = "ip_preference"
        elif key == "responseType":
            suggest = "response_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNodeSpecServiceDiscoveryDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNodeSpecServiceDiscoveryDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNodeSpecServiceDiscoveryDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 ip_preference: Optional[str] = None,
                 response_type: Optional[str] = None):
        """
        :param str hostname: DNS host name for your virtual node.
        :param str ip_preference: The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
        :param str response_type: The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
        """
        VirtualNodeSpecServiceDiscoveryDns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ip_preference=ip_preference,
            response_type=response_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional[str] = None,
             ip_preference: Optional[str] = None,
             response_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hostname is None:
            raise TypeError("Missing 'hostname' argument")
        if ip_preference is None and 'ipPreference' in kwargs:
            ip_preference = kwargs['ipPreference']
        if response_type is None and 'responseType' in kwargs:
            response_type = kwargs['responseType']

        _setter("hostname", hostname)
        if ip_preference is not None:
            _setter("ip_preference", ip_preference)
        if response_type is not None:
            _setter("response_type", response_type)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        DNS host name for your virtual node.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipPreference")
    def ip_preference(self) -> Optional[str]:
        """
        The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
        """
        return pulumi.get(self, "ip_preference")

    @property
    @pulumi.getter(name="responseType")
    def response_type(self) -> Optional[str]:
        """
        The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
        """
        return pulumi.get(self, "response_type")


@pulumi.output_type
class VirtualRouterSpec(dict):
    def __init__(__self__, *,
                 listeners: Optional[Sequence['outputs.VirtualRouterSpecListener']] = None):
        """
        :param Sequence['VirtualRouterSpecListenerArgs'] listeners: Listeners that the virtual router is expected to receive inbound traffic from.
               Currently only one listener is supported per virtual router.
        """
        VirtualRouterSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            listeners=listeners,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             listeners: Optional[Sequence['outputs.VirtualRouterSpecListener']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if listeners is not None:
            _setter("listeners", listeners)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.VirtualRouterSpecListener']]:
        """
        Listeners that the virtual router is expected to receive inbound traffic from.
        Currently only one listener is supported per virtual router.
        """
        return pulumi.get(self, "listeners")


@pulumi.output_type
class VirtualRouterSpecListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portMapping":
            suggest = "port_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualRouterSpecListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualRouterSpecListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualRouterSpecListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_mapping: 'outputs.VirtualRouterSpecListenerPortMapping'):
        """
        :param 'VirtualRouterSpecListenerPortMappingArgs' port_mapping: Port mapping information for the listener.
        """
        VirtualRouterSpecListener._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_mapping=port_mapping,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_mapping: Optional['outputs.VirtualRouterSpecListenerPortMapping'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_mapping is None and 'portMapping' in kwargs:
            port_mapping = kwargs['portMapping']
        if port_mapping is None:
            raise TypeError("Missing 'port_mapping' argument")

        _setter("port_mapping", port_mapping)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> 'outputs.VirtualRouterSpecListenerPortMapping':
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")


@pulumi.output_type
class VirtualRouterSpecListenerPortMapping(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        """
        :param int port: Port used for the port mapping.
        :param str protocol: Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
        """
        VirtualRouterSpecListenerPortMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VirtualServiceSpec(dict):
    def __init__(__self__, *,
                 provider: Optional['outputs.VirtualServiceSpecProvider'] = None):
        """
        :param 'VirtualServiceSpecProviderArgs' provider: App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        """
        VirtualServiceSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provider=provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provider: Optional['outputs.VirtualServiceSpecProvider'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if provider is not None:
            _setter("provider", provider)

    @property
    @pulumi.getter
    def provider(self) -> Optional['outputs.VirtualServiceSpecProvider']:
        """
        App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class VirtualServiceSpecProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNode":
            suggest = "virtual_node"
        elif key == "virtualRouter":
            suggest = "virtual_router"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node: Optional['outputs.VirtualServiceSpecProviderVirtualNode'] = None,
                 virtual_router: Optional['outputs.VirtualServiceSpecProviderVirtualRouter'] = None):
        """
        :param 'VirtualServiceSpecProviderVirtualNodeArgs' virtual_node: Virtual node associated with a virtual service.
        :param 'VirtualServiceSpecProviderVirtualRouterArgs' virtual_router: Virtual router associated with a virtual service.
        """
        VirtualServiceSpecProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node=virtual_node,
            virtual_router=virtual_router,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node: Optional['outputs.VirtualServiceSpecProviderVirtualNode'] = None,
             virtual_router: Optional['outputs.VirtualServiceSpecProviderVirtualRouter'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_router is None and 'virtualRouter' in kwargs:
            virtual_router = kwargs['virtualRouter']

        if virtual_node is not None:
            _setter("virtual_node", virtual_node)
        if virtual_router is not None:
            _setter("virtual_router", virtual_router)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> Optional['outputs.VirtualServiceSpecProviderVirtualNode']:
        """
        Virtual node associated with a virtual service.
        """
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter(name="virtualRouter")
    def virtual_router(self) -> Optional['outputs.VirtualServiceSpecProviderVirtualRouter']:
        """
        Virtual router associated with a virtual service.
        """
        return pulumi.get(self, "virtual_router")


@pulumi.output_type
class VirtualServiceSpecProviderVirtualNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNodeName":
            suggest = "virtual_node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecProviderVirtualNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecProviderVirtualNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecProviderVirtualNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_node_name: str):
        """
        :param str virtual_node_name: Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        VirtualServiceSpecProviderVirtualNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node_name=virtual_node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node_name is None and 'virtualNodeName' in kwargs:
            virtual_node_name = kwargs['virtualNodeName']
        if virtual_node_name is None:
            raise TypeError("Missing 'virtual_node_name' argument")

        _setter("virtual_node_name", virtual_node_name)

    @property
    @pulumi.getter(name="virtualNodeName")
    def virtual_node_name(self) -> str:
        """
        Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node_name")


@pulumi.output_type
class VirtualServiceSpecProviderVirtualRouter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualRouterName":
            suggest = "virtual_router_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecProviderVirtualRouter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecProviderVirtualRouter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecProviderVirtualRouter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_router_name: str):
        """
        :param str virtual_router_name: Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        VirtualServiceSpecProviderVirtualRouter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_router_name=virtual_router_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_router_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_router_name is None and 'virtualRouterName' in kwargs:
            virtual_router_name = kwargs['virtualRouterName']
        if virtual_router_name is None:
            raise TypeError("Missing 'virtual_router_name' argument")

        _setter("virtual_router_name", virtual_router_name)

    @property
    @pulumi.getter(name="virtualRouterName")
    def virtual_router_name(self) -> str:
        """
        Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_router_name")


@pulumi.output_type
class GetGatewayRouteSpecResult(dict):
    def __init__(__self__, *,
                 grpc_routes: Sequence['outputs.GetGatewayRouteSpecGrpcRouteResult'],
                 http2_routes: Sequence['outputs.GetGatewayRouteSpecHttp2RouteResult'],
                 http_routes: Sequence['outputs.GetGatewayRouteSpecHttpRouteResult'],
                 priority: int):
        GetGatewayRouteSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc_routes=grpc_routes,
            http2_routes=http2_routes,
            http_routes=http_routes,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc_routes: Optional[Sequence['outputs.GetGatewayRouteSpecGrpcRouteResult']] = None,
             http2_routes: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteResult']] = None,
             http_routes: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteResult']] = None,
             priority: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpc_routes is None and 'grpcRoutes' in kwargs:
            grpc_routes = kwargs['grpcRoutes']
        if grpc_routes is None:
            raise TypeError("Missing 'grpc_routes' argument")
        if http2_routes is None and 'http2Routes' in kwargs:
            http2_routes = kwargs['http2Routes']
        if http2_routes is None:
            raise TypeError("Missing 'http2_routes' argument")
        if http_routes is None and 'httpRoutes' in kwargs:
            http_routes = kwargs['httpRoutes']
        if http_routes is None:
            raise TypeError("Missing 'http_routes' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")

        _setter("grpc_routes", grpc_routes)
        _setter("http2_routes", http2_routes)
        _setter("http_routes", http_routes)
        _setter("priority", priority)

    @property
    @pulumi.getter(name="grpcRoutes")
    def grpc_routes(self) -> Sequence['outputs.GetGatewayRouteSpecGrpcRouteResult']:
        return pulumi.get(self, "grpc_routes")

    @property
    @pulumi.getter(name="http2Routes")
    def http2_routes(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteResult']:
        return pulumi.get(self, "http2_routes")

    @property
    @pulumi.getter(name="httpRoutes")
    def http_routes(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteResult']:
        return pulumi.get(self, "http_routes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetGatewayRouteSpecGrpcRouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionResult'],
                 matches: Sequence['outputs.GetGatewayRouteSpecGrpcRouteMatchResult']):
        GetGatewayRouteSpecGrpcRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecGrpcRouteMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("actions", actions)
        _setter("matches", matches)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecGrpcRouteMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetGatewayRouteSpecGrpcRouteActionResult(dict):
    def __init__(__self__, *,
                 targets: Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetResult']):
        GetGatewayRouteSpecGrpcRouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            targets=targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             targets: Optional[Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetResult']:
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetGatewayRouteSpecGrpcRouteActionTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_services: Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult']):
        GetGatewayRouteSpecGrpcRouteActionTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_services=virtual_services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_services: Optional[Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_services is None and 'virtualServices' in kwargs:
            virtual_services = kwargs['virtualServices']
        if virtual_services is None:
            raise TypeError("Missing 'virtual_services' argument")

        _setter("port", port)
        _setter("virtual_services", virtual_services)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualServices")
    def virtual_services(self) -> Sequence['outputs.GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult']:
        return pulumi.get(self, "virtual_services")


@pulumi.output_type
class GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult(dict):
    def __init__(__self__, *,
                 virtual_service_name: str):
        GetGatewayRouteSpecGrpcRouteActionTargetVirtualServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GetGatewayRouteSpecGrpcRouteMatchResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service_name: str):
        GetGatewayRouteSpecGrpcRouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("port", port)
        _setter("service_name", service_name)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionResult'],
                 matches: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchResult']):
        GetGatewayRouteSpecHttp2RouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("actions", actions)
        _setter("matches", matches)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionResult(dict):
    def __init__(__self__, *,
                 rewrites: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteResult'],
                 targets: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetResult']):
        GetGatewayRouteSpecHttp2RouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rewrites=rewrites,
            targets=targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rewrites: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteResult']] = None,
             targets: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rewrites is None:
            raise TypeError("Missing 'rewrites' argument")
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("rewrites", rewrites)
        _setter("targets", targets)

    @property
    @pulumi.getter
    def rewrites(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteResult']:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetResult']:
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionRewriteResult(dict):
    def __init__(__self__, *,
                 hostnames: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult'],
                 paths: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePathResult'],
                 prefixes: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult']):
        GetGatewayRouteSpecHttp2RouteActionRewriteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostnames=hostnames,
            paths=paths,
            prefixes=prefixes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostnames: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult']] = None,
             paths: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePathResult']] = None,
             prefixes: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hostnames is None:
            raise TypeError("Missing 'hostnames' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if prefixes is None:
            raise TypeError("Missing 'prefixes' argument")

        _setter("hostnames", hostnames)
        _setter("paths", paths)
        _setter("prefixes", prefixes)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult']:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def prefixes(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult']:
        return pulumi.get(self, "prefixes")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult(dict):
    def __init__(__self__, *,
                 default_target_hostname: str):
        GetGatewayRouteSpecHttp2RouteActionRewriteHostnameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_target_hostname=default_target_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_target_hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_target_hostname is None and 'defaultTargetHostname' in kwargs:
            default_target_hostname = kwargs['defaultTargetHostname']
        if default_target_hostname is None:
            raise TypeError("Missing 'default_target_hostname' argument")

        _setter("default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> str:
        return pulumi.get(self, "default_target_hostname")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionRewritePathResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetGatewayRouteSpecHttp2RouteActionRewritePathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult(dict):
    def __init__(__self__, *,
                 default_prefix: str,
                 value: str):
        GetGatewayRouteSpecHttp2RouteActionRewritePrefixResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_prefix=default_prefix,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_prefix: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_prefix is None and 'defaultPrefix' in kwargs:
            default_prefix = kwargs['defaultPrefix']
        if default_prefix is None:
            raise TypeError("Missing 'default_prefix' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("default_prefix", default_prefix)
        _setter("value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> str:
        return pulumi.get(self, "default_prefix")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_services: Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult']):
        GetGatewayRouteSpecHttp2RouteActionTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_services=virtual_services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_services: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_services is None and 'virtualServices' in kwargs:
            virtual_services = kwargs['virtualServices']
        if virtual_services is None:
            raise TypeError("Missing 'virtual_services' argument")

        _setter("port", port)
        _setter("virtual_services", virtual_services)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualServices")
    def virtual_services(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult']:
        return pulumi.get(self, "virtual_services")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult(dict):
    def __init__(__self__, *,
                 virtual_service_name: str):
        GetGatewayRouteSpecHttp2RouteActionTargetVirtualServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderResult'],
                 hostnames: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHostnameResult'],
                 paths: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchPathResult'],
                 port: int,
                 prefix: str,
                 query_parameters: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult']):
        GetGatewayRouteSpecHttp2RouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            hostnames=hostnames,
            paths=paths,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderResult']] = None,
             hostnames: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHostnameResult']] = None,
             paths: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchPathResult']] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if headers is None:
            raise TypeError("Missing 'headers' argument")
        if hostnames is None:
            raise TypeError("Missing 'hostnames' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_parameters is None:
            raise TypeError("Missing 'query_parameters' argument")

        _setter("headers", headers)
        _setter("hostnames", hostnames)
        _setter("paths", paths)
        _setter("port", port)
        _setter("prefix", prefix)
        _setter("query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHostnameResult']:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchPathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult']:
        return pulumi.get(self, "query_parameters")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchHeaderResult(dict):
    def __init__(__self__, *,
                 invert: bool,
                 matches: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult'],
                 name: str):
        """
        :param str name: Name of the gateway route.
        """
        GetGatewayRouteSpecHttp2RouteMatchHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invert=invert,
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invert: Optional[bool] = None,
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if invert is None:
            raise TypeError("Missing 'invert' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("invert", invert)
        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the gateway route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str,
                 ranges: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult'],
                 regex: str,
                 suffix: str):
        GetGatewayRouteSpecHttp2RouteMatchHeaderMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            ranges=ranges,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             ranges: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult']] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if ranges is None:
            raise TypeError("Missing 'ranges' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("prefix", prefix)
        _setter("ranges", ranges)
        _setter("regex", regex)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult']:
        return pulumi.get(self, "ranges")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        return pulumi.get(self, "start")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchHostnameResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 suffix: str):
        GetGatewayRouteSpecHttp2RouteMatchHostnameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 regex: str):
        GetGatewayRouteSpecHttp2RouteMatchPathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")

        _setter("exact", exact)
        _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult'],
                 name: str):
        """
        :param str name: Name of the gateway route.
        """
        GetGatewayRouteSpecHttp2RouteMatchQueryParameterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the gateway route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionResult'],
                 matches: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchResult']):
        GetGatewayRouteSpecHttpRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("actions", actions)
        _setter("matches", matches)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionResult(dict):
    def __init__(__self__, *,
                 rewrites: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteResult'],
                 targets: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetResult']):
        GetGatewayRouteSpecHttpRouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rewrites=rewrites,
            targets=targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rewrites: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteResult']] = None,
             targets: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rewrites is None:
            raise TypeError("Missing 'rewrites' argument")
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("rewrites", rewrites)
        _setter("targets", targets)

    @property
    @pulumi.getter
    def rewrites(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteResult']:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetResult']:
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionRewriteResult(dict):
    def __init__(__self__, *,
                 hostnames: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult'],
                 paths: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePathResult'],
                 prefixes: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePrefixResult']):
        GetGatewayRouteSpecHttpRouteActionRewriteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostnames=hostnames,
            paths=paths,
            prefixes=prefixes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostnames: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult']] = None,
             paths: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePathResult']] = None,
             prefixes: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePrefixResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hostnames is None:
            raise TypeError("Missing 'hostnames' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if prefixes is None:
            raise TypeError("Missing 'prefixes' argument")

        _setter("hostnames", hostnames)
        _setter("paths", paths)
        _setter("prefixes", prefixes)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult']:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def prefixes(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionRewritePrefixResult']:
        return pulumi.get(self, "prefixes")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult(dict):
    def __init__(__self__, *,
                 default_target_hostname: str):
        GetGatewayRouteSpecHttpRouteActionRewriteHostnameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_target_hostname=default_target_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_target_hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_target_hostname is None and 'defaultTargetHostname' in kwargs:
            default_target_hostname = kwargs['defaultTargetHostname']
        if default_target_hostname is None:
            raise TypeError("Missing 'default_target_hostname' argument")

        _setter("default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> str:
        return pulumi.get(self, "default_target_hostname")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionRewritePathResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetGatewayRouteSpecHttpRouteActionRewritePathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionRewritePrefixResult(dict):
    def __init__(__self__, *,
                 default_prefix: str,
                 value: str):
        GetGatewayRouteSpecHttpRouteActionRewritePrefixResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_prefix=default_prefix,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_prefix: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_prefix is None and 'defaultPrefix' in kwargs:
            default_prefix = kwargs['defaultPrefix']
        if default_prefix is None:
            raise TypeError("Missing 'default_prefix' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("default_prefix", default_prefix)
        _setter("value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> str:
        return pulumi.get(self, "default_prefix")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_services: Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult']):
        GetGatewayRouteSpecHttpRouteActionTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_services=virtual_services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_services: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_services is None and 'virtualServices' in kwargs:
            virtual_services = kwargs['virtualServices']
        if virtual_services is None:
            raise TypeError("Missing 'virtual_services' argument")

        _setter("port", port)
        _setter("virtual_services", virtual_services)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualServices")
    def virtual_services(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult']:
        return pulumi.get(self, "virtual_services")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult(dict):
    def __init__(__self__, *,
                 virtual_service_name: str):
        GetGatewayRouteSpecHttpRouteActionTargetVirtualServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderResult'],
                 hostnames: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHostnameResult'],
                 paths: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchPathResult'],
                 port: int,
                 prefix: str,
                 query_parameters: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterResult']):
        GetGatewayRouteSpecHttpRouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            hostnames=hostnames,
            paths=paths,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderResult']] = None,
             hostnames: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHostnameResult']] = None,
             paths: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchPathResult']] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if headers is None:
            raise TypeError("Missing 'headers' argument")
        if hostnames is None:
            raise TypeError("Missing 'hostnames' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_parameters is None:
            raise TypeError("Missing 'query_parameters' argument")

        _setter("headers", headers)
        _setter("hostnames", hostnames)
        _setter("paths", paths)
        _setter("port", port)
        _setter("prefix", prefix)
        _setter("query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHostnameResult']:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchPathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterResult']:
        return pulumi.get(self, "query_parameters")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchHeaderResult(dict):
    def __init__(__self__, *,
                 invert: bool,
                 matches: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult'],
                 name: str):
        """
        :param str name: Name of the gateway route.
        """
        GetGatewayRouteSpecHttpRouteMatchHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invert=invert,
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invert: Optional[bool] = None,
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if invert is None:
            raise TypeError("Missing 'invert' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("invert", invert)
        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the gateway route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str,
                 ranges: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult'],
                 regex: str,
                 suffix: str):
        GetGatewayRouteSpecHttpRouteMatchHeaderMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            ranges=ranges,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             ranges: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult']] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if ranges is None:
            raise TypeError("Missing 'ranges' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("prefix", prefix)
        _setter("ranges", ranges)
        _setter("regex", regex)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult']:
        return pulumi.get(self, "ranges")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        GetGatewayRouteSpecHttpRouteMatchHeaderMatchRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        return pulumi.get(self, "start")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchHostnameResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 suffix: str):
        GetGatewayRouteSpecHttpRouteMatchHostnameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 regex: str):
        GetGatewayRouteSpecHttpRouteMatchPathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")

        _setter("exact", exact)
        _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchQueryParameterResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult'],
                 name: str):
        """
        :param str name: Name of the gateway route.
        """
        GetGatewayRouteSpecHttpRouteMatchQueryParameterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the gateway route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetGatewayRouteSpecHttpRouteMatchQueryParameterMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetMeshSpecResult(dict):
    def __init__(__self__, *,
                 egress_filters: Sequence['outputs.GetMeshSpecEgressFilterResult']):
        GetMeshSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            egress_filters=egress_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             egress_filters: Optional[Sequence['outputs.GetMeshSpecEgressFilterResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if egress_filters is None and 'egressFilters' in kwargs:
            egress_filters = kwargs['egressFilters']
        if egress_filters is None:
            raise TypeError("Missing 'egress_filters' argument")

        _setter("egress_filters", egress_filters)

    @property
    @pulumi.getter(name="egressFilters")
    def egress_filters(self) -> Sequence['outputs.GetMeshSpecEgressFilterResult']:
        return pulumi.get(self, "egress_filters")


@pulumi.output_type
class GetMeshSpecEgressFilterResult(dict):
    def __init__(__self__, *,
                 type: str):
        GetMeshSpecEgressFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRouteSpecResult(dict):
    def __init__(__self__, *,
                 grpc_routes: Sequence['outputs.GetRouteSpecGrpcRouteResult'],
                 http2_routes: Sequence['outputs.GetRouteSpecHttp2RouteResult'],
                 http_routes: Sequence['outputs.GetRouteSpecHttpRouteResult'],
                 priority: int,
                 tcp_routes: Sequence['outputs.GetRouteSpecTcpRouteResult']):
        GetRouteSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc_routes=grpc_routes,
            http2_routes=http2_routes,
            http_routes=http_routes,
            priority=priority,
            tcp_routes=tcp_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc_routes: Optional[Sequence['outputs.GetRouteSpecGrpcRouteResult']] = None,
             http2_routes: Optional[Sequence['outputs.GetRouteSpecHttp2RouteResult']] = None,
             http_routes: Optional[Sequence['outputs.GetRouteSpecHttpRouteResult']] = None,
             priority: Optional[int] = None,
             tcp_routes: Optional[Sequence['outputs.GetRouteSpecTcpRouteResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpc_routes is None and 'grpcRoutes' in kwargs:
            grpc_routes = kwargs['grpcRoutes']
        if grpc_routes is None:
            raise TypeError("Missing 'grpc_routes' argument")
        if http2_routes is None and 'http2Routes' in kwargs:
            http2_routes = kwargs['http2Routes']
        if http2_routes is None:
            raise TypeError("Missing 'http2_routes' argument")
        if http_routes is None and 'httpRoutes' in kwargs:
            http_routes = kwargs['httpRoutes']
        if http_routes is None:
            raise TypeError("Missing 'http_routes' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if tcp_routes is None and 'tcpRoutes' in kwargs:
            tcp_routes = kwargs['tcpRoutes']
        if tcp_routes is None:
            raise TypeError("Missing 'tcp_routes' argument")

        _setter("grpc_routes", grpc_routes)
        _setter("http2_routes", http2_routes)
        _setter("http_routes", http_routes)
        _setter("priority", priority)
        _setter("tcp_routes", tcp_routes)

    @property
    @pulumi.getter(name="grpcRoutes")
    def grpc_routes(self) -> Sequence['outputs.GetRouteSpecGrpcRouteResult']:
        return pulumi.get(self, "grpc_routes")

    @property
    @pulumi.getter(name="http2Routes")
    def http2_routes(self) -> Sequence['outputs.GetRouteSpecHttp2RouteResult']:
        return pulumi.get(self, "http2_routes")

    @property
    @pulumi.getter(name="httpRoutes")
    def http_routes(self) -> Sequence['outputs.GetRouteSpecHttpRouteResult']:
        return pulumi.get(self, "http_routes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="tcpRoutes")
    def tcp_routes(self) -> Sequence['outputs.GetRouteSpecTcpRouteResult']:
        return pulumi.get(self, "tcp_routes")


@pulumi.output_type
class GetRouteSpecGrpcRouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRouteSpecGrpcRouteActionResult'],
                 matches: Sequence['outputs.GetRouteSpecGrpcRouteMatchResult'],
                 retry_policies: Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyResult'],
                 timeouts: Sequence['outputs.GetRouteSpecGrpcRouteTimeoutResult']):
        GetRouteSpecGrpcRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
            retry_policies=retry_policies,
            timeouts=timeouts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetRouteSpecGrpcRouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecGrpcRouteMatchResult']] = None,
             retry_policies: Optional[Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyResult']] = None,
             timeouts: Optional[Sequence['outputs.GetRouteSpecGrpcRouteTimeoutResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if retry_policies is None and 'retryPolicies' in kwargs:
            retry_policies = kwargs['retryPolicies']
        if retry_policies is None:
            raise TypeError("Missing 'retry_policies' argument")
        if timeouts is None:
            raise TypeError("Missing 'timeouts' argument")

        _setter("actions", actions)
        _setter("matches", matches)
        _setter("retry_policies", retry_policies)
        _setter("timeouts", timeouts)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRouteSpecGrpcRouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecGrpcRouteMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter(name="retryPolicies")
    def retry_policies(self) -> Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyResult']:
        return pulumi.get(self, "retry_policies")

    @property
    @pulumi.getter
    def timeouts(self) -> Sequence['outputs.GetRouteSpecGrpcRouteTimeoutResult']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetRouteSpecGrpcRouteActionResult(dict):
    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.GetRouteSpecGrpcRouteActionWeightedTargetResult']):
        GetRouteSpecGrpcRouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.GetRouteSpecGrpcRouteActionWeightedTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.GetRouteSpecGrpcRouteActionWeightedTargetResult']:
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class GetRouteSpecGrpcRouteActionWeightedTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_node: str,
                 weight: int):
        GetRouteSpecGrpcRouteActionWeightedTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_node=virtual_node,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("port", port)
        _setter("virtual_node", virtual_node)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRouteSpecGrpcRouteMatchResult(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataResult'],
                 method_name: str,
                 port: int,
                 prefix: str,
                 service_name: str):
        GetRouteSpecGrpcRouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadatas=metadatas,
            method_name=method_name,
            port=port,
            prefix=prefix,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadatas: Optional[Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataResult']] = None,
             method_name: Optional[str] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metadatas is None:
            raise TypeError("Missing 'metadatas' argument")
        if method_name is None and 'methodName' in kwargs:
            method_name = kwargs['methodName']
        if method_name is None:
            raise TypeError("Missing 'method_name' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("metadatas", metadatas)
        _setter("method_name", method_name)
        _setter("port", port)
        _setter("prefix", prefix)
        _setter("service_name", service_name)

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataResult']:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> str:
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetRouteSpecGrpcRouteMatchMetadataResult(dict):
    def __init__(__self__, *,
                 invert: bool,
                 matches: Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchResult'],
                 name: str):
        """
        :param str name: Name of the route.
        """
        GetRouteSpecGrpcRouteMatchMetadataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invert=invert,
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invert: Optional[bool] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if invert is None:
            raise TypeError("Missing 'invert' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("invert", invert)
        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteSpecGrpcRouteMatchMetadataMatchResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str,
                 ranges: Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult'],
                 regex: str,
                 suffix: str):
        GetRouteSpecGrpcRouteMatchMetadataMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            ranges=ranges,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             ranges: Optional[Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult']] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if ranges is None:
            raise TypeError("Missing 'ranges' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("prefix", prefix)
        _setter("ranges", ranges)
        _setter("regex", regex)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult']:
        return pulumi.get(self, "ranges")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        GetRouteSpecGrpcRouteMatchMetadataMatchRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        return pulumi.get(self, "start")


@pulumi.output_type
class GetRouteSpecGrpcRouteRetryPolicyResult(dict):
    def __init__(__self__, *,
                 grpc_retry_events: Sequence[str],
                 http_retry_events: Sequence[str],
                 max_retries: int,
                 per_retry_timeouts: Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult'],
                 tcp_retry_events: Sequence[str]):
        GetRouteSpecGrpcRouteRetryPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpc_retry_events=grpc_retry_events,
            http_retry_events=http_retry_events,
            max_retries=max_retries,
            per_retry_timeouts=per_retry_timeouts,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpc_retry_events: Optional[Sequence[str]] = None,
             http_retry_events: Optional[Sequence[str]] = None,
             max_retries: Optional[int] = None,
             per_retry_timeouts: Optional[Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult']] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpc_retry_events is None and 'grpcRetryEvents' in kwargs:
            grpc_retry_events = kwargs['grpcRetryEvents']
        if grpc_retry_events is None:
            raise TypeError("Missing 'grpc_retry_events' argument")
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if http_retry_events is None:
            raise TypeError("Missing 'http_retry_events' argument")
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeouts is None and 'perRetryTimeouts' in kwargs:
            per_retry_timeouts = kwargs['perRetryTimeouts']
        if per_retry_timeouts is None:
            raise TypeError("Missing 'per_retry_timeouts' argument")
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']
        if tcp_retry_events is None:
            raise TypeError("Missing 'tcp_retry_events' argument")

        _setter("grpc_retry_events", grpc_retry_events)
        _setter("http_retry_events", http_retry_events)
        _setter("max_retries", max_retries)
        _setter("per_retry_timeouts", per_retry_timeouts)
        _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="grpcRetryEvents")
    def grpc_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "grpc_retry_events")

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeouts")
    def per_retry_timeouts(self) -> Sequence['outputs.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult']:
        return pulumi.get(self, "per_retry_timeouts")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecGrpcRouteTimeoutResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetRouteSpecGrpcRouteTimeoutIdleResult'],
                 per_requests: Sequence['outputs.GetRouteSpecGrpcRouteTimeoutPerRequestResult']):
        GetRouteSpecGrpcRouteTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetRouteSpecGrpcRouteTimeoutIdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetRouteSpecGrpcRouteTimeoutPerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetRouteSpecGrpcRouteTimeoutIdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetRouteSpecGrpcRouteTimeoutPerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetRouteSpecGrpcRouteTimeoutIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecGrpcRouteTimeoutIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecGrpcRouteTimeoutPerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecGrpcRouteTimeoutPerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttp2RouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRouteSpecHttp2RouteActionResult'],
                 matches: Sequence['outputs.GetRouteSpecHttp2RouteMatchResult'],
                 retry_policies: Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyResult'],
                 timeouts: Sequence['outputs.GetRouteSpecHttp2RouteTimeoutResult']):
        GetRouteSpecHttp2RouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
            retry_policies=retry_policies,
            timeouts=timeouts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetRouteSpecHttp2RouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchResult']] = None,
             retry_policies: Optional[Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyResult']] = None,
             timeouts: Optional[Sequence['outputs.GetRouteSpecHttp2RouteTimeoutResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if retry_policies is None and 'retryPolicies' in kwargs:
            retry_policies = kwargs['retryPolicies']
        if retry_policies is None:
            raise TypeError("Missing 'retry_policies' argument")
        if timeouts is None:
            raise TypeError("Missing 'timeouts' argument")

        _setter("actions", actions)
        _setter("matches", matches)
        _setter("retry_policies", retry_policies)
        _setter("timeouts", timeouts)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRouteSpecHttp2RouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter(name="retryPolicies")
    def retry_policies(self) -> Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyResult']:
        return pulumi.get(self, "retry_policies")

    @property
    @pulumi.getter
    def timeouts(self) -> Sequence['outputs.GetRouteSpecHttp2RouteTimeoutResult']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetRouteSpecHttp2RouteActionResult(dict):
    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.GetRouteSpecHttp2RouteActionWeightedTargetResult']):
        GetRouteSpecHttp2RouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.GetRouteSpecHttp2RouteActionWeightedTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.GetRouteSpecHttp2RouteActionWeightedTargetResult']:
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class GetRouteSpecHttp2RouteActionWeightedTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_node: str,
                 weight: int):
        GetRouteSpecHttp2RouteActionWeightedTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_node=virtual_node,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("port", port)
        _setter("virtual_node", virtual_node)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderResult'],
                 method: str,
                 paths: Sequence['outputs.GetRouteSpecHttp2RouteMatchPathResult'],
                 port: int,
                 prefix: str,
                 query_parameters: Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterResult'],
                 scheme: str):
        GetRouteSpecHttp2RouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            method=method,
            paths=paths,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderResult']] = None,
             method: Optional[str] = None,
             paths: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchPathResult']] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterResult']] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if headers is None:
            raise TypeError("Missing 'headers' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_parameters is None:
            raise TypeError("Missing 'query_parameters' argument")
        if scheme is None:
            raise TypeError("Missing 'scheme' argument")

        _setter("headers", headers)
        _setter("method", method)
        _setter("paths", paths)
        _setter("port", port)
        _setter("prefix", prefix)
        _setter("query_parameters", query_parameters)
        _setter("scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchPathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterResult']:
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchHeaderResult(dict):
    def __init__(__self__, *,
                 invert: bool,
                 matches: Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchResult'],
                 name: str):
        """
        :param str name: Name of the route.
        """
        GetRouteSpecHttp2RouteMatchHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invert=invert,
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invert: Optional[bool] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if invert is None:
            raise TypeError("Missing 'invert' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("invert", invert)
        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchHeaderMatchResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str,
                 ranges: Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult'],
                 regex: str,
                 suffix: str):
        GetRouteSpecHttp2RouteMatchHeaderMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            ranges=ranges,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             ranges: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult']] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if ranges is None:
            raise TypeError("Missing 'ranges' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("prefix", prefix)
        _setter("ranges", ranges)
        _setter("regex", regex)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult']:
        return pulumi.get(self, "ranges")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        GetRouteSpecHttp2RouteMatchHeaderMatchRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        return pulumi.get(self, "start")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 regex: str):
        GetRouteSpecHttp2RouteMatchPathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")

        _setter("exact", exact)
        _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchQueryParameterResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterMatchResult'],
                 name: str):
        """
        :param str name: Name of the route.
        """
        GetRouteSpecHttp2RouteMatchQueryParameterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttp2RouteMatchQueryParameterMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteSpecHttp2RouteMatchQueryParameterMatchResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetRouteSpecHttp2RouteMatchQueryParameterMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetRouteSpecHttp2RouteRetryPolicyResult(dict):
    def __init__(__self__, *,
                 http_retry_events: Sequence[str],
                 max_retries: int,
                 per_retry_timeouts: Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult'],
                 tcp_retry_events: Sequence[str]):
        GetRouteSpecHttp2RouteRetryPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_retry_events=http_retry_events,
            max_retries=max_retries,
            per_retry_timeouts=per_retry_timeouts,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_retry_events: Optional[Sequence[str]] = None,
             max_retries: Optional[int] = None,
             per_retry_timeouts: Optional[Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult']] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if http_retry_events is None:
            raise TypeError("Missing 'http_retry_events' argument")
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeouts is None and 'perRetryTimeouts' in kwargs:
            per_retry_timeouts = kwargs['perRetryTimeouts']
        if per_retry_timeouts is None:
            raise TypeError("Missing 'per_retry_timeouts' argument")
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']
        if tcp_retry_events is None:
            raise TypeError("Missing 'tcp_retry_events' argument")

        _setter("http_retry_events", http_retry_events)
        _setter("max_retries", max_retries)
        _setter("per_retry_timeouts", per_retry_timeouts)
        _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeouts")
    def per_retry_timeouts(self) -> Sequence['outputs.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult']:
        return pulumi.get(self, "per_retry_timeouts")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttp2RouteTimeoutResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetRouteSpecHttp2RouteTimeoutIdleResult'],
                 per_requests: Sequence['outputs.GetRouteSpecHttp2RouteTimeoutPerRequestResult']):
        GetRouteSpecHttp2RouteTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetRouteSpecHttp2RouteTimeoutIdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetRouteSpecHttp2RouteTimeoutPerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetRouteSpecHttp2RouteTimeoutIdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetRouteSpecHttp2RouteTimeoutPerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetRouteSpecHttp2RouteTimeoutIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttp2RouteTimeoutIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttp2RouteTimeoutPerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttp2RouteTimeoutPerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttpRouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRouteSpecHttpRouteActionResult'],
                 matches: Sequence['outputs.GetRouteSpecHttpRouteMatchResult'],
                 retry_policies: Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyResult'],
                 timeouts: Sequence['outputs.GetRouteSpecHttpRouteTimeoutResult']):
        GetRouteSpecHttpRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
            retry_policies=retry_policies,
            timeouts=timeouts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetRouteSpecHttpRouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchResult']] = None,
             retry_policies: Optional[Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyResult']] = None,
             timeouts: Optional[Sequence['outputs.GetRouteSpecHttpRouteTimeoutResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if retry_policies is None and 'retryPolicies' in kwargs:
            retry_policies = kwargs['retryPolicies']
        if retry_policies is None:
            raise TypeError("Missing 'retry_policies' argument")
        if timeouts is None:
            raise TypeError("Missing 'timeouts' argument")

        _setter("actions", actions)
        _setter("matches", matches)
        _setter("retry_policies", retry_policies)
        _setter("timeouts", timeouts)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRouteSpecHttpRouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter(name="retryPolicies")
    def retry_policies(self) -> Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyResult']:
        return pulumi.get(self, "retry_policies")

    @property
    @pulumi.getter
    def timeouts(self) -> Sequence['outputs.GetRouteSpecHttpRouteTimeoutResult']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetRouteSpecHttpRouteActionResult(dict):
    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.GetRouteSpecHttpRouteActionWeightedTargetResult']):
        GetRouteSpecHttpRouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.GetRouteSpecHttpRouteActionWeightedTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.GetRouteSpecHttpRouteActionWeightedTargetResult']:
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class GetRouteSpecHttpRouteActionWeightedTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_node: str,
                 weight: int):
        GetRouteSpecHttpRouteActionWeightedTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_node=virtual_node,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("port", port)
        _setter("virtual_node", virtual_node)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderResult'],
                 method: str,
                 paths: Sequence['outputs.GetRouteSpecHttpRouteMatchPathResult'],
                 port: int,
                 prefix: str,
                 query_parameters: Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterResult'],
                 scheme: str):
        GetRouteSpecHttpRouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            method=method,
            paths=paths,
            port=port,
            prefix=prefix,
            query_parameters=query_parameters,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderResult']] = None,
             method: Optional[str] = None,
             paths: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchPathResult']] = None,
             port: Optional[int] = None,
             prefix: Optional[str] = None,
             query_parameters: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterResult']] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if headers is None:
            raise TypeError("Missing 'headers' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_parameters is None:
            raise TypeError("Missing 'query_parameters' argument")
        if scheme is None:
            raise TypeError("Missing 'scheme' argument")

        _setter("headers", headers)
        _setter("method", method)
        _setter("paths", paths)
        _setter("port", port)
        _setter("prefix", prefix)
        _setter("query_parameters", query_parameters)
        _setter("scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchPathResult']:
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterResult']:
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchHeaderResult(dict):
    def __init__(__self__, *,
                 invert: bool,
                 matches: Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchResult'],
                 name: str):
        """
        :param str name: Name of the route.
        """
        GetRouteSpecHttpRouteMatchHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invert=invert,
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invert: Optional[bool] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if invert is None:
            raise TypeError("Missing 'invert' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("invert", invert)
        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchHeaderMatchResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str,
                 ranges: Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchRangeResult'],
                 regex: str,
                 suffix: str):
        GetRouteSpecHttpRouteMatchHeaderMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            prefix=prefix,
            ranges=ranges,
            regex=regex,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             prefix: Optional[str] = None,
             ranges: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchRangeResult']] = None,
             regex: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if ranges is None:
            raise TypeError("Missing 'ranges' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("exact", exact)
        _setter("prefix", prefix)
        _setter("ranges", ranges)
        _setter("regex", regex)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchHeaderMatchRangeResult']:
        return pulumi.get(self, "ranges")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchHeaderMatchRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        GetRouteSpecHttpRouteMatchHeaderMatchRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[int] = None,
             start: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        return pulumi.get(self, "start")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 regex: str):
        GetRouteSpecHttpRouteMatchPathResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             regex: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")
        if regex is None:
            raise TypeError("Missing 'regex' argument")

        _setter("exact", exact)
        _setter("regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchQueryParameterResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterMatchResult'],
                 name: str):
        """
        :param str name: Name of the route.
        """
        GetRouteSpecHttpRouteMatchQueryParameterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterMatchResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("matches", matches)
        _setter("name", name)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecHttpRouteMatchQueryParameterMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteSpecHttpRouteMatchQueryParameterMatchResult(dict):
    def __init__(__self__, *,
                 exact: str):
        GetRouteSpecHttpRouteMatchQueryParameterMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exact is None:
            raise TypeError("Missing 'exact' argument")

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetRouteSpecHttpRouteRetryPolicyResult(dict):
    def __init__(__self__, *,
                 http_retry_events: Sequence[str],
                 max_retries: int,
                 per_retry_timeouts: Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult'],
                 tcp_retry_events: Sequence[str]):
        GetRouteSpecHttpRouteRetryPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_retry_events=http_retry_events,
            max_retries=max_retries,
            per_retry_timeouts=per_retry_timeouts,
            tcp_retry_events=tcp_retry_events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_retry_events: Optional[Sequence[str]] = None,
             max_retries: Optional[int] = None,
             per_retry_timeouts: Optional[Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult']] = None,
             tcp_retry_events: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_retry_events is None and 'httpRetryEvents' in kwargs:
            http_retry_events = kwargs['httpRetryEvents']
        if http_retry_events is None:
            raise TypeError("Missing 'http_retry_events' argument")
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if max_retries is None:
            raise TypeError("Missing 'max_retries' argument")
        if per_retry_timeouts is None and 'perRetryTimeouts' in kwargs:
            per_retry_timeouts = kwargs['perRetryTimeouts']
        if per_retry_timeouts is None:
            raise TypeError("Missing 'per_retry_timeouts' argument")
        if tcp_retry_events is None and 'tcpRetryEvents' in kwargs:
            tcp_retry_events = kwargs['tcpRetryEvents']
        if tcp_retry_events is None:
            raise TypeError("Missing 'tcp_retry_events' argument")

        _setter("http_retry_events", http_retry_events)
        _setter("max_retries", max_retries)
        _setter("per_retry_timeouts", per_retry_timeouts)
        _setter("tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "http_retry_events")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="perRetryTimeouts")
    def per_retry_timeouts(self) -> Sequence['outputs.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult']:
        return pulumi.get(self, "per_retry_timeouts")

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Sequence[str]:
        return pulumi.get(self, "tcp_retry_events")


@pulumi.output_type
class GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttpRouteRetryPolicyPerRetryTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttpRouteTimeoutResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetRouteSpecHttpRouteTimeoutIdleResult'],
                 per_requests: Sequence['outputs.GetRouteSpecHttpRouteTimeoutPerRequestResult']):
        GetRouteSpecHttpRouteTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetRouteSpecHttpRouteTimeoutIdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetRouteSpecHttpRouteTimeoutPerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetRouteSpecHttpRouteTimeoutIdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetRouteSpecHttpRouteTimeoutPerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetRouteSpecHttpRouteTimeoutIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttpRouteTimeoutIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecHttpRouteTimeoutPerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecHttpRouteTimeoutPerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouteSpecTcpRouteResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRouteSpecTcpRouteActionResult'],
                 matches: Sequence['outputs.GetRouteSpecTcpRouteMatchResult'],
                 timeouts: Sequence['outputs.GetRouteSpecTcpRouteTimeoutResult']):
        GetRouteSpecTcpRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            matches=matches,
            timeouts=timeouts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.GetRouteSpecTcpRouteActionResult']] = None,
             matches: Optional[Sequence['outputs.GetRouteSpecTcpRouteMatchResult']] = None,
             timeouts: Optional[Sequence['outputs.GetRouteSpecTcpRouteTimeoutResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if matches is None:
            raise TypeError("Missing 'matches' argument")
        if timeouts is None:
            raise TypeError("Missing 'timeouts' argument")

        _setter("actions", actions)
        _setter("matches", matches)
        _setter("timeouts", timeouts)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRouteSpecTcpRouteActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRouteSpecTcpRouteMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def timeouts(self) -> Sequence['outputs.GetRouteSpecTcpRouteTimeoutResult']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetRouteSpecTcpRouteActionResult(dict):
    def __init__(__self__, *,
                 weighted_targets: Sequence['outputs.GetRouteSpecTcpRouteActionWeightedTargetResult']):
        GetRouteSpecTcpRouteActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            weighted_targets=weighted_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             weighted_targets: Optional[Sequence['outputs.GetRouteSpecTcpRouteActionWeightedTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if weighted_targets is None and 'weightedTargets' in kwargs:
            weighted_targets = kwargs['weightedTargets']
        if weighted_targets is None:
            raise TypeError("Missing 'weighted_targets' argument")

        _setter("weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> Sequence['outputs.GetRouteSpecTcpRouteActionWeightedTargetResult']:
        return pulumi.get(self, "weighted_targets")


@pulumi.output_type
class GetRouteSpecTcpRouteActionWeightedTargetResult(dict):
    def __init__(__self__, *,
                 port: int,
                 virtual_node: str,
                 weight: int):
        GetRouteSpecTcpRouteActionWeightedTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            virtual_node=virtual_node,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             virtual_node: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if virtual_node is None and 'virtualNode' in kwargs:
            virtual_node = kwargs['virtualNode']
        if virtual_node is None:
            raise TypeError("Missing 'virtual_node' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("port", port)
        _setter("virtual_node", virtual_node)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> str:
        return pulumi.get(self, "virtual_node")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRouteSpecTcpRouteMatchResult(dict):
    def __init__(__self__, *,
                 port: int):
        GetRouteSpecTcpRouteMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRouteSpecTcpRouteTimeoutResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetRouteSpecTcpRouteTimeoutIdleResult']):
        GetRouteSpecTcpRouteTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetRouteSpecTcpRouteTimeoutIdleResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")

        _setter("idles", idles)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetRouteSpecTcpRouteTimeoutIdleResult']:
        return pulumi.get(self, "idles")


@pulumi.output_type
class GetRouteSpecTcpRouteTimeoutIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetRouteSpecTcpRouteTimeoutIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualGatewaySpecResult(dict):
    def __init__(__self__, *,
                 backend_defaults: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultResult'],
                 listeners: Sequence['outputs.GetVirtualGatewaySpecListenerResult'],
                 loggings: Sequence['outputs.GetVirtualGatewaySpecLoggingResult']):
        GetVirtualGatewaySpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_defaults=backend_defaults,
            listeners=listeners,
            loggings=loggings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_defaults: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultResult']] = None,
             listeners: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerResult']] = None,
             loggings: Optional[Sequence['outputs.GetVirtualGatewaySpecLoggingResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_defaults is None and 'backendDefaults' in kwargs:
            backend_defaults = kwargs['backendDefaults']
        if backend_defaults is None:
            raise TypeError("Missing 'backend_defaults' argument")
        if listeners is None:
            raise TypeError("Missing 'listeners' argument")
        if loggings is None:
            raise TypeError("Missing 'loggings' argument")

        _setter("backend_defaults", backend_defaults)
        _setter("listeners", listeners)
        _setter("loggings", loggings)

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultResult']:
        return pulumi.get(self, "backend_defaults")

    @property
    @pulumi.getter
    def listeners(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerResult']:
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def loggings(self) -> Sequence['outputs.GetVirtualGatewaySpecLoggingResult']:
        return pulumi.get(self, "loggings")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultResult(dict):
    def __init__(__self__, *,
                 client_policies: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyResult']):
        GetVirtualGatewaySpecBackendDefaultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_policies=client_policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_policies: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_policies is None and 'clientPolicies' in kwargs:
            client_policies = kwargs['clientPolicies']
        if client_policies is None:
            raise TypeError("Missing 'client_policies' argument")

        _setter("client_policies", client_policies)

    @property
    @pulumi.getter(name="clientPolicies")
    def client_policies(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyResult']:
        return pulumi.get(self, "client_policies")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyResult(dict):
    def __init__(__self__, *,
                 tls: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult'],
                 enforce: bool,
                 ports: Sequence[int],
                 validations: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            enforce=enforce,
            ports=ports,
            validations=validations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult']] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             validations: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if enforce is None:
            raise TypeError("Missing 'enforce' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if validations is None:
            raise TypeError("Missing 'validations' argument")

        _setter("certificates", certificates)
        _setter("enforce", enforce)
        _setter("ports", ports)
        _setter("validations", validations)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult'],
                 sds: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult(dict):
    def __init__(__self__, *,
                 subject_alternative_names: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult'],
                 trusts: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_alternative_names=subject_alternative_names,
            trusts=trusts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_alternative_names: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult']] = None,
             trusts: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if trusts is None:
            raise TypeError("Missing 'trusts' argument")

        _setter("subject_alternative_names", subject_alternative_names)
        _setter("trusts", trusts)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult']:
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter
    def trusts(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult']:
        return pulumi.get(self, "trusts")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        return pulumi.get(self, "exacts")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult(dict):
    def __init__(__self__, *,
                 acms: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult'],
                 files: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult'],
                 sds: Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult']):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acms=acms,
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acms: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult']] = None,
             files: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acms is None:
            raise TypeError("Missing 'acms' argument")
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("acms", acms)
        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def acms(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult']:
        return pulumi.get(self, "acms")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult(dict):
    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualGatewaySpecListenerResult(dict):
    def __init__(__self__, *,
                 connection_pools: Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolResult'],
                 health_checks: Sequence['outputs.GetVirtualGatewaySpecListenerHealthCheckResult'],
                 port_mappings: Sequence['outputs.GetVirtualGatewaySpecListenerPortMappingResult'],
                 tls: Sequence['outputs.GetVirtualGatewaySpecListenerTlResult']):
        GetVirtualGatewaySpecListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_pools=connection_pools,
            health_checks=health_checks,
            port_mappings=port_mappings,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_pools: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolResult']] = None,
             health_checks: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerHealthCheckResult']] = None,
             port_mappings: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerPortMappingResult']] = None,
             tls: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_pools is None and 'connectionPools' in kwargs:
            connection_pools = kwargs['connectionPools']
        if connection_pools is None:
            raise TypeError("Missing 'connection_pools' argument")
        if health_checks is None and 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if health_checks is None:
            raise TypeError("Missing 'health_checks' argument")
        if port_mappings is None and 'portMappings' in kwargs:
            port_mappings = kwargs['portMappings']
        if port_mappings is None:
            raise TypeError("Missing 'port_mappings' argument")
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("connection_pools", connection_pools)
        _setter("health_checks", health_checks)
        _setter("port_mappings", port_mappings)
        _setter("tls", tls)

    @property
    @pulumi.getter(name="connectionPools")
    def connection_pools(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolResult']:
        return pulumi.get(self, "connection_pools")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerHealthCheckResult']:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="portMappings")
    def port_mappings(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerPortMappingResult']:
        return pulumi.get(self, "port_mappings")

    @property
    @pulumi.getter
    def tls(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlResult']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetVirtualGatewaySpecListenerConnectionPoolResult(dict):
    def __init__(__self__, *,
                 grpcs: Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolGrpcResult'],
                 http2s: Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttp2Result'],
                 https: Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttpResult']):
        GetVirtualGatewaySpecListenerConnectionPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpcs=grpcs,
            http2s=http2s,
            https=https,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpcs: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolGrpcResult']] = None,
             http2s: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttp2Result']] = None,
             https: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttpResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpcs is None:
            raise TypeError("Missing 'grpcs' argument")
        if http2s is None:
            raise TypeError("Missing 'http2s' argument")
        if https is None:
            raise TypeError("Missing 'https' argument")

        _setter("grpcs", grpcs)
        _setter("http2s", http2s)
        _setter("https", https)

    @property
    @pulumi.getter
    def grpcs(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolGrpcResult']:
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter
    def http2s(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttp2Result']:
        return pulumi.get(self, "http2s")

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerConnectionPoolHttpResult']:
        return pulumi.get(self, "https")


@pulumi.output_type
class GetVirtualGatewaySpecListenerConnectionPoolGrpcResult(dict):
    def __init__(__self__, *,
                 max_requests: int):
        GetVirtualGatewaySpecListenerConnectionPoolGrpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class GetVirtualGatewaySpecListenerConnectionPoolHttp2Result(dict):
    def __init__(__self__, *,
                 max_requests: int):
        GetVirtualGatewaySpecListenerConnectionPoolHttp2Result._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class GetVirtualGatewaySpecListenerConnectionPoolHttpResult(dict):
    def __init__(__self__, *,
                 max_connections: int,
                 max_pending_requests: int):
        GetVirtualGatewaySpecListenerConnectionPoolHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
            max_pending_requests=max_pending_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             max_pending_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")
        if max_pending_requests is None and 'maxPendingRequests' in kwargs:
            max_pending_requests = kwargs['maxPendingRequests']
        if max_pending_requests is None:
            raise TypeError("Missing 'max_pending_requests' argument")

        _setter("max_connections", max_connections)
        _setter("max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> int:
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class GetVirtualGatewaySpecListenerHealthCheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: int,
                 interval_millis: int,
                 path: str,
                 port: int,
                 protocol: str,
                 timeout_millis: int,
                 unhealthy_threshold: int):
        GetVirtualGatewaySpecListenerHealthCheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy_threshold=healthy_threshold,
            interval_millis=interval_millis,
            path=path,
            port=port,
            protocol=protocol,
            timeout_millis=timeout_millis,
            unhealthy_threshold=unhealthy_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy_threshold: Optional[int] = None,
             interval_millis: Optional[int] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             timeout_millis: Optional[int] = None,
             unhealthy_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if healthy_threshold is None:
            raise TypeError("Missing 'healthy_threshold' argument")
        if interval_millis is None and 'intervalMillis' in kwargs:
            interval_millis = kwargs['intervalMillis']
        if interval_millis is None:
            raise TypeError("Missing 'interval_millis' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if timeout_millis is None and 'timeoutMillis' in kwargs:
            timeout_millis = kwargs['timeoutMillis']
        if timeout_millis is None:
            raise TypeError("Missing 'timeout_millis' argument")
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']
        if unhealthy_threshold is None:
            raise TypeError("Missing 'unhealthy_threshold' argument")

        _setter("healthy_threshold", healthy_threshold)
        _setter("interval_millis", interval_millis)
        _setter("path", path)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("timeout_millis", timeout_millis)
        _setter("unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> int:
        return pulumi.get(self, "interval_millis")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> int:
        return pulumi.get(self, "timeout_millis")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetVirtualGatewaySpecListenerPortMappingResult(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        GetVirtualGatewaySpecListenerPortMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateResult'],
                 mode: str,
                 validations: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationResult']):
        GetVirtualGatewaySpecListenerTlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            mode=mode,
            validations=validations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateResult']] = None,
             mode: Optional[str] = None,
             validations: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if validations is None:
            raise TypeError("Missing 'validations' argument")

        _setter("certificates", certificates)
        _setter("mode", mode)
        _setter("validations", validations)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationResult']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlCertificateResult(dict):
    def __init__(__self__, *,
                 acms: Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateAcmResult'],
                 files: Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateFileResult'],
                 sds: Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateSdResult']):
        GetVirtualGatewaySpecListenerTlCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acms=acms,
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acms: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateAcmResult']] = None,
             files: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acms is None:
            raise TypeError("Missing 'acms' argument")
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("acms", acms)
        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def acms(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateAcmResult']:
        return pulumi.get(self, "acms")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlCertificateSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlCertificateAcmResult(dict):
    def __init__(__self__, *,
                 certificate_arn: str):
        GetVirtualGatewaySpecListenerTlCertificateAcmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_arn=certificate_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if certificate_arn is None:
            raise TypeError("Missing 'certificate_arn' argument")

        _setter("certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        return pulumi.get(self, "certificate_arn")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlCertificateFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        GetVirtualGatewaySpecListenerTlCertificateFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlCertificateSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualGatewaySpecListenerTlCertificateSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationResult(dict):
    def __init__(__self__, *,
                 subject_alternative_names: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult'],
                 trusts: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustResult']):
        GetVirtualGatewaySpecListenerTlValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_alternative_names=subject_alternative_names,
            trusts=trusts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_alternative_names: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult']] = None,
             trusts: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if trusts is None:
            raise TypeError("Missing 'trusts' argument")

        _setter("subject_alternative_names", subject_alternative_names)
        _setter("trusts", trusts)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult']:
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter
    def trusts(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustResult']:
        return pulumi.get(self, "trusts")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult']):
        GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        return pulumi.get(self, "exacts")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationTrustResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustFileResult'],
                 sds: Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustSdResult']):
        GetVirtualGatewaySpecListenerTlValidationTrustResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualGatewaySpecListenerTlValidationTrustSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationTrustFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetVirtualGatewaySpecListenerTlValidationTrustFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetVirtualGatewaySpecListenerTlValidationTrustSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualGatewaySpecListenerTlValidationTrustSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualGatewaySpecLoggingResult(dict):
    def __init__(__self__, *,
                 access_logs: Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogResult']):
        GetVirtualGatewaySpecLoggingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_logs=access_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_logs: Optional[Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_logs is None and 'accessLogs' in kwargs:
            access_logs = kwargs['accessLogs']
        if access_logs is None:
            raise TypeError("Missing 'access_logs' argument")

        _setter("access_logs", access_logs)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogResult']:
        return pulumi.get(self, "access_logs")


@pulumi.output_type
class GetVirtualGatewaySpecLoggingAccessLogResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileResult']):
        GetVirtualGatewaySpecLoggingAccessLogResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")

        _setter("files", files)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileResult']:
        return pulumi.get(self, "files")


@pulumi.output_type
class GetVirtualGatewaySpecLoggingAccessLogFileResult(dict):
    def __init__(__self__, *,
                 formats: Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatResult'],
                 path: str):
        GetVirtualGatewaySpecLoggingAccessLogFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formats=formats,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formats: Optional[Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatResult']] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if formats is None:
            raise TypeError("Missing 'formats' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("formats", formats)
        _setter("path", path)

    @property
    @pulumi.getter
    def formats(self) -> Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatResult']:
        return pulumi.get(self, "formats")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")


@pulumi.output_type
class GetVirtualGatewaySpecLoggingAccessLogFileFormatResult(dict):
    def __init__(__self__, *,
                 jsons: Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult'],
                 text: str):
        GetVirtualGatewaySpecLoggingAccessLogFileFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsons=jsons,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsons: Optional[Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult']] = None,
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if jsons is None:
            raise TypeError("Missing 'jsons' argument")
        if text is None:
            raise TypeError("Missing 'text' argument")

        _setter("jsons", jsons)
        _setter("text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Sequence['outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult']:
        return pulumi.get(self, "jsons")

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")


@pulumi.output_type
class GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        GetVirtualGatewaySpecLoggingAccessLogFileFormatJsonResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecResult(dict):
    def __init__(__self__, *,
                 backend_defaults: Sequence['outputs.GetVirtualNodeSpecBackendDefaultResult'],
                 backends: Sequence['outputs.GetVirtualNodeSpecBackendResult'],
                 listeners: Sequence['outputs.GetVirtualNodeSpecListenerResult'],
                 loggings: Sequence['outputs.GetVirtualNodeSpecLoggingResult'],
                 service_discoveries: Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryResult']):
        GetVirtualNodeSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_defaults=backend_defaults,
            backends=backends,
            listeners=listeners,
            loggings=loggings,
            service_discoveries=service_discoveries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_defaults: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultResult']] = None,
             backends: Optional[Sequence['outputs.GetVirtualNodeSpecBackendResult']] = None,
             listeners: Optional[Sequence['outputs.GetVirtualNodeSpecListenerResult']] = None,
             loggings: Optional[Sequence['outputs.GetVirtualNodeSpecLoggingResult']] = None,
             service_discoveries: Optional[Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_defaults is None and 'backendDefaults' in kwargs:
            backend_defaults = kwargs['backendDefaults']
        if backend_defaults is None:
            raise TypeError("Missing 'backend_defaults' argument")
        if backends is None:
            raise TypeError("Missing 'backends' argument")
        if listeners is None:
            raise TypeError("Missing 'listeners' argument")
        if loggings is None:
            raise TypeError("Missing 'loggings' argument")
        if service_discoveries is None and 'serviceDiscoveries' in kwargs:
            service_discoveries = kwargs['serviceDiscoveries']
        if service_discoveries is None:
            raise TypeError("Missing 'service_discoveries' argument")

        _setter("backend_defaults", backend_defaults)
        _setter("backends", backends)
        _setter("listeners", listeners)
        _setter("loggings", loggings)
        _setter("service_discoveries", service_discoveries)

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultResult']:
        return pulumi.get(self, "backend_defaults")

    @property
    @pulumi.getter
    def backends(self) -> Sequence['outputs.GetVirtualNodeSpecBackendResult']:
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter
    def listeners(self) -> Sequence['outputs.GetVirtualNodeSpecListenerResult']:
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def loggings(self) -> Sequence['outputs.GetVirtualNodeSpecLoggingResult']:
        return pulumi.get(self, "loggings")

    @property
    @pulumi.getter(name="serviceDiscoveries")
    def service_discoveries(self) -> Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryResult']:
        return pulumi.get(self, "service_discoveries")


@pulumi.output_type
class GetVirtualNodeSpecBackendResult(dict):
    def __init__(__self__, *,
                 virtual_services: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceResult']):
        GetVirtualNodeSpecBackendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_services=virtual_services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_services: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_services is None and 'virtualServices' in kwargs:
            virtual_services = kwargs['virtualServices']
        if virtual_services is None:
            raise TypeError("Missing 'virtual_services' argument")

        _setter("virtual_services", virtual_services)

    @property
    @pulumi.getter(name="virtualServices")
    def virtual_services(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceResult']:
        return pulumi.get(self, "virtual_services")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultResult(dict):
    def __init__(__self__, *,
                 client_policies: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyResult']):
        GetVirtualNodeSpecBackendDefaultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_policies=client_policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_policies: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_policies is None and 'clientPolicies' in kwargs:
            client_policies = kwargs['clientPolicies']
        if client_policies is None:
            raise TypeError("Missing 'client_policies' argument")

        _setter("client_policies", client_policies)

    @property
    @pulumi.getter(name="clientPolicies")
    def client_policies(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyResult']:
        return pulumi.get(self, "client_policies")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyResult(dict):
    def __init__(__self__, *,
                 tls: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlResult']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult'],
                 enforce: bool,
                 ports: Sequence[int],
                 validations: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            enforce=enforce,
            ports=ports,
            validations=validations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult']] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             validations: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if enforce is None:
            raise TypeError("Missing 'enforce' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if validations is None:
            raise TypeError("Missing 'validations' argument")

        _setter("certificates", certificates)
        _setter("enforce", enforce)
        _setter("ports", ports)
        _setter("validations", validations)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult(dict):
    def __init__(__self__, *,
                 subject_alternative_names: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult'],
                 trusts: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_alternative_names=subject_alternative_names,
            trusts=trusts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_alternative_names: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult']] = None,
             trusts: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if trusts is None:
            raise TypeError("Missing 'trusts' argument")

        _setter("subject_alternative_names", subject_alternative_names)
        _setter("trusts", trusts)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult']:
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter
    def trusts(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult']:
        return pulumi.get(self, "trusts")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        return pulumi.get(self, "exacts")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult(dict):
    def __init__(__self__, *,
                 acms: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult'],
                 files: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult']):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acms=acms,
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acms: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult']] = None,
             files: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acms is None:
            raise TypeError("Missing 'acms' argument")
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("acms", acms)
        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def acms(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult']:
        return pulumi.get(self, "acms")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult(dict):
    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceResult(dict):
    def __init__(__self__, *,
                 client_policies: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult'],
                 virtual_service_name: str):
        GetVirtualNodeSpecBackendVirtualServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_policies=client_policies,
            virtual_service_name=virtual_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_policies: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult']] = None,
             virtual_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_policies is None and 'clientPolicies' in kwargs:
            client_policies = kwargs['clientPolicies']
        if client_policies is None:
            raise TypeError("Missing 'client_policies' argument")
        if virtual_service_name is None and 'virtualServiceName' in kwargs:
            virtual_service_name = kwargs['virtualServiceName']
        if virtual_service_name is None:
            raise TypeError("Missing 'virtual_service_name' argument")

        _setter("client_policies", client_policies)
        _setter("virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="clientPolicies")
    def client_policies(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult']:
        return pulumi.get(self, "client_policies")

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> str:
        return pulumi.get(self, "virtual_service_name")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult(dict):
    def __init__(__self__, *,
                 tls: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult'],
                 enforce: bool,
                 ports: Sequence[int],
                 validations: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            enforce=enforce,
            ports=ports,
            validations=validations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult']] = None,
             enforce: Optional[bool] = None,
             ports: Optional[Sequence[int]] = None,
             validations: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if enforce is None:
            raise TypeError("Missing 'enforce' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if validations is None:
            raise TypeError("Missing 'validations' argument")

        _setter("certificates", certificates)
        _setter("enforce", enforce)
        _setter("ports", ports)
        _setter("validations", validations)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def enforce(self) -> bool:
        return pulumi.get(self, "enforce")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult(dict):
    def __init__(__self__, *,
                 subject_alternative_names: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult'],
                 trusts: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_alternative_names=subject_alternative_names,
            trusts=trusts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_alternative_names: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult']] = None,
             trusts: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if trusts is None:
            raise TypeError("Missing 'trusts' argument")

        _setter("subject_alternative_names", subject_alternative_names)
        _setter("trusts", trusts)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult']:
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter
    def trusts(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult']:
        return pulumi.get(self, "trusts")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        return pulumi.get(self, "exacts")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult(dict):
    def __init__(__self__, *,
                 acms: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult'],
                 files: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult']):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acms=acms,
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acms: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult']] = None,
             files: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acms is None:
            raise TypeError("Missing 'acms' argument")
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("acms", acms)
        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def acms(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult']:
        return pulumi.get(self, "acms")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult(dict):
    def __init__(__self__, *,
                 certificate_authority_arns: Sequence[str]):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_authority_arns=certificate_authority_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_authority_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_authority_arns is None and 'certificateAuthorityArns' in kwargs:
            certificate_authority_arns = kwargs['certificateAuthorityArns']
        if certificate_authority_arns is None:
            raise TypeError("Missing 'certificate_authority_arns' argument")

        _setter("certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Sequence[str]:
        return pulumi.get(self, "certificate_authority_arns")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecListenerResult(dict):
    def __init__(__self__, *,
                 connection_pools: Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolResult'],
                 health_checks: Sequence['outputs.GetVirtualNodeSpecListenerHealthCheckResult'],
                 outlier_detections: Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionResult'],
                 port_mappings: Sequence['outputs.GetVirtualNodeSpecListenerPortMappingResult'],
                 timeouts: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutResult'],
                 tls: Sequence['outputs.GetVirtualNodeSpecListenerTlResult']):
        GetVirtualNodeSpecListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_pools=connection_pools,
            health_checks=health_checks,
            outlier_detections=outlier_detections,
            port_mappings=port_mappings,
            timeouts=timeouts,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_pools: Optional[Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolResult']] = None,
             health_checks: Optional[Sequence['outputs.GetVirtualNodeSpecListenerHealthCheckResult']] = None,
             outlier_detections: Optional[Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionResult']] = None,
             port_mappings: Optional[Sequence['outputs.GetVirtualNodeSpecListenerPortMappingResult']] = None,
             timeouts: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutResult']] = None,
             tls: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_pools is None and 'connectionPools' in kwargs:
            connection_pools = kwargs['connectionPools']
        if connection_pools is None:
            raise TypeError("Missing 'connection_pools' argument")
        if health_checks is None and 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if health_checks is None:
            raise TypeError("Missing 'health_checks' argument")
        if outlier_detections is None and 'outlierDetections' in kwargs:
            outlier_detections = kwargs['outlierDetections']
        if outlier_detections is None:
            raise TypeError("Missing 'outlier_detections' argument")
        if port_mappings is None and 'portMappings' in kwargs:
            port_mappings = kwargs['portMappings']
        if port_mappings is None:
            raise TypeError("Missing 'port_mappings' argument")
        if timeouts is None:
            raise TypeError("Missing 'timeouts' argument")
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("connection_pools", connection_pools)
        _setter("health_checks", health_checks)
        _setter("outlier_detections", outlier_detections)
        _setter("port_mappings", port_mappings)
        _setter("timeouts", timeouts)
        _setter("tls", tls)

    @property
    @pulumi.getter(name="connectionPools")
    def connection_pools(self) -> Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolResult']:
        return pulumi.get(self, "connection_pools")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Sequence['outputs.GetVirtualNodeSpecListenerHealthCheckResult']:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="outlierDetections")
    def outlier_detections(self) -> Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionResult']:
        return pulumi.get(self, "outlier_detections")

    @property
    @pulumi.getter(name="portMappings")
    def port_mappings(self) -> Sequence['outputs.GetVirtualNodeSpecListenerPortMappingResult']:
        return pulumi.get(self, "port_mappings")

    @property
    @pulumi.getter
    def timeouts(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutResult']:
        return pulumi.get(self, "timeouts")

    @property
    @pulumi.getter
    def tls(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlResult']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetVirtualNodeSpecListenerConnectionPoolResult(dict):
    def __init__(__self__, *,
                 grpcs: Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolGrpcResult'],
                 http2s: Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttp2Result'],
                 https: Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttpResult'],
                 tcps: Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolTcpResult']):
        GetVirtualNodeSpecListenerConnectionPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpcs=grpcs,
            http2s=http2s,
            https=https,
            tcps=tcps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpcs: Optional[Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolGrpcResult']] = None,
             http2s: Optional[Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttp2Result']] = None,
             https: Optional[Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttpResult']] = None,
             tcps: Optional[Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolTcpResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpcs is None:
            raise TypeError("Missing 'grpcs' argument")
        if http2s is None:
            raise TypeError("Missing 'http2s' argument")
        if https is None:
            raise TypeError("Missing 'https' argument")
        if tcps is None:
            raise TypeError("Missing 'tcps' argument")

        _setter("grpcs", grpcs)
        _setter("http2s", http2s)
        _setter("https", https)
        _setter("tcps", tcps)

    @property
    @pulumi.getter
    def grpcs(self) -> Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolGrpcResult']:
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter
    def http2s(self) -> Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttp2Result']:
        return pulumi.get(self, "http2s")

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolHttpResult']:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def tcps(self) -> Sequence['outputs.GetVirtualNodeSpecListenerConnectionPoolTcpResult']:
        return pulumi.get(self, "tcps")


@pulumi.output_type
class GetVirtualNodeSpecListenerConnectionPoolGrpcResult(dict):
    def __init__(__self__, *,
                 max_requests: int):
        GetVirtualNodeSpecListenerConnectionPoolGrpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerConnectionPoolHttp2Result(dict):
    def __init__(__self__, *,
                 max_requests: int):
        GetVirtualNodeSpecListenerConnectionPoolHttp2Result._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_requests=max_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_requests is None and 'maxRequests' in kwargs:
            max_requests = kwargs['maxRequests']
        if max_requests is None:
            raise TypeError("Missing 'max_requests' argument")

        _setter("max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        return pulumi.get(self, "max_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerConnectionPoolHttpResult(dict):
    def __init__(__self__, *,
                 max_connections: int,
                 max_pending_requests: int):
        GetVirtualNodeSpecListenerConnectionPoolHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
            max_pending_requests=max_pending_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             max_pending_requests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")
        if max_pending_requests is None and 'maxPendingRequests' in kwargs:
            max_pending_requests = kwargs['maxPendingRequests']
        if max_pending_requests is None:
            raise TypeError("Missing 'max_pending_requests' argument")

        _setter("max_connections", max_connections)
        _setter("max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> int:
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerConnectionPoolTcpResult(dict):
    def __init__(__self__, *,
                 max_connections: int):
        GetVirtualNodeSpecListenerConnectionPoolTcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_connections=max_connections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_connections: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_connections is None:
            raise TypeError("Missing 'max_connections' argument")

        _setter("max_connections", max_connections)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")


@pulumi.output_type
class GetVirtualNodeSpecListenerHealthCheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: int,
                 interval_millis: int,
                 path: str,
                 port: int,
                 protocol: str,
                 timeout_millis: int,
                 unhealthy_threshold: int):
        GetVirtualNodeSpecListenerHealthCheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy_threshold=healthy_threshold,
            interval_millis=interval_millis,
            path=path,
            port=port,
            protocol=protocol,
            timeout_millis=timeout_millis,
            unhealthy_threshold=unhealthy_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy_threshold: Optional[int] = None,
             interval_millis: Optional[int] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             timeout_millis: Optional[int] = None,
             unhealthy_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if healthy_threshold is None:
            raise TypeError("Missing 'healthy_threshold' argument")
        if interval_millis is None and 'intervalMillis' in kwargs:
            interval_millis = kwargs['intervalMillis']
        if interval_millis is None:
            raise TypeError("Missing 'interval_millis' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if timeout_millis is None and 'timeoutMillis' in kwargs:
            timeout_millis = kwargs['timeoutMillis']
        if timeout_millis is None:
            raise TypeError("Missing 'timeout_millis' argument")
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']
        if unhealthy_threshold is None:
            raise TypeError("Missing 'unhealthy_threshold' argument")

        _setter("healthy_threshold", healthy_threshold)
        _setter("interval_millis", interval_millis)
        _setter("path", path)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("timeout_millis", timeout_millis)
        _setter("unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> int:
        return pulumi.get(self, "interval_millis")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> int:
        return pulumi.get(self, "timeout_millis")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetVirtualNodeSpecListenerOutlierDetectionResult(dict):
    def __init__(__self__, *,
                 base_ejection_durations: Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult'],
                 intervals: Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionIntervalResult'],
                 max_ejection_percent: int,
                 max_server_errors: int):
        GetVirtualNodeSpecListenerOutlierDetectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_ejection_durations=base_ejection_durations,
            intervals=intervals,
            max_ejection_percent=max_ejection_percent,
            max_server_errors=max_server_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_ejection_durations: Optional[Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult']] = None,
             intervals: Optional[Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionIntervalResult']] = None,
             max_ejection_percent: Optional[int] = None,
             max_server_errors: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if base_ejection_durations is None and 'baseEjectionDurations' in kwargs:
            base_ejection_durations = kwargs['baseEjectionDurations']
        if base_ejection_durations is None:
            raise TypeError("Missing 'base_ejection_durations' argument")
        if intervals is None:
            raise TypeError("Missing 'intervals' argument")
        if max_ejection_percent is None and 'maxEjectionPercent' in kwargs:
            max_ejection_percent = kwargs['maxEjectionPercent']
        if max_ejection_percent is None:
            raise TypeError("Missing 'max_ejection_percent' argument")
        if max_server_errors is None and 'maxServerErrors' in kwargs:
            max_server_errors = kwargs['maxServerErrors']
        if max_server_errors is None:
            raise TypeError("Missing 'max_server_errors' argument")

        _setter("base_ejection_durations", base_ejection_durations)
        _setter("intervals", intervals)
        _setter("max_ejection_percent", max_ejection_percent)
        _setter("max_server_errors", max_server_errors)

    @property
    @pulumi.getter(name="baseEjectionDurations")
    def base_ejection_durations(self) -> Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult']:
        return pulumi.get(self, "base_ejection_durations")

    @property
    @pulumi.getter
    def intervals(self) -> Sequence['outputs.GetVirtualNodeSpecListenerOutlierDetectionIntervalResult']:
        return pulumi.get(self, "intervals")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> int:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="maxServerErrors")
    def max_server_errors(self) -> int:
        return pulumi.get(self, "max_server_errors")


@pulumi.output_type
class GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerOutlierDetectionIntervalResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerOutlierDetectionIntervalResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerPortMappingResult(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        GetVirtualNodeSpecListenerPortMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutResult(dict):
    def __init__(__self__, *,
                 grpcs: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcResult'],
                 http2s: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2Result'],
                 https: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpResult'],
                 tcps: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpResult']):
        GetVirtualNodeSpecListenerTimeoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grpcs=grpcs,
            http2s=http2s,
            https=https,
            tcps=tcps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grpcs: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcResult']] = None,
             http2s: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2Result']] = None,
             https: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpResult']] = None,
             tcps: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if grpcs is None:
            raise TypeError("Missing 'grpcs' argument")
        if http2s is None:
            raise TypeError("Missing 'http2s' argument")
        if https is None:
            raise TypeError("Missing 'https' argument")
        if tcps is None:
            raise TypeError("Missing 'tcps' argument")

        _setter("grpcs", grpcs)
        _setter("http2s", http2s)
        _setter("https", https)
        _setter("tcps", tcps)

    @property
    @pulumi.getter
    def grpcs(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcResult']:
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter
    def http2s(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2Result']:
        return pulumi.get(self, "http2s")

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpResult']:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def tcps(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpResult']:
        return pulumi.get(self, "tcps")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutGrpcResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcIdleResult'],
                 per_requests: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult']):
        GetVirtualNodeSpecListenerTimeoutGrpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcIdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcIdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutGrpcIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutGrpcIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutGrpcPerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttp2Result(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2IdleResult'],
                 per_requests: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult']):
        GetVirtualNodeSpecListenerTimeoutHttp2Result._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2IdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2IdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttp2IdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutHttp2IdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutHttp2PerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttpResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpIdleResult'],
                 per_requests: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult']):
        GetVirtualNodeSpecListenerTimeoutHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
            per_requests=per_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpIdleResult']] = None,
             per_requests: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")
        if per_requests is None and 'perRequests' in kwargs:
            per_requests = kwargs['perRequests']
        if per_requests is None:
            raise TypeError("Missing 'per_requests' argument")

        _setter("idles", idles)
        _setter("per_requests", per_requests)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpIdleResult']:
        return pulumi.get(self, "idles")

    @property
    @pulumi.getter(name="perRequests")
    def per_requests(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult']:
        return pulumi.get(self, "per_requests")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttpIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutHttpIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutHttpPerRequestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutTcpResult(dict):
    def __init__(__self__, *,
                 idles: Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpIdleResult']):
        GetVirtualNodeSpecListenerTimeoutTcpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idles=idles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idles: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpIdleResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if idles is None:
            raise TypeError("Missing 'idles' argument")

        _setter("idles", idles)

    @property
    @pulumi.getter
    def idles(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTimeoutTcpIdleResult']:
        return pulumi.get(self, "idles")


@pulumi.output_type
class GetVirtualNodeSpecListenerTimeoutTcpIdleResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        GetVirtualNodeSpecListenerTimeoutTcpIdleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateResult'],
                 mode: str,
                 validations: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationResult']):
        GetVirtualNodeSpecListenerTlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            mode=mode,
            validations=validations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateResult']] = None,
             mode: Optional[str] = None,
             validations: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if validations is None:
            raise TypeError("Missing 'validations' argument")

        _setter("certificates", certificates)
        _setter("mode", mode)
        _setter("validations", validations)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationResult']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlCertificateResult(dict):
    def __init__(__self__, *,
                 acms: Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateAcmResult'],
                 files: Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateSdResult']):
        GetVirtualNodeSpecListenerTlCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acms=acms,
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acms: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateAcmResult']] = None,
             files: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acms is None:
            raise TypeError("Missing 'acms' argument")
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("acms", acms)
        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def acms(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateAcmResult']:
        return pulumi.get(self, "acms")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlCertificateSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlCertificateAcmResult(dict):
    def __init__(__self__, *,
                 certificate_arn: str):
        GetVirtualNodeSpecListenerTlCertificateAcmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_arn=certificate_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if certificate_arn is None:
            raise TypeError("Missing 'certificate_arn' argument")

        _setter("certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        return pulumi.get(self, "certificate_arn")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlCertificateFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str,
                 private_key: str):
        GetVirtualNodeSpecListenerTlCertificateFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate_chain", certificate_chain)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlCertificateSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecListenerTlCertificateSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationResult(dict):
    def __init__(__self__, *,
                 subject_alternative_names: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult'],
                 trusts: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustResult']):
        GetVirtualNodeSpecListenerTlValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_alternative_names=subject_alternative_names,
            trusts=trusts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_alternative_names: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult']] = None,
             trusts: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if trusts is None:
            raise TypeError("Missing 'trusts' argument")

        _setter("subject_alternative_names", subject_alternative_names)
        _setter("trusts", trusts)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult']:
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter
    def trusts(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustResult']:
        return pulumi.get(self, "trusts")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult']):
        GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matches is None:
            raise TypeError("Missing 'matches' argument")

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult(dict):
    def __init__(__self__, *,
                 exacts: Sequence[str]):
        GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exacts=exacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exacts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exacts is None:
            raise TypeError("Missing 'exacts' argument")

        _setter("exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> Sequence[str]:
        return pulumi.get(self, "exacts")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationTrustResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustFileResult'],
                 sds: Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustSdResult']):
        GetVirtualNodeSpecListenerTlValidationTrustResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
            sds=sds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustFileResult']] = None,
             sds: Optional[Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustSdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")
        if sds is None:
            raise TypeError("Missing 'sds' argument")

        _setter("files", files)
        _setter("sds", sds)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustFileResult']:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def sds(self) -> Sequence['outputs.GetVirtualNodeSpecListenerTlValidationTrustSdResult']:
        return pulumi.get(self, "sds")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationTrustFileResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetVirtualNodeSpecListenerTlValidationTrustFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_chain is None and 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']
        if certificate_chain is None:
            raise TypeError("Missing 'certificate_chain' argument")

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetVirtualNodeSpecListenerTlValidationTrustSdResult(dict):
    def __init__(__self__, *,
                 secret_name: str):
        GetVirtualNodeSpecListenerTlValidationTrustSdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_name=secret_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")

        _setter("secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetVirtualNodeSpecLoggingResult(dict):
    def __init__(__self__, *,
                 access_logs: Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogResult']):
        GetVirtualNodeSpecLoggingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_logs=access_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_logs: Optional[Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_logs is None and 'accessLogs' in kwargs:
            access_logs = kwargs['accessLogs']
        if access_logs is None:
            raise TypeError("Missing 'access_logs' argument")

        _setter("access_logs", access_logs)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogResult']:
        return pulumi.get(self, "access_logs")


@pulumi.output_type
class GetVirtualNodeSpecLoggingAccessLogResult(dict):
    def __init__(__self__, *,
                 files: Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileResult']):
        GetVirtualNodeSpecLoggingAccessLogResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            files=files,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             files: Optional[Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if files is None:
            raise TypeError("Missing 'files' argument")

        _setter("files", files)

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileResult']:
        return pulumi.get(self, "files")


@pulumi.output_type
class GetVirtualNodeSpecLoggingAccessLogFileResult(dict):
    def __init__(__self__, *,
                 formats: Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatResult'],
                 path: str):
        GetVirtualNodeSpecLoggingAccessLogFileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formats=formats,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formats: Optional[Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatResult']] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if formats is None:
            raise TypeError("Missing 'formats' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("formats", formats)
        _setter("path", path)

    @property
    @pulumi.getter
    def formats(self) -> Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatResult']:
        return pulumi.get(self, "formats")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")


@pulumi.output_type
class GetVirtualNodeSpecLoggingAccessLogFileFormatResult(dict):
    def __init__(__self__, *,
                 jsons: Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult'],
                 text: str):
        GetVirtualNodeSpecLoggingAccessLogFileFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsons=jsons,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsons: Optional[Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult']] = None,
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if jsons is None:
            raise TypeError("Missing 'jsons' argument")
        if text is None:
            raise TypeError("Missing 'text' argument")

        _setter("jsons", jsons)
        _setter("text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Sequence['outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult']:
        return pulumi.get(self, "jsons")

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")


@pulumi.output_type
class GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        GetVirtualNodeSpecLoggingAccessLogFileFormatJsonResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNodeSpecServiceDiscoveryResult(dict):
    def __init__(__self__, *,
                 aws_cloud_maps: Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult'],
                 dns: Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryDnResult']):
        GetVirtualNodeSpecServiceDiscoveryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_cloud_maps=aws_cloud_maps,
            dns=dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_cloud_maps: Optional[Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult']] = None,
             dns: Optional[Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryDnResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_cloud_maps is None and 'awsCloudMaps' in kwargs:
            aws_cloud_maps = kwargs['awsCloudMaps']
        if aws_cloud_maps is None:
            raise TypeError("Missing 'aws_cloud_maps' argument")
        if dns is None:
            raise TypeError("Missing 'dns' argument")

        _setter("aws_cloud_maps", aws_cloud_maps)
        _setter("dns", dns)

    @property
    @pulumi.getter(name="awsCloudMaps")
    def aws_cloud_maps(self) -> Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult']:
        return pulumi.get(self, "aws_cloud_maps")

    @property
    @pulumi.getter
    def dns(self) -> Sequence['outputs.GetVirtualNodeSpecServiceDiscoveryDnResult']:
        return pulumi.get(self, "dns")


@pulumi.output_type
class GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult(dict):
    def __init__(__self__, *,
                 attributes: Mapping[str, str],
                 namespace_name: str,
                 service_name: str):
        GetVirtualNodeSpecServiceDiscoveryAwsCloudMapResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attributes=attributes,
            namespace_name=namespace_name,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attributes: Optional[Mapping[str, str]] = None,
             namespace_name: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attributes is None:
            raise TypeError("Missing 'attributes' argument")
        if namespace_name is None and 'namespaceName' in kwargs:
            namespace_name = kwargs['namespaceName']
        if namespace_name is None:
            raise TypeError("Missing 'namespace_name' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("attributes", attributes)
        _setter("namespace_name", namespace_name)
        _setter("service_name", service_name)

    @property
    @pulumi.getter
    def attributes(self) -> Mapping[str, str]:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        return pulumi.get(self, "namespace_name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetVirtualNodeSpecServiceDiscoveryDnResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ip_preference: str,
                 response_type: str):
        GetVirtualNodeSpecServiceDiscoveryDnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ip_preference=ip_preference,
            response_type=response_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional[str] = None,
             ip_preference: Optional[str] = None,
             response_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hostname is None:
            raise TypeError("Missing 'hostname' argument")
        if ip_preference is None and 'ipPreference' in kwargs:
            ip_preference = kwargs['ipPreference']
        if ip_preference is None:
            raise TypeError("Missing 'ip_preference' argument")
        if response_type is None and 'responseType' in kwargs:
            response_type = kwargs['responseType']
        if response_type is None:
            raise TypeError("Missing 'response_type' argument")

        _setter("hostname", hostname)
        _setter("ip_preference", ip_preference)
        _setter("response_type", response_type)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipPreference")
    def ip_preference(self) -> str:
        return pulumi.get(self, "ip_preference")

    @property
    @pulumi.getter(name="responseType")
    def response_type(self) -> str:
        return pulumi.get(self, "response_type")


@pulumi.output_type
class GetVirtualRouterSpecResult(dict):
    def __init__(__self__, *,
                 listeners: Sequence['outputs.GetVirtualRouterSpecListenerResult']):
        GetVirtualRouterSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            listeners=listeners,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             listeners: Optional[Sequence['outputs.GetVirtualRouterSpecListenerResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if listeners is None:
            raise TypeError("Missing 'listeners' argument")

        _setter("listeners", listeners)

    @property
    @pulumi.getter
    def listeners(self) -> Sequence['outputs.GetVirtualRouterSpecListenerResult']:
        return pulumi.get(self, "listeners")


@pulumi.output_type
class GetVirtualRouterSpecListenerResult(dict):
    def __init__(__self__, *,
                 port_mappings: Sequence['outputs.GetVirtualRouterSpecListenerPortMappingResult']):
        GetVirtualRouterSpecListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_mappings=port_mappings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_mappings: Optional[Sequence['outputs.GetVirtualRouterSpecListenerPortMappingResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_mappings is None and 'portMappings' in kwargs:
            port_mappings = kwargs['portMappings']
        if port_mappings is None:
            raise TypeError("Missing 'port_mappings' argument")

        _setter("port_mappings", port_mappings)

    @property
    @pulumi.getter(name="portMappings")
    def port_mappings(self) -> Sequence['outputs.GetVirtualRouterSpecListenerPortMappingResult']:
        return pulumi.get(self, "port_mappings")


@pulumi.output_type
class GetVirtualRouterSpecListenerPortMappingResult(dict):
    def __init__(__self__, *,
                 port: int,
                 protocol: str):
        GetVirtualRouterSpecListenerPortMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetVirtualServiceSpecResult(dict):
    def __init__(__self__, *,
                 providers: Sequence['outputs.GetVirtualServiceSpecProviderResult']):
        GetVirtualServiceSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            providers=providers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             providers: Optional[Sequence['outputs.GetVirtualServiceSpecProviderResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if providers is None:
            raise TypeError("Missing 'providers' argument")

        _setter("providers", providers)

    @property
    @pulumi.getter
    def providers(self) -> Sequence['outputs.GetVirtualServiceSpecProviderResult']:
        return pulumi.get(self, "providers")


@pulumi.output_type
class GetVirtualServiceSpecProviderResult(dict):
    def __init__(__self__, *,
                 virtual_nodes: Sequence['outputs.GetVirtualServiceSpecProviderVirtualNodeResult'],
                 virtual_routers: Sequence['outputs.GetVirtualServiceSpecProviderVirtualRouterResult']):
        GetVirtualServiceSpecProviderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_nodes=virtual_nodes,
            virtual_routers=virtual_routers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_nodes: Optional[Sequence['outputs.GetVirtualServiceSpecProviderVirtualNodeResult']] = None,
             virtual_routers: Optional[Sequence['outputs.GetVirtualServiceSpecProviderVirtualRouterResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_nodes is None and 'virtualNodes' in kwargs:
            virtual_nodes = kwargs['virtualNodes']
        if virtual_nodes is None:
            raise TypeError("Missing 'virtual_nodes' argument")
        if virtual_routers is None and 'virtualRouters' in kwargs:
            virtual_routers = kwargs['virtualRouters']
        if virtual_routers is None:
            raise TypeError("Missing 'virtual_routers' argument")

        _setter("virtual_nodes", virtual_nodes)
        _setter("virtual_routers", virtual_routers)

    @property
    @pulumi.getter(name="virtualNodes")
    def virtual_nodes(self) -> Sequence['outputs.GetVirtualServiceSpecProviderVirtualNodeResult']:
        return pulumi.get(self, "virtual_nodes")

    @property
    @pulumi.getter(name="virtualRouters")
    def virtual_routers(self) -> Sequence['outputs.GetVirtualServiceSpecProviderVirtualRouterResult']:
        return pulumi.get(self, "virtual_routers")


@pulumi.output_type
class GetVirtualServiceSpecProviderVirtualNodeResult(dict):
    def __init__(__self__, *,
                 virtual_node_name: str):
        GetVirtualServiceSpecProviderVirtualNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_node_name=virtual_node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_node_name is None and 'virtualNodeName' in kwargs:
            virtual_node_name = kwargs['virtualNodeName']
        if virtual_node_name is None:
            raise TypeError("Missing 'virtual_node_name' argument")

        _setter("virtual_node_name", virtual_node_name)

    @property
    @pulumi.getter(name="virtualNodeName")
    def virtual_node_name(self) -> str:
        return pulumi.get(self, "virtual_node_name")


@pulumi.output_type
class GetVirtualServiceSpecProviderVirtualRouterResult(dict):
    def __init__(__self__, *,
                 virtual_router_name: str):
        GetVirtualServiceSpecProviderVirtualRouterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_router_name=virtual_router_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_router_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_router_name is None and 'virtualRouterName' in kwargs:
            virtual_router_name = kwargs['virtualRouterName']
        if virtual_router_name is None:
            raise TypeError("Missing 'virtual_router_name' argument")

        _setter("virtual_router_name", virtual_router_name)

    @property
    @pulumi.getter(name="virtualRouterName")
    def virtual_router_name(self) -> str:
        return pulumi.get(self, "virtual_router_name")


