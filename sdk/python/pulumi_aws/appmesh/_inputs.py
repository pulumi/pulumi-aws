# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GatewayRouteSpecArgs',
    'GatewayRouteSpecArgsDict',
    'GatewayRouteSpecGrpcRouteArgs',
    'GatewayRouteSpecGrpcRouteArgsDict',
    'GatewayRouteSpecGrpcRouteActionArgs',
    'GatewayRouteSpecGrpcRouteActionArgsDict',
    'GatewayRouteSpecGrpcRouteActionTargetArgs',
    'GatewayRouteSpecGrpcRouteActionTargetArgsDict',
    'GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs',
    'GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgsDict',
    'GatewayRouteSpecGrpcRouteMatchArgs',
    'GatewayRouteSpecGrpcRouteMatchArgsDict',
    'GatewayRouteSpecHttp2RouteArgs',
    'GatewayRouteSpecHttp2RouteArgsDict',
    'GatewayRouteSpecHttp2RouteActionArgs',
    'GatewayRouteSpecHttp2RouteActionArgsDict',
    'GatewayRouteSpecHttp2RouteActionRewriteArgs',
    'GatewayRouteSpecHttp2RouteActionRewriteArgsDict',
    'GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs',
    'GatewayRouteSpecHttp2RouteActionRewriteHostnameArgsDict',
    'GatewayRouteSpecHttp2RouteActionRewritePathArgs',
    'GatewayRouteSpecHttp2RouteActionRewritePathArgsDict',
    'GatewayRouteSpecHttp2RouteActionRewritePrefixArgs',
    'GatewayRouteSpecHttp2RouteActionRewritePrefixArgsDict',
    'GatewayRouteSpecHttp2RouteActionTargetArgs',
    'GatewayRouteSpecHttp2RouteActionTargetArgsDict',
    'GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs',
    'GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgsDict',
    'GatewayRouteSpecHttp2RouteMatchArgs',
    'GatewayRouteSpecHttp2RouteMatchArgsDict',
    'GatewayRouteSpecHttp2RouteMatchHeaderArgs',
    'GatewayRouteSpecHttp2RouteMatchHeaderArgsDict',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatchArgsDict',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs',
    'GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict',
    'GatewayRouteSpecHttp2RouteMatchHostnameArgs',
    'GatewayRouteSpecHttp2RouteMatchHostnameArgsDict',
    'GatewayRouteSpecHttp2RouteMatchPathArgs',
    'GatewayRouteSpecHttp2RouteMatchPathArgsDict',
    'GatewayRouteSpecHttp2RouteMatchQueryParameterArgs',
    'GatewayRouteSpecHttp2RouteMatchQueryParameterArgsDict',
    'GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs',
    'GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgsDict',
    'GatewayRouteSpecHttpRouteArgs',
    'GatewayRouteSpecHttpRouteArgsDict',
    'GatewayRouteSpecHttpRouteActionArgs',
    'GatewayRouteSpecHttpRouteActionArgsDict',
    'GatewayRouteSpecHttpRouteActionRewriteArgs',
    'GatewayRouteSpecHttpRouteActionRewriteArgsDict',
    'GatewayRouteSpecHttpRouteActionRewriteHostnameArgs',
    'GatewayRouteSpecHttpRouteActionRewriteHostnameArgsDict',
    'GatewayRouteSpecHttpRouteActionRewritePathArgs',
    'GatewayRouteSpecHttpRouteActionRewritePathArgsDict',
    'GatewayRouteSpecHttpRouteActionRewritePrefixArgs',
    'GatewayRouteSpecHttpRouteActionRewritePrefixArgsDict',
    'GatewayRouteSpecHttpRouteActionTargetArgs',
    'GatewayRouteSpecHttpRouteActionTargetArgsDict',
    'GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs',
    'GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgsDict',
    'GatewayRouteSpecHttpRouteMatchArgs',
    'GatewayRouteSpecHttpRouteMatchArgsDict',
    'GatewayRouteSpecHttpRouteMatchHeaderArgs',
    'GatewayRouteSpecHttpRouteMatchHeaderArgsDict',
    'GatewayRouteSpecHttpRouteMatchHeaderMatchArgs',
    'GatewayRouteSpecHttpRouteMatchHeaderMatchArgsDict',
    'GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs',
    'GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgsDict',
    'GatewayRouteSpecHttpRouteMatchHostnameArgs',
    'GatewayRouteSpecHttpRouteMatchHostnameArgsDict',
    'GatewayRouteSpecHttpRouteMatchPathArgs',
    'GatewayRouteSpecHttpRouteMatchPathArgsDict',
    'GatewayRouteSpecHttpRouteMatchQueryParameterArgs',
    'GatewayRouteSpecHttpRouteMatchQueryParameterArgsDict',
    'GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs',
    'GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgsDict',
    'MeshSpecArgs',
    'MeshSpecArgsDict',
    'MeshSpecEgressFilterArgs',
    'MeshSpecEgressFilterArgsDict',
    'MeshSpecServiceDiscoveryArgs',
    'MeshSpecServiceDiscoveryArgsDict',
    'RouteSpecArgs',
    'RouteSpecArgsDict',
    'RouteSpecGrpcRouteArgs',
    'RouteSpecGrpcRouteArgsDict',
    'RouteSpecGrpcRouteActionArgs',
    'RouteSpecGrpcRouteActionArgsDict',
    'RouteSpecGrpcRouteActionWeightedTargetArgs',
    'RouteSpecGrpcRouteActionWeightedTargetArgsDict',
    'RouteSpecGrpcRouteMatchArgs',
    'RouteSpecGrpcRouteMatchArgsDict',
    'RouteSpecGrpcRouteMatchMetadataArgs',
    'RouteSpecGrpcRouteMatchMetadataArgsDict',
    'RouteSpecGrpcRouteMatchMetadataMatchArgs',
    'RouteSpecGrpcRouteMatchMetadataMatchArgsDict',
    'RouteSpecGrpcRouteMatchMetadataMatchRangeArgs',
    'RouteSpecGrpcRouteMatchMetadataMatchRangeArgsDict',
    'RouteSpecGrpcRouteRetryPolicyArgs',
    'RouteSpecGrpcRouteRetryPolicyArgsDict',
    'RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs',
    'RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgsDict',
    'RouteSpecGrpcRouteTimeoutArgs',
    'RouteSpecGrpcRouteTimeoutArgsDict',
    'RouteSpecGrpcRouteTimeoutIdleArgs',
    'RouteSpecGrpcRouteTimeoutIdleArgsDict',
    'RouteSpecGrpcRouteTimeoutPerRequestArgs',
    'RouteSpecGrpcRouteTimeoutPerRequestArgsDict',
    'RouteSpecHttp2RouteArgs',
    'RouteSpecHttp2RouteArgsDict',
    'RouteSpecHttp2RouteActionArgs',
    'RouteSpecHttp2RouteActionArgsDict',
    'RouteSpecHttp2RouteActionWeightedTargetArgs',
    'RouteSpecHttp2RouteActionWeightedTargetArgsDict',
    'RouteSpecHttp2RouteMatchArgs',
    'RouteSpecHttp2RouteMatchArgsDict',
    'RouteSpecHttp2RouteMatchHeaderArgs',
    'RouteSpecHttp2RouteMatchHeaderArgsDict',
    'RouteSpecHttp2RouteMatchHeaderMatchArgs',
    'RouteSpecHttp2RouteMatchHeaderMatchArgsDict',
    'RouteSpecHttp2RouteMatchHeaderMatchRangeArgs',
    'RouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict',
    'RouteSpecHttp2RouteMatchPathArgs',
    'RouteSpecHttp2RouteMatchPathArgsDict',
    'RouteSpecHttp2RouteMatchQueryParameterArgs',
    'RouteSpecHttp2RouteMatchQueryParameterArgsDict',
    'RouteSpecHttp2RouteMatchQueryParameterMatchArgs',
    'RouteSpecHttp2RouteMatchQueryParameterMatchArgsDict',
    'RouteSpecHttp2RouteRetryPolicyArgs',
    'RouteSpecHttp2RouteRetryPolicyArgsDict',
    'RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs',
    'RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgsDict',
    'RouteSpecHttp2RouteTimeoutArgs',
    'RouteSpecHttp2RouteTimeoutArgsDict',
    'RouteSpecHttp2RouteTimeoutIdleArgs',
    'RouteSpecHttp2RouteTimeoutIdleArgsDict',
    'RouteSpecHttp2RouteTimeoutPerRequestArgs',
    'RouteSpecHttp2RouteTimeoutPerRequestArgsDict',
    'RouteSpecHttpRouteArgs',
    'RouteSpecHttpRouteArgsDict',
    'RouteSpecHttpRouteActionArgs',
    'RouteSpecHttpRouteActionArgsDict',
    'RouteSpecHttpRouteActionWeightedTargetArgs',
    'RouteSpecHttpRouteActionWeightedTargetArgsDict',
    'RouteSpecHttpRouteMatchArgs',
    'RouteSpecHttpRouteMatchArgsDict',
    'RouteSpecHttpRouteMatchHeaderArgs',
    'RouteSpecHttpRouteMatchHeaderArgsDict',
    'RouteSpecHttpRouteMatchHeaderMatchArgs',
    'RouteSpecHttpRouteMatchHeaderMatchArgsDict',
    'RouteSpecHttpRouteMatchHeaderMatchRangeArgs',
    'RouteSpecHttpRouteMatchHeaderMatchRangeArgsDict',
    'RouteSpecHttpRouteMatchPathArgs',
    'RouteSpecHttpRouteMatchPathArgsDict',
    'RouteSpecHttpRouteMatchQueryParameterArgs',
    'RouteSpecHttpRouteMatchQueryParameterArgsDict',
    'RouteSpecHttpRouteMatchQueryParameterMatchArgs',
    'RouteSpecHttpRouteMatchQueryParameterMatchArgsDict',
    'RouteSpecHttpRouteRetryPolicyArgs',
    'RouteSpecHttpRouteRetryPolicyArgsDict',
    'RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs',
    'RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgsDict',
    'RouteSpecHttpRouteTimeoutArgs',
    'RouteSpecHttpRouteTimeoutArgsDict',
    'RouteSpecHttpRouteTimeoutIdleArgs',
    'RouteSpecHttpRouteTimeoutIdleArgsDict',
    'RouteSpecHttpRouteTimeoutPerRequestArgs',
    'RouteSpecHttpRouteTimeoutPerRequestArgsDict',
    'RouteSpecTcpRouteArgs',
    'RouteSpecTcpRouteArgsDict',
    'RouteSpecTcpRouteActionArgs',
    'RouteSpecTcpRouteActionArgsDict',
    'RouteSpecTcpRouteActionWeightedTargetArgs',
    'RouteSpecTcpRouteActionWeightedTargetArgsDict',
    'RouteSpecTcpRouteMatchArgs',
    'RouteSpecTcpRouteMatchArgsDict',
    'RouteSpecTcpRouteTimeoutArgs',
    'RouteSpecTcpRouteTimeoutArgsDict',
    'RouteSpecTcpRouteTimeoutIdleArgs',
    'RouteSpecTcpRouteTimeoutIdleArgsDict',
    'VirtualGatewaySpecArgs',
    'VirtualGatewaySpecArgsDict',
    'VirtualGatewaySpecBackendDefaultsArgs',
    'VirtualGatewaySpecBackendDefaultsArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs',
    'VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict',
    'VirtualGatewaySpecListenerArgs',
    'VirtualGatewaySpecListenerArgsDict',
    'VirtualGatewaySpecListenerConnectionPoolArgs',
    'VirtualGatewaySpecListenerConnectionPoolArgsDict',
    'VirtualGatewaySpecListenerConnectionPoolGrpcArgs',
    'VirtualGatewaySpecListenerConnectionPoolGrpcArgsDict',
    'VirtualGatewaySpecListenerConnectionPoolHttp2Args',
    'VirtualGatewaySpecListenerConnectionPoolHttp2ArgsDict',
    'VirtualGatewaySpecListenerConnectionPoolHttpArgs',
    'VirtualGatewaySpecListenerConnectionPoolHttpArgsDict',
    'VirtualGatewaySpecListenerHealthCheckArgs',
    'VirtualGatewaySpecListenerHealthCheckArgsDict',
    'VirtualGatewaySpecListenerPortMappingArgs',
    'VirtualGatewaySpecListenerPortMappingArgsDict',
    'VirtualGatewaySpecListenerTlsArgs',
    'VirtualGatewaySpecListenerTlsArgsDict',
    'VirtualGatewaySpecListenerTlsCertificateArgs',
    'VirtualGatewaySpecListenerTlsCertificateArgsDict',
    'VirtualGatewaySpecListenerTlsCertificateAcmArgs',
    'VirtualGatewaySpecListenerTlsCertificateAcmArgsDict',
    'VirtualGatewaySpecListenerTlsCertificateFileArgs',
    'VirtualGatewaySpecListenerTlsCertificateFileArgsDict',
    'VirtualGatewaySpecListenerTlsCertificateSdsArgs',
    'VirtualGatewaySpecListenerTlsCertificateSdsArgsDict',
    'VirtualGatewaySpecListenerTlsValidationArgs',
    'VirtualGatewaySpecListenerTlsValidationArgsDict',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgsDict',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs',
    'VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict',
    'VirtualGatewaySpecListenerTlsValidationTrustArgs',
    'VirtualGatewaySpecListenerTlsValidationTrustArgsDict',
    'VirtualGatewaySpecListenerTlsValidationTrustFileArgs',
    'VirtualGatewaySpecListenerTlsValidationTrustFileArgsDict',
    'VirtualGatewaySpecListenerTlsValidationTrustSdsArgs',
    'VirtualGatewaySpecListenerTlsValidationTrustSdsArgsDict',
    'VirtualGatewaySpecLoggingArgs',
    'VirtualGatewaySpecLoggingArgsDict',
    'VirtualGatewaySpecLoggingAccessLogArgs',
    'VirtualGatewaySpecLoggingAccessLogArgsDict',
    'VirtualGatewaySpecLoggingAccessLogFileArgs',
    'VirtualGatewaySpecLoggingAccessLogFileArgsDict',
    'VirtualGatewaySpecLoggingAccessLogFileFormatArgs',
    'VirtualGatewaySpecLoggingAccessLogFileFormatArgsDict',
    'VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs',
    'VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgsDict',
    'VirtualNodeSpecArgs',
    'VirtualNodeSpecArgsDict',
    'VirtualNodeSpecBackendArgs',
    'VirtualNodeSpecBackendArgsDict',
    'VirtualNodeSpecBackendDefaultsArgs',
    'VirtualNodeSpecBackendDefaultsArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs',
    'VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict',
    'VirtualNodeSpecBackendVirtualServiceArgs',
    'VirtualNodeSpecBackendVirtualServiceArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgsDict',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs',
    'VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgsDict',
    'VirtualNodeSpecListenerArgs',
    'VirtualNodeSpecListenerArgsDict',
    'VirtualNodeSpecListenerConnectionPoolArgs',
    'VirtualNodeSpecListenerConnectionPoolArgsDict',
    'VirtualNodeSpecListenerConnectionPoolGrpcArgs',
    'VirtualNodeSpecListenerConnectionPoolGrpcArgsDict',
    'VirtualNodeSpecListenerConnectionPoolHttp2Args',
    'VirtualNodeSpecListenerConnectionPoolHttp2ArgsDict',
    'VirtualNodeSpecListenerConnectionPoolHttpArgs',
    'VirtualNodeSpecListenerConnectionPoolHttpArgsDict',
    'VirtualNodeSpecListenerConnectionPoolTcpArgs',
    'VirtualNodeSpecListenerConnectionPoolTcpArgsDict',
    'VirtualNodeSpecListenerHealthCheckArgs',
    'VirtualNodeSpecListenerHealthCheckArgsDict',
    'VirtualNodeSpecListenerOutlierDetectionArgs',
    'VirtualNodeSpecListenerOutlierDetectionArgsDict',
    'VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs',
    'VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgsDict',
    'VirtualNodeSpecListenerOutlierDetectionIntervalArgs',
    'VirtualNodeSpecListenerOutlierDetectionIntervalArgsDict',
    'VirtualNodeSpecListenerPortMappingArgs',
    'VirtualNodeSpecListenerPortMappingArgsDict',
    'VirtualNodeSpecListenerTimeoutArgs',
    'VirtualNodeSpecListenerTimeoutArgsDict',
    'VirtualNodeSpecListenerTimeoutGrpcArgs',
    'VirtualNodeSpecListenerTimeoutGrpcArgsDict',
    'VirtualNodeSpecListenerTimeoutGrpcIdleArgs',
    'VirtualNodeSpecListenerTimeoutGrpcIdleArgsDict',
    'VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs',
    'VirtualNodeSpecListenerTimeoutGrpcPerRequestArgsDict',
    'VirtualNodeSpecListenerTimeoutHttp2Args',
    'VirtualNodeSpecListenerTimeoutHttp2ArgsDict',
    'VirtualNodeSpecListenerTimeoutHttp2IdleArgs',
    'VirtualNodeSpecListenerTimeoutHttp2IdleArgsDict',
    'VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs',
    'VirtualNodeSpecListenerTimeoutHttp2PerRequestArgsDict',
    'VirtualNodeSpecListenerTimeoutHttpArgs',
    'VirtualNodeSpecListenerTimeoutHttpArgsDict',
    'VirtualNodeSpecListenerTimeoutHttpIdleArgs',
    'VirtualNodeSpecListenerTimeoutHttpIdleArgsDict',
    'VirtualNodeSpecListenerTimeoutHttpPerRequestArgs',
    'VirtualNodeSpecListenerTimeoutHttpPerRequestArgsDict',
    'VirtualNodeSpecListenerTimeoutTcpArgs',
    'VirtualNodeSpecListenerTimeoutTcpArgsDict',
    'VirtualNodeSpecListenerTimeoutTcpIdleArgs',
    'VirtualNodeSpecListenerTimeoutTcpIdleArgsDict',
    'VirtualNodeSpecListenerTlsArgs',
    'VirtualNodeSpecListenerTlsArgsDict',
    'VirtualNodeSpecListenerTlsCertificateArgs',
    'VirtualNodeSpecListenerTlsCertificateArgsDict',
    'VirtualNodeSpecListenerTlsCertificateAcmArgs',
    'VirtualNodeSpecListenerTlsCertificateAcmArgsDict',
    'VirtualNodeSpecListenerTlsCertificateFileArgs',
    'VirtualNodeSpecListenerTlsCertificateFileArgsDict',
    'VirtualNodeSpecListenerTlsCertificateSdsArgs',
    'VirtualNodeSpecListenerTlsCertificateSdsArgsDict',
    'VirtualNodeSpecListenerTlsValidationArgs',
    'VirtualNodeSpecListenerTlsValidationArgsDict',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgsDict',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs',
    'VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict',
    'VirtualNodeSpecListenerTlsValidationTrustArgs',
    'VirtualNodeSpecListenerTlsValidationTrustArgsDict',
    'VirtualNodeSpecListenerTlsValidationTrustFileArgs',
    'VirtualNodeSpecListenerTlsValidationTrustFileArgsDict',
    'VirtualNodeSpecListenerTlsValidationTrustSdsArgs',
    'VirtualNodeSpecListenerTlsValidationTrustSdsArgsDict',
    'VirtualNodeSpecLoggingArgs',
    'VirtualNodeSpecLoggingArgsDict',
    'VirtualNodeSpecLoggingAccessLogArgs',
    'VirtualNodeSpecLoggingAccessLogArgsDict',
    'VirtualNodeSpecLoggingAccessLogFileArgs',
    'VirtualNodeSpecLoggingAccessLogFileArgsDict',
    'VirtualNodeSpecLoggingAccessLogFileFormatArgs',
    'VirtualNodeSpecLoggingAccessLogFileFormatArgsDict',
    'VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs',
    'VirtualNodeSpecLoggingAccessLogFileFormatJsonArgsDict',
    'VirtualNodeSpecServiceDiscoveryArgs',
    'VirtualNodeSpecServiceDiscoveryArgsDict',
    'VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs',
    'VirtualNodeSpecServiceDiscoveryAwsCloudMapArgsDict',
    'VirtualNodeSpecServiceDiscoveryDnsArgs',
    'VirtualNodeSpecServiceDiscoveryDnsArgsDict',
    'VirtualRouterSpecArgs',
    'VirtualRouterSpecArgsDict',
    'VirtualRouterSpecListenerArgs',
    'VirtualRouterSpecListenerArgsDict',
    'VirtualRouterSpecListenerPortMappingArgs',
    'VirtualRouterSpecListenerPortMappingArgsDict',
    'VirtualServiceSpecArgs',
    'VirtualServiceSpecArgsDict',
    'VirtualServiceSpecProviderArgs',
    'VirtualServiceSpecProviderArgsDict',
    'VirtualServiceSpecProviderVirtualNodeArgs',
    'VirtualServiceSpecProviderVirtualNodeArgsDict',
    'VirtualServiceSpecProviderVirtualRouterArgs',
    'VirtualServiceSpecProviderVirtualRouterArgsDict',
]

MYPY = False

if not MYPY:
    class GatewayRouteSpecArgsDict(TypedDict):
        grpc_route: NotRequired[pulumi.Input['GatewayRouteSpecGrpcRouteArgsDict']]
        """
        Specification of a gRPC gateway route.
        """
        http2_route: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteArgsDict']]
        """
        Specification of an HTTP/2 gateway route.
        """
        http_route: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteArgsDict']]
        """
        Specification of an HTTP gateway route.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority for the gateway route, between `0` and `1000`.
        """
elif False:
    GatewayRouteSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecArgs:
    def __init__(__self__, *,
                 grpc_route: Optional[pulumi.Input['GatewayRouteSpecGrpcRouteArgs']] = None,
                 http2_route: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteArgs']] = None,
                 http_route: Optional[pulumi.Input['GatewayRouteSpecHttpRouteArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['GatewayRouteSpecGrpcRouteArgs'] grpc_route: Specification of a gRPC gateway route.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteArgs'] http2_route: Specification of an HTTP/2 gateway route.
        :param pulumi.Input['GatewayRouteSpecHttpRouteArgs'] http_route: Specification of an HTTP gateway route.
        :param pulumi.Input[int] priority: Priority for the gateway route, between `0` and `1000`.
        """
        if grpc_route is not None:
            pulumi.set(__self__, "grpc_route", grpc_route)
        if http2_route is not None:
            pulumi.set(__self__, "http2_route", http2_route)
        if http_route is not None:
            pulumi.set(__self__, "http_route", http_route)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional[pulumi.Input['GatewayRouteSpecGrpcRouteArgs']]:
        """
        Specification of a gRPC gateway route.
        """
        return pulumi.get(self, "grpc_route")

    @grpc_route.setter
    def grpc_route(self, value: Optional[pulumi.Input['GatewayRouteSpecGrpcRouteArgs']]):
        pulumi.set(self, "grpc_route", value)

    @property
    @pulumi.getter(name="http2Route")
    def http2_route(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteArgs']]:
        """
        Specification of an HTTP/2 gateway route.
        """
        return pulumi.get(self, "http2_route")

    @http2_route.setter
    def http2_route(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteArgs']]):
        pulumi.set(self, "http2_route", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteArgs']]:
        """
        Specification of an HTTP gateway route.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteArgs']]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority for the gateway route, between `0` and `1000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class GatewayRouteSpecGrpcRouteArgsDict(TypedDict):
        action: pulumi.Input['GatewayRouteSpecGrpcRouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: pulumi.Input['GatewayRouteSpecGrpcRouteMatchArgsDict']
        """
        Criteria for determining a request match.
        """
elif False:
    GatewayRouteSpecGrpcRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecGrpcRouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GatewayRouteSpecGrpcRouteActionArgs'],
                 match: pulumi.Input['GatewayRouteSpecGrpcRouteMatchArgs']):
        """
        :param pulumi.Input['GatewayRouteSpecGrpcRouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['GatewayRouteSpecGrpcRouteMatchArgs'] match: Criteria for determining a request match.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GatewayRouteSpecGrpcRouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GatewayRouteSpecGrpcRouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['GatewayRouteSpecGrpcRouteMatchArgs']:
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['GatewayRouteSpecGrpcRouteMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecGrpcRouteActionArgsDict(TypedDict):
        target: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetArgsDict']
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
elif False:
    GatewayRouteSpecGrpcRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecGrpcRouteActionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetArgs']):
        """
        :param pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetArgs'] target: Target that traffic is routed to when a request matches the gateway route.
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetArgs']:
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class GatewayRouteSpecGrpcRouteActionTargetArgsDict(TypedDict):
        virtual_service: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgsDict']
        """
        Virtual service gateway route target.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
elif False:
    GatewayRouteSpecGrpcRouteActionTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecGrpcRouteActionTargetArgs:
    def __init__(__self__, *,
                 virtual_service: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs'],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs'] virtual_service: Virtual service gateway route target.
        :param pulumi.Input[int] port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        pulumi.set(__self__, "virtual_service", virtual_service)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs']:
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @virtual_service.setter
    def virtual_service(self, value: pulumi.Input['GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs']):
        pulumi.set(self, "virtual_service", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgsDict(TypedDict):
        virtual_service_name: pulumi.Input[str]
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
elif False:
    GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecGrpcRouteActionTargetVirtualServiceArgs:
    def __init__(__self__, *,
                 virtual_service_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")

    @virtual_service_name.setter
    def virtual_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_service_name", value)


if not MYPY:
    class GatewayRouteSpecGrpcRouteMatchArgsDict(TypedDict):
        service_name: pulumi.Input[str]
        """
        Fully qualified domain name for the service to match from the request.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
elif False:
    GatewayRouteSpecGrpcRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecGrpcRouteMatchArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] service_name: Fully qualified domain name for the service to match from the request.
        :param pulumi.Input[int] port: The port number to match from the request.
        """
        pulumi.set(__self__, "service_name", service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Fully qualified domain name for the service to match from the request.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteArgsDict(TypedDict):
        action: pulumi.Input['GatewayRouteSpecHttp2RouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: pulumi.Input['GatewayRouteSpecHttp2RouteMatchArgsDict']
        """
        Criteria for determining a request match.
        """
elif False:
    GatewayRouteSpecHttp2RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GatewayRouteSpecHttp2RouteActionArgs'],
                 match: pulumi.Input['GatewayRouteSpecHttp2RouteMatchArgs']):
        """
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchArgs'] match: Criteria for determining a request match.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GatewayRouteSpecHttp2RouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GatewayRouteSpecHttp2RouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['GatewayRouteSpecHttp2RouteMatchArgs']:
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['GatewayRouteSpecHttp2RouteMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionArgsDict(TypedDict):
        target: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetArgsDict']
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        rewrite: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteArgsDict']]
        """
        Gateway route action to rewrite.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetArgs'],
                 rewrite: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteArgs']] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetArgs'] target: Target that traffic is routed to when a request matches the gateway route.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteArgs'] rewrite: Gateway route action to rewrite.
        """
        pulumi.set(__self__, "target", target)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetArgs']:
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetArgs']):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def rewrite(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteArgs']]:
        """
        Gateway route action to rewrite.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteArgs']]):
        pulumi.set(self, "rewrite", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionRewriteArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteHostnameArgsDict']]
        """
        Host name to rewrite.
        """
        path: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePathArgsDict']]
        """
        Exact path to rewrite.
        """
        prefix: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePrefixArgsDict']]
        """
        Specified beginning characters to rewrite.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionRewriteArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs']] = None,
                 path: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePathArgs']] = None,
                 prefix: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePrefixArgs']] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs'] hostname: Host name to rewrite.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePathArgs'] path: Exact path to rewrite.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePrefixArgs'] prefix: Specified beginning characters to rewrite.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs']]:
        """
        Host name to rewrite.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePathArgs']]:
        """
        Exact path to rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePrefixArgs']]:
        """
        Specified beginning characters to rewrite.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteActionRewritePrefixArgs']]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionRewriteHostnameArgsDict(TypedDict):
        default_target_hostname: pulumi.Input[str]
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionRewriteHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionRewriteHostnameArgs:
    def __init__(__self__, *,
                 default_target_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_target_hostname: Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        pulumi.set(__self__, "default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> pulumi.Input[str]:
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_target_hostname")

    @default_target_hostname.setter
    def default_target_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_target_hostname", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionRewritePathArgsDict(TypedDict):
        exact: pulumi.Input[str]
        """
        The exact path to match on.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionRewritePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionRewritePathArgs:
    def __init__(__self__, *,
                 exact: pulumi.Input[str]):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        """
        pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> pulumi.Input[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: pulumi.Input[str]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionRewritePrefixArgsDict(TypedDict):
        default_prefix: NotRequired[pulumi.Input[str]]
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value used to replace the incoming route prefix when rewritten.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionRewritePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionRewritePrefixArgs:
    def __init__(__self__, *,
                 default_prefix: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_prefix: Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[str] value: Value used to replace the incoming route prefix when rewritten.
        """
        if default_prefix is not None:
            pulumi.set(__self__, "default_prefix", default_prefix)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_prefix")

    @default_prefix.setter
    def default_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_prefix", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value used to replace the incoming route prefix when rewritten.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionTargetArgsDict(TypedDict):
        virtual_service: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgsDict']
        """
        Virtual service gateway route target.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionTargetArgs:
    def __init__(__self__, *,
                 virtual_service: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs'],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs'] virtual_service: Virtual service gateway route target.
        :param pulumi.Input[int] port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        pulumi.set(__self__, "virtual_service", virtual_service)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs']:
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @virtual_service.setter
    def virtual_service(self, value: pulumi.Input['GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs']):
        pulumi.set(self, "virtual_service", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgsDict(TypedDict):
        virtual_service_name: pulumi.Input[str]
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
elif False:
    GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteActionTargetVirtualServiceArgs:
    def __init__(__self__, *,
                 virtual_service_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")

    @virtual_service_name.setter
    def virtual_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_service_name", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderArgsDict']]]]
        """
        Client request headers to match on.
        """
        hostname: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHostnameArgsDict']]
        """
        Host name to match on.
        """
        path: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteMatchPathArgsDict']]
        """
        Client request path to match on.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        """
        query_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterArgsDict']]]]
        """
        Client request query parameters to match on.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderArgs']]]] = None,
                 hostname: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHostnameArgs']] = None,
                 path: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderArgs']]] headers: Client request headers to match on.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchHostnameArgs'] hostname: Host name to match on.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchPathArgs'] path: Client request path to match on.
        :param pulumi.Input[int] port: The port number to match from the request.
        :param pulumi.Input[str] prefix: Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterArgs']]] query_parameters: Client request query parameters to match on.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderArgs']]]]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHostnameArgs']]:
        """
        Host name to match on.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchPathArgs']]:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterArgs']]]]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterArgs']]]]):
        pulumi.set(self, "query_parameters", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        invert: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        match: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchArgsDict']]
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 invert: Optional[pulumi.Input[bool]] = None,
                 match: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the HTTP header in the client request that will be matched on.
        :param pulumi.Input[bool] invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs'] match: Method and value to match the header value sent with a request. Specify one match method.
        """
        pulumi.set(__self__, "name", name)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs']]:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchHeaderMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must match the specified value exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must begin with the specified characters.
        """
        range: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict']]
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must include the specified characters.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must end with the specified characters.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 range: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs']] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Header value sent by the client must match the specified value exactly.
        :param pulumi.Input[str] prefix: Header value sent by the client must begin with the specified characters.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs'] range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param pulumi.Input[str] regex: Header value sent by the client must include the specified characters.
        :param pulumi.Input[str] suffix: Header value sent by the client must end with the specified characters.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs']]:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range.
        """
        start: pulumi.Input[int]
        """
        Start of the range.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchHeaderMatchRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range.
        :param pulumi.Input[int] start: Start of the range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchHostnameArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Exact host name to match on.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Specified ending characters of the host name to match on.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchHostnameArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Exact host name to match on.
        :param pulumi.Input[str] suffix: Specified ending characters of the host name to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Exact host name to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Specified ending characters of the host name to match on.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchPathArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact path to match on.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        The regex used to match the path.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchPathArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        :param pulumi.Input[str] regex: The regex used to match the path.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchQueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the query parameter that will be matched on.
        """
        match: NotRequired[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgsDict']]
        """
        The query parameter to match on.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 match: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the query parameter that will be matched on.
        :param pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs'] match: The query parameter to match on.
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs']]:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact query parameter to match on.
        """
elif False:
    GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttp2RouteMatchQueryParameterMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact query parameter to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact query parameter to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteArgsDict(TypedDict):
        action: pulumi.Input['GatewayRouteSpecHttpRouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: pulumi.Input['GatewayRouteSpecHttpRouteMatchArgsDict']
        """
        Criteria for determining a request match.
        """
elif False:
    GatewayRouteSpecHttpRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GatewayRouteSpecHttpRouteActionArgs'],
                 match: pulumi.Input['GatewayRouteSpecHttpRouteMatchArgs']):
        """
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchArgs'] match: Criteria for determining a request match.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GatewayRouteSpecHttpRouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GatewayRouteSpecHttpRouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['GatewayRouteSpecHttpRouteMatchArgs']:
        """
        Criteria for determining a request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['GatewayRouteSpecHttpRouteMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionArgsDict(TypedDict):
        target: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetArgsDict']
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        rewrite: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteArgsDict']]
        """
        Gateway route action to rewrite.
        """
elif False:
    GatewayRouteSpecHttpRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetArgs'],
                 rewrite: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteArgs']] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionTargetArgs'] target: Target that traffic is routed to when a request matches the gateway route.
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteArgs'] rewrite: Gateway route action to rewrite.
        """
        pulumi.set(__self__, "target", target)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input['GatewayRouteSpecHttpRouteActionTargetArgs']:
        """
        Target that traffic is routed to when a request matches the gateway route.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetArgs']):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def rewrite(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteArgs']]:
        """
        Gateway route action to rewrite.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteArgs']]):
        pulumi.set(self, "rewrite", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionRewriteArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteHostnameArgsDict']]
        """
        Host name to rewrite.
        """
        path: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePathArgsDict']]
        """
        Exact path to rewrite.
        """
        prefix: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePrefixArgsDict']]
        """
        Specified beginning characters to rewrite.
        """
elif False:
    GatewayRouteSpecHttpRouteActionRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionRewriteArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteHostnameArgs']] = None,
                 path: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePathArgs']] = None,
                 prefix: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePrefixArgs']] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteHostnameArgs'] hostname: Host name to rewrite.
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePathArgs'] path: Exact path to rewrite.
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePrefixArgs'] prefix: Specified beginning characters to rewrite.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteHostnameArgs']]:
        """
        Host name to rewrite.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewriteHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePathArgs']]:
        """
        Exact path to rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePrefixArgs']]:
        """
        Specified beginning characters to rewrite.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteActionRewritePrefixArgs']]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionRewriteHostnameArgsDict(TypedDict):
        default_target_hostname: pulumi.Input[str]
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
elif False:
    GatewayRouteSpecHttpRouteActionRewriteHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionRewriteHostnameArgs:
    def __init__(__self__, *,
                 default_target_hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_target_hostname: Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        pulumi.set(__self__, "default_target_hostname", default_target_hostname)

    @property
    @pulumi.getter(name="defaultTargetHostname")
    def default_target_hostname(self) -> pulumi.Input[str]:
        """
        Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_target_hostname")

    @default_target_hostname.setter
    def default_target_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_target_hostname", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionRewritePathArgsDict(TypedDict):
        exact: pulumi.Input[str]
        """
        The exact path to match on.
        """
elif False:
    GatewayRouteSpecHttpRouteActionRewritePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionRewritePathArgs:
    def __init__(__self__, *,
                 exact: pulumi.Input[str]):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        """
        pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> pulumi.Input[str]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: pulumi.Input[str]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionRewritePrefixArgsDict(TypedDict):
        default_prefix: NotRequired[pulumi.Input[str]]
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value used to replace the incoming route prefix when rewritten.
        """
elif False:
    GatewayRouteSpecHttpRouteActionRewritePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionRewritePrefixArgs:
    def __init__(__self__, *,
                 default_prefix: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_prefix: Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[str] value: Value used to replace the incoming route prefix when rewritten.
        """
        if default_prefix is not None:
            pulumi.set(__self__, "default_prefix", default_prefix)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="defaultPrefix")
    def default_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "default_prefix")

    @default_prefix.setter
    def default_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_prefix", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value used to replace the incoming route prefix when rewritten.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionTargetArgsDict(TypedDict):
        virtual_service: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgsDict']
        """
        Virtual service gateway route target.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
elif False:
    GatewayRouteSpecHttpRouteActionTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionTargetArgs:
    def __init__(__self__, *,
                 virtual_service: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs'],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs'] virtual_service: Virtual service gateway route target.
        :param pulumi.Input[int] port: The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        pulumi.set(__self__, "virtual_service", virtual_service)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> pulumi.Input['GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs']:
        """
        Virtual service gateway route target.
        """
        return pulumi.get(self, "virtual_service")

    @virtual_service.setter
    def virtual_service(self, value: pulumi.Input['GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs']):
        pulumi.set(self, "virtual_service", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgsDict(TypedDict):
        virtual_service_name: pulumi.Input[str]
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
elif False:
    GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteActionTargetVirtualServiceArgs:
    def __init__(__self__, *,
                 virtual_service_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] virtual_service_name: Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "virtual_service_name", virtual_service_name)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")

    @virtual_service_name.setter
    def virtual_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_service_name", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderArgsDict']]]]
        """
        Client request headers to match on.
        """
        hostname: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteMatchHostnameArgsDict']]
        """
        Host name to match on.
        """
        path: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteMatchPathArgsDict']]
        """
        Client request path to match on.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        """
        query_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterArgsDict']]]]
        """
        Client request query parameters to match on.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderArgs']]]] = None,
                 hostname: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHostnameArgs']] = None,
                 path: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderArgs']]] headers: Client request headers to match on.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchHostnameArgs'] hostname: Host name to match on.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchPathArgs'] path: Client request path to match on.
        :param pulumi.Input[int] port: The port number to match from the request.
        :param pulumi.Input[str] prefix: Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterArgs']]] query_parameters: Client request query parameters to match on.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderArgs']]]]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHostnameArgs']]:
        """
        Host name to match on.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchPathArgs']]:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterArgs']]]]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterArgs']]]]):
        pulumi.set(self, "query_parameters", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        invert: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        match: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchArgsDict']]
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 invert: Optional[pulumi.Input[bool]] = None,
                 match: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the HTTP header in the client request that will be matched on.
        :param pulumi.Input[bool] invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchArgs'] match: Method and value to match the header value sent with a request. Specify one match method.
        """
        pulumi.set(__self__, "name", name)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchArgs']]:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchHeaderMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must match the specified value exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must begin with the specified characters.
        """
        range: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgsDict']]
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must include the specified characters.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must end with the specified characters.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 range: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs']] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Header value sent by the client must match the specified value exactly.
        :param pulumi.Input[str] prefix: Header value sent by the client must begin with the specified characters.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs'] range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param pulumi.Input[str] regex: Header value sent by the client must include the specified characters.
        :param pulumi.Input[str] suffix: Header value sent by the client must end with the specified characters.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs']]:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range.
        """
        start: pulumi.Input[int]
        """
        Start of the range.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchHeaderMatchRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range.
        :param pulumi.Input[int] start: Start of the range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchHostnameArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Exact host name to match on.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Specified ending characters of the host name to match on.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchHostnameArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Exact host name to match on.
        :param pulumi.Input[str] suffix: Specified ending characters of the host name to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Exact host name to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Specified ending characters of the host name to match on.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchPathArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact path to match on.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        The regex used to match the path.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchPathArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        :param pulumi.Input[str] regex: The regex used to match the path.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchQueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the query parameter that will be matched on.
        """
        match: NotRequired[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgsDict']]
        """
        The query parameter to match on.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 match: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the query parameter that will be matched on.
        :param pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs'] match: The query parameter to match on.
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs']]:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact query parameter to match on.
        """
elif False:
    GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouteSpecHttpRouteMatchQueryParameterMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact query parameter to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact query parameter to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class MeshSpecArgsDict(TypedDict):
        egress_filter: NotRequired[pulumi.Input['MeshSpecEgressFilterArgsDict']]
        """
        Egress filter rules for the service mesh.
        """
        service_discovery: NotRequired[pulumi.Input['MeshSpecServiceDiscoveryArgsDict']]
        """
        The service discovery information for the service mesh.
        """
elif False:
    MeshSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshSpecArgs:
    def __init__(__self__, *,
                 egress_filter: Optional[pulumi.Input['MeshSpecEgressFilterArgs']] = None,
                 service_discovery: Optional[pulumi.Input['MeshSpecServiceDiscoveryArgs']] = None):
        """
        :param pulumi.Input['MeshSpecEgressFilterArgs'] egress_filter: Egress filter rules for the service mesh.
        :param pulumi.Input['MeshSpecServiceDiscoveryArgs'] service_discovery: The service discovery information for the service mesh.
        """
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if service_discovery is not None:
            pulumi.set(__self__, "service_discovery", service_discovery)

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input['MeshSpecEgressFilterArgs']]:
        """
        Egress filter rules for the service mesh.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input['MeshSpecEgressFilterArgs']]):
        pulumi.set(self, "egress_filter", value)

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional[pulumi.Input['MeshSpecServiceDiscoveryArgs']]:
        """
        The service discovery information for the service mesh.
        """
        return pulumi.get(self, "service_discovery")

    @service_discovery.setter
    def service_discovery(self, value: Optional[pulumi.Input['MeshSpecServiceDiscoveryArgs']]):
        pulumi.set(self, "service_discovery", value)


if not MYPY:
    class MeshSpecEgressFilterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Egress filter type. By default, the type is `DROP_ALL`. Valid values are `ALLOW_ALL` and `DROP_ALL`.
        """
elif False:
    MeshSpecEgressFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshSpecEgressFilterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Egress filter type. By default, the type is `DROP_ALL`. Valid values are `ALLOW_ALL` and `DROP_ALL`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Egress filter type. By default, the type is `DROP_ALL`. Valid values are `ALLOW_ALL` and `DROP_ALL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MeshSpecServiceDiscoveryArgsDict(TypedDict):
        ip_preference: NotRequired[pulumi.Input[str]]
        """
        The IP version to use to control traffic within the mesh. Valid values are `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, and `IPv6_ONLY`.
        """
elif False:
    MeshSpecServiceDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeshSpecServiceDiscoveryArgs:
    def __init__(__self__, *,
                 ip_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_preference: The IP version to use to control traffic within the mesh. Valid values are `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, and `IPv6_ONLY`.
        """
        if ip_preference is not None:
            pulumi.set(__self__, "ip_preference", ip_preference)

    @property
    @pulumi.getter(name="ipPreference")
    def ip_preference(self) -> Optional[pulumi.Input[str]]:
        """
        The IP version to use to control traffic within the mesh. Valid values are `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, and `IPv6_ONLY`.
        """
        return pulumi.get(self, "ip_preference")

    @ip_preference.setter
    def ip_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_preference", value)


if not MYPY:
    class RouteSpecArgsDict(TypedDict):
        grpc_route: NotRequired[pulumi.Input['RouteSpecGrpcRouteArgsDict']]
        """
        GRPC routing information for the route.
        """
        http2_route: NotRequired[pulumi.Input['RouteSpecHttp2RouteArgsDict']]
        """
        HTTP/2 routing information for the route.
        """
        http_route: NotRequired[pulumi.Input['RouteSpecHttpRouteArgsDict']]
        """
        HTTP routing information for the route.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority for the route, between `0` and `1000`.
        Routes are matched based on the specified value, where `0` is the highest priority.
        """
        tcp_route: NotRequired[pulumi.Input['RouteSpecTcpRouteArgsDict']]
        """
        TCP routing information for the route.
        """
elif False:
    RouteSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecArgs:
    def __init__(__self__, *,
                 grpc_route: Optional[pulumi.Input['RouteSpecGrpcRouteArgs']] = None,
                 http2_route: Optional[pulumi.Input['RouteSpecHttp2RouteArgs']] = None,
                 http_route: Optional[pulumi.Input['RouteSpecHttpRouteArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 tcp_route: Optional[pulumi.Input['RouteSpecTcpRouteArgs']] = None):
        """
        :param pulumi.Input['RouteSpecGrpcRouteArgs'] grpc_route: GRPC routing information for the route.
        :param pulumi.Input['RouteSpecHttp2RouteArgs'] http2_route: HTTP/2 routing information for the route.
        :param pulumi.Input['RouteSpecHttpRouteArgs'] http_route: HTTP routing information for the route.
        :param pulumi.Input[int] priority: Priority for the route, between `0` and `1000`.
               Routes are matched based on the specified value, where `0` is the highest priority.
        :param pulumi.Input['RouteSpecTcpRouteArgs'] tcp_route: TCP routing information for the route.
        """
        if grpc_route is not None:
            pulumi.set(__self__, "grpc_route", grpc_route)
        if http2_route is not None:
            pulumi.set(__self__, "http2_route", http2_route)
        if http_route is not None:
            pulumi.set(__self__, "http_route", http_route)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if tcp_route is not None:
            pulumi.set(__self__, "tcp_route", tcp_route)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteArgs']]:
        """
        GRPC routing information for the route.
        """
        return pulumi.get(self, "grpc_route")

    @grpc_route.setter
    def grpc_route(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteArgs']]):
        pulumi.set(self, "grpc_route", value)

    @property
    @pulumi.getter(name="http2Route")
    def http2_route(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteArgs']]:
        """
        HTTP/2 routing information for the route.
        """
        return pulumi.get(self, "http2_route")

    @http2_route.setter
    def http2_route(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteArgs']]):
        pulumi.set(self, "http2_route", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional[pulumi.Input['RouteSpecHttpRouteArgs']]:
        """
        HTTP routing information for the route.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: Optional[pulumi.Input['RouteSpecHttpRouteArgs']]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority for the route, between `0` and `1000`.
        Routes are matched based on the specified value, where `0` is the highest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="tcpRoute")
    def tcp_route(self) -> Optional[pulumi.Input['RouteSpecTcpRouteArgs']]:
        """
        TCP routing information for the route.
        """
        return pulumi.get(self, "tcp_route")

    @tcp_route.setter
    def tcp_route(self, value: Optional[pulumi.Input['RouteSpecTcpRouteArgs']]):
        pulumi.set(self, "tcp_route", value)


if not MYPY:
    class RouteSpecGrpcRouteArgsDict(TypedDict):
        action: pulumi.Input['RouteSpecGrpcRouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: NotRequired[pulumi.Input['RouteSpecGrpcRouteMatchArgsDict']]
        """
        Criteria for determining an gRPC request match.
        """
        retry_policy: NotRequired[pulumi.Input['RouteSpecGrpcRouteRetryPolicyArgsDict']]
        """
        Retry policy.
        """
        timeout: NotRequired[pulumi.Input['RouteSpecGrpcRouteTimeoutArgsDict']]
        """
        Types of timeouts.
        """
elif False:
    RouteSpecGrpcRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RouteSpecGrpcRouteActionArgs'],
                 match: Optional[pulumi.Input['RouteSpecGrpcRouteMatchArgs']] = None,
                 retry_policy: Optional[pulumi.Input['RouteSpecGrpcRouteRetryPolicyArgs']] = None,
                 timeout: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutArgs']] = None):
        """
        :param pulumi.Input['RouteSpecGrpcRouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['RouteSpecGrpcRouteMatchArgs'] match: Criteria for determining an gRPC request match.
        :param pulumi.Input['RouteSpecGrpcRouteRetryPolicyArgs'] retry_policy: Retry policy.
        :param pulumi.Input['RouteSpecGrpcRouteTimeoutArgs'] timeout: Types of timeouts.
        """
        pulumi.set(__self__, "action", action)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RouteSpecGrpcRouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RouteSpecGrpcRouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteMatchArgs']]:
        """
        Criteria for determining an gRPC request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteMatchArgs']]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteRetryPolicyArgs']]:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteRetryPolicyArgs']]):
        pulumi.set(self, "retry_policy", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutArgs']]:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutArgs']]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RouteSpecGrpcRouteActionArgsDict(TypedDict):
        weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteActionWeightedTargetArgsDict']]]
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
elif False:
    RouteSpecGrpcRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteActionArgs:
    def __init__(__self__, *,
                 weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteActionWeightedTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteActionWeightedTargetArgs']]] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        pulumi.set(__self__, "weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteActionWeightedTargetArgs']]]:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")

    @weighted_targets.setter
    def weighted_targets(self, value: pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteActionWeightedTargetArgs']]]):
        pulumi.set(self, "weighted_targets", value)


if not MYPY:
    class RouteSpecGrpcRouteActionWeightedTargetArgsDict(TypedDict):
        virtual_node: pulumi.Input[str]
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        weight: pulumi.Input[int]
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The targeted port of the weighted object.
        """
elif False:
    RouteSpecGrpcRouteActionWeightedTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteActionWeightedTargetArgs:
    def __init__(__self__, *,
                 virtual_node: pulumi.Input[str],
                 weight: pulumi.Input[int],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param pulumi.Input[int] weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param pulumi.Input[int] port: The targeted port of the weighted object.
        """
        pulumi.set(__self__, "virtual_node", virtual_node)
        pulumi.set(__self__, "weight", weight)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> pulumi.Input[str]:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @virtual_node.setter
    def virtual_node(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_node", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RouteSpecGrpcRouteMatchArgsDict(TypedDict):
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteMatchMetadataArgsDict']]]]
        """
        Data to match from the gRPC request.
        """
        method_name: NotRequired[pulumi.Input[str]]
        """
        Method name to match from the request. If you specify a name, you must also specify a `service_name`.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
        prefix: NotRequired[pulumi.Input[str]]
        service_name: NotRequired[pulumi.Input[str]]
        """
        Fully qualified domain name for the service to match from the request.
        """
elif False:
    RouteSpecGrpcRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteMatchArgs:
    def __init__(__self__, *,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteMatchMetadataArgs']]]] = None,
                 method_name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteMatchMetadataArgs']]] metadatas: Data to match from the gRPC request.
        :param pulumi.Input[str] method_name: Method name to match from the request. If you specify a name, you must also specify a `service_name`.
        :param pulumi.Input[int] port: The port number to match from the request.
        :param pulumi.Input[str] service_name: Fully qualified domain name for the service to match from the request.
        """
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if method_name is not None:
            pulumi.set(__self__, "method_name", method_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteMatchMetadataArgs']]]]:
        """
        Data to match from the gRPC request.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecGrpcRouteMatchMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[pulumi.Input[str]]:
        """
        Method name to match from the request. If you specify a name, you must also specify a `service_name`.
        """
        return pulumi.get(self, "method_name")

    @method_name.setter
    def method_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method_name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified domain name for the service to match from the request.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class RouteSpecGrpcRouteMatchMetadataArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the route. Must be between 1 and 50 characters in length.
        """
        invert: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
        """
        match: NotRequired[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchArgsDict']]
        """
        Data to match from the request.
        """
elif False:
    RouteSpecGrpcRouteMatchMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteMatchMetadataArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 invert: Optional[pulumi.Input[bool]] = None,
                 match: Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the route. Must be between 1 and 50 characters in length.
        :param pulumi.Input[bool] invert: If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
        :param pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchArgs'] match: Data to match from the request.
        """
        pulumi.set(__self__, "name", name)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the route. Must be between 1 and 50 characters in length.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchArgs']]:
        """
        Data to match from the request.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class RouteSpecGrpcRouteMatchMetadataMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
        """
        range: NotRequired[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchRangeArgsDict']]
        """
        Object that specifies the range of numbers that the value sent by the client must be included in.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
        """
elif False:
    RouteSpecGrpcRouteMatchMetadataMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteMatchMetadataMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 range: Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchRangeArgs']] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] prefix: Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
        :param pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchRangeArgs'] range: Object that specifies the range of numbers that the value sent by the client must be included in.
        :param pulumi.Input[str] regex: Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] suffix: Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchRangeArgs']]:
        """
        Object that specifies the range of numbers that the value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteMatchMetadataMatchRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class RouteSpecGrpcRouteMatchMetadataMatchRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range.
        """
        start: pulumi.Input[int]
        """
        Start of the range.
        """
elif False:
    RouteSpecGrpcRouteMatchMetadataMatchRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteMatchMetadataMatchRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range.
        :param pulumi.Input[int] start: Start of the range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class RouteSpecGrpcRouteRetryPolicyArgsDict(TypedDict):
        max_retries: pulumi.Input[int]
        """
        Maximum number of retries.
        """
        per_retry_timeout: pulumi.Input['RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgsDict']
        """
        Per-retry timeout.
        """
        grpc_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of gRPC retry events.
        Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
        """
        http_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        tcp_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of TCP retry events. The only valid value is `connection-error`.
        """
elif False:
    RouteSpecGrpcRouteRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteRetryPolicyArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[int],
                 per_retry_timeout: pulumi.Input['RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs'],
                 grpc_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tcp_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] max_retries: Maximum number of retries.
        :param pulumi.Input['RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs'] per_retry_timeout: Per-retry timeout.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grpc_retry_events: List of gRPC retry events.
               Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
        """
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "per_retry_timeout", per_retry_timeout)
        if grpc_retry_events is not None:
            pulumi.set(__self__, "grpc_retry_events", grpc_retry_events)
        if http_retry_events is not None:
            pulumi.set(__self__, "http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            pulumi.set(__self__, "tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[int]:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> pulumi.Input['RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs']:
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @per_retry_timeout.setter
    def per_retry_timeout(self, value: pulumi.Input['RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs']):
        pulumi.set(self, "per_retry_timeout", value)

    @property
    @pulumi.getter(name="grpcRetryEvents")
    def grpc_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of gRPC retry events.
        Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
        """
        return pulumi.get(self, "grpc_retry_events")

    @grpc_retry_events.setter
    def grpc_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grpc_retry_events", value)

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @http_retry_events.setter
    def http_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_retry_events", value)

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.
        """
        return pulumi.get(self, "tcp_retry_events")

    @tcp_retry_events.setter
    def tcp_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tcp_retry_events", value)


if not MYPY:
    class RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Retry value.
        """
elif False:
    RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteRetryPolicyPerRetryTimeoutArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Retry unit. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Retry value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Retry value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecGrpcRouteTimeoutArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['RouteSpecGrpcRouteTimeoutIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['RouteSpecGrpcRouteTimeoutPerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    RouteSpecGrpcRouteTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteTimeoutArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutIdleArgs']] = None,
                 per_request: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutPerRequestArgs']] = None):
        """
        :param pulumi.Input['RouteSpecGrpcRouteTimeoutIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['RouteSpecGrpcRouteTimeoutPerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutIdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutPerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['RouteSpecGrpcRouteTimeoutPerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class RouteSpecGrpcRouteTimeoutIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecGrpcRouteTimeoutIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteTimeoutIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecGrpcRouteTimeoutPerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecGrpcRouteTimeoutPerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecGrpcRouteTimeoutPerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttp2RouteArgsDict(TypedDict):
        action: pulumi.Input['RouteSpecHttp2RouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: pulumi.Input['RouteSpecHttp2RouteMatchArgsDict']
        """
        Criteria for determining an HTTP request match.
        """
        retry_policy: NotRequired[pulumi.Input['RouteSpecHttp2RouteRetryPolicyArgsDict']]
        """
        Retry policy.
        """
        timeout: NotRequired[pulumi.Input['RouteSpecHttp2RouteTimeoutArgsDict']]
        """
        Types of timeouts.
        """
elif False:
    RouteSpecHttp2RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RouteSpecHttp2RouteActionArgs'],
                 match: pulumi.Input['RouteSpecHttp2RouteMatchArgs'],
                 retry_policy: Optional[pulumi.Input['RouteSpecHttp2RouteRetryPolicyArgs']] = None,
                 timeout: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutArgs']] = None):
        """
        :param pulumi.Input['RouteSpecHttp2RouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['RouteSpecHttp2RouteMatchArgs'] match: Criteria for determining an HTTP request match.
        :param pulumi.Input['RouteSpecHttp2RouteRetryPolicyArgs'] retry_policy: Retry policy.
        :param pulumi.Input['RouteSpecHttp2RouteTimeoutArgs'] timeout: Types of timeouts.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RouteSpecHttp2RouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RouteSpecHttp2RouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['RouteSpecHttp2RouteMatchArgs']:
        """
        Criteria for determining an HTTP request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['RouteSpecHttp2RouteMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteRetryPolicyArgs']]:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteRetryPolicyArgs']]):
        pulumi.set(self, "retry_policy", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutArgs']]:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutArgs']]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RouteSpecHttp2RouteActionArgsDict(TypedDict):
        weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteActionWeightedTargetArgsDict']]]
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
elif False:
    RouteSpecHttp2RouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteActionArgs:
    def __init__(__self__, *,
                 weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteActionWeightedTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteActionWeightedTargetArgs']]] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        pulumi.set(__self__, "weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteActionWeightedTargetArgs']]]:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")

    @weighted_targets.setter
    def weighted_targets(self, value: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteActionWeightedTargetArgs']]]):
        pulumi.set(self, "weighted_targets", value)


if not MYPY:
    class RouteSpecHttp2RouteActionWeightedTargetArgsDict(TypedDict):
        virtual_node: pulumi.Input[str]
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        weight: pulumi.Input[int]
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The targeted port of the weighted object.
        """
elif False:
    RouteSpecHttp2RouteActionWeightedTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteActionWeightedTargetArgs:
    def __init__(__self__, *,
                 virtual_node: pulumi.Input[str],
                 weight: pulumi.Input[int],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param pulumi.Input[int] weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param pulumi.Input[int] port: The targeted port of the weighted object.
        """
        pulumi.set(__self__, "virtual_node", virtual_node)
        pulumi.set(__self__, "weight", weight)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> pulumi.Input[str]:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @virtual_node.setter
    def virtual_node(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_node", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchHeaderArgsDict']]]]
        """
        Client request headers to match on.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        path: NotRequired[pulumi.Input['RouteSpecHttp2RouteMatchPathArgsDict']]
        """
        Client request path to match on.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Path with which to match requests.
        This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        """
        query_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterArgsDict']]]]
        """
        Client request query parameters to match on.
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
elif False:
    RouteSpecHttp2RouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchHeaderArgs']]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['RouteSpecHttp2RouteMatchPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterArgs']]]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchHeaderArgs']]] headers: Client request headers to match on.
        :param pulumi.Input[str] method: Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        :param pulumi.Input['RouteSpecHttp2RouteMatchPathArgs'] path: Client request path to match on.
        :param pulumi.Input[int] port: The port number to match from the request.
        :param pulumi.Input[str] prefix: Path with which to match requests.
               This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterArgs']]] query_parameters: Client request query parameters to match on.
        :param pulumi.Input[str] scheme: Client request header scheme to match on. Valid values: `http`, `https`.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchHeaderArgs']]]]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteMatchPathArgs']]:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteMatchPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Path with which to match requests.
        This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterArgs']]]]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterArgs']]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        invert: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        match: NotRequired[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchArgsDict']]
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
elif False:
    RouteSpecHttp2RouteMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 invert: Optional[pulumi.Input[bool]] = None,
                 match: Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the HTTP header in the client request that will be matched on.
        :param pulumi.Input[bool] invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchArgs'] match: Method and value to match the header value sent with a request. Specify one match method.
        """
        pulumi.set(__self__, "name", name)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchArgs']]:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchHeaderMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must match the specified value exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must begin with the specified characters.
        """
        range: NotRequired[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict']]
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must include the specified characters.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must end with the specified characters.
        """
elif False:
    RouteSpecHttp2RouteMatchHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 range: Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchRangeArgs']] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Header value sent by the client must match the specified value exactly.
        :param pulumi.Input[str] prefix: Header value sent by the client must begin with the specified characters.
        :param pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchRangeArgs'] range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param pulumi.Input[str] regex: Header value sent by the client must include the specified characters.
        :param pulumi.Input[str] suffix: Header value sent by the client must end with the specified characters.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchRangeArgs']]:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteMatchHeaderMatchRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range.
        """
        start: pulumi.Input[int]
        """
        Start of the range.
        """
elif False:
    RouteSpecHttp2RouteMatchHeaderMatchRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchHeaderMatchRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range.
        :param pulumi.Input[int] start: Start of the range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchPathArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact path to match on.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        The regex used to match the path.
        """
elif False:
    RouteSpecHttp2RouteMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchPathArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        :param pulumi.Input[str] regex: The regex used to match the path.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchQueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the query parameter that will be matched on.
        """
        match: NotRequired[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterMatchArgsDict']]
        """
        The query parameter to match on.
        """
elif False:
    RouteSpecHttp2RouteMatchQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 match: Optional[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the query parameter that will be matched on.
        :param pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterMatchArgs'] match: The query parameter to match on.
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterMatchArgs']]:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteMatchQueryParameterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class RouteSpecHttp2RouteMatchQueryParameterMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact query parameter to match on.
        """
elif False:
    RouteSpecHttp2RouteMatchQueryParameterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteMatchQueryParameterMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact query parameter to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact query parameter to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class RouteSpecHttp2RouteRetryPolicyArgsDict(TypedDict):
        max_retries: pulumi.Input[int]
        """
        Maximum number of retries.
        """
        per_retry_timeout: pulumi.Input['RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgsDict']
        """
        Per-retry timeout.
        """
        http_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        tcp_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of TCP retry events. The only valid value is `connection-error`.

        You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
elif False:
    RouteSpecHttp2RouteRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteRetryPolicyArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[int],
                 per_retry_timeout: pulumi.Input['RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs'],
                 http_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tcp_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] max_retries: Maximum number of retries.
        :param pulumi.Input['RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs'] per_retry_timeout: Per-retry timeout.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
               
               You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "per_retry_timeout", per_retry_timeout)
        if http_retry_events is not None:
            pulumi.set(__self__, "http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            pulumi.set(__self__, "tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[int]:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> pulumi.Input['RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs']:
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @per_retry_timeout.setter
    def per_retry_timeout(self, value: pulumi.Input['RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs']):
        pulumi.set(self, "per_retry_timeout", value)

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @http_retry_events.setter
    def http_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_retry_events", value)

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.

        You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
        return pulumi.get(self, "tcp_retry_events")

    @tcp_retry_events.setter
    def tcp_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tcp_retry_events", value)


if not MYPY:
    class RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Retry value.
        """
elif False:
    RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteRetryPolicyPerRetryTimeoutArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Retry unit. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Retry value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Retry value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttp2RouteTimeoutArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['RouteSpecHttp2RouteTimeoutIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['RouteSpecHttp2RouteTimeoutPerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    RouteSpecHttp2RouteTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteTimeoutArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutIdleArgs']] = None,
                 per_request: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutPerRequestArgs']] = None):
        """
        :param pulumi.Input['RouteSpecHttp2RouteTimeoutIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['RouteSpecHttp2RouteTimeoutPerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutIdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutPerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['RouteSpecHttp2RouteTimeoutPerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class RouteSpecHttp2RouteTimeoutIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecHttp2RouteTimeoutIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteTimeoutIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttp2RouteTimeoutPerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecHttp2RouteTimeoutPerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttp2RouteTimeoutPerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttpRouteArgsDict(TypedDict):
        action: pulumi.Input['RouteSpecHttpRouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: pulumi.Input['RouteSpecHttpRouteMatchArgsDict']
        """
        Criteria for determining an HTTP request match.
        """
        retry_policy: NotRequired[pulumi.Input['RouteSpecHttpRouteRetryPolicyArgsDict']]
        """
        Retry policy.
        """
        timeout: NotRequired[pulumi.Input['RouteSpecHttpRouteTimeoutArgsDict']]
        """
        Types of timeouts.
        """
elif False:
    RouteSpecHttpRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RouteSpecHttpRouteActionArgs'],
                 match: pulumi.Input['RouteSpecHttpRouteMatchArgs'],
                 retry_policy: Optional[pulumi.Input['RouteSpecHttpRouteRetryPolicyArgs']] = None,
                 timeout: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutArgs']] = None):
        """
        :param pulumi.Input['RouteSpecHttpRouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['RouteSpecHttpRouteMatchArgs'] match: Criteria for determining an HTTP request match.
        :param pulumi.Input['RouteSpecHttpRouteRetryPolicyArgs'] retry_policy: Retry policy.
        :param pulumi.Input['RouteSpecHttpRouteTimeoutArgs'] timeout: Types of timeouts.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RouteSpecHttpRouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RouteSpecHttpRouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['RouteSpecHttpRouteMatchArgs']:
        """
        Criteria for determining an HTTP request match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['RouteSpecHttpRouteMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input['RouteSpecHttpRouteRetryPolicyArgs']]:
        """
        Retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input['RouteSpecHttpRouteRetryPolicyArgs']]):
        pulumi.set(self, "retry_policy", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['RouteSpecHttpRouteTimeoutArgs']]:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutArgs']]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RouteSpecHttpRouteActionArgsDict(TypedDict):
        weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteActionWeightedTargetArgsDict']]]
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
elif False:
    RouteSpecHttpRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteActionArgs:
    def __init__(__self__, *,
                 weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteActionWeightedTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteActionWeightedTargetArgs']]] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        pulumi.set(__self__, "weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteActionWeightedTargetArgs']]]:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")

    @weighted_targets.setter
    def weighted_targets(self, value: pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteActionWeightedTargetArgs']]]):
        pulumi.set(self, "weighted_targets", value)


if not MYPY:
    class RouteSpecHttpRouteActionWeightedTargetArgsDict(TypedDict):
        virtual_node: pulumi.Input[str]
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        weight: pulumi.Input[int]
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The targeted port of the weighted object.
        """
elif False:
    RouteSpecHttpRouteActionWeightedTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteActionWeightedTargetArgs:
    def __init__(__self__, *,
                 virtual_node: pulumi.Input[str],
                 weight: pulumi.Input[int],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param pulumi.Input[int] weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param pulumi.Input[int] port: The targeted port of the weighted object.
        """
        pulumi.set(__self__, "virtual_node", virtual_node)
        pulumi.set(__self__, "weight", weight)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> pulumi.Input[str]:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @virtual_node.setter
    def virtual_node(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_node", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RouteSpecHttpRouteMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchHeaderArgsDict']]]]
        """
        Client request headers to match on.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        path: NotRequired[pulumi.Input['RouteSpecHttpRouteMatchPathArgsDict']]
        """
        Client request path to match on.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port number to match from the request.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Path with which to match requests.
        This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        """
        query_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterArgsDict']]]]
        """
        Client request query parameters to match on.
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
elif False:
    RouteSpecHttpRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchHeaderArgs']]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['RouteSpecHttpRouteMatchPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterArgs']]]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchHeaderArgs']]] headers: Client request headers to match on.
        :param pulumi.Input[str] method: Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        :param pulumi.Input['RouteSpecHttpRouteMatchPathArgs'] path: Client request path to match on.
        :param pulumi.Input[int] port: The port number to match from the request.
        :param pulumi.Input[str] prefix: Path with which to match requests.
               This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterArgs']]] query_parameters: Client request query parameters to match on.
        :param pulumi.Input[str] scheme: Client request header scheme to match on. Valid values: `http`, `https`.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchHeaderArgs']]]]:
        """
        Client request headers to match on.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RouteSpecHttpRouteMatchPathArgs']]:
        """
        Client request path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RouteSpecHttpRouteMatchPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to match from the request.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Path with which to match requests.
        This parameter must always start with /, which by itself matches all requests to the virtual router service name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterArgs']]]]:
        """
        Client request query parameters to match on.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterArgs']]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Client request header scheme to match on. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class RouteSpecHttpRouteMatchHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        invert: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        match: NotRequired[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchArgsDict']]
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
elif False:
    RouteSpecHttpRouteMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 invert: Optional[pulumi.Input[bool]] = None,
                 match: Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the HTTP header in the client request that will be matched on.
        :param pulumi.Input[bool] invert: If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        :param pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchArgs'] match: Method and value to match the header value sent with a request. Specify one match method.
        """
        pulumi.set(__self__, "name", name)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the HTTP header in the client request that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchArgs']]:
        """
        Method and value to match the header value sent with a request. Specify one match method.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class RouteSpecHttpRouteMatchHeaderMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must match the specified value exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must begin with the specified characters.
        """
        range: NotRequired[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchRangeArgsDict']]
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must include the specified characters.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Header value sent by the client must end with the specified characters.
        """
elif False:
    RouteSpecHttpRouteMatchHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 range: Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchRangeArgs']] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Header value sent by the client must match the specified value exactly.
        :param pulumi.Input[str] prefix: Header value sent by the client must begin with the specified characters.
        :param pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchRangeArgs'] range: Object that specifies the range of numbers that the header value sent by the client must be included in.
        :param pulumi.Input[str] regex: Header value sent by the client must include the specified characters.
        :param pulumi.Input[str] suffix: Header value sent by the client must end with the specified characters.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must match the specified value exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must begin with the specified characters.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchRangeArgs']]:
        """
        Object that specifies the range of numbers that the header value sent by the client must be included in.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['RouteSpecHttpRouteMatchHeaderMatchRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must include the specified characters.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Header value sent by the client must end with the specified characters.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class RouteSpecHttpRouteMatchHeaderMatchRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range.
        """
        start: pulumi.Input[int]
        """
        Start of the range.
        """
elif False:
    RouteSpecHttpRouteMatchHeaderMatchRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchHeaderMatchRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range.
        :param pulumi.Input[int] start: Start of the range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class RouteSpecHttpRouteMatchPathArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact path to match on.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        The regex used to match the path.
        """
elif False:
    RouteSpecHttpRouteMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchPathArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact path to match on.
        :param pulumi.Input[str] regex: The regex used to match the path.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact path to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regex used to match the path.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class RouteSpecHttpRouteMatchQueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the query parameter that will be matched on.
        """
        match: NotRequired[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterMatchArgsDict']]
        """
        The query parameter to match on.
        """
elif False:
    RouteSpecHttpRouteMatchQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 match: Optional[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterMatchArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for the query parameter that will be matched on.
        :param pulumi.Input['RouteSpecHttpRouteMatchQueryParameterMatchArgs'] match: The query parameter to match on.
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the query parameter that will be matched on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterMatchArgs']]:
        """
        The query parameter to match on.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecHttpRouteMatchQueryParameterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class RouteSpecHttpRouteMatchQueryParameterMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The exact query parameter to match on.
        """
elif False:
    RouteSpecHttpRouteMatchQueryParameterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteMatchQueryParameterMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The exact query parameter to match on.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The exact query parameter to match on.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class RouteSpecHttpRouteRetryPolicyArgsDict(TypedDict):
        max_retries: pulumi.Input[int]
        """
        Maximum number of retries.
        """
        per_retry_timeout: pulumi.Input['RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgsDict']
        """
        Per-retry timeout.
        """
        http_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        tcp_retry_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of TCP retry events. The only valid value is `connection-error`.

        You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
elif False:
    RouteSpecHttpRouteRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteRetryPolicyArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[int],
                 per_retry_timeout: pulumi.Input['RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs'],
                 http_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tcp_retry_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] max_retries: Maximum number of retries.
        :param pulumi.Input['RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs'] per_retry_timeout: Per-retry timeout.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_retry_events: List of HTTP retry events.
               Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tcp_retry_events: List of TCP retry events. The only valid value is `connection-error`.
               
               You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "per_retry_timeout", per_retry_timeout)
        if http_retry_events is not None:
            pulumi.set(__self__, "http_retry_events", http_retry_events)
        if tcp_retry_events is not None:
            pulumi.set(__self__, "tcp_retry_events", tcp_retry_events)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[int]:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="perRetryTimeout")
    def per_retry_timeout(self) -> pulumi.Input['RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs']:
        """
        Per-retry timeout.
        """
        return pulumi.get(self, "per_retry_timeout")

    @per_retry_timeout.setter
    def per_retry_timeout(self, value: pulumi.Input['RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs']):
        pulumi.set(self, "per_retry_timeout", value)

    @property
    @pulumi.getter(name="httpRetryEvents")
    def http_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP retry events.
        Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
        """
        return pulumi.get(self, "http_retry_events")

    @http_retry_events.setter
    def http_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_retry_events", value)

    @property
    @pulumi.getter(name="tcpRetryEvents")
    def tcp_retry_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of TCP retry events. The only valid value is `connection-error`.

        You must specify at least one value for `http_retry_events`, or at least one value for `tcp_retry_events`.
        """
        return pulumi.get(self, "tcp_retry_events")

    @tcp_retry_events.setter
    def tcp_retry_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tcp_retry_events", value)


if not MYPY:
    class RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Retry value.
        """
elif False:
    RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteRetryPolicyPerRetryTimeoutArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Retry unit. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Retry value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Retry unit. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Retry value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttpRouteTimeoutArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['RouteSpecHttpRouteTimeoutIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['RouteSpecHttpRouteTimeoutPerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    RouteSpecHttpRouteTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteTimeoutArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutIdleArgs']] = None,
                 per_request: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutPerRequestArgs']] = None):
        """
        :param pulumi.Input['RouteSpecHttpRouteTimeoutIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['RouteSpecHttpRouteTimeoutPerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['RouteSpecHttpRouteTimeoutIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutIdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['RouteSpecHttpRouteTimeoutPerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['RouteSpecHttpRouteTimeoutPerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class RouteSpecHttpRouteTimeoutIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecHttpRouteTimeoutIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteTimeoutIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecHttpRouteTimeoutPerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecHttpRouteTimeoutPerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecHttpRouteTimeoutPerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteSpecTcpRouteArgsDict(TypedDict):
        action: pulumi.Input['RouteSpecTcpRouteActionArgsDict']
        """
        Action to take if a match is determined.
        """
        match: NotRequired[pulumi.Input['RouteSpecTcpRouteMatchArgsDict']]
        timeout: NotRequired[pulumi.Input['RouteSpecTcpRouteTimeoutArgsDict']]
        """
        Types of timeouts.
        """
elif False:
    RouteSpecTcpRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RouteSpecTcpRouteActionArgs'],
                 match: Optional[pulumi.Input['RouteSpecTcpRouteMatchArgs']] = None,
                 timeout: Optional[pulumi.Input['RouteSpecTcpRouteTimeoutArgs']] = None):
        """
        :param pulumi.Input['RouteSpecTcpRouteActionArgs'] action: Action to take if a match is determined.
        :param pulumi.Input['RouteSpecTcpRouteTimeoutArgs'] timeout: Types of timeouts.
        """
        pulumi.set(__self__, "action", action)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RouteSpecTcpRouteActionArgs']:
        """
        Action to take if a match is determined.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RouteSpecTcpRouteActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['RouteSpecTcpRouteMatchArgs']]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['RouteSpecTcpRouteMatchArgs']]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['RouteSpecTcpRouteTimeoutArgs']]:
        """
        Types of timeouts.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['RouteSpecTcpRouteTimeoutArgs']]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RouteSpecTcpRouteActionArgsDict(TypedDict):
        weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecTcpRouteActionWeightedTargetArgsDict']]]
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
elif False:
    RouteSpecTcpRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteActionArgs:
    def __init__(__self__, *,
                 weighted_targets: pulumi.Input[Sequence[pulumi.Input['RouteSpecTcpRouteActionWeightedTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteSpecTcpRouteActionWeightedTargetArgs']]] weighted_targets: Targets that traffic is routed to when a request matches the route.
               You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        pulumi.set(__self__, "weighted_targets", weighted_targets)

    @property
    @pulumi.getter(name="weightedTargets")
    def weighted_targets(self) -> pulumi.Input[Sequence[pulumi.Input['RouteSpecTcpRouteActionWeightedTargetArgs']]]:
        """
        Targets that traffic is routed to when a request matches the route.
        You can specify one or more targets and their relative weights with which to distribute traffic.
        """
        return pulumi.get(self, "weighted_targets")

    @weighted_targets.setter
    def weighted_targets(self, value: pulumi.Input[Sequence[pulumi.Input['RouteSpecTcpRouteActionWeightedTargetArgs']]]):
        pulumi.set(self, "weighted_targets", value)


if not MYPY:
    class RouteSpecTcpRouteActionWeightedTargetArgsDict(TypedDict):
        virtual_node: pulumi.Input[str]
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        weight: pulumi.Input[int]
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The targeted port of the weighted object.
        """
elif False:
    RouteSpecTcpRouteActionWeightedTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteActionWeightedTargetArgs:
    def __init__(__self__, *,
                 virtual_node: pulumi.Input[str],
                 weight: pulumi.Input[int],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] virtual_node: Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        :param pulumi.Input[int] weight: Relative weight of the weighted target. An integer between 0 and 100.
        :param pulumi.Input[int] port: The targeted port of the weighted object.
        """
        pulumi.set(__self__, "virtual_node", virtual_node)
        pulumi.set(__self__, "weight", weight)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> pulumi.Input[str]:
        """
        Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node")

    @virtual_node.setter
    def virtual_node(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_node", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Relative weight of the weighted target. An integer between 0 and 100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The targeted port of the weighted object.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RouteSpecTcpRouteMatchArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
elif False:
    RouteSpecTcpRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteMatchArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RouteSpecTcpRouteTimeoutArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['RouteSpecTcpRouteTimeoutIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
elif False:
    RouteSpecTcpRouteTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteTimeoutArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['RouteSpecTcpRouteTimeoutIdleArgs']] = None):
        """
        :param pulumi.Input['RouteSpecTcpRouteTimeoutIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['RouteSpecTcpRouteTimeoutIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['RouteSpecTcpRouteTimeoutIdleArgs']]):
        pulumi.set(self, "idle", value)


if not MYPY:
    class RouteSpecTcpRouteTimeoutIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    RouteSpecTcpRouteTimeoutIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteSpecTcpRouteTimeoutIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualGatewaySpecArgsDict(TypedDict):
        listeners: pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecListenerArgsDict']]]
        """
        Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        """
        backend_defaults: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsArgsDict']]
        """
        Defaults for backends.
        """
        logging: NotRequired[pulumi.Input['VirtualGatewaySpecLoggingArgsDict']]
        """
        Inbound and outbound access logging information for the virtual gateway.
        """
elif False:
    VirtualGatewaySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecArgs:
    def __init__(__self__, *,
                 listeners: pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecListenerArgs']]],
                 backend_defaults: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsArgs']] = None,
                 logging: Optional[pulumi.Input['VirtualGatewaySpecLoggingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecListenerArgs']]] listeners: Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsArgs'] backend_defaults: Defaults for backends.
        :param pulumi.Input['VirtualGatewaySpecLoggingArgs'] logging: Inbound and outbound access logging information for the virtual gateway.
        """
        pulumi.set(__self__, "listeners", listeners)
        if backend_defaults is not None:
            pulumi.set(__self__, "backend_defaults", backend_defaults)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def listeners(self) -> pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecListenerArgs']]]:
        """
        Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecListenerArgs']]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsArgs']]:
        """
        Defaults for backends.
        """
        return pulumi.get(self, "backend_defaults")

    @backend_defaults.setter
    def backend_defaults(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsArgs']]):
        pulumi.set(self, "backend_defaults", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['VirtualGatewaySpecLoggingArgs']]:
        """
        Inbound and outbound access logging information for the virtual gateway.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['VirtualGatewaySpecLoggingArgs']]):
        pulumi.set(self, "logging", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsArgsDict(TypedDict):
        client_policy: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyArgsDict']]
        """
        Default client policy for virtual gateway backends.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsArgs:
    def __init__(__self__, *,
                 client_policy: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyArgs'] client_policy: Default client policy for virtual gateway backends.
        """
        if client_policy is not None:
            pulumi.set(__self__, "client_policy", client_policy)

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyArgs']]:
        """
        Default client policy for virtual gateway backends.
        """
        return pulumi.get(self, "client_policy")

    @client_policy.setter
    def client_policy(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyArgs']]):
        pulumi.set(self, "client_policy", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgsDict']]
        """
        Transport Layer Security (TLS) client policy.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs'] tls: Transport Layer Security (TLS) client policy.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs']]:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgsDict(TypedDict):
        validation: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgsDict']
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        certificate: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgsDict']]
        """
        Listener's TLS certificate.
        """
        enforce: NotRequired[pulumi.Input[bool]]
        """
        Whether the policy is enforced. Default is `true`.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        One or more ports that the policy is enforced for.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsArgs:
    def __init__(__self__, *,
                 validation: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs'],
                 certificate: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs']] = None,
                 enforce: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs'] validation: Listener's Transport Layer Security (TLS) validation context.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs'] certificate: Listener's TLS certificate.
        :param pulumi.Input[bool] enforce: Whether the policy is enforced. Default is `true`.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: One or more ports that the policy is enforced for.
        """
        pulumi.set(__self__, "validation", validation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs']:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs']):
        pulumi.set(self, "validation", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs']]:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict']]
        """
        Local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict']]
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs'] file: Local file certificate.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs'] sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs']]:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']]:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        private_key: pulumi.Input[str]
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] private_key: Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgsDict(TypedDict):
        trust: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict']
        """
        TLS validation context trust.
        """
        subject_alternative_names: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict']]
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationArgs:
    def __init__(__self__, *,
                 trust: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs'],
                 subject_alternative_names: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs'] trust: TLS validation context trust.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs'] subject_alternative_names: SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        pulumi.set(__self__, "trust", trust)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs']:
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs']):
        pulumi.set(self, "trust", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']]:
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict(TypedDict):
        match: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict']
        """
        Criteria for determining a SAN's match.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs'] match: Criteria for determining a SAN's match.
        """
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']:
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict(TypedDict):
        exacts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values sent must match the specified values exactly.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs:
    def __init__(__self__, *,
                 exacts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exacts: Values sent must match the specified values exactly.
        """
        pulumi.set(__self__, "exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")

    @exacts.setter
    def exacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "exacts", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict(TypedDict):
        acm: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict']]
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        file: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict']]
        """
        TLS validation context trust for a local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict']]
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustArgs:
    def __init__(__self__, *,
                 acm: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']] = None,
                 file: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs'] acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs'] file: TLS validation context trust for a local file certificate.
        :param pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs'] sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if acm is not None:
            pulumi.set(__self__, "acm", acm)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']]:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @acm.setter
    def acm(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']]):
        pulumi.set(self, "acm", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']]:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']]:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict(TypedDict):
        certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        One or more ACM ARNs.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs:
    def __init__(__self__, *,
                 certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_authority_arns: One or more ACM ARNs.
        """
        pulumi.set(__self__, "certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")

    @certificate_authority_arns.setter
    def certificate_authority_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "certificate_authority_arns", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualGatewaySpecListenerArgsDict(TypedDict):
        port_mapping: pulumi.Input['VirtualGatewaySpecListenerPortMappingArgsDict']
        """
        Port mapping information for the listener.
        """
        connection_pool: NotRequired[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolArgsDict']]
        """
        Connection pool information for the listener.
        """
        health_check: NotRequired[pulumi.Input['VirtualGatewaySpecListenerHealthCheckArgsDict']]
        """
        Health check information for the listener.
        """
        tls: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsArgsDict']]
        """
        Transport Layer Security (TLS) properties for the listener
        """
elif False:
    VirtualGatewaySpecListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerArgs:
    def __init__(__self__, *,
                 port_mapping: pulumi.Input['VirtualGatewaySpecListenerPortMappingArgs'],
                 connection_pool: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolArgs']] = None,
                 health_check: Optional[pulumi.Input['VirtualGatewaySpecListenerHealthCheckArgs']] = None,
                 tls: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerPortMappingArgs'] port_mapping: Port mapping information for the listener.
        :param pulumi.Input['VirtualGatewaySpecListenerConnectionPoolArgs'] connection_pool: Connection pool information for the listener.
        :param pulumi.Input['VirtualGatewaySpecListenerHealthCheckArgs'] health_check: Health check information for the listener.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsArgs'] tls: Transport Layer Security (TLS) properties for the listener
        """
        pulumi.set(__self__, "port_mapping", port_mapping)
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> pulumi.Input['VirtualGatewaySpecListenerPortMappingArgs']:
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")

    @port_mapping.setter
    def port_mapping(self, value: pulumi.Input['VirtualGatewaySpecListenerPortMappingArgs']):
        pulumi.set(self, "port_mapping", value)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolArgs']]:
        """
        Connection pool information for the listener.
        """
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerHealthCheckArgs']]:
        """
        Health check information for the listener.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsArgs']]:
        """
        Transport Layer Security (TLS) properties for the listener
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class VirtualGatewaySpecListenerConnectionPoolArgsDict(TypedDict):
        grpc: NotRequired[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolGrpcArgsDict']]
        """
        Connection pool information for gRPC listeners.
        """
        http: NotRequired[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttpArgsDict']]
        """
        Connection pool information for HTTP listeners.
        """
        http2: NotRequired[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttp2ArgsDict']]
        """
        Connection pool information for HTTP2 listeners.
        """
elif False:
    VirtualGatewaySpecListenerConnectionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerConnectionPoolArgs:
    def __init__(__self__, *,
                 grpc: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolGrpcArgs']] = None,
                 http: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttpArgs']] = None,
                 http2: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttp2Args']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerConnectionPoolGrpcArgs'] grpc: Connection pool information for gRPC listeners.
        :param pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttpArgs'] http: Connection pool information for HTTP listeners.
        :param pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttp2Args'] http2: Connection pool information for HTTP2 listeners.
        """
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolGrpcArgs']]:
        """
        Connection pool information for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttpArgs']]:
        """
        Connection pool information for HTTP listeners.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttp2Args']]:
        """
        Connection pool information for HTTP2 listeners.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerConnectionPoolHttp2Args']]):
        pulumi.set(self, "http2", value)


if not MYPY:
    class VirtualGatewaySpecListenerConnectionPoolGrpcArgsDict(TypedDict):
        max_requests: pulumi.Input[int]
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualGatewaySpecListenerConnectionPoolGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerConnectionPoolGrpcArgs:
    def __init__(__self__, *,
                 max_requests: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> pulumi.Input[int]:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")

    @max_requests.setter
    def max_requests(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_requests", value)


if not MYPY:
    class VirtualGatewaySpecListenerConnectionPoolHttp2ArgsDict(TypedDict):
        max_requests: pulumi.Input[int]
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualGatewaySpecListenerConnectionPoolHttp2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerConnectionPoolHttp2Args:
    def __init__(__self__, *,
                 max_requests: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> pulumi.Input[int]:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")

    @max_requests.setter
    def max_requests(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_requests", value)


if not MYPY:
    class VirtualGatewaySpecListenerConnectionPoolHttpArgsDict(TypedDict):
        max_connections: pulumi.Input[int]
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        max_pending_requests: NotRequired[pulumi.Input[int]]
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualGatewaySpecListenerConnectionPoolHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 max_connections: pulumi.Input[int],
                 max_pending_requests: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        :param pulumi.Input[int] max_pending_requests: Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> pulumi.Input[int]:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_pending_requests")

    @max_pending_requests.setter
    def max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pending_requests", value)


if not MYPY:
    class VirtualGatewaySpecListenerHealthCheckArgsDict(TypedDict):
        healthy_threshold: pulumi.Input[int]
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        interval_millis: pulumi.Input[int]
        """
        Time period in milliseconds between each health check execution.
        """
        protocol: pulumi.Input[str]
        """
        Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
        """
        timeout_millis: pulumi.Input[int]
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        unhealthy_threshold: pulumi.Input[int]
        """
        Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
elif False:
    VirtualGatewaySpecListenerHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerHealthCheckArgs:
    def __init__(__self__, *,
                 healthy_threshold: pulumi.Input[int],
                 interval_millis: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 timeout_millis: pulumi.Input[int],
                 unhealthy_threshold: pulumi.Input[int],
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] healthy_threshold: Number of consecutive successful health checks that must occur before declaring listener healthy.
        :param pulumi.Input[int] interval_millis: Time period in milliseconds between each health check execution.
        :param pulumi.Input[str] protocol: Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
        :param pulumi.Input[int] timeout_millis: Amount of time to wait when receiving a response from the health check, in milliseconds.
        :param pulumi.Input[int] unhealthy_threshold: Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        :param pulumi.Input[str] path: Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        :param pulumi.Input[int] port: Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "interval_millis", interval_millis)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout_millis", timeout_millis)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> pulumi.Input[int]:
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> pulumi.Input[int]:
        """
        Time period in milliseconds between each health check execution.
        """
        return pulumi.get(self, "interval_millis")

    @interval_millis.setter
    def interval_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_millis", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> pulumi.Input[int]:
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        return pulumi.get(self, "timeout_millis")

    @timeout_millis.setter
    def timeout_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout_millis", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> pulumi.Input[int]:
        """
        Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "unhealthy_threshold", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class VirtualGatewaySpecListenerPortMappingArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Port used for the port mapping.
        """
        protocol: pulumi.Input[str]
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
elif False:
    VirtualGatewaySpecListenerPortMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerPortMappingArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str]):
        """
        :param pulumi.Input[int] port: Port used for the port mapping.
        :param pulumi.Input[str] protocol: Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsArgsDict(TypedDict):
        certificate: pulumi.Input['VirtualGatewaySpecListenerTlsCertificateArgsDict']
        """
        Listener's TLS certificate.
        """
        mode: pulumi.Input[str]
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        validation: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsValidationArgsDict']]
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
elif False:
    VirtualGatewaySpecListenerTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input['VirtualGatewaySpecListenerTlsCertificateArgs'],
                 mode: pulumi.Input[str],
                 validation: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerTlsCertificateArgs'] certificate: Listener's TLS certificate.
        :param pulumi.Input[str] mode: Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationArgs'] validation: Listener's Transport Layer Security (TLS) validation context.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "mode", mode)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input['VirtualGatewaySpecListenerTlsCertificateArgs']:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input['VirtualGatewaySpecListenerTlsCertificateArgs']):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationArgs']]:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsCertificateArgsDict(TypedDict):
        acm: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateAcmArgsDict']]
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        file: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateFileArgsDict']]
        """
        Local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateSdsArgsDict']]
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualGatewaySpecListenerTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsCertificateArgs:
    def __init__(__self__, *,
                 acm: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateAcmArgs']] = None,
                 file: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerTlsCertificateAcmArgs'] acm: An AWS Certificate Manager (ACM) certificate.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsCertificateFileArgs'] file: Local file certificate.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsCertificateSdsArgs'] sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if acm is not None:
            pulumi.set(__self__, "acm", acm)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateAcmArgs']]:
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @acm.setter
    def acm(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateAcmArgs']]):
        pulumi.set(self, "acm", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateFileArgs']]:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateSdsArgs']]:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsCertificateSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsCertificateAcmArgsDict(TypedDict):
        certificate_arn: pulumi.Input[str]
        """
        ARN for the certificate.
        """
elif False:
    VirtualGatewaySpecListenerTlsCertificateAcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsCertificateAcmArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_arn: ARN for the certificate.
        """
        pulumi.set(__self__, "certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[str]:
        """
        ARN for the certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_arn", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsCertificateFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        private_key: pulumi.Input[str]
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualGatewaySpecListenerTlsCertificateFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsCertificateFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] private_key: Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsCertificateSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualGatewaySpecListenerTlsCertificateSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsCertificateSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationArgsDict(TypedDict):
        trust: pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustArgsDict']
        """
        TLS validation context trust.
        """
        subject_alternative_names: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgsDict']]
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationArgs:
    def __init__(__self__, *,
                 trust: pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustArgs'],
                 subject_alternative_names: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustArgs'] trust: TLS validation context trust.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs'] subject_alternative_names: SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        pulumi.set(__self__, "trust", trust)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustArgs']:
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustArgs']):
        pulumi.set(self, "trust", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs']]:
        """
        SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs']]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgsDict(TypedDict):
        match: pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict']
        """
        Criteria for determining a SAN's match.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs'] match: Criteria for determining a SAN's match.
        """
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']:
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict(TypedDict):
        exacts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values sent must match the specified values exactly.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatchArgs:
    def __init__(__self__, *,
                 exacts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exacts: Values sent must match the specified values exactly.
        """
        pulumi.set(__self__, "exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")

    @exacts.setter
    def exacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "exacts", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationTrustArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustFileArgsDict']]
        """
        TLS validation context trust for a local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustSdsArgsDict']]
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationTrustArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationTrustArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustFileArgs'] file: TLS validation context trust for a local file certificate.
        :param pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustSdsArgs'] sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustFileArgs']]:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustSdsArgs']]:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualGatewaySpecListenerTlsValidationTrustSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationTrustFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationTrustFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationTrustFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class VirtualGatewaySpecListenerTlsValidationTrustSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualGatewaySpecListenerTlsValidationTrustSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecListenerTlsValidationTrustSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualGatewaySpecLoggingArgsDict(TypedDict):
        access_log: NotRequired[pulumi.Input['VirtualGatewaySpecLoggingAccessLogArgsDict']]
        """
        Access log configuration for a virtual gateway.
        """
elif False:
    VirtualGatewaySpecLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecLoggingArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecLoggingAccessLogArgs'] access_log: Access log configuration for a virtual gateway.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogArgs']]:
        """
        Access log configuration for a virtual gateway.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogArgs']]):
        pulumi.set(self, "access_log", value)


if not MYPY:
    class VirtualGatewaySpecLoggingAccessLogArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileArgsDict']]
        """
        File object to send virtual gateway access logs to.
        """
elif False:
    VirtualGatewaySpecLoggingAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecLoggingAccessLogArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileArgs']] = None):
        """
        :param pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileArgs'] file: File object to send virtual gateway access logs to.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileArgs']]:
        """
        File object to send virtual gateway access logs to.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileArgs']]):
        pulumi.set(self, "file", value)


if not MYPY:
    class VirtualGatewaySpecLoggingAccessLogFileArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        format: NotRequired[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatArgsDict']]
        """
        The specified format for the logs.
        """
elif False:
    VirtualGatewaySpecLoggingAccessLogFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecLoggingAccessLogFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 format: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatArgs']] = None):
        """
        :param pulumi.Input[str] path: File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        :param pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatArgs'] format: The specified format for the logs.
        """
        pulumi.set(__self__, "path", path)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatArgs']]:
        """
        The specified format for the logs.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatArgs']]):
        pulumi.set(self, "format", value)


if not MYPY:
    class VirtualGatewaySpecLoggingAccessLogFileFormatArgsDict(TypedDict):
        jsons: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgsDict']]]]
        """
        The logging format for JSON.
        """
        text: NotRequired[pulumi.Input[str]]
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
elif False:
    VirtualGatewaySpecLoggingAccessLogFileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecLoggingAccessLogFileFormatArgs:
    def __init__(__self__, *,
                 jsons: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs']]]] = None,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs']]] jsons: The logging format for JSON.
        :param pulumi.Input[str] text: The logging format for text. Must be between 1 and 1000 characters in length.
        """
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs']]]]:
        """
        The logging format for JSON.
        """
        return pulumi.get(self, "jsons")

    @jsons.setter
    def jsons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs']]]]):
        pulumi.set(self, "jsons", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        value: pulumi.Input[str]
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
elif False:
    VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewaySpecLoggingAccessLogFileFormatJsonArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The specified key for the JSON. Must be between 1 and 100 characters in length.
        :param pulumi.Input[str] value: The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecArgsDict(TypedDict):
        backend_defaults: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsArgsDict']]
        """
        Defaults for backends.
        """
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecBackendArgsDict']]]]
        """
        Backends to which the virtual node is expected to send outbound traffic.
        """
        listeners: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerArgsDict']]]]
        """
        Listeners from which the virtual node is expected to receive inbound traffic.
        """
        logging: NotRequired[pulumi.Input['VirtualNodeSpecLoggingArgsDict']]
        """
        Inbound and outbound access logging information for the virtual node.
        """
        service_discovery: NotRequired[pulumi.Input['VirtualNodeSpecServiceDiscoveryArgsDict']]
        """
        Service discovery information for the virtual node.
        """
elif False:
    VirtualNodeSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecArgs:
    def __init__(__self__, *,
                 backend_defaults: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsArgs']] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecBackendArgs']]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerArgs']]]] = None,
                 logging: Optional[pulumi.Input['VirtualNodeSpecLoggingArgs']] = None,
                 service_discovery: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsArgs'] backend_defaults: Defaults for backends.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecBackendArgs']]] backends: Backends to which the virtual node is expected to send outbound traffic.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerArgs']]] listeners: Listeners from which the virtual node is expected to receive inbound traffic.
        :param pulumi.Input['VirtualNodeSpecLoggingArgs'] logging: Inbound and outbound access logging information for the virtual node.
        :param pulumi.Input['VirtualNodeSpecServiceDiscoveryArgs'] service_discovery: Service discovery information for the virtual node.
        """
        if backend_defaults is not None:
            pulumi.set(__self__, "backend_defaults", backend_defaults)
        if backends is not None:
            pulumi.set(__self__, "backends", backends)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if service_discovery is not None:
            pulumi.set(__self__, "service_discovery", service_discovery)

    @property
    @pulumi.getter(name="backendDefaults")
    def backend_defaults(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsArgs']]:
        """
        Defaults for backends.
        """
        return pulumi.get(self, "backend_defaults")

    @backend_defaults.setter
    def backend_defaults(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsArgs']]):
        pulumi.set(self, "backend_defaults", value)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecBackendArgs']]]]:
        """
        Backends to which the virtual node is expected to send outbound traffic.
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecBackendArgs']]]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerArgs']]]]:
        """
        Listeners from which the virtual node is expected to receive inbound traffic.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerArgs']]]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['VirtualNodeSpecLoggingArgs']]:
        """
        Inbound and outbound access logging information for the virtual node.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['VirtualNodeSpecLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryArgs']]:
        """
        Service discovery information for the virtual node.
        """
        return pulumi.get(self, "service_discovery")

    @service_discovery.setter
    def service_discovery(self, value: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryArgs']]):
        pulumi.set(self, "service_discovery", value)


if not MYPY:
    class VirtualNodeSpecBackendArgsDict(TypedDict):
        virtual_service: pulumi.Input['VirtualNodeSpecBackendVirtualServiceArgsDict']
        """
        Virtual service to use as a backend for a virtual node.
        """
elif False:
    VirtualNodeSpecBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendArgs:
    def __init__(__self__, *,
                 virtual_service: pulumi.Input['VirtualNodeSpecBackendVirtualServiceArgs']):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceArgs'] virtual_service: Virtual service to use as a backend for a virtual node.
        """
        pulumi.set(__self__, "virtual_service", virtual_service)

    @property
    @pulumi.getter(name="virtualService")
    def virtual_service(self) -> pulumi.Input['VirtualNodeSpecBackendVirtualServiceArgs']:
        """
        Virtual service to use as a backend for a virtual node.
        """
        return pulumi.get(self, "virtual_service")

    @virtual_service.setter
    def virtual_service(self, value: pulumi.Input['VirtualNodeSpecBackendVirtualServiceArgs']):
        pulumi.set(self, "virtual_service", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsArgsDict(TypedDict):
        client_policy: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyArgsDict']]
        """
        Default client policy for virtual service backends. See above for details.
        """
elif False:
    VirtualNodeSpecBackendDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsArgs:
    def __init__(__self__, *,
                 client_policy: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyArgs'] client_policy: Default client policy for virtual service backends. See above for details.
        """
        if client_policy is not None:
            pulumi.set(__self__, "client_policy", client_policy)

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyArgs']]:
        """
        Default client policy for virtual service backends. See above for details.
        """
        return pulumi.get(self, "client_policy")

    @client_policy.setter
    def client_policy(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyArgs']]):
        pulumi.set(self, "client_policy", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsArgsDict']]
        """
        Transport Layer Security (TLS) client policy.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs'] tls: Transport Layer Security (TLS) client policy.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs']]:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsArgsDict(TypedDict):
        validation: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgsDict']
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        certificate: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgsDict']]
        """
        Listener's TLS certificate.
        """
        enforce: NotRequired[pulumi.Input[bool]]
        """
        Whether the policy is enforced. Default is `true`.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        One or more ports that the policy is enforced for.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsArgs:
    def __init__(__self__, *,
                 validation: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs'],
                 certificate: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs']] = None,
                 enforce: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs'] validation: Listener's Transport Layer Security (TLS) validation context.
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs'] certificate: Listener's TLS certificate.
        :param pulumi.Input[bool] enforce: Whether the policy is enforced. Default is `true`.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: One or more ports that the policy is enforced for.
        """
        pulumi.set(__self__, "validation", validation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs']:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs']):
        pulumi.set(self, "validation", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs']]:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict']]
        """
        Local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict']]
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs'] file: Local file certificate.
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs'] sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs']]:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']]:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        private_key: pulumi.Input[str]
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgsDict(TypedDict):
        trust: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict']
        """
        TLS validation context trust.
        """
        subject_alternative_names: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict']]
        """
        SANs for a TLS validation context.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationArgs:
    def __init__(__self__, *,
                 trust: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs'],
                 subject_alternative_names: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs'] trust: TLS validation context trust.
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs'] subject_alternative_names: SANs for a TLS validation context.
        """
        pulumi.set(__self__, "trust", trust)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs']:
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs']):
        pulumi.set(self, "trust", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']]:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs']]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict(TypedDict):
        match: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict']
        """
        Criteria for determining a SAN's match.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs'] match: Criteria for determining a SAN's match.
        """
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']:
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict(TypedDict):
        exacts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values sent must match the specified values exactly.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs:
    def __init__(__self__, *,
                 exacts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exacts: Values sent must match the specified values exactly.
        """
        pulumi.set(__self__, "exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")

    @exacts.setter
    def exacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "exacts", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict(TypedDict):
        acm: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict']]
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        file: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict']]
        """
        TLS validation context trust for a local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict']]
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustArgs:
    def __init__(__self__, *,
                 acm: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']] = None,
                 file: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs'] acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs'] file: TLS validation context trust for a local file certificate.
        :param pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs'] sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if acm is not None:
            pulumi.set(__self__, "acm", acm)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']]:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @acm.setter
    def acm(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs']]):
        pulumi.set(self, "acm", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']]:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']]:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict(TypedDict):
        certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        One or more ACM ARNs.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcmArgs:
    def __init__(__self__, *,
                 certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_authority_arns: One or more ACM ARNs.
        """
        pulumi.set(__self__, "certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")

    @certificate_authority_arns.setter
    def certificate_authority_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "certificate_authority_arns", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceArgsDict(TypedDict):
        virtual_service_name: pulumi.Input[str]
        """
        Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
        """
        client_policy: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyArgsDict']]
        """
        Client policy for the backend.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceArgs:
    def __init__(__self__, *,
                 virtual_service_name: pulumi.Input[str],
                 client_policy: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyArgs']] = None):
        """
        :param pulumi.Input[str] virtual_service_name: Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyArgs'] client_policy: Client policy for the backend.
        """
        pulumi.set(__self__, "virtual_service_name", virtual_service_name)
        if client_policy is not None:
            pulumi.set(__self__, "client_policy", client_policy)

    @property
    @pulumi.getter(name="virtualServiceName")
    def virtual_service_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_service_name")

    @virtual_service_name.setter
    def virtual_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_service_name", value)

    @property
    @pulumi.getter(name="clientPolicy")
    def client_policy(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyArgs']]:
        """
        Client policy for the backend.
        """
        return pulumi.get(self, "client_policy")

    @client_policy.setter
    def client_policy(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyArgs']]):
        pulumi.set(self, "client_policy", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgsDict']]
        """
        Transport Layer Security (TLS) client policy.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs'] tls: Transport Layer Security (TLS) client policy.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs']]:
        """
        Transport Layer Security (TLS) client policy.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgsDict(TypedDict):
        validation: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgsDict']
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        certificate: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgsDict']]
        """
        Listener's TLS certificate.
        """
        enforce: NotRequired[pulumi.Input[bool]]
        """
        Whether the policy is enforced. Default is `true`.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        One or more ports that the policy is enforced for.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsArgs:
    def __init__(__self__, *,
                 validation: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs'],
                 certificate: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs']] = None,
                 enforce: Optional[pulumi.Input[bool]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs'] validation: Listener's Transport Layer Security (TLS) validation context.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs'] certificate: Listener's TLS certificate.
        :param pulumi.Input[bool] enforce: Whether the policy is enforced. Default is `true`.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: One or more ports that the policy is enforced for.
        """
        pulumi.set(__self__, "validation", validation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def validation(self) -> pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs']:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs']):
        pulumi.set(self, "validation", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs']]:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the policy is enforced. Default is `true`.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        One or more ports that the policy is enforced for.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgsDict']]
        """
        Local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgsDict']]
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs'] file: Local file certificate.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs'] sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs']]:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs']]:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        private_key: pulumi.Input[str]
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgsDict(TypedDict):
        trust: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgsDict']
        """
        TLS validation context trust.
        """
        subject_alternative_names: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgsDict']]
        """
        SANs for a TLS validation context.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationArgs:
    def __init__(__self__, *,
                 trust: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs'],
                 subject_alternative_names: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs'] trust: TLS validation context trust.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs'] subject_alternative_names: SANs for a TLS validation context.
        """
        pulumi.set(__self__, "trust", trust)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs']:
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs']):
        pulumi.set(self, "trust", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs']]:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs']]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgsDict(TypedDict):
        match: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict']
        """
        Criteria for determining a SAN's match.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs'] match: Criteria for determining a SAN's match.
        """
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']:
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict(TypedDict):
        exacts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values sent must match the specified values exactly.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchArgs:
    def __init__(__self__, *,
                 exacts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exacts: Values sent must match the specified values exactly.
        """
        pulumi.set(__self__, "exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")

    @exacts.setter
    def exacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "exacts", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgsDict(TypedDict):
        acm: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgsDict']]
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        file: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgsDict']]
        """
        TLS validation context trust for a local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgsDict']]
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustArgs:
    def __init__(__self__, *,
                 acm: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs']] = None,
                 file: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs'] acm: TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs'] file: TLS validation context trust for a local file certificate.
        :param pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs'] sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if acm is not None:
            pulumi.set(__self__, "acm", acm)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs']]:
        """
        TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @acm.setter
    def acm(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs']]):
        pulumi.set(self, "acm", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs']]:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs']]:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgsDict(TypedDict):
        certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        One or more ACM ARNs.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmArgs:
    def __init__(__self__, *,
                 certificate_authority_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_authority_arns: One or more ACM ARNs.
        """
        pulumi.set(__self__, "certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more ACM ARNs.
        """
        return pulumi.get(self, "certificate_authority_arns")

    @certificate_authority_arns.setter
    def certificate_authority_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "certificate_authority_arns", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecListenerArgsDict(TypedDict):
        port_mapping: pulumi.Input['VirtualNodeSpecListenerPortMappingArgsDict']
        """
        Port mapping information for the listener.
        """
        connection_pool: NotRequired[pulumi.Input['VirtualNodeSpecListenerConnectionPoolArgsDict']]
        """
        Connection pool information for the listener.
        """
        health_check: NotRequired[pulumi.Input['VirtualNodeSpecListenerHealthCheckArgsDict']]
        """
        Health check information for the listener.
        """
        outlier_detection: NotRequired[pulumi.Input['VirtualNodeSpecListenerOutlierDetectionArgsDict']]
        """
        Outlier detection information for the listener.
        """
        timeout: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutArgsDict']]
        """
        Timeouts for different protocols.
        """
        tls: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsArgsDict']]
        """
        Transport Layer Security (TLS) properties for the listener
        """
elif False:
    VirtualNodeSpecListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerArgs:
    def __init__(__self__, *,
                 port_mapping: pulumi.Input['VirtualNodeSpecListenerPortMappingArgs'],
                 connection_pool: Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolArgs']] = None,
                 health_check: Optional[pulumi.Input['VirtualNodeSpecListenerHealthCheckArgs']] = None,
                 outlier_detection: Optional[pulumi.Input['VirtualNodeSpecListenerOutlierDetectionArgs']] = None,
                 timeout: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutArgs']] = None,
                 tls: Optional[pulumi.Input['VirtualNodeSpecListenerTlsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerPortMappingArgs'] port_mapping: Port mapping information for the listener.
        :param pulumi.Input['VirtualNodeSpecListenerConnectionPoolArgs'] connection_pool: Connection pool information for the listener.
        :param pulumi.Input['VirtualNodeSpecListenerHealthCheckArgs'] health_check: Health check information for the listener.
        :param pulumi.Input['VirtualNodeSpecListenerOutlierDetectionArgs'] outlier_detection: Outlier detection information for the listener.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutArgs'] timeout: Timeouts for different protocols.
        :param pulumi.Input['VirtualNodeSpecListenerTlsArgs'] tls: Transport Layer Security (TLS) properties for the listener
        """
        pulumi.set(__self__, "port_mapping", port_mapping)
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> pulumi.Input['VirtualNodeSpecListenerPortMappingArgs']:
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")

    @port_mapping.setter
    def port_mapping(self, value: pulumi.Input['VirtualNodeSpecListenerPortMappingArgs']):
        pulumi.set(self, "port_mapping", value)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolArgs']]:
        """
        Connection pool information for the listener.
        """
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerHealthCheckArgs']]:
        """
        Health check information for the listener.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerOutlierDetectionArgs']]:
        """
        Outlier detection information for the listener.
        """
        return pulumi.get(self, "outlier_detection")

    @outlier_detection.setter
    def outlier_detection(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerOutlierDetectionArgs']]):
        pulumi.set(self, "outlier_detection", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutArgs']]:
        """
        Timeouts for different protocols.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutArgs']]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsArgs']]:
        """
        Transport Layer Security (TLS) properties for the listener
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class VirtualNodeSpecListenerConnectionPoolArgsDict(TypedDict):
        grpc: NotRequired[pulumi.Input['VirtualNodeSpecListenerConnectionPoolGrpcArgsDict']]
        """
        Connection pool information for gRPC listeners.
        """
        http2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttp2ArgsDict']]]]
        """
        Connection pool information for HTTP2 listeners.
        """
        https: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttpArgsDict']]]]
        """
        Connection pool information for HTTP listeners.
        """
        tcps: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolTcpArgsDict']]]]
        """
        Connection pool information for TCP listeners.
        """
elif False:
    VirtualNodeSpecListenerConnectionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerConnectionPoolArgs:
    def __init__(__self__, *,
                 grpc: Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolGrpcArgs']] = None,
                 http2s: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttp2Args']]]] = None,
                 https: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttpArgs']]]] = None,
                 tcps: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolTcpArgs']]]] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerConnectionPoolGrpcArgs'] grpc: Connection pool information for gRPC listeners.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttp2Args']]] http2s: Connection pool information for HTTP2 listeners.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttpArgs']]] https: Connection pool information for HTTP listeners.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolTcpArgs']]] tcps: Connection pool information for TCP listeners.
        """
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http2s is not None:
            pulumi.set(__self__, "http2s", http2s)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if tcps is not None:
            pulumi.set(__self__, "tcps", tcps)

    @property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolGrpcArgs']]:
        """
        Connection pool information for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerConnectionPoolGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @property
    @pulumi.getter
    def http2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttp2Args']]]]:
        """
        Connection pool information for HTTP2 listeners.
        """
        return pulumi.get(self, "http2s")

    @http2s.setter
    def http2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttp2Args']]]]):
        pulumi.set(self, "http2s", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttpArgs']]]]:
        """
        Connection pool information for HTTP listeners.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolHttpArgs']]]]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter
    def tcps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolTcpArgs']]]]:
        """
        Connection pool information for TCP listeners.
        """
        return pulumi.get(self, "tcps")

    @tcps.setter
    def tcps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecListenerConnectionPoolTcpArgs']]]]):
        pulumi.set(self, "tcps", value)


if not MYPY:
    class VirtualNodeSpecListenerConnectionPoolGrpcArgsDict(TypedDict):
        max_requests: pulumi.Input[int]
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualNodeSpecListenerConnectionPoolGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerConnectionPoolGrpcArgs:
    def __init__(__self__, *,
                 max_requests: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> pulumi.Input[int]:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")

    @max_requests.setter
    def max_requests(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_requests", value)


if not MYPY:
    class VirtualNodeSpecListenerConnectionPoolHttp2ArgsDict(TypedDict):
        max_requests: pulumi.Input[int]
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualNodeSpecListenerConnectionPoolHttp2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerConnectionPoolHttp2Args:
    def __init__(__self__, *,
                 max_requests: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_requests: Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_requests", max_requests)

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> pulumi.Input[int]:
        """
        Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_requests")

    @max_requests.setter
    def max_requests(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_requests", value)


if not MYPY:
    class VirtualNodeSpecListenerConnectionPoolHttpArgsDict(TypedDict):
        max_connections: pulumi.Input[int]
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        max_pending_requests: NotRequired[pulumi.Input[int]]
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualNodeSpecListenerConnectionPoolHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 max_connections: pulumi.Input[int],
                 max_pending_requests: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        :param pulumi.Input[int] max_pending_requests: Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> pulumi.Input[int]:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Number of overflowing requests after `max_connections` Envoy will queue to upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_pending_requests")

    @max_pending_requests.setter
    def max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pending_requests", value)


if not MYPY:
    class VirtualNodeSpecListenerConnectionPoolTcpArgsDict(TypedDict):
        max_connections: pulumi.Input[int]
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
elif False:
    VirtualNodeSpecListenerConnectionPoolTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerConnectionPoolTcpArgs:
    def __init__(__self__, *,
                 max_connections: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_connections: Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        pulumi.set(__self__, "max_connections", max_connections)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> pulumi.Input[int]:
        """
        Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_connections", value)


if not MYPY:
    class VirtualNodeSpecListenerHealthCheckArgsDict(TypedDict):
        healthy_threshold: pulumi.Input[int]
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        interval_millis: pulumi.Input[int]
        """
        Time period in milliseconds between each health check execution.
        """
        protocol: pulumi.Input[str]
        """
        Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        timeout_millis: pulumi.Input[int]
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        unhealthy_threshold: pulumi.Input[int]
        """
        Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
elif False:
    VirtualNodeSpecListenerHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerHealthCheckArgs:
    def __init__(__self__, *,
                 healthy_threshold: pulumi.Input[int],
                 interval_millis: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 timeout_millis: pulumi.Input[int],
                 unhealthy_threshold: pulumi.Input[int],
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] healthy_threshold: Number of consecutive successful health checks that must occur before declaring listener healthy.
        :param pulumi.Input[int] interval_millis: Time period in milliseconds between each health check execution.
        :param pulumi.Input[str] protocol: Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
        :param pulumi.Input[int] timeout_millis: Amount of time to wait when receiving a response from the health check, in milliseconds.
        :param pulumi.Input[int] unhealthy_threshold: Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        :param pulumi.Input[str] path: Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        :param pulumi.Input[int] port: Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "interval_millis", interval_millis)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout_millis", timeout_millis)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> pulumi.Input[int]:
        """
        Number of consecutive successful health checks that must occur before declaring listener healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="intervalMillis")
    def interval_millis(self) -> pulumi.Input[int]:
        """
        Time period in milliseconds between each health check execution.
        """
        return pulumi.get(self, "interval_millis")

    @interval_millis.setter
    def interval_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_millis", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="timeoutMillis")
    def timeout_millis(self) -> pulumi.Input[int]:
        """
        Amount of time to wait when receiving a response from the health check, in milliseconds.
        """
        return pulumi.get(self, "timeout_millis")

    @timeout_millis.setter
    def timeout_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout_millis", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> pulumi.Input[int]:
        """
        Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "unhealthy_threshold", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Destination port for the health check request. This port must match the port defined in the `port_mapping` for the listener.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class VirtualNodeSpecListenerOutlierDetectionArgsDict(TypedDict):
        base_ejection_duration: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgsDict']
        """
        Base amount of time for which a host is ejected.
        """
        interval: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionIntervalArgsDict']
        """
        Time interval between ejection sweep analysis.
        """
        max_ejection_percent: pulumi.Input[int]
        """
        Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        Minimum value of `0`. Maximum value of `100`.
        """
        max_server_errors: pulumi.Input[int]
        """
        Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
        """
elif False:
    VirtualNodeSpecListenerOutlierDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerOutlierDetectionArgs:
    def __init__(__self__, *,
                 base_ejection_duration: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs'],
                 interval: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionIntervalArgs'],
                 max_ejection_percent: pulumi.Input[int],
                 max_server_errors: pulumi.Input[int]):
        """
        :param pulumi.Input['VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs'] base_ejection_duration: Base amount of time for which a host is ejected.
        :param pulumi.Input['VirtualNodeSpecListenerOutlierDetectionIntervalArgs'] interval: Time interval between ejection sweep analysis.
        :param pulumi.Input[int] max_ejection_percent: Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
               Minimum value of `0`. Maximum value of `100`.
        :param pulumi.Input[int] max_server_errors: Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
        """
        pulumi.set(__self__, "base_ejection_duration", base_ejection_duration)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        pulumi.set(__self__, "max_server_errors", max_server_errors)

    @property
    @pulumi.getter(name="baseEjectionDuration")
    def base_ejection_duration(self) -> pulumi.Input['VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs']:
        """
        Base amount of time for which a host is ejected.
        """
        return pulumi.get(self, "base_ejection_duration")

    @base_ejection_duration.setter
    def base_ejection_duration(self, value: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs']):
        pulumi.set(self, "base_ejection_duration", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input['VirtualNodeSpecListenerOutlierDetectionIntervalArgs']:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input['VirtualNodeSpecListenerOutlierDetectionIntervalArgs']):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> pulumi.Input[int]:
        """
        Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        Minimum value of `0`. Maximum value of `100`.
        """
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_ejection_percent", value)

    @property
    @pulumi.getter(name="maxServerErrors")
    def max_server_errors(self) -> pulumi.Input[int]:
        """
        Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
        """
        return pulumi.get(self, "max_server_errors")

    @max_server_errors.setter
    def max_server_errors(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_server_errors", value)


if not MYPY:
    class VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerOutlierDetectionBaseEjectionDurationArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerOutlierDetectionIntervalArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerOutlierDetectionIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerOutlierDetectionIntervalArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerPortMappingArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Port used for the port mapping.
        """
        protocol: pulumi.Input[str]
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
elif False:
    VirtualNodeSpecListenerPortMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerPortMappingArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str]):
        """
        :param pulumi.Input[int] port: Port used for the port mapping.
        :param pulumi.Input[str] protocol: Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutArgsDict(TypedDict):
        grpc: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcArgsDict']]
        """
        Timeouts for gRPC listeners.
        """
        http: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpArgsDict']]
        """
        Timeouts for HTTP listeners.
        """
        http2: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2ArgsDict']]
        """
        Timeouts for HTTP2 listeners.
        """
        tcp: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpArgsDict']]
        """
        Timeouts for TCP listeners.
        """
elif False:
    VirtualNodeSpecListenerTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutArgs:
    def __init__(__self__, *,
                 grpc: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcArgs']] = None,
                 http: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpArgs']] = None,
                 http2: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2Args']] = None,
                 tcp: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcArgs'] grpc: Timeouts for gRPC listeners.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttpArgs'] http: Timeouts for HTTP listeners.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2Args'] http2: Timeouts for HTTP2 listeners.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutTcpArgs'] tcp: Timeouts for TCP listeners.
        """
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcArgs']]:
        """
        Timeouts for gRPC listeners.
        """
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpArgs']]:
        """
        Timeouts for HTTP listeners.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2Args']]:
        """
        Timeouts for HTTP2 listeners.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2Args']]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpArgs']]:
        """
        Timeouts for TCP listeners.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpArgs']]):
        pulumi.set(self, "tcp", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutGrpcArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcPerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    VirtualNodeSpecListenerTimeoutGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutGrpcArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcIdleArgs']] = None,
                 per_request: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcIdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutGrpcIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutGrpcIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutGrpcIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutGrpcPerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutGrpcPerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutGrpcPerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttp2ArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2IdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2PerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttp2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttp2Args:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2IdleArgs']] = None,
                 per_request: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2IdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2IdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2IdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttp2IdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttp2IdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttp2IdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttp2PerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttp2PerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttp2PerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttpArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        per_request: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpPerRequestArgsDict']]
        """
        Per request timeout.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttpArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpIdleArgs']] = None,
                 per_request: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpPerRequestArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttpIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutHttpPerRequestArgs'] per_request: Per request timeout.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)
        if per_request is not None:
            pulumi.set(__self__, "per_request", per_request)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpIdleArgs']]):
        pulumi.set(self, "idle", value)

    @property
    @pulumi.getter(name="perRequest")
    def per_request(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpPerRequestArgs']]:
        """
        Per request timeout.
        """
        return pulumi.get(self, "per_request")

    @per_request.setter
    def per_request(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutHttpPerRequestArgs']]):
        pulumi.set(self, "per_request", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttpIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttpIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttpIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutHttpPerRequestArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutHttpPerRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutHttpPerRequestArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutTcpArgsDict(TypedDict):
        idle: NotRequired[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpIdleArgsDict']]
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
elif False:
    VirtualNodeSpecListenerTimeoutTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutTcpArgs:
    def __init__(__self__, *,
                 idle: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpIdleArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTimeoutTcpIdleArgs'] idle: Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        if idle is not None:
            pulumi.set(__self__, "idle", idle)

    @property
    @pulumi.getter
    def idle(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpIdleArgs']]:
        """
        Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
        """
        return pulumi.get(self, "idle")

    @idle.setter
    def idle(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTimeoutTcpIdleArgs']]):
        pulumi.set(self, "idle", value)


if not MYPY:
    class VirtualNodeSpecListenerTimeoutTcpIdleArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        value: pulumi.Input[int]
        """
        Number of time units. Minimum value of `0`.
        """
elif False:
    VirtualNodeSpecListenerTimeoutTcpIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTimeoutTcpIdleArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time. Valid values: `ms`, `s`.
        :param pulumi.Input[int] value: Number of time units. Minimum value of `0`.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time. Valid values: `ms`, `s`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Number of time units. Minimum value of `0`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsArgsDict(TypedDict):
        certificate: pulumi.Input['VirtualNodeSpecListenerTlsCertificateArgsDict']
        """
        Listener's TLS certificate.
        """
        mode: pulumi.Input[str]
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        validation: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsValidationArgsDict']]
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
elif False:
    VirtualNodeSpecListenerTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input['VirtualNodeSpecListenerTlsCertificateArgs'],
                 mode: pulumi.Input[str],
                 validation: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTlsCertificateArgs'] certificate: Listener's TLS certificate.
        :param pulumi.Input[str] mode: Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationArgs'] validation: Listener's Transport Layer Security (TLS) validation context.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "mode", mode)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input['VirtualNodeSpecListenerTlsCertificateArgs']:
        """
        Listener's TLS certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input['VirtualNodeSpecListenerTlsCertificateArgs']):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationArgs']]:
        """
        Listener's Transport Layer Security (TLS) validation context.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsCertificateArgsDict(TypedDict):
        acm: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsCertificateAcmArgsDict']]
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        file: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsCertificateFileArgsDict']]
        """
        Local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsCertificateSdsArgsDict']]
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecListenerTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsCertificateArgs:
    def __init__(__self__, *,
                 acm: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateAcmArgs']] = None,
                 file: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTlsCertificateAcmArgs'] acm: An AWS Certificate Manager (ACM) certificate.
        :param pulumi.Input['VirtualNodeSpecListenerTlsCertificateFileArgs'] file: Local file certificate.
        :param pulumi.Input['VirtualNodeSpecListenerTlsCertificateSdsArgs'] sds: A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if acm is not None:
            pulumi.set(__self__, "acm", acm)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def acm(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateAcmArgs']]:
        """
        An AWS Certificate Manager (ACM) certificate.
        """
        return pulumi.get(self, "acm")

    @acm.setter
    def acm(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateAcmArgs']]):
        pulumi.set(self, "acm", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateFileArgs']]:
        """
        Local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateSdsArgs']]:
        """
        A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsCertificateSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsCertificateAcmArgsDict(TypedDict):
        certificate_arn: pulumi.Input[str]
        """
        ARN for the certificate.
        """
elif False:
    VirtualNodeSpecListenerTlsCertificateAcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsCertificateAcmArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_arn: ARN for the certificate.
        """
        pulumi.set(__self__, "certificate_arn", certificate_arn)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[str]:
        """
        ARN for the certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_arn", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsCertificateFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        private_key: pulumi.Input[str]
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecListenerTlsCertificateFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsCertificateFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        :param pulumi.Input[str] private_key: Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsCertificateSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecListenerTlsCertificateSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsCertificateSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationArgsDict(TypedDict):
        trust: pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustArgsDict']
        """
        TLS validation context trust.
        """
        subject_alternative_names: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgsDict']]
        """
        SANs for a TLS validation context.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationArgs:
    def __init__(__self__, *,
                 trust: pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustArgs'],
                 subject_alternative_names: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustArgs'] trust: TLS validation context trust.
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs'] subject_alternative_names: SANs for a TLS validation context.
        """
        pulumi.set(__self__, "trust", trust)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def trust(self) -> pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustArgs']:
        """
        TLS validation context trust.
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustArgs']):
        pulumi.set(self, "trust", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs']]:
        """
        SANs for a TLS validation context.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs']]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgsDict(TypedDict):
        match: pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict']
        """
        Criteria for determining a SAN's match.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs'] match: Criteria for determining a SAN's match.
        """
        pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']:
        """
        Criteria for determining a SAN's match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict(TypedDict):
        exacts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values sent must match the specified values exactly.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatchArgs:
    def __init__(__self__, *,
                 exacts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exacts: Values sent must match the specified values exactly.
        """
        pulumi.set(__self__, "exacts", exacts)

    @property
    @pulumi.getter
    def exacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values sent must match the specified values exactly.
        """
        return pulumi.get(self, "exacts")

    @exacts.setter
    def exacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "exacts", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationTrustArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustFileArgsDict']]
        """
        TLS validation context trust for a local file certificate.
        """
        sds: NotRequired[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustSdsArgsDict']]
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationTrustArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationTrustArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustFileArgs']] = None,
                 sds: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustSdsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustFileArgs'] file: TLS validation context trust for a local file certificate.
        :param pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustSdsArgs'] sds: TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sds is not None:
            pulumi.set(__self__, "sds", sds)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustFileArgs']]:
        """
        TLS validation context trust for a local file certificate.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def sds(self) -> Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustSdsArgs']]:
        """
        TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
        """
        return pulumi.get(self, "sds")

    @sds.setter
    def sds(self, value: Optional[pulumi.Input['VirtualNodeSpecListenerTlsValidationTrustSdsArgs']]):
        pulumi.set(self, "sds", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationTrustFileArgsDict(TypedDict):
        certificate_chain: pulumi.Input[str]
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationTrustFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationTrustFileArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class VirtualNodeSpecListenerTlsValidationTrustSdsArgsDict(TypedDict):
        secret_name: pulumi.Input[str]
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
elif False:
    VirtualNodeSpecListenerTlsValidationTrustSdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecListenerTlsValidationTrustSdsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_name: Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class VirtualNodeSpecLoggingArgsDict(TypedDict):
        access_log: NotRequired[pulumi.Input['VirtualNodeSpecLoggingAccessLogArgsDict']]
        """
        Access log configuration for a virtual node.
        """
elif False:
    VirtualNodeSpecLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecLoggingArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecLoggingAccessLogArgs'] access_log: Access log configuration for a virtual node.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogArgs']]:
        """
        Access log configuration for a virtual node.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogArgs']]):
        pulumi.set(self, "access_log", value)


if not MYPY:
    class VirtualNodeSpecLoggingAccessLogArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileArgsDict']]
        """
        File object to send virtual node access logs to.
        """
elif False:
    VirtualNodeSpecLoggingAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecLoggingAccessLogArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecLoggingAccessLogFileArgs'] file: File object to send virtual node access logs to.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileArgs']]:
        """
        File object to send virtual node access logs to.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileArgs']]):
        pulumi.set(self, "file", value)


if not MYPY:
    class VirtualNodeSpecLoggingAccessLogFileArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        format: NotRequired[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatArgsDict']]
        """
        The specified format for the logs.
        """
elif False:
    VirtualNodeSpecLoggingAccessLogFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecLoggingAccessLogFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 format: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatArgs']] = None):
        """
        :param pulumi.Input[str] path: File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        :param pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatArgs'] format: The specified format for the logs.
        """
        pulumi.set(__self__, "path", path)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatArgs']]:
        """
        The specified format for the logs.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatArgs']]):
        pulumi.set(self, "format", value)


if not MYPY:
    class VirtualNodeSpecLoggingAccessLogFileFormatArgsDict(TypedDict):
        jsons: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgsDict']]]]
        """
        The logging format for JSON.
        """
        text: NotRequired[pulumi.Input[str]]
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
elif False:
    VirtualNodeSpecLoggingAccessLogFileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecLoggingAccessLogFileFormatArgs:
    def __init__(__self__, *,
                 jsons: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs']]]] = None,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs']]] jsons: The logging format for JSON.
        :param pulumi.Input[str] text: The logging format for text. Must be between 1 and 1000 characters in length.
        """
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def jsons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs']]]]:
        """
        The logging format for JSON.
        """
        return pulumi.get(self, "jsons")

    @jsons.setter
    def jsons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs']]]]):
        pulumi.set(self, "jsons", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        The logging format for text. Must be between 1 and 1000 characters in length.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class VirtualNodeSpecLoggingAccessLogFileFormatJsonArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        value: pulumi.Input[str]
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
elif False:
    VirtualNodeSpecLoggingAccessLogFileFormatJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecLoggingAccessLogFileFormatJsonArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The specified key for the JSON. Must be between 1 and 100 characters in length.
        :param pulumi.Input[str] value: The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The specified key for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The specified value for the JSON. Must be between 1 and 100 characters in length.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNodeSpecServiceDiscoveryArgsDict(TypedDict):
        aws_cloud_map: NotRequired[pulumi.Input['VirtualNodeSpecServiceDiscoveryAwsCloudMapArgsDict']]
        """
        Any AWS Cloud Map information for the virtual node.
        """
        dns: NotRequired[pulumi.Input['VirtualNodeSpecServiceDiscoveryDnsArgsDict']]
        """
        DNS service name for the virtual node.
        """
elif False:
    VirtualNodeSpecServiceDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecServiceDiscoveryArgs:
    def __init__(__self__, *,
                 aws_cloud_map: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs']] = None,
                 dns: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryDnsArgs']] = None):
        """
        :param pulumi.Input['VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs'] aws_cloud_map: Any AWS Cloud Map information for the virtual node.
        :param pulumi.Input['VirtualNodeSpecServiceDiscoveryDnsArgs'] dns: DNS service name for the virtual node.
        """
        if aws_cloud_map is not None:
            pulumi.set(__self__, "aws_cloud_map", aws_cloud_map)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)

    @property
    @pulumi.getter(name="awsCloudMap")
    def aws_cloud_map(self) -> Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs']]:
        """
        Any AWS Cloud Map information for the virtual node.
        """
        return pulumi.get(self, "aws_cloud_map")

    @aws_cloud_map.setter
    def aws_cloud_map(self, value: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs']]):
        pulumi.set(self, "aws_cloud_map", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryDnsArgs']]:
        """
        DNS service name for the virtual node.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['VirtualNodeSpecServiceDiscoveryDnsArgs']]):
        pulumi.set(self, "dns", value)


if not MYPY:
    class VirtualNodeSpecServiceDiscoveryAwsCloudMapArgsDict(TypedDict):
        namespace_name: pulumi.Input[str]
        """
        Name of the AWS Cloud Map namespace to use.
        Use the `servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
        """
        service_name: pulumi.Input[str]
        """
        Name of the AWS Cloud Map service to use. Use the `servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
        """
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        """
elif False:
    VirtualNodeSpecServiceDiscoveryAwsCloudMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecServiceDiscoveryAwsCloudMapArgs:
    def __init__(__self__, *,
                 namespace_name: pulumi.Input[str],
                 service_name: pulumi.Input[str],
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] namespace_name: Name of the AWS Cloud Map namespace to use.
               Use the `servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
        :param pulumi.Input[str] service_name: Name of the AWS Cloud Map service to use. Use the `servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        """
        pulumi.set(__self__, "namespace_name", namespace_name)
        pulumi.set(__self__, "service_name", service_name)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> pulumi.Input[str]:
        """
        Name of the AWS Cloud Map namespace to use.
        Use the `servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_name", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Name of the AWS Cloud Map service to use. Use the `servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class VirtualNodeSpecServiceDiscoveryDnsArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        DNS host name for your virtual node.
        """
        ip_preference: NotRequired[pulumi.Input[str]]
        """
        The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
        """
        response_type: NotRequired[pulumi.Input[str]]
        """
        The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
        """
elif False:
    VirtualNodeSpecServiceDiscoveryDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNodeSpecServiceDiscoveryDnsArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ip_preference: Optional[pulumi.Input[str]] = None,
                 response_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: DNS host name for your virtual node.
        :param pulumi.Input[str] ip_preference: The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
        :param pulumi.Input[str] response_type: The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
        """
        pulumi.set(__self__, "hostname", hostname)
        if ip_preference is not None:
            pulumi.set(__self__, "ip_preference", ip_preference)
        if response_type is not None:
            pulumi.set(__self__, "response_type", response_type)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        DNS host name for your virtual node.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipPreference")
    def ip_preference(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
        """
        return pulumi.get(self, "ip_preference")

    @ip_preference.setter
    def ip_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_preference", value)

    @property
    @pulumi.getter(name="responseType")
    def response_type(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
        """
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_type", value)


if not MYPY:
    class VirtualRouterSpecArgsDict(TypedDict):
        listeners: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualRouterSpecListenerArgsDict']]]]
        """
        Listeners that the virtual router is expected to receive inbound traffic from.
        Currently only one listener is supported per virtual router.
        """
elif False:
    VirtualRouterSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualRouterSpecArgs:
    def __init__(__self__, *,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualRouterSpecListenerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualRouterSpecListenerArgs']]] listeners: Listeners that the virtual router is expected to receive inbound traffic from.
               Currently only one listener is supported per virtual router.
        """
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualRouterSpecListenerArgs']]]]:
        """
        Listeners that the virtual router is expected to receive inbound traffic from.
        Currently only one listener is supported per virtual router.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualRouterSpecListenerArgs']]]]):
        pulumi.set(self, "listeners", value)


if not MYPY:
    class VirtualRouterSpecListenerArgsDict(TypedDict):
        port_mapping: pulumi.Input['VirtualRouterSpecListenerPortMappingArgsDict']
        """
        Port mapping information for the listener.
        """
elif False:
    VirtualRouterSpecListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualRouterSpecListenerArgs:
    def __init__(__self__, *,
                 port_mapping: pulumi.Input['VirtualRouterSpecListenerPortMappingArgs']):
        """
        :param pulumi.Input['VirtualRouterSpecListenerPortMappingArgs'] port_mapping: Port mapping information for the listener.
        """
        pulumi.set(__self__, "port_mapping", port_mapping)

    @property
    @pulumi.getter(name="portMapping")
    def port_mapping(self) -> pulumi.Input['VirtualRouterSpecListenerPortMappingArgs']:
        """
        Port mapping information for the listener.
        """
        return pulumi.get(self, "port_mapping")

    @port_mapping.setter
    def port_mapping(self, value: pulumi.Input['VirtualRouterSpecListenerPortMappingArgs']):
        pulumi.set(self, "port_mapping", value)


if not MYPY:
    class VirtualRouterSpecListenerPortMappingArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Port used for the port mapping.
        """
        protocol: pulumi.Input[str]
        """
        Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
        """
elif False:
    VirtualRouterSpecListenerPortMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualRouterSpecListenerPortMappingArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str]):
        """
        :param pulumi.Input[int] port: Port used for the port mapping.
        :param pulumi.Input[str] protocol: Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port used for the port mapping.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class VirtualServiceSpecArgsDict(TypedDict):
        provider: NotRequired[pulumi.Input['VirtualServiceSpecProviderArgsDict']]
        """
        App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        """
elif False:
    VirtualServiceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualServiceSpecArgs:
    def __init__(__self__, *,
                 provider: Optional[pulumi.Input['VirtualServiceSpecProviderArgs']] = None):
        """
        :param pulumi.Input['VirtualServiceSpecProviderArgs'] provider: App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        """
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input['VirtualServiceSpecProviderArgs']]:
        """
        App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input['VirtualServiceSpecProviderArgs']]):
        pulumi.set(self, "provider", value)


if not MYPY:
    class VirtualServiceSpecProviderArgsDict(TypedDict):
        virtual_node: NotRequired[pulumi.Input['VirtualServiceSpecProviderVirtualNodeArgsDict']]
        """
        Virtual node associated with a virtual service.
        """
        virtual_router: NotRequired[pulumi.Input['VirtualServiceSpecProviderVirtualRouterArgsDict']]
        """
        Virtual router associated with a virtual service.
        """
elif False:
    VirtualServiceSpecProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualServiceSpecProviderArgs:
    def __init__(__self__, *,
                 virtual_node: Optional[pulumi.Input['VirtualServiceSpecProviderVirtualNodeArgs']] = None,
                 virtual_router: Optional[pulumi.Input['VirtualServiceSpecProviderVirtualRouterArgs']] = None):
        """
        :param pulumi.Input['VirtualServiceSpecProviderVirtualNodeArgs'] virtual_node: Virtual node associated with a virtual service.
        :param pulumi.Input['VirtualServiceSpecProviderVirtualRouterArgs'] virtual_router: Virtual router associated with a virtual service.
        """
        if virtual_node is not None:
            pulumi.set(__self__, "virtual_node", virtual_node)
        if virtual_router is not None:
            pulumi.set(__self__, "virtual_router", virtual_router)

    @property
    @pulumi.getter(name="virtualNode")
    def virtual_node(self) -> Optional[pulumi.Input['VirtualServiceSpecProviderVirtualNodeArgs']]:
        """
        Virtual node associated with a virtual service.
        """
        return pulumi.get(self, "virtual_node")

    @virtual_node.setter
    def virtual_node(self, value: Optional[pulumi.Input['VirtualServiceSpecProviderVirtualNodeArgs']]):
        pulumi.set(self, "virtual_node", value)

    @property
    @pulumi.getter(name="virtualRouter")
    def virtual_router(self) -> Optional[pulumi.Input['VirtualServiceSpecProviderVirtualRouterArgs']]:
        """
        Virtual router associated with a virtual service.
        """
        return pulumi.get(self, "virtual_router")

    @virtual_router.setter
    def virtual_router(self, value: Optional[pulumi.Input['VirtualServiceSpecProviderVirtualRouterArgs']]):
        pulumi.set(self, "virtual_router", value)


if not MYPY:
    class VirtualServiceSpecProviderVirtualNodeArgsDict(TypedDict):
        virtual_node_name: pulumi.Input[str]
        """
        Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualServiceSpecProviderVirtualNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualServiceSpecProviderVirtualNodeArgs:
    def __init__(__self__, *,
                 virtual_node_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] virtual_node_name: Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "virtual_node_name", virtual_node_name)

    @property
    @pulumi.getter(name="virtualNodeName")
    def virtual_node_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_node_name")

    @virtual_node_name.setter
    def virtual_node_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_node_name", value)


if not MYPY:
    class VirtualServiceSpecProviderVirtualRouterArgsDict(TypedDict):
        virtual_router_name: pulumi.Input[str]
        """
        Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
elif False:
    VirtualServiceSpecProviderVirtualRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualServiceSpecProviderVirtualRouterArgs:
    def __init__(__self__, *,
                 virtual_router_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] virtual_router_name: Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        pulumi.set(__self__, "virtual_router_name", virtual_router_name)

    @property
    @pulumi.getter(name="virtualRouterName")
    def virtual_router_name(self) -> pulumi.Input[str]:
        """
        Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
        """
        return pulumi.get(self, "virtual_router_name")

    @virtual_router_name.setter
    def virtual_router_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_router_name", value)


