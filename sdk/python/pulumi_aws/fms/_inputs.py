# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'PolicyExcludeMapArgs',
    'PolicyExcludeMapArgsDict',
    'PolicyIncludeMapArgs',
    'PolicyIncludeMapArgsDict',
    'PolicySecurityServicePolicyDataArgs',
    'PolicySecurityServicePolicyDataArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionArgs',
    'PolicySecurityServicePolicyDataPolicyOptionArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs',
    'PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgsDict',
    'PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgs',
    'PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgsDict',
    'ResourceSetResourceSetArgs',
    'ResourceSetResourceSetArgsDict',
    'ResourceSetTimeoutsArgs',
    'ResourceSetTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class PolicyExcludeMapArgsDict(TypedDict):
        accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        """
        orgunits: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.

        You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
elif False:
    PolicyExcludeMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyExcludeMapArgs:
    def __init__(__self__, *,
                 accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 orgunits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] accounts: A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] orgunits: A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
               
               You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if orgunits is not None:
            pulumi.set(__self__, "orgunits", orgunits)

    @property
    @pulumi.getter
    def accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        """
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "accounts", value)

    @property
    @pulumi.getter
    def orgunits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.

        You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
        return pulumi.get(self, "orgunits")

    @orgunits.setter
    def orgunits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "orgunits", value)


if not MYPY:
    class PolicyIncludeMapArgsDict(TypedDict):
        accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        """
        orgunits: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.

        You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
elif False:
    PolicyIncludeMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyIncludeMapArgs:
    def __init__(__self__, *,
                 accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 orgunits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] accounts: A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] orgunits: A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
               
               You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if orgunits is not None:
            pulumi.set(__self__, "orgunits", orgunits)

    @property
    @pulumi.getter
    def accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
        """
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "accounts", value)

    @property
    @pulumi.getter
    def orgunits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.

        You can specify inclusions or exclusions, but not both. If you specify an `include_map`, AWS Firewall Manager applies the policy to all accounts specified by the `include_map`, and does not evaluate any `exclude_map` specifications. If you do not specify an `include_map`, then Firewall Manager applies the policy to all accounts except for those specified by the `exclude_map`.
        """
        return pulumi.get(self, "orgunits")

    @orgunits.setter
    def orgunits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "orgunits", value)


if not MYPY:
    class PolicySecurityServicePolicyDataArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        An integer value containing ICMP type.
        """
        managed_service_data: NotRequired[pulumi.Input[str]]
        """
        Details about the service that are specific to the service type, in JSON format. For service type `SHIELD_ADVANCED`, this is an empty string. Examples depending on `type` can be found in the [AWS Firewall Manager SecurityServicePolicyData API Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html).
        """
        policy_option: NotRequired[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionArgsDict']]
        """
        Contains the Network Firewall firewall policy options to configure a centralized deployment model. See the `policy_option` block.
        """
elif False:
    PolicySecurityServicePolicyDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 managed_service_data: Optional[pulumi.Input[str]] = None,
                 policy_option: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionArgs']] = None):
        """
        :param pulumi.Input[str] type: An integer value containing ICMP type.
        :param pulumi.Input[str] managed_service_data: Details about the service that are specific to the service type, in JSON format. For service type `SHIELD_ADVANCED`, this is an empty string. Examples depending on `type` can be found in the [AWS Firewall Manager SecurityServicePolicyData API Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html).
        :param pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionArgs'] policy_option: Contains the Network Firewall firewall policy options to configure a centralized deployment model. See the `policy_option` block.
        """
        pulumi.set(__self__, "type", type)
        if managed_service_data is not None:
            pulumi.set(__self__, "managed_service_data", managed_service_data)
        if policy_option is not None:
            pulumi.set(__self__, "policy_option", policy_option)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        An integer value containing ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="managedServiceData")
    def managed_service_data(self) -> Optional[pulumi.Input[str]]:
        """
        Details about the service that are specific to the service type, in JSON format. For service type `SHIELD_ADVANCED`, this is an empty string. Examples depending on `type` can be found in the [AWS Firewall Manager SecurityServicePolicyData API Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html).
        """
        return pulumi.get(self, "managed_service_data")

    @managed_service_data.setter
    def managed_service_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_service_data", value)

    @property
    @pulumi.getter(name="policyOption")
    def policy_option(self) -> Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionArgs']]:
        """
        Contains the Network Firewall firewall policy options to configure a centralized deployment model. See the `policy_option` block.
        """
        return pulumi.get(self, "policy_option")

    @policy_option.setter
    def policy_option(self, value: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionArgs']]):
        pulumi.set(self, "policy_option", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionArgsDict(TypedDict):
        network_acl_common_policy: NotRequired[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgsDict']]
        """
        Defines NACL rules across accounts in their AWS Organization. See the `network_acl_common_policy` block.
        """
        network_firewall_policy: NotRequired[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgsDict']]
        """
        Defines the deployment model to use for the firewall policy.  See the `network_firewall_policy` block.
        """
        third_party_firewall_policy: NotRequired[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgsDict']]
elif False:
    PolicySecurityServicePolicyDataPolicyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionArgs:
    def __init__(__self__, *,
                 network_acl_common_policy: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs']] = None,
                 network_firewall_policy: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs']] = None,
                 third_party_firewall_policy: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgs']] = None):
        """
        :param pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs'] network_acl_common_policy: Defines NACL rules across accounts in their AWS Organization. See the `network_acl_common_policy` block.
        :param pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs'] network_firewall_policy: Defines the deployment model to use for the firewall policy.  See the `network_firewall_policy` block.
        """
        if network_acl_common_policy is not None:
            pulumi.set(__self__, "network_acl_common_policy", network_acl_common_policy)
        if network_firewall_policy is not None:
            pulumi.set(__self__, "network_firewall_policy", network_firewall_policy)
        if third_party_firewall_policy is not None:
            pulumi.set(__self__, "third_party_firewall_policy", third_party_firewall_policy)

    @property
    @pulumi.getter(name="networkAclCommonPolicy")
    def network_acl_common_policy(self) -> Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs']]:
        """
        Defines NACL rules across accounts in their AWS Organization. See the `network_acl_common_policy` block.
        """
        return pulumi.get(self, "network_acl_common_policy")

    @network_acl_common_policy.setter
    def network_acl_common_policy(self, value: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs']]):
        pulumi.set(self, "network_acl_common_policy", value)

    @property
    @pulumi.getter(name="networkFirewallPolicy")
    def network_firewall_policy(self) -> Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs']]:
        """
        Defines the deployment model to use for the firewall policy.  See the `network_firewall_policy` block.
        """
        return pulumi.get(self, "network_firewall_policy")

    @network_firewall_policy.setter
    def network_firewall_policy(self, value: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs']]):
        pulumi.set(self, "network_firewall_policy", value)

    @property
    @pulumi.getter(name="thirdPartyFirewallPolicy")
    def third_party_firewall_policy(self) -> Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgs']]:
        return pulumi.get(self, "third_party_firewall_policy")

    @third_party_firewall_policy.setter
    def third_party_firewall_policy(self, value: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgs']]):
        pulumi.set(self, "third_party_firewall_policy", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgsDict(TypedDict):
        network_acl_entry_set: NotRequired[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgsDict']]
        """
        Defines NACL entries for Network ACL policy. See the `network_acl_entry_set` block.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyArgs:
    def __init__(__self__, *,
                 network_acl_entry_set: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs']] = None):
        """
        :param pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs'] network_acl_entry_set: Defines NACL entries for Network ACL policy. See the `network_acl_entry_set` block.
        """
        if network_acl_entry_set is not None:
            pulumi.set(__self__, "network_acl_entry_set", network_acl_entry_set)

    @property
    @pulumi.getter(name="networkAclEntrySet")
    def network_acl_entry_set(self) -> Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs']]:
        """
        Defines NACL entries for Network ACL policy. See the `network_acl_entry_set` block.
        """
        return pulumi.get(self, "network_acl_entry_set")

    @network_acl_entry_set.setter
    def network_acl_entry_set(self, value: Optional[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs']]):
        pulumi.set(self, "network_acl_entry_set", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgsDict(TypedDict):
        force_remediate_for_first_entries: pulumi.Input[bool]
        """
        A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        """
        force_remediate_for_last_entries: pulumi.Input[bool]
        """
        A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        """
        first_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgsDict']]]]
        """
        The rules that you want to run first in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 1 and 5000. See the `first_entry` block.
        """
        last_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgsDict']]]]
        """
        The rules that you want to run last in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 32000 and 32766. See the `last_entry` block.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetArgs:
    def __init__(__self__, *,
                 force_remediate_for_first_entries: pulumi.Input[bool],
                 force_remediate_for_last_entries: pulumi.Input[bool],
                 first_entries: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs']]]] = None,
                 last_entries: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs']]]] = None):
        """
        :param pulumi.Input[bool] force_remediate_for_first_entries: A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        :param pulumi.Input[bool] force_remediate_for_last_entries: A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs']]] first_entries: The rules that you want to run first in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 1 and 5000. See the `first_entry` block.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs']]] last_entries: The rules that you want to run last in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 32000 and 32766. See the `last_entry` block.
        """
        pulumi.set(__self__, "force_remediate_for_first_entries", force_remediate_for_first_entries)
        pulumi.set(__self__, "force_remediate_for_last_entries", force_remediate_for_last_entries)
        if first_entries is not None:
            pulumi.set(__self__, "first_entries", first_entries)
        if last_entries is not None:
            pulumi.set(__self__, "last_entries", last_entries)

    @property
    @pulumi.getter(name="forceRemediateForFirstEntries")
    def force_remediate_for_first_entries(self) -> pulumi.Input[bool]:
        """
        A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        """
        return pulumi.get(self, "force_remediate_for_first_entries")

    @force_remediate_for_first_entries.setter
    def force_remediate_for_first_entries(self, value: pulumi.Input[bool]):
        pulumi.set(self, "force_remediate_for_first_entries", value)

    @property
    @pulumi.getter(name="forceRemediateForLastEntries")
    def force_remediate_for_last_entries(self) -> pulumi.Input[bool]:
        """
        A boolean value, if true Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If false Firewall Manager marks the network ACL as noncompliant and does not try to remediate.
        """
        return pulumi.get(self, "force_remediate_for_last_entries")

    @force_remediate_for_last_entries.setter
    def force_remediate_for_last_entries(self, value: pulumi.Input[bool]):
        pulumi.set(self, "force_remediate_for_last_entries", value)

    @property
    @pulumi.getter(name="firstEntries")
    def first_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs']]]]:
        """
        The rules that you want to run first in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 1 and 5000. See the `first_entry` block.
        """
        return pulumi.get(self, "first_entries")

    @first_entries.setter
    def first_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs']]]]):
        pulumi.set(self, "first_entries", value)

    @property
    @pulumi.getter(name="lastEntries")
    def last_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs']]]]:
        """
        The rules that you want to run last in the Firewall Manager managed network ACLs. Firewall manager creates entries with ID value between 32000 and 32766. See the `last_entry` block.
        """
        return pulumi.get(self, "last_entries")

    @last_entries.setter
    def last_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs']]]]):
        pulumi.set(self, "last_entries", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgsDict(TypedDict):
        egress: pulumi.Input[bool]
        """
        A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        """
        protocol: pulumi.Input[str]
        """
        The protocol number. A value of "-1" means all protocols.
        """
        rule_action: pulumi.Input[str]
        """
        A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        """
        cidr_block: NotRequired[pulumi.Input[str]]
        """
        A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        """
        icmp_type_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgsDict']]]]
        """
        A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        """
        A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgsDict']]]]
        """
        A configuration block for PortRange. See the `port_range` block.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryArgs:
    def __init__(__self__, *,
                 egress: pulumi.Input[bool],
                 protocol: pulumi.Input[str],
                 rule_action: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_type_codes: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs']]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs']]]] = None):
        """
        :param pulumi.Input[bool] egress: A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        :param pulumi.Input[str] protocol: The protocol number. A value of "-1" means all protocols.
        :param pulumi.Input[str] rule_action: A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        :param pulumi.Input[str] cidr_block: A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs']]] icmp_type_codes: A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        :param pulumi.Input[str] ipv6_cidr_block: A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs']]] port_ranges: A configuration block for PortRange. See the `port_range` block.
        """
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_type_codes is not None:
            pulumi.set(__self__, "icmp_type_codes", icmp_type_codes)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)

    @property
    @pulumi.getter
    def egress(self) -> pulumi.Input[bool]:
        """
        A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: pulumi.Input[bool]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol number. A value of "-1" means all protocols.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> pulumi.Input[str]:
        """
        A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "rule_action")

    @rule_action.setter
    def rule_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_action", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpTypeCodes")
    def icmp_type_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs']]]]:
        """
        A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        """
        return pulumi.get(self, "icmp_type_codes")

    @icmp_type_codes.setter
    def icmp_type_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs']]]]):
        pulumi.set(self, "icmp_type_codes", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs']]]]:
        """
        A configuration block for PortRange. See the `port_range` block.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs']]]]):
        pulumi.set(self, "port_ranges", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        An integer value containing ICMP code.
        """
        type: NotRequired[pulumi.Input[int]]
        """
        An integer value containing ICMP type.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryIcmpTypeCodeArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] code: An integer value containing ICMP code.
        :param pulumi.Input[int] type: An integer value containing ICMP type.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value containing ICMP code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value containing ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[int]]
        """
        The beginning port number of the range.
        """
        to: NotRequired[pulumi.Input[int]]
        """
        The ending port number of the range.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetFirstEntryPortRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[int]] = None,
                 to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_: The beginning port number of the range.
        :param pulumi.Input[int] to: The ending port number of the range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[int]]:
        """
        The beginning port number of the range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[int]]:
        """
        The ending port number of the range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgsDict(TypedDict):
        egress: pulumi.Input[bool]
        """
        A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        """
        protocol: pulumi.Input[str]
        """
        The protocol number. A value of "-1" means all protocols.
        """
        rule_action: pulumi.Input[str]
        """
        A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        """
        cidr_block: NotRequired[pulumi.Input[str]]
        """
        A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        """
        icmp_type_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgsDict']]]]
        """
        A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        """
        A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgsDict']]]]
        """
        A configuration block for PortRange. See the `port_range` block.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryArgs:
    def __init__(__self__, *,
                 egress: pulumi.Input[bool],
                 protocol: pulumi.Input[str],
                 rule_action: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_type_codes: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs']]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs']]]] = None):
        """
        :param pulumi.Input[bool] egress: A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        :param pulumi.Input[str] protocol: The protocol number. A value of "-1" means all protocols.
        :param pulumi.Input[str] rule_action: A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        :param pulumi.Input[str] cidr_block: A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs']]] icmp_type_codes: A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        :param pulumi.Input[str] ipv6_cidr_block: A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs']]] port_ranges: A configuration block for PortRange. See the `port_range` block.
        """
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_type_codes is not None:
            pulumi.set(__self__, "icmp_type_codes", icmp_type_codes)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)

    @property
    @pulumi.getter
    def egress(self) -> pulumi.Input[bool]:
        """
        A boolean value, if true Firewall Manager creates egress rule. If false Firewall Manager creates ingress rule.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: pulumi.Input[bool]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol number. A value of "-1" means all protocols.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> pulumi.Input[str]:
        """
        A string value that indicates whether to allow or deny the traffic that matches the rule. Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "rule_action")

    @rule_action.setter
    def rule_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_action", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        A string value containing the IPv4 network range to allow or deny, in CIDR notation.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpTypeCodes")
    def icmp_type_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs']]]]:
        """
        A configuration block for ICMP protocol: The ICMP type and code. See the `icmp_type_code` block.
        """
        return pulumi.get(self, "icmp_type_codes")

    @icmp_type_codes.setter
    def icmp_type_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs']]]]):
        pulumi.set(self, "icmp_type_codes", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        A string value containing the IPv6 network range to allow or deny, in CIDR notation.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs']]]]:
        """
        A configuration block for PortRange. See the `port_range` block.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs']]]]):
        pulumi.set(self, "port_ranges", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        An integer value containing ICMP code.
        """
        type: NotRequired[pulumi.Input[int]]
        """
        An integer value containing ICMP type.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryIcmpTypeCodeArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] code: An integer value containing ICMP code.
        :param pulumi.Input[int] type: An integer value containing ICMP type.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value containing ICMP code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value containing ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[int]]
        """
        The beginning port number of the range.
        """
        to: NotRequired[pulumi.Input[int]]
        """
        The ending port number of the range.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkAclCommonPolicyNetworkAclEntrySetLastEntryPortRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[int]] = None,
                 to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_: The beginning port number of the range.
        :param pulumi.Input[int] to: The ending port number of the range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[int]]:
        """
        The beginning port number of the range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[int]]:
        """
        The ending port number of the range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgsDict(TypedDict):
        firewall_deployment_model: NotRequired[pulumi.Input[str]]
        """
        Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicyArgs:
    def __init__(__self__, *,
                 firewall_deployment_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] firewall_deployment_model: Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
        if firewall_deployment_model is not None:
            pulumi.set(__self__, "firewall_deployment_model", firewall_deployment_model)

    @property
    @pulumi.getter(name="firewallDeploymentModel")
    def firewall_deployment_model(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
        return pulumi.get(self, "firewall_deployment_model")

    @firewall_deployment_model.setter
    def firewall_deployment_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_deployment_model", value)


if not MYPY:
    class PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgsDict(TypedDict):
        firewall_deployment_model: NotRequired[pulumi.Input[str]]
        """
        Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
elif False:
    PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicyArgs:
    def __init__(__self__, *,
                 firewall_deployment_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] firewall_deployment_model: Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
        if firewall_deployment_model is not None:
            pulumi.set(__self__, "firewall_deployment_model", firewall_deployment_model)

    @property
    @pulumi.getter(name="firewallDeploymentModel")
    def firewall_deployment_model(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
        """
        return pulumi.get(self, "firewall_deployment_model")

    @firewall_deployment_model.setter
    def firewall_deployment_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_deployment_model", value)


if not MYPY:
    class ResourceSetResourceSetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Descriptive name of the resource set. You can't change the name of a resource set after you create it.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the resource set.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the resource set. It's returned in the responses to create and list commands. You provide it to operations like update and delete.
        """
        last_update_time: NotRequired[pulumi.Input[str]]
        """
        Last time that the reosurce set was changed.
        """
        resource_set_status: NotRequired[pulumi.Input[str]]
        """
        Indicates whether the resource set is in or out of the admin's Region scope. Valid values are `ACTIVE` (Admin can manage and delete the resource set) or `OUT_OF_ADMIN_SCOPE` (Admin can view the resource set, but theyy can't edit or delete the resource set.)
        """
        resource_type_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Determines the resources that can be associated to the resource set. Depending on your setting for max results and the number of resource sets, a single call might not return the full list.
        """
        update_token: NotRequired[pulumi.Input[str]]
elif False:
    ResourceSetResourceSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSetResourceSetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_update_time: Optional[pulumi.Input[str]] = None,
                 resource_set_status: Optional[pulumi.Input[str]] = None,
                 resource_type_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 update_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Descriptive name of the resource set. You can't change the name of a resource set after you create it.
        :param pulumi.Input[str] description: Description of the resource set.
        :param pulumi.Input[str] id: Unique identifier for the resource set. It's returned in the responses to create and list commands. You provide it to operations like update and delete.
        :param pulumi.Input[str] last_update_time: Last time that the reosurce set was changed.
        :param pulumi.Input[str] resource_set_status: Indicates whether the resource set is in or out of the admin's Region scope. Valid values are `ACTIVE` (Admin can manage and delete the resource set) or `OUT_OF_ADMIN_SCOPE` (Admin can view the resource set, but theyy can't edit or delete the resource set.)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_type_lists: Determines the resources that can be associated to the resource set. Depending on your setting for max results and the number of resource sets, a single call might not return the full list.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if resource_set_status is not None:
            pulumi.set(__self__, "resource_set_status", resource_set_status)
        if resource_type_lists is not None:
            pulumi.set(__self__, "resource_type_lists", resource_type_lists)
        if update_token is not None:
            pulumi.set(__self__, "update_token", update_token)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Descriptive name of the resource set. You can't change the name of a resource set after you create it.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the resource set.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the resource set. It's returned in the responses to create and list commands. You provide it to operations like update and delete.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time that the reosurce set was changed.
        """
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter(name="resourceSetStatus")
    def resource_set_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates whether the resource set is in or out of the admin's Region scope. Valid values are `ACTIVE` (Admin can manage and delete the resource set) or `OUT_OF_ADMIN_SCOPE` (Admin can view the resource set, but theyy can't edit or delete the resource set.)
        """
        return pulumi.get(self, "resource_set_status")

    @resource_set_status.setter
    def resource_set_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_set_status", value)

    @property
    @pulumi.getter(name="resourceTypeLists")
    def resource_type_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Determines the resources that can be associated to the resource set. Depending on your setting for max results and the number of resource sets, a single call might not return the full list.
        """
        return pulumi.get(self, "resource_type_lists")

    @resource_type_lists.setter
    def resource_type_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_type_lists", value)

    @property
    @pulumi.getter(name="updateToken")
    def update_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "update_token")

    @update_token.setter
    def update_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_token", value)


if not MYPY:
    class ResourceSetTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ResourceSetTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSetTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


