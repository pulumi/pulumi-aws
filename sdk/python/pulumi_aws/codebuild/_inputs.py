# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FleetComputeConfigurationArgs',
    'FleetComputeConfigurationArgsDict',
    'FleetScalingConfigurationArgs',
    'FleetScalingConfigurationArgsDict',
    'FleetScalingConfigurationTargetTrackingScalingConfigArgs',
    'FleetScalingConfigurationTargetTrackingScalingConfigArgsDict',
    'FleetStatusArgs',
    'FleetStatusArgsDict',
    'FleetVpcConfigArgs',
    'FleetVpcConfigArgsDict',
    'ProjectArtifactsArgs',
    'ProjectArtifactsArgsDict',
    'ProjectBuildBatchConfigArgs',
    'ProjectBuildBatchConfigArgsDict',
    'ProjectBuildBatchConfigRestrictionsArgs',
    'ProjectBuildBatchConfigRestrictionsArgsDict',
    'ProjectCacheArgs',
    'ProjectCacheArgsDict',
    'ProjectEnvironmentArgs',
    'ProjectEnvironmentArgsDict',
    'ProjectEnvironmentDockerServerArgs',
    'ProjectEnvironmentDockerServerArgsDict',
    'ProjectEnvironmentEnvironmentVariableArgs',
    'ProjectEnvironmentEnvironmentVariableArgsDict',
    'ProjectEnvironmentFleetArgs',
    'ProjectEnvironmentFleetArgsDict',
    'ProjectEnvironmentRegistryCredentialArgs',
    'ProjectEnvironmentRegistryCredentialArgsDict',
    'ProjectFileSystemLocationArgs',
    'ProjectFileSystemLocationArgsDict',
    'ProjectLogsConfigArgs',
    'ProjectLogsConfigArgsDict',
    'ProjectLogsConfigCloudwatchLogsArgs',
    'ProjectLogsConfigCloudwatchLogsArgsDict',
    'ProjectLogsConfigS3LogsArgs',
    'ProjectLogsConfigS3LogsArgsDict',
    'ProjectSecondaryArtifactArgs',
    'ProjectSecondaryArtifactArgsDict',
    'ProjectSecondarySourceArgs',
    'ProjectSecondarySourceArgsDict',
    'ProjectSecondarySourceAuthArgs',
    'ProjectSecondarySourceAuthArgsDict',
    'ProjectSecondarySourceBuildStatusConfigArgs',
    'ProjectSecondarySourceBuildStatusConfigArgsDict',
    'ProjectSecondarySourceGitSubmodulesConfigArgs',
    'ProjectSecondarySourceGitSubmodulesConfigArgsDict',
    'ProjectSecondarySourceVersionArgs',
    'ProjectSecondarySourceVersionArgsDict',
    'ProjectSourceArgs',
    'ProjectSourceArgsDict',
    'ProjectSourceAuthArgs',
    'ProjectSourceAuthArgsDict',
    'ProjectSourceBuildStatusConfigArgs',
    'ProjectSourceBuildStatusConfigArgsDict',
    'ProjectSourceGitSubmodulesConfigArgs',
    'ProjectSourceGitSubmodulesConfigArgsDict',
    'ProjectVpcConfigArgs',
    'ProjectVpcConfigArgsDict',
    'ReportGroupExportConfigArgs',
    'ReportGroupExportConfigArgsDict',
    'ReportGroupExportConfigS3DestinationArgs',
    'ReportGroupExportConfigS3DestinationArgsDict',
    'WebhookFilterGroupArgs',
    'WebhookFilterGroupArgsDict',
    'WebhookFilterGroupFilterArgs',
    'WebhookFilterGroupFilterArgsDict',
    'WebhookPullRequestBuildPolicyArgs',
    'WebhookPullRequestBuildPolicyArgsDict',
    'WebhookScopeConfigurationArgs',
    'WebhookScopeConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class FleetComputeConfigurationArgsDict(TypedDict):
        disk: NotRequired[pulumi.Input[_builtins.int]]
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        machine_type: NotRequired[pulumi.Input[_builtins.str]]
        memory: NotRequired[pulumi.Input[_builtins.int]]
        vcpu: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetComputeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetComputeConfigurationArgs:
    def __init__(__self__, *,
                 disk: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 machine_type: Optional[pulumi.Input[_builtins.str]] = None,
                 memory: Optional[pulumi.Input[_builtins.int]] = None,
                 vcpu: Optional[pulumi.Input[_builtins.int]] = None):
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if vcpu is not None:
            pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machine_type", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "vcpu")

    @vcpu.setter
    def vcpu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vcpu", value)


if not MYPY:
    class FleetScalingConfigurationArgsDict(TypedDict):
        desired_capacity: NotRequired[pulumi.Input[_builtins.int]]
        max_capacity: NotRequired[pulumi.Input[_builtins.int]]
        scaling_type: NotRequired[pulumi.Input[_builtins.str]]
        target_tracking_scaling_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetScalingConfigurationTargetTrackingScalingConfigArgsDict']]]]
elif False:
    FleetScalingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetScalingConfigurationArgs:
    def __init__(__self__, *,
                 desired_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 max_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 scaling_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target_tracking_scaling_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FleetScalingConfigurationTargetTrackingScalingConfigArgs']]]] = None):
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if scaling_type is not None:
            pulumi.set(__self__, "scaling_type", scaling_type)
        if target_tracking_scaling_configs is not None:
            pulumi.set(__self__, "target_tracking_scaling_configs", target_tracking_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "desired_capacity")

    @desired_capacity.setter
    def desired_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "desired_capacity", value)

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_capacity", value)

    @_builtins.property
    @pulumi.getter(name="scalingType")
    def scaling_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scaling_type")

    @scaling_type.setter
    def scaling_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_type", value)

    @_builtins.property
    @pulumi.getter(name="targetTrackingScalingConfigs")
    def target_tracking_scaling_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetScalingConfigurationTargetTrackingScalingConfigArgs']]]]:
        return pulumi.get(self, "target_tracking_scaling_configs")

    @target_tracking_scaling_configs.setter
    def target_tracking_scaling_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetScalingConfigurationTargetTrackingScalingConfigArgs']]]]):
        pulumi.set(self, "target_tracking_scaling_configs", value)


if not MYPY:
    class FleetScalingConfigurationTargetTrackingScalingConfigArgsDict(TypedDict):
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        target_value: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    FleetScalingConfigurationTargetTrackingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetScalingConfigurationTargetTrackingScalingConfigArgs:
    def __init__(__self__, *,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target_value: Optional[pulumi.Input[_builtins.float]] = None):
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if target_value is not None:
            pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "target_value", value)


if not MYPY:
    class FleetStatusArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        status_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FleetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetStatusArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.str]] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class FleetVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        vpc_id: pulumi.Input[_builtins.str]
elif False:
    FleetVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 vpc_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ProjectArtifactsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        artifact_identifier: NotRequired[pulumi.Input[_builtins.str]]
        bucket_owner_access: NotRequired[pulumi.Input[_builtins.str]]
        encryption_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace_type: NotRequired[pulumi.Input[_builtins.str]]
        override_artifact_name: NotRequired[pulumi.Input[_builtins.bool]]
        packaging: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectArtifactsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectArtifactsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 artifact_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_owner_access: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_type: Optional[pulumi.Input[_builtins.str]] = None,
                 override_artifact_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 packaging: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if artifact_identifier is not None:
            pulumi.set(__self__, "artifact_identifier", artifact_identifier)
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace_type is not None:
            pulumi.set(__self__, "namespace_type", namespace_type)
        if override_artifact_name is not None:
            pulumi.set(__self__, "override_artifact_name", override_artifact_name)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="artifactIdentifier")
    def artifact_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_identifier")

    @artifact_identifier.setter
    def artifact_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_identifier", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_owner_access")

    @bucket_owner_access.setter
    def bucket_owner_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_access", value)

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "encryption_disabled")

    @encryption_disabled.setter
    def encryption_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encryption_disabled", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="namespaceType")
    def namespace_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace_type")

    @namespace_type.setter
    def namespace_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_type", value)

    @_builtins.property
    @pulumi.getter(name="overrideArtifactName")
    def override_artifact_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "override_artifact_name")

    @override_artifact_name.setter
    def override_artifact_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_artifact_name", value)

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "packaging")

    @packaging.setter
    def packaging(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packaging", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ProjectBuildBatchConfigArgsDict(TypedDict):
        service_role: pulumi.Input[_builtins.str]
        combine_artifacts: NotRequired[pulumi.Input[_builtins.bool]]
        restrictions: NotRequired[pulumi.Input['ProjectBuildBatchConfigRestrictionsArgsDict']]
        timeout_in_mins: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ProjectBuildBatchConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectBuildBatchConfigArgs:
    def __init__(__self__, *,
                 service_role: pulumi.Input[_builtins.str],
                 combine_artifacts: Optional[pulumi.Input[_builtins.bool]] = None,
                 restrictions: Optional[pulumi.Input['ProjectBuildBatchConfigRestrictionsArgs']] = None,
                 timeout_in_mins: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "service_role", service_role)
        if combine_artifacts is not None:
            pulumi.set(__self__, "combine_artifacts", combine_artifacts)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)
        if timeout_in_mins is not None:
            pulumi.set(__self__, "timeout_in_mins", timeout_in_mins)

    @_builtins.property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "service_role")

    @service_role.setter
    def service_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_role", value)

    @_builtins.property
    @pulumi.getter(name="combineArtifacts")
    def combine_artifacts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "combine_artifacts")

    @combine_artifacts.setter
    def combine_artifacts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "combine_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input['ProjectBuildBatchConfigRestrictionsArgs']]:
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input['ProjectBuildBatchConfigRestrictionsArgs']]):
        pulumi.set(self, "restrictions", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMins")
    def timeout_in_mins(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_in_mins")

    @timeout_in_mins.setter
    def timeout_in_mins(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_mins", value)


if not MYPY:
    class ProjectBuildBatchConfigRestrictionsArgsDict(TypedDict):
        compute_types_alloweds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        maximum_builds_allowed: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ProjectBuildBatchConfigRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectBuildBatchConfigRestrictionsArgs:
    def __init__(__self__, *,
                 compute_types_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 maximum_builds_allowed: Optional[pulumi.Input[_builtins.int]] = None):
        if compute_types_alloweds is not None:
            pulumi.set(__self__, "compute_types_alloweds", compute_types_alloweds)
        if maximum_builds_allowed is not None:
            pulumi.set(__self__, "maximum_builds_allowed", maximum_builds_allowed)

    @_builtins.property
    @pulumi.getter(name="computeTypesAlloweds")
    def compute_types_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "compute_types_alloweds")

    @compute_types_alloweds.setter
    def compute_types_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "compute_types_alloweds", value)

    @_builtins.property
    @pulumi.getter(name="maximumBuildsAllowed")
    def maximum_builds_allowed(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_builds_allowed")

    @maximum_builds_allowed.setter
    def maximum_builds_allowed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_builds_allowed", value)


if not MYPY:
    class ProjectCacheArgsDict(TypedDict):
        cache_namespace: NotRequired[pulumi.Input[_builtins.str]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectCacheArgs:
    def __init__(__self__, *,
                 cache_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 modes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_namespace is not None:
            pulumi.set(__self__, "cache_namespace", cache_namespace)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cacheNamespace")
    def cache_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_namespace")

    @cache_namespace.setter
    def cache_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_namespace", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "modes")

    @modes.setter
    def modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "modes", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectEnvironmentArgsDict(TypedDict):
        compute_type: pulumi.Input[_builtins.str]
        image: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        docker_server: NotRequired[pulumi.Input['ProjectEnvironmentDockerServerArgsDict']]
        environment_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentEnvironmentVariableArgsDict']]]]
        fleet: NotRequired[pulumi.Input['ProjectEnvironmentFleetArgsDict']]
        image_pull_credentials_type: NotRequired[pulumi.Input[_builtins.str]]
        privileged_mode: NotRequired[pulumi.Input[_builtins.bool]]
        registry_credential: NotRequired[pulumi.Input['ProjectEnvironmentRegistryCredentialArgsDict']]
elif False:
    ProjectEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[_builtins.str],
                 image: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_server: Optional[pulumi.Input['ProjectEnvironmentDockerServerArgs']] = None,
                 environment_variables: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentEnvironmentVariableArgs']]]] = None,
                 fleet: Optional[pulumi.Input['ProjectEnvironmentFleetArgs']] = None,
                 image_pull_credentials_type: Optional[pulumi.Input[_builtins.str]] = None,
                 privileged_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 registry_credential: Optional[pulumi.Input['ProjectEnvironmentRegistryCredentialArgs']] = None):
        pulumi.set(__self__, "compute_type", compute_type)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if docker_server is not None:
            pulumi.set(__self__, "docker_server", docker_server)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fleet is not None:
            pulumi.set(__self__, "fleet", fleet)
        if image_pull_credentials_type is not None:
            pulumi.set(__self__, "image_pull_credentials_type", image_pull_credentials_type)
        if privileged_mode is not None:
            pulumi.set(__self__, "privileged_mode", privileged_mode)
        if registry_credential is not None:
            pulumi.set(__self__, "registry_credential", registry_credential)

    @_builtins.property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compute_type", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="dockerServer")
    def docker_server(self) -> Optional[pulumi.Input['ProjectEnvironmentDockerServerArgs']]:
        return pulumi.get(self, "docker_server")

    @docker_server.setter
    def docker_server(self, value: Optional[pulumi.Input['ProjectEnvironmentDockerServerArgs']]):
        pulumi.set(self, "docker_server", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentEnvironmentVariableArgs']]]]:
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentEnvironmentVariableArgs']]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter
    def fleet(self) -> Optional[pulumi.Input['ProjectEnvironmentFleetArgs']]:
        return pulumi.get(self, "fleet")

    @fleet.setter
    def fleet(self, value: Optional[pulumi.Input['ProjectEnvironmentFleetArgs']]):
        pulumi.set(self, "fleet", value)

    @_builtins.property
    @pulumi.getter(name="imagePullCredentialsType")
    def image_pull_credentials_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image_pull_credentials_type")

    @image_pull_credentials_type.setter
    def image_pull_credentials_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_pull_credentials_type", value)

    @_builtins.property
    @pulumi.getter(name="privilegedMode")
    def privileged_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "privileged_mode")

    @privileged_mode.setter
    def privileged_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "privileged_mode", value)

    @_builtins.property
    @pulumi.getter(name="registryCredential")
    def registry_credential(self) -> Optional[pulumi.Input['ProjectEnvironmentRegistryCredentialArgs']]:
        return pulumi.get(self, "registry_credential")

    @registry_credential.setter
    def registry_credential(self, value: Optional[pulumi.Input['ProjectEnvironmentRegistryCredentialArgs']]):
        pulumi.set(self, "registry_credential", value)


if not MYPY:
    class ProjectEnvironmentDockerServerArgsDict(TypedDict):
        compute_type: pulumi.Input[_builtins.str]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ProjectEnvironmentDockerServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentDockerServerArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[_builtins.str],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "compute_type", compute_type)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compute_type", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class ProjectEnvironmentEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectEnvironmentEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectEnvironmentFleetArgsDict(TypedDict):
        fleet_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectEnvironmentFleetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentFleetArgs:
    def __init__(__self__, *,
                 fleet_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if fleet_arn is not None:
            pulumi.set(__self__, "fleet_arn", fleet_arn)

    @_builtins.property
    @pulumi.getter(name="fleetArn")
    def fleet_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fleet_arn")

    @fleet_arn.setter
    def fleet_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fleet_arn", value)


if not MYPY:
    class ProjectEnvironmentRegistryCredentialArgsDict(TypedDict):
        credential: pulumi.Input[_builtins.str]
        credential_provider: pulumi.Input[_builtins.str]
elif False:
    ProjectEnvironmentRegistryCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentRegistryCredentialArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input[_builtins.str],
                 credential_provider: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "credential_provider", credential_provider)

    @_builtins.property
    @pulumi.getter
    def credential(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential", value)

    @_builtins.property
    @pulumi.getter(name="credentialProvider")
    def credential_provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "credential_provider")

    @credential_provider.setter
    def credential_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_provider", value)


if not MYPY:
    class ProjectFileSystemLocationArgsDict(TypedDict):
        identifier: NotRequired[pulumi.Input[_builtins.str]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        mount_options: NotRequired[pulumi.Input[_builtins.str]]
        mount_point: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectFileSystemLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectFileSystemLocationArgs:
    def __init__(__self__, *,
                 identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_options: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_point: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_options", value)

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_point", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectLogsConfigArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['ProjectLogsConfigCloudwatchLogsArgsDict']]
        s3_logs: NotRequired[pulumi.Input['ProjectLogsConfigS3LogsArgsDict']]
elif False:
    ProjectLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectLogsConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['ProjectLogsConfigCloudwatchLogsArgs']] = None,
                 s3_logs: Optional[pulumi.Input['ProjectLogsConfigS3LogsArgs']] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if s3_logs is not None:
            pulumi.set(__self__, "s3_logs", s3_logs)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['ProjectLogsConfigCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['ProjectLogsConfigCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter(name="s3Logs")
    def s3_logs(self) -> Optional[pulumi.Input['ProjectLogsConfigS3LogsArgs']]:
        return pulumi.get(self, "s3_logs")

    @s3_logs.setter
    def s3_logs(self, value: Optional[pulumi.Input['ProjectLogsConfigS3LogsArgs']]):
        pulumi.set(self, "s3_logs", value)


if not MYPY:
    class ProjectLogsConfigCloudwatchLogsArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        stream_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectLogsConfigCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectLogsConfigCloudwatchLogsArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class ProjectLogsConfigS3LogsArgsDict(TypedDict):
        bucket_owner_access: NotRequired[pulumi.Input[_builtins.str]]
        encryption_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectLogsConfigS3LogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectLogsConfigS3LogsArgs:
    def __init__(__self__, *,
                 bucket_owner_access: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_owner_access")

    @bucket_owner_access.setter
    def bucket_owner_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_access", value)

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "encryption_disabled")

    @encryption_disabled.setter
    def encryption_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encryption_disabled", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ProjectSecondaryArtifactArgsDict(TypedDict):
        artifact_identifier: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        bucket_owner_access: NotRequired[pulumi.Input[_builtins.str]]
        encryption_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace_type: NotRequired[pulumi.Input[_builtins.str]]
        override_artifact_name: NotRequired[pulumi.Input[_builtins.bool]]
        packaging: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectSecondaryArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondaryArtifactArgs:
    def __init__(__self__, *,
                 artifact_identifier: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 bucket_owner_access: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_type: Optional[pulumi.Input[_builtins.str]] = None,
                 override_artifact_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 packaging: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "artifact_identifier", artifact_identifier)
        pulumi.set(__self__, "type", type)
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace_type is not None:
            pulumi.set(__self__, "namespace_type", namespace_type)
        if override_artifact_name is not None:
            pulumi.set(__self__, "override_artifact_name", override_artifact_name)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="artifactIdentifier")
    def artifact_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "artifact_identifier")

    @artifact_identifier.setter
    def artifact_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "artifact_identifier", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_owner_access")

    @bucket_owner_access.setter
    def bucket_owner_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_access", value)

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "encryption_disabled")

    @encryption_disabled.setter
    def encryption_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encryption_disabled", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="namespaceType")
    def namespace_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace_type")

    @namespace_type.setter
    def namespace_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_type", value)

    @_builtins.property
    @pulumi.getter(name="overrideArtifactName")
    def override_artifact_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "override_artifact_name")

    @override_artifact_name.setter
    def override_artifact_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_artifact_name", value)

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "packaging")

    @packaging.setter
    def packaging(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packaging", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ProjectSecondarySourceArgsDict(TypedDict):
        source_identifier: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        auth: NotRequired[pulumi.Input['ProjectSecondarySourceAuthArgsDict']]
        build_status_config: NotRequired[pulumi.Input['ProjectSecondarySourceBuildStatusConfigArgsDict']]
        buildspec: NotRequired[pulumi.Input[_builtins.str]]
        git_clone_depth: NotRequired[pulumi.Input[_builtins.int]]
        git_submodules_config: NotRequired[pulumi.Input['ProjectSecondarySourceGitSubmodulesConfigArgsDict']]
        insecure_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        report_build_status: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ProjectSecondarySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondarySourceArgs:
    def __init__(__self__, *,
                 source_identifier: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ProjectSecondarySourceAuthArgs']] = None,
                 build_status_config: Optional[pulumi.Input['ProjectSecondarySourceBuildStatusConfigArgs']] = None,
                 buildspec: Optional[pulumi.Input[_builtins.str]] = None,
                 git_clone_depth: Optional[pulumi.Input[_builtins.int]] = None,
                 git_submodules_config: Optional[pulumi.Input['ProjectSecondarySourceGitSubmodulesConfigArgs']] = None,
                 insecure_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 report_build_status: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "source_identifier", source_identifier)
        pulumi.set(__self__, "type", type)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if build_status_config is not None:
            pulumi.set(__self__, "build_status_config", build_status_config)
        if buildspec is not None:
            pulumi.set(__self__, "buildspec", buildspec)
        if git_clone_depth is not None:
            pulumi.set(__self__, "git_clone_depth", git_clone_depth)
        if git_submodules_config is not None:
            pulumi.set(__self__, "git_submodules_config", git_submodules_config)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)

    @_builtins.property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_identifier")

    @source_identifier.setter
    def source_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_identifier", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ProjectSecondarySourceAuthArgs']]:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ProjectSecondarySourceAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="buildStatusConfig")
    def build_status_config(self) -> Optional[pulumi.Input['ProjectSecondarySourceBuildStatusConfigArgs']]:
        return pulumi.get(self, "build_status_config")

    @build_status_config.setter
    def build_status_config(self, value: Optional[pulumi.Input['ProjectSecondarySourceBuildStatusConfigArgs']]):
        pulumi.set(self, "build_status_config", value)

    @_builtins.property
    @pulumi.getter
    def buildspec(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "buildspec")

    @buildspec.setter
    def buildspec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "buildspec", value)

    @_builtins.property
    @pulumi.getter(name="gitCloneDepth")
    def git_clone_depth(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "git_clone_depth")

    @git_clone_depth.setter
    def git_clone_depth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "git_clone_depth", value)

    @_builtins.property
    @pulumi.getter(name="gitSubmodulesConfig")
    def git_submodules_config(self) -> Optional[pulumi.Input['ProjectSecondarySourceGitSubmodulesConfigArgs']]:
        return pulumi.get(self, "git_submodules_config")

    @git_submodules_config.setter
    def git_submodules_config(self, value: Optional[pulumi.Input['ProjectSecondarySourceGitSubmodulesConfigArgs']]):
        pulumi.set(self, "git_submodules_config", value)

    @_builtins.property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "insecure_ssl")

    @insecure_ssl.setter
    def insecure_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_ssl", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "report_build_status")

    @report_build_status.setter
    def report_build_status(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "report_build_status", value)


if not MYPY:
    class ProjectSecondarySourceAuthArgsDict(TypedDict):
        resource: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    ProjectSecondarySourceAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondarySourceAuthArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectSecondarySourceBuildStatusConfigArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        target_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectSecondarySourceBuildStatusConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondarySourceBuildStatusConfigArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 target_url: Optional[pulumi.Input[_builtins.str]] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_url", value)


if not MYPY:
    class ProjectSecondarySourceGitSubmodulesConfigArgsDict(TypedDict):
        fetch_submodules: pulumi.Input[_builtins.bool]
elif False:
    ProjectSecondarySourceGitSubmodulesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondarySourceGitSubmodulesConfigArgs:
    def __init__(__self__, *,
                 fetch_submodules: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "fetch_submodules", fetch_submodules)

    @_builtins.property
    @pulumi.getter(name="fetchSubmodules")
    def fetch_submodules(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "fetch_submodules")

    @fetch_submodules.setter
    def fetch_submodules(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "fetch_submodules", value)


if not MYPY:
    class ProjectSecondarySourceVersionArgsDict(TypedDict):
        source_identifier: pulumi.Input[_builtins.str]
        source_version: pulumi.Input[_builtins.str]
elif False:
    ProjectSecondarySourceVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSecondarySourceVersionArgs:
    def __init__(__self__, *,
                 source_identifier: pulumi.Input[_builtins.str],
                 source_version: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "source_identifier", source_identifier)
        pulumi.set(__self__, "source_version", source_version)

    @_builtins.property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_identifier")

    @source_identifier.setter
    def source_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_identifier", value)

    @_builtins.property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_version")

    @source_version.setter
    def source_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_version", value)


if not MYPY:
    class ProjectSourceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        auth: NotRequired[pulumi.Input['ProjectSourceAuthArgsDict']]
        build_status_config: NotRequired[pulumi.Input['ProjectSourceBuildStatusConfigArgsDict']]
        buildspec: NotRequired[pulumi.Input[_builtins.str]]
        git_clone_depth: NotRequired[pulumi.Input[_builtins.int]]
        git_submodules_config: NotRequired[pulumi.Input['ProjectSourceGitSubmodulesConfigArgsDict']]
        insecure_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        report_build_status: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ProjectSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ProjectSourceAuthArgs']] = None,
                 build_status_config: Optional[pulumi.Input['ProjectSourceBuildStatusConfigArgs']] = None,
                 buildspec: Optional[pulumi.Input[_builtins.str]] = None,
                 git_clone_depth: Optional[pulumi.Input[_builtins.int]] = None,
                 git_submodules_config: Optional[pulumi.Input['ProjectSourceGitSubmodulesConfigArgs']] = None,
                 insecure_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 report_build_status: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "type", type)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if build_status_config is not None:
            pulumi.set(__self__, "build_status_config", build_status_config)
        if buildspec is not None:
            pulumi.set(__self__, "buildspec", buildspec)
        if git_clone_depth is not None:
            pulumi.set(__self__, "git_clone_depth", git_clone_depth)
        if git_submodules_config is not None:
            pulumi.set(__self__, "git_submodules_config", git_submodules_config)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ProjectSourceAuthArgs']]:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ProjectSourceAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="buildStatusConfig")
    def build_status_config(self) -> Optional[pulumi.Input['ProjectSourceBuildStatusConfigArgs']]:
        return pulumi.get(self, "build_status_config")

    @build_status_config.setter
    def build_status_config(self, value: Optional[pulumi.Input['ProjectSourceBuildStatusConfigArgs']]):
        pulumi.set(self, "build_status_config", value)

    @_builtins.property
    @pulumi.getter
    def buildspec(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "buildspec")

    @buildspec.setter
    def buildspec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "buildspec", value)

    @_builtins.property
    @pulumi.getter(name="gitCloneDepth")
    def git_clone_depth(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "git_clone_depth")

    @git_clone_depth.setter
    def git_clone_depth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "git_clone_depth", value)

    @_builtins.property
    @pulumi.getter(name="gitSubmodulesConfig")
    def git_submodules_config(self) -> Optional[pulumi.Input['ProjectSourceGitSubmodulesConfigArgs']]:
        return pulumi.get(self, "git_submodules_config")

    @git_submodules_config.setter
    def git_submodules_config(self, value: Optional[pulumi.Input['ProjectSourceGitSubmodulesConfigArgs']]):
        pulumi.set(self, "git_submodules_config", value)

    @_builtins.property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "insecure_ssl")

    @insecure_ssl.setter
    def insecure_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_ssl", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "report_build_status")

    @report_build_status.setter
    def report_build_status(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "report_build_status", value)


if not MYPY:
    class ProjectSourceAuthArgsDict(TypedDict):
        resource: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    ProjectSourceAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSourceAuthArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProjectSourceBuildStatusConfigArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        target_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectSourceBuildStatusConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSourceBuildStatusConfigArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 target_url: Optional[pulumi.Input[_builtins.str]] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_url", value)


if not MYPY:
    class ProjectSourceGitSubmodulesConfigArgsDict(TypedDict):
        fetch_submodules: pulumi.Input[_builtins.bool]
elif False:
    ProjectSourceGitSubmodulesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSourceGitSubmodulesConfigArgs:
    def __init__(__self__, *,
                 fetch_submodules: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "fetch_submodules", fetch_submodules)

    @_builtins.property
    @pulumi.getter(name="fetchSubmodules")
    def fetch_submodules(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "fetch_submodules")

    @fetch_submodules.setter
    def fetch_submodules(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "fetch_submodules", value)


if not MYPY:
    class ProjectVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        vpc_id: pulumi.Input[_builtins.str]
elif False:
    ProjectVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 vpc_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ReportGroupExportConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        s3_destination: NotRequired[pulumi.Input['ReportGroupExportConfigS3DestinationArgsDict']]
elif False:
    ReportGroupExportConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportGroupExportConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 s3_destination: Optional[pulumi.Input['ReportGroupExportConfigS3DestinationArgs']] = None):
        pulumi.set(__self__, "type", type)
        if s3_destination is not None:
            pulumi.set(__self__, "s3_destination", s3_destination)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="s3Destination")
    def s3_destination(self) -> Optional[pulumi.Input['ReportGroupExportConfigS3DestinationArgs']]:
        return pulumi.get(self, "s3_destination")

    @s3_destination.setter
    def s3_destination(self, value: Optional[pulumi.Input['ReportGroupExportConfigS3DestinationArgs']]):
        pulumi.set(self, "s3_destination", value)


if not MYPY:
    class ReportGroupExportConfigS3DestinationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        encryption_key: pulumi.Input[_builtins.str]
        encryption_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        packaging: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReportGroupExportConfigS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportGroupExportConfigS3DestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 encryption_key: pulumi.Input[_builtins.str],
                 encryption_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 packaging: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "encryption_key", encryption_key)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "encryption_key", value)

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "encryption_disabled")

    @encryption_disabled.setter
    def encryption_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encryption_disabled", value)

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "packaging")

    @packaging.setter
    def packaging(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packaging", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WebhookFilterGroupArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebhookFilterGroupFilterArgsDict']]]]
elif False:
    WebhookFilterGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookFilterGroupArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookFilterGroupFilterArgs']]]] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookFilterGroupFilterArgs']]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookFilterGroupFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class WebhookFilterGroupFilterArgsDict(TypedDict):
        pattern: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        exclude_matched_pattern: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    WebhookFilterGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookFilterGroupFilterArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 exclude_matched_pattern: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)
        if exclude_matched_pattern is not None:
            pulumi.set(__self__, "exclude_matched_pattern", exclude_matched_pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="excludeMatchedPattern")
    def exclude_matched_pattern(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "exclude_matched_pattern")

    @exclude_matched_pattern.setter
    def exclude_matched_pattern(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_matched_pattern", value)


if not MYPY:
    class WebhookPullRequestBuildPolicyArgsDict(TypedDict):
        requires_comment_approval: pulumi.Input[_builtins.str]
        approver_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebhookPullRequestBuildPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookPullRequestBuildPolicyArgs:
    def __init__(__self__, *,
                 requires_comment_approval: pulumi.Input[_builtins.str],
                 approver_roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "requires_comment_approval", requires_comment_approval)
        if approver_roles is not None:
            pulumi.set(__self__, "approver_roles", approver_roles)

    @_builtins.property
    @pulumi.getter(name="requiresCommentApproval")
    def requires_comment_approval(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "requires_comment_approval")

    @requires_comment_approval.setter
    def requires_comment_approval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "requires_comment_approval", value)

    @_builtins.property
    @pulumi.getter(name="approverRoles")
    def approver_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "approver_roles")

    @approver_roles.setter
    def approver_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "approver_roles", value)


if not MYPY:
    class WebhookScopeConfigurationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
        domain: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebhookScopeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookScopeConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str],
                 domain: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)


