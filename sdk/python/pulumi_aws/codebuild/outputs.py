# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'FleetComputeConfiguration',
    'FleetScalingConfiguration',
    'FleetScalingConfigurationTargetTrackingScalingConfig',
    'FleetStatus',
    'FleetVpcConfig',
    'ProjectArtifacts',
    'ProjectBuildBatchConfig',
    'ProjectBuildBatchConfigRestrictions',
    'ProjectCache',
    'ProjectEnvironment',
    'ProjectEnvironmentDockerServer',
    'ProjectEnvironmentEnvironmentVariable',
    'ProjectEnvironmentFleet',
    'ProjectEnvironmentRegistryCredential',
    'ProjectFileSystemLocation',
    'ProjectLogsConfig',
    'ProjectLogsConfigCloudwatchLogs',
    'ProjectLogsConfigS3Logs',
    'ProjectSecondaryArtifact',
    'ProjectSecondarySource',
    'ProjectSecondarySourceAuth',
    'ProjectSecondarySourceBuildStatusConfig',
    'ProjectSecondarySourceGitSubmodulesConfig',
    'ProjectSecondarySourceVersion',
    'ProjectSource',
    'ProjectSourceAuth',
    'ProjectSourceBuildStatusConfig',
    'ProjectSourceGitSubmodulesConfig',
    'ProjectVpcConfig',
    'ReportGroupExportConfig',
    'ReportGroupExportConfigS3Destination',
    'WebhookFilterGroup',
    'WebhookFilterGroupFilter',
    'WebhookPullRequestBuildPolicy',
    'WebhookScopeConfiguration',
    'GetFleetComputeConfigurationResult',
    'GetFleetScalingConfigurationResult',
    'GetFleetScalingConfigurationTargetTrackingScalingConfigResult',
    'GetFleetStatusResult',
    'GetFleetVpcConfigResult',
]

@pulumi.output_type
class FleetComputeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "machineType":
            suggest = "machine_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetComputeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetComputeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetComputeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk: Optional[_builtins.int] = None,
                 instance_type: Optional[_builtins.str] = None,
                 machine_type: Optional[_builtins.str] = None,
                 memory: Optional[_builtins.int] = None,
                 vcpu: Optional[_builtins.int] = None):
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if vcpu is not None:
            pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "vcpu")


@pulumi.output_type
class FleetScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredCapacity":
            suggest = "desired_capacity"
        elif key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "scalingType":
            suggest = "scaling_type"
        elif key == "targetTrackingScalingConfigs":
            suggest = "target_tracking_scaling_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_capacity: Optional[_builtins.int] = None,
                 max_capacity: Optional[_builtins.int] = None,
                 scaling_type: Optional[_builtins.str] = None,
                 target_tracking_scaling_configs: Optional[Sequence['outputs.FleetScalingConfigurationTargetTrackingScalingConfig']] = None):
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if scaling_type is not None:
            pulumi.set(__self__, "scaling_type", scaling_type)
        if target_tracking_scaling_configs is not None:
            pulumi.set(__self__, "target_tracking_scaling_configs", target_tracking_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "desired_capacity")

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_capacity")

    @_builtins.property
    @pulumi.getter(name="scalingType")
    def scaling_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scaling_type")

    @_builtins.property
    @pulumi.getter(name="targetTrackingScalingConfigs")
    def target_tracking_scaling_configs(self) -> Optional[Sequence['outputs.FleetScalingConfigurationTargetTrackingScalingConfig']]:
        return pulumi.get(self, "target_tracking_scaling_configs")


@pulumi.output_type
class FleetScalingConfigurationTargetTrackingScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetScalingConfigurationTargetTrackingScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetScalingConfigurationTargetTrackingScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetScalingConfigurationTargetTrackingScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: Optional[_builtins.str] = None,
                 target_value: Optional[_builtins.float] = None):
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if target_value is not None:
            pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "target_value")


@pulumi.output_type
class FleetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "context")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class FleetVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ProjectArtifacts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactIdentifier":
            suggest = "artifact_identifier"
        elif key == "bucketOwnerAccess":
            suggest = "bucket_owner_access"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"
        elif key == "namespaceType":
            suggest = "namespace_type"
        elif key == "overrideArtifactName":
            suggest = "override_artifact_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectArtifacts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectArtifacts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectArtifacts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 artifact_identifier: Optional[_builtins.str] = None,
                 bucket_owner_access: Optional[_builtins.str] = None,
                 encryption_disabled: Optional[_builtins.bool] = None,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace_type: Optional[_builtins.str] = None,
                 override_artifact_name: Optional[_builtins.bool] = None,
                 packaging: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if artifact_identifier is not None:
            pulumi.set(__self__, "artifact_identifier", artifact_identifier)
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace_type is not None:
            pulumi.set(__self__, "namespace_type", namespace_type)
        if override_artifact_name is not None:
            pulumi.set(__self__, "override_artifact_name", override_artifact_name)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="artifactIdentifier")
    def artifact_identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "artifact_identifier")

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner_access")

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_disabled")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="namespaceType")
    def namespace_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace_type")

    @_builtins.property
    @pulumi.getter(name="overrideArtifactName")
    def override_artifact_name(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "override_artifact_name")

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "packaging")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class ProjectBuildBatchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceRole":
            suggest = "service_role"
        elif key == "combineArtifacts":
            suggest = "combine_artifacts"
        elif key == "timeoutInMins":
            suggest = "timeout_in_mins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBuildBatchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBuildBatchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBuildBatchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_role: _builtins.str,
                 combine_artifacts: Optional[_builtins.bool] = None,
                 restrictions: Optional['outputs.ProjectBuildBatchConfigRestrictions'] = None,
                 timeout_in_mins: Optional[_builtins.int] = None):
        pulumi.set(__self__, "service_role", service_role)
        if combine_artifacts is not None:
            pulumi.set(__self__, "combine_artifacts", combine_artifacts)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)
        if timeout_in_mins is not None:
            pulumi.set(__self__, "timeout_in_mins", timeout_in_mins)

    @_builtins.property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> _builtins.str:
        return pulumi.get(self, "service_role")

    @_builtins.property
    @pulumi.getter(name="combineArtifacts")
    def combine_artifacts(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "combine_artifacts")

    @_builtins.property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.ProjectBuildBatchConfigRestrictions']:
        return pulumi.get(self, "restrictions")

    @_builtins.property
    @pulumi.getter(name="timeoutInMins")
    def timeout_in_mins(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_in_mins")


@pulumi.output_type
class ProjectBuildBatchConfigRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeTypesAlloweds":
            suggest = "compute_types_alloweds"
        elif key == "maximumBuildsAllowed":
            suggest = "maximum_builds_allowed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBuildBatchConfigRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBuildBatchConfigRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBuildBatchConfigRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_types_alloweds: Optional[Sequence[_builtins.str]] = None,
                 maximum_builds_allowed: Optional[_builtins.int] = None):
        if compute_types_alloweds is not None:
            pulumi.set(__self__, "compute_types_alloweds", compute_types_alloweds)
        if maximum_builds_allowed is not None:
            pulumi.set(__self__, "maximum_builds_allowed", maximum_builds_allowed)

    @_builtins.property
    @pulumi.getter(name="computeTypesAlloweds")
    def compute_types_alloweds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "compute_types_alloweds")

    @_builtins.property
    @pulumi.getter(name="maximumBuildsAllowed")
    def maximum_builds_allowed(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_builds_allowed")


@pulumi.output_type
class ProjectCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheNamespace":
            suggest = "cache_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_namespace: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 modes: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        if cache_namespace is not None:
            pulumi.set(__self__, "cache_namespace", cache_namespace)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cacheNamespace")
    def cache_namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cache_namespace")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def modes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "modes")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "dockerServer":
            suggest = "docker_server"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "imagePullCredentialsType":
            suggest = "image_pull_credentials_type"
        elif key == "privilegedMode":
            suggest = "privileged_mode"
        elif key == "registryCredential":
            suggest = "registry_credential"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: _builtins.str,
                 image: _builtins.str,
                 type: _builtins.str,
                 certificate: Optional[_builtins.str] = None,
                 docker_server: Optional['outputs.ProjectEnvironmentDockerServer'] = None,
                 environment_variables: Optional[Sequence['outputs.ProjectEnvironmentEnvironmentVariable']] = None,
                 fleet: Optional['outputs.ProjectEnvironmentFleet'] = None,
                 image_pull_credentials_type: Optional[_builtins.str] = None,
                 privileged_mode: Optional[_builtins.bool] = None,
                 registry_credential: Optional['outputs.ProjectEnvironmentRegistryCredential'] = None):
        pulumi.set(__self__, "compute_type", compute_type)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if docker_server is not None:
            pulumi.set(__self__, "docker_server", docker_server)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fleet is not None:
            pulumi.set(__self__, "fleet", fleet)
        if image_pull_credentials_type is not None:
            pulumi.set(__self__, "image_pull_credentials_type", image_pull_credentials_type)
        if privileged_mode is not None:
            pulumi.set(__self__, "privileged_mode", privileged_mode)
        if registry_credential is not None:
            pulumi.set(__self__, "registry_credential", registry_credential)

    @_builtins.property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> _builtins.str:
        return pulumi.get(self, "compute_type")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="dockerServer")
    def docker_server(self) -> Optional['outputs.ProjectEnvironmentDockerServer']:
        return pulumi.get(self, "docker_server")

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.ProjectEnvironmentEnvironmentVariable']]:
        return pulumi.get(self, "environment_variables")

    @_builtins.property
    @pulumi.getter
    def fleet(self) -> Optional['outputs.ProjectEnvironmentFleet']:
        return pulumi.get(self, "fleet")

    @_builtins.property
    @pulumi.getter(name="imagePullCredentialsType")
    def image_pull_credentials_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_credentials_type")

    @_builtins.property
    @pulumi.getter(name="privilegedMode")
    def privileged_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "privileged_mode")

    @_builtins.property
    @pulumi.getter(name="registryCredential")
    def registry_credential(self) -> Optional['outputs.ProjectEnvironmentRegistryCredential']:
        return pulumi.get(self, "registry_credential")


@pulumi.output_type
class ProjectEnvironmentDockerServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironmentDockerServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironmentDockerServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironmentDockerServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: _builtins.str,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "compute_type", compute_type)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> _builtins.str:
        return pulumi.get(self, "compute_type")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class ProjectEnvironmentEnvironmentVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectEnvironmentFleet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fleetArn":
            suggest = "fleet_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironmentFleet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironmentFleet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironmentFleet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fleet_arn: Optional[_builtins.str] = None):
        if fleet_arn is not None:
            pulumi.set(__self__, "fleet_arn", fleet_arn)

    @_builtins.property
    @pulumi.getter(name="fleetArn")
    def fleet_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fleet_arn")


@pulumi.output_type
class ProjectEnvironmentRegistryCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialProvider":
            suggest = "credential_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironmentRegistryCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironmentRegistryCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironmentRegistryCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: _builtins.str,
                 credential_provider: _builtins.str):
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "credential_provider", credential_provider)

    @_builtins.property
    @pulumi.getter
    def credential(self) -> _builtins.str:
        return pulumi.get(self, "credential")

    @_builtins.property
    @pulumi.getter(name="credentialProvider")
    def credential_provider(self) -> _builtins.str:
        return pulumi.get(self, "credential_provider")


@pulumi.output_type
class ProjectFileSystemLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountOptions":
            suggest = "mount_options"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectFileSystemLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectFileSystemLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectFileSystemLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 mount_options: Optional[_builtins.str] = None,
                 mount_point: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_point")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectLogsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"
        elif key == "s3Logs":
            suggest = "s3_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLogsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLogsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLogsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_logs: Optional['outputs.ProjectLogsConfigCloudwatchLogs'] = None,
                 s3_logs: Optional['outputs.ProjectLogsConfigS3Logs'] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if s3_logs is not None:
            pulumi.set(__self__, "s3_logs", s3_logs)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.ProjectLogsConfigCloudwatchLogs']:
        return pulumi.get(self, "cloudwatch_logs")

    @_builtins.property
    @pulumi.getter(name="s3Logs")
    def s3_logs(self) -> Optional['outputs.ProjectLogsConfigS3Logs']:
        return pulumi.get(self, "s3_logs")


@pulumi.output_type
class ProjectLogsConfigCloudwatchLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLogsConfigCloudwatchLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLogsConfigCloudwatchLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLogsConfigCloudwatchLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ProjectLogsConfigS3Logs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwnerAccess":
            suggest = "bucket_owner_access"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLogsConfigS3Logs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLogsConfigS3Logs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLogsConfigS3Logs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_owner_access: Optional[_builtins.str] = None,
                 encryption_disabled: Optional[_builtins.bool] = None,
                 location: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner_access")

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_disabled")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class ProjectSecondaryArtifact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactIdentifier":
            suggest = "artifact_identifier"
        elif key == "bucketOwnerAccess":
            suggest = "bucket_owner_access"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"
        elif key == "namespaceType":
            suggest = "namespace_type"
        elif key == "overrideArtifactName":
            suggest = "override_artifact_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSecondaryArtifact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSecondaryArtifact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSecondaryArtifact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_identifier: _builtins.str,
                 type: _builtins.str,
                 bucket_owner_access: Optional[_builtins.str] = None,
                 encryption_disabled: Optional[_builtins.bool] = None,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace_type: Optional[_builtins.str] = None,
                 override_artifact_name: Optional[_builtins.bool] = None,
                 packaging: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "artifact_identifier", artifact_identifier)
        pulumi.set(__self__, "type", type)
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace_type is not None:
            pulumi.set(__self__, "namespace_type", namespace_type)
        if override_artifact_name is not None:
            pulumi.set(__self__, "override_artifact_name", override_artifact_name)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="artifactIdentifier")
    def artifact_identifier(self) -> _builtins.str:
        return pulumi.get(self, "artifact_identifier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner_access")

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_disabled")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="namespaceType")
    def namespace_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace_type")

    @_builtins.property
    @pulumi.getter(name="overrideArtifactName")
    def override_artifact_name(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "override_artifact_name")

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "packaging")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class ProjectSecondarySource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIdentifier":
            suggest = "source_identifier"
        elif key == "buildStatusConfig":
            suggest = "build_status_config"
        elif key == "gitCloneDepth":
            suggest = "git_clone_depth"
        elif key == "gitSubmodulesConfig":
            suggest = "git_submodules_config"
        elif key == "insecureSsl":
            suggest = "insecure_ssl"
        elif key == "reportBuildStatus":
            suggest = "report_build_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSecondarySource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSecondarySource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSecondarySource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_identifier: _builtins.str,
                 type: _builtins.str,
                 auth: Optional['outputs.ProjectSecondarySourceAuth'] = None,
                 build_status_config: Optional['outputs.ProjectSecondarySourceBuildStatusConfig'] = None,
                 buildspec: Optional[_builtins.str] = None,
                 git_clone_depth: Optional[_builtins.int] = None,
                 git_submodules_config: Optional['outputs.ProjectSecondarySourceGitSubmodulesConfig'] = None,
                 insecure_ssl: Optional[_builtins.bool] = None,
                 location: Optional[_builtins.str] = None,
                 report_build_status: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "source_identifier", source_identifier)
        pulumi.set(__self__, "type", type)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if build_status_config is not None:
            pulumi.set(__self__, "build_status_config", build_status_config)
        if buildspec is not None:
            pulumi.set(__self__, "buildspec", buildspec)
        if git_clone_depth is not None:
            pulumi.set(__self__, "git_clone_depth", git_clone_depth)
        if git_submodules_config is not None:
            pulumi.set(__self__, "git_submodules_config", git_submodules_config)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)

    @_builtins.property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> _builtins.str:
        return pulumi.get(self, "source_identifier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.ProjectSecondarySourceAuth']:
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="buildStatusConfig")
    def build_status_config(self) -> Optional['outputs.ProjectSecondarySourceBuildStatusConfig']:
        return pulumi.get(self, "build_status_config")

    @_builtins.property
    @pulumi.getter
    def buildspec(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "buildspec")

    @_builtins.property
    @pulumi.getter(name="gitCloneDepth")
    def git_clone_depth(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "git_clone_depth")

    @_builtins.property
    @pulumi.getter(name="gitSubmodulesConfig")
    def git_submodules_config(self) -> Optional['outputs.ProjectSecondarySourceGitSubmodulesConfig']:
        return pulumi.get(self, "git_submodules_config")

    @_builtins.property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "insecure_ssl")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "report_build_status")


@pulumi.output_type
class ProjectSecondarySourceAuth(dict):
    def __init__(__self__, *,
                 resource: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectSecondarySourceBuildStatusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSecondarySourceBuildStatusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSecondarySourceBuildStatusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSecondarySourceBuildStatusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context: Optional[_builtins.str] = None,
                 target_url: Optional[_builtins.str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "context")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class ProjectSecondarySourceGitSubmodulesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fetchSubmodules":
            suggest = "fetch_submodules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSecondarySourceGitSubmodulesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSecondarySourceGitSubmodulesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSecondarySourceGitSubmodulesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fetch_submodules: _builtins.bool):
        pulumi.set(__self__, "fetch_submodules", fetch_submodules)

    @_builtins.property
    @pulumi.getter(name="fetchSubmodules")
    def fetch_submodules(self) -> _builtins.bool:
        return pulumi.get(self, "fetch_submodules")


@pulumi.output_type
class ProjectSecondarySourceVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIdentifier":
            suggest = "source_identifier"
        elif key == "sourceVersion":
            suggest = "source_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSecondarySourceVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSecondarySourceVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSecondarySourceVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_identifier: _builtins.str,
                 source_version: _builtins.str):
        pulumi.set(__self__, "source_identifier", source_identifier)
        pulumi.set(__self__, "source_version", source_version)

    @_builtins.property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> _builtins.str:
        return pulumi.get(self, "source_identifier")

    @_builtins.property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> _builtins.str:
        return pulumi.get(self, "source_version")


@pulumi.output_type
class ProjectSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildStatusConfig":
            suggest = "build_status_config"
        elif key == "gitCloneDepth":
            suggest = "git_clone_depth"
        elif key == "gitSubmodulesConfig":
            suggest = "git_submodules_config"
        elif key == "insecureSsl":
            suggest = "insecure_ssl"
        elif key == "reportBuildStatus":
            suggest = "report_build_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 auth: Optional['outputs.ProjectSourceAuth'] = None,
                 build_status_config: Optional['outputs.ProjectSourceBuildStatusConfig'] = None,
                 buildspec: Optional[_builtins.str] = None,
                 git_clone_depth: Optional[_builtins.int] = None,
                 git_submodules_config: Optional['outputs.ProjectSourceGitSubmodulesConfig'] = None,
                 insecure_ssl: Optional[_builtins.bool] = None,
                 location: Optional[_builtins.str] = None,
                 report_build_status: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "type", type)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if build_status_config is not None:
            pulumi.set(__self__, "build_status_config", build_status_config)
        if buildspec is not None:
            pulumi.set(__self__, "buildspec", buildspec)
        if git_clone_depth is not None:
            pulumi.set(__self__, "git_clone_depth", git_clone_depth)
        if git_submodules_config is not None:
            pulumi.set(__self__, "git_submodules_config", git_submodules_config)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.ProjectSourceAuth']:
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="buildStatusConfig")
    def build_status_config(self) -> Optional['outputs.ProjectSourceBuildStatusConfig']:
        return pulumi.get(self, "build_status_config")

    @_builtins.property
    @pulumi.getter
    def buildspec(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "buildspec")

    @_builtins.property
    @pulumi.getter(name="gitCloneDepth")
    def git_clone_depth(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "git_clone_depth")

    @_builtins.property
    @pulumi.getter(name="gitSubmodulesConfig")
    def git_submodules_config(self) -> Optional['outputs.ProjectSourceGitSubmodulesConfig']:
        return pulumi.get(self, "git_submodules_config")

    @_builtins.property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "insecure_ssl")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "report_build_status")


@pulumi.output_type
class ProjectSourceAuth(dict):
    def __init__(__self__, *,
                 resource: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectSourceBuildStatusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSourceBuildStatusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSourceBuildStatusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSourceBuildStatusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context: Optional[_builtins.str] = None,
                 target_url: Optional[_builtins.str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "context")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_url")


@pulumi.output_type
class ProjectSourceGitSubmodulesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fetchSubmodules":
            suggest = "fetch_submodules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSourceGitSubmodulesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSourceGitSubmodulesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSourceGitSubmodulesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fetch_submodules: _builtins.bool):
        pulumi.set(__self__, "fetch_submodules", fetch_submodules)

    @_builtins.property
    @pulumi.getter(name="fetchSubmodules")
    def fetch_submodules(self) -> _builtins.bool:
        return pulumi.get(self, "fetch_submodules")


@pulumi.output_type
class ProjectVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ReportGroupExportConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Destination":
            suggest = "s3_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportGroupExportConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportGroupExportConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportGroupExportConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 s3_destination: Optional['outputs.ReportGroupExportConfigS3Destination'] = None):
        pulumi.set(__self__, "type", type)
        if s3_destination is not None:
            pulumi.set(__self__, "s3_destination", s3_destination)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="s3Destination")
    def s3_destination(self) -> Optional['outputs.ReportGroupExportConfigS3Destination']:
        return pulumi.get(self, "s3_destination")


@pulumi.output_type
class ReportGroupExportConfigS3Destination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKey":
            suggest = "encryption_key"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportGroupExportConfigS3Destination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportGroupExportConfigS3Destination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportGroupExportConfigS3Destination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 encryption_key: _builtins.str,
                 encryption_disabled: Optional[_builtins.bool] = None,
                 packaging: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "encryption_key", encryption_key)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> _builtins.str:
        return pulumi.get(self, "encryption_key")

    @_builtins.property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_disabled")

    @_builtins.property
    @pulumi.getter
    def packaging(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "packaging")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class WebhookFilterGroup(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.WebhookFilterGroupFilter']] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.WebhookFilterGroupFilter']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class WebhookFilterGroupFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeMatchedPattern":
            suggest = "exclude_matched_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookFilterGroupFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookFilterGroupFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookFilterGroupFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pattern: _builtins.str,
                 type: _builtins.str,
                 exclude_matched_pattern: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)
        if exclude_matched_pattern is not None:
            pulumi.set(__self__, "exclude_matched_pattern", exclude_matched_pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="excludeMatchedPattern")
    def exclude_matched_pattern(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "exclude_matched_pattern")


@pulumi.output_type
class WebhookPullRequestBuildPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiresCommentApproval":
            suggest = "requires_comment_approval"
        elif key == "approverRoles":
            suggest = "approver_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookPullRequestBuildPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookPullRequestBuildPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookPullRequestBuildPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requires_comment_approval: _builtins.str,
                 approver_roles: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "requires_comment_approval", requires_comment_approval)
        if approver_roles is not None:
            pulumi.set(__self__, "approver_roles", approver_roles)

    @_builtins.property
    @pulumi.getter(name="requiresCommentApproval")
    def requires_comment_approval(self) -> _builtins.str:
        return pulumi.get(self, "requires_comment_approval")

    @_builtins.property
    @pulumi.getter(name="approverRoles")
    def approver_roles(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "approver_roles")


@pulumi.output_type
class WebhookScopeConfiguration(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 scope: _builtins.str,
                 domain: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetFleetComputeConfigurationResult(dict):
    def __init__(__self__, *,
                 disk: _builtins.int,
                 instance_type: _builtins.str,
                 machine_type: _builtins.str,
                 memory: _builtins.int,
                 vcpu: _builtins.int):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.int:
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> _builtins.str:
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> _builtins.int:
        return pulumi.get(self, "vcpu")


@pulumi.output_type
class GetFleetScalingConfigurationResult(dict):
    def __init__(__self__, *,
                 desired_capacity: _builtins.int,
                 max_capacity: _builtins.int,
                 scaling_type: _builtins.str,
                 target_tracking_scaling_configs: Sequence['outputs.GetFleetScalingConfigurationTargetTrackingScalingConfigResult']):
        pulumi.set(__self__, "desired_capacity", desired_capacity)
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "scaling_type", scaling_type)
        pulumi.set(__self__, "target_tracking_scaling_configs", target_tracking_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> _builtins.int:
        return pulumi.get(self, "desired_capacity")

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> _builtins.int:
        return pulumi.get(self, "max_capacity")

    @_builtins.property
    @pulumi.getter(name="scalingType")
    def scaling_type(self) -> _builtins.str:
        return pulumi.get(self, "scaling_type")

    @_builtins.property
    @pulumi.getter(name="targetTrackingScalingConfigs")
    def target_tracking_scaling_configs(self) -> Sequence['outputs.GetFleetScalingConfigurationTargetTrackingScalingConfigResult']:
        return pulumi.get(self, "target_tracking_scaling_configs")


@pulumi.output_type
class GetFleetScalingConfigurationTargetTrackingScalingConfigResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 target_value: _builtins.float):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> _builtins.float:
        return pulumi.get(self, "target_value")


@pulumi.output_type
class GetFleetStatusResult(dict):
    def __init__(__self__, *,
                 context: _builtins.str,
                 message: _builtins.str,
                 status_code: _builtins.str):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def context(self) -> _builtins.str:
        return pulumi.get(self, "context")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.str:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetFleetVpcConfigResult(dict):
    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


