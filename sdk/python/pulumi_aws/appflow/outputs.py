# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ConnectorProfileConnectorProfileConfig',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileProperties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk',
    'FlowDestinationFlowConfig',
    'FlowDestinationFlowConfigDestinationConnectorProperties',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig',
    'FlowSourceFlowConfig',
    'FlowSourceFlowConfigIncrementalPullConfig',
    'FlowSourceFlowConfigSourceConnectorProperties',
    'FlowSourceFlowConfigSourceConnectorPropertiesAmplitude',
    'FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector',
    'FlowSourceFlowConfigSourceConnectorPropertiesDatadog',
    'FlowSourceFlowConfigSourceConnectorPropertiesDynatrace',
    'FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics',
    'FlowSourceFlowConfigSourceConnectorPropertiesInforNexus',
    'FlowSourceFlowConfigSourceConnectorPropertiesMarketo',
    'FlowSourceFlowConfigSourceConnectorPropertiesS3',
    'FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig',
    'FlowSourceFlowConfigSourceConnectorPropertiesSalesforce',
    'FlowSourceFlowConfigSourceConnectorPropertiesSapoData',
    'FlowSourceFlowConfigSourceConnectorPropertiesServiceNow',
    'FlowSourceFlowConfigSourceConnectorPropertiesSingular',
    'FlowSourceFlowConfigSourceConnectorPropertiesSlack',
    'FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro',
    'FlowSourceFlowConfigSourceConnectorPropertiesVeeva',
    'FlowSourceFlowConfigSourceConnectorPropertiesZendesk',
    'FlowTask',
    'FlowTaskConnectorOperator',
    'FlowTriggerConfig',
    'FlowTriggerConfigTriggerProperties',
    'FlowTriggerConfigTriggerPropertiesScheduled',
]

@pulumi.output_type
class ConnectorProfileConnectorProfileConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorProfileCredentials":
            suggest = "connector_profile_credentials"
        elif key == "connectorProfileProperties":
            suggest = "connector_profile_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_profile_credentials: 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials',
                 connector_profile_properties: 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileProperties'):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsArgs' connector_profile_credentials: The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesArgs' connector_profile_properties: The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
        """
        pulumi.set(__self__, "connector_profile_credentials", connector_profile_credentials)
        pulumi.set(__self__, "connector_profile_properties", connector_profile_properties)

    @property
    @pulumi.getter(name="connectorProfileCredentials")
    def connector_profile_credentials(self) -> 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials':
        """
        The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "connector_profile_credentials")

    @property
    @pulumi.getter(name="connectorProfileProperties")
    def connector_profile_properties(self) -> 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileProperties':
        """
        The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
        """
        return pulumi.get(self, "connector_profile_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude'] = None,
                 custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector'] = None,
                 datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog'] = None,
                 dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace'] = None,
                 google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics'] = None,
                 honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode'] = None,
                 infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus'] = None,
                 marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo'] = None,
                 redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift'] = None,
                 salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce'] = None,
                 sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData'] = None,
                 service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow'] = None,
                 singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular'] = None,
                 slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack'] = None,
                 snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake'] = None,
                 trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro'] = None,
                 veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva'] = None,
                 zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitudeArgs' amplitude: The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorArgs' custom_connector: The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadogArgs' datadog: Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatraceArgs' dynatrace: The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsArgs' google_analytics: The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeArgs' honeycode: The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexusArgs' infor_nexus: The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoArgs' marketo: Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshiftArgs' redshift: Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceArgs' salesforce: The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataArgs' sapo_data: The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNowArgs' service_now: The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingularArgs' singular: Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackArgs' slack: Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflakeArgs' snowflake: The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicroArgs' trendmicro: The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeevaArgs' veeva: Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskArgs' zendesk: Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        if amplitude is not None:
            pulumi.set(__self__, "amplitude", amplitude)
        if custom_connector is not None:
            pulumi.set(__self__, "custom_connector", custom_connector)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if dynatrace is not None:
            pulumi.set(__self__, "dynatrace", dynatrace)
        if google_analytics is not None:
            pulumi.set(__self__, "google_analytics", google_analytics)
        if honeycode is not None:
            pulumi.set(__self__, "honeycode", honeycode)
        if infor_nexus is not None:
            pulumi.set(__self__, "infor_nexus", infor_nexus)
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if redshift is not None:
            pulumi.set(__self__, "redshift", redshift)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if sapo_data is not None:
            pulumi.set(__self__, "sapo_data", sapo_data)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if singular is not None:
            pulumi.set(__self__, "singular", singular)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if snowflake is not None:
            pulumi.set(__self__, "snowflake", snowflake)
        if trendmicro is not None:
            pulumi.set(__self__, "trendmicro", trendmicro)
        if veeva is not None:
            pulumi.set(__self__, "veeva", veeva)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude']:
        """
        The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector']:
        """
        The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog']:
        """
        Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace']:
        """
        The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics']:
        """
        The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode']:
        """
        The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus']:
        """
        The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo']:
        """
        Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift']:
        """
        Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce']:
        """
        The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData']:
        """
        The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow']:
        """
        The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular']:
        """
        Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack']:
        """
        Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake']:
        """
        The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro']:
        """
        The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva']:
        """
        Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk']:
        """
        Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 secret_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str secret_key: The Secret Access Key portion of the credentials.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        The Secret Access Key portion of the credentials.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationType":
            suggest = "authentication_type"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_type: str,
                 api_key: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey'] = None,
                 basic: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic'] = None,
                 custom: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom'] = None,
                 oauth2: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2'] = None):
        """
        :param str authentication_type: The authentication type that the custom connector uses for authenticating while creating a connector profile. One of: `APIKEY`, `BASIC`, `CUSTOM`, `OAUTH2`.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKeyArgs' api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasicArgs' basic: Basic credentials that are required for the authentication of the user.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustomArgs' custom: If the connector uses the custom authentication mechanism, this holds the required credentials.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2Args' oauth2: OAuth 2.0 credentials required for the authentication of the user.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if oauth2 is not None:
            pulumi.set(__self__, "oauth2", oauth2)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type that the custom connector uses for authenticating while creating a connector profile. One of: `APIKEY`, `BASIC`, `CUSTOM`, `OAUTH2`.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey']:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic']:
        """
        Basic credentials that are required for the authentication of the user.
        """
        return pulumi.get(self, "basic")

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom']:
        """
        If the connector uses the custom authentication mechanism, this holds the required credentials.
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def oauth2(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2']:
        """
        OAuth 2.0 credentials required for the authentication of the user.
        """
        return pulumi.get(self, "oauth2")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecretKey":
            suggest = "api_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 api_secret_key: Optional[str] = None):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str api_secret_key: The Secret Access Key portion of the credentials.
        """
        pulumi.set(__self__, "api_key", api_key)
        if api_secret_key is not None:
            pulumi.set(__self__, "api_secret_key", api_secret_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiSecretKey")
    def api_secret_key(self) -> Optional[str]:
        """
        The Secret Access Key portion of the credentials.
        """
        return pulumi.get(self, "api_secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAuthenticationType":
            suggest = "custom_authentication_type"
        elif key == "credentialsMap":
            suggest = "credentials_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_authentication_type: str,
                 credentials_map: Optional[Mapping[str, str]] = None):
        """
        :param str custom_authentication_type: The custom authentication type that the connector uses.
        :param Mapping[str, str] credentials_map: A map that holds custom authentication credentials.
        """
        pulumi.set(__self__, "custom_authentication_type", custom_authentication_type)
        if credentials_map is not None:
            pulumi.set(__self__, "credentials_map", credentials_map)

    @property
    @pulumi.getter(name="customAuthenticationType")
    def custom_authentication_type(self) -> str:
        """
        The custom authentication type that the connector uses.
        """
        return pulumi.get(self, "custom_authentication_type")

    @property
    @pulumi.getter(name="credentialsMap")
    def credentials_map(self) -> Optional[Mapping[str, str]]:
        """
        A map that holds custom authentication credentials.
        """
        return pulumi.get(self, "credentials_map")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh expired access token.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "applicationKey":
            suggest = "application_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 application_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str application_key: Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "application_key", application_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> str:
        """
        Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        """
        return pulumi.get(self, "application_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: The API tokens used by Dynatrace API to authenticate various API calls.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The API tokens used by Dynatrace API to authenticate various API calls.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh expired access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh expired access token.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 datakey: str,
                 secret_access_key: str,
                 user_id: str):
        """
        :param str access_key_id: The Access Key portion of the credentials.
        :param str datakey: Encryption keys used to encrypt data.
        :param str secret_access_key: The secret key used to sign requests.
        :param str user_id: Identifier for the user.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "datakey", datakey)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        The Access Key portion of the credentials.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def datakey(self) -> str:
        """
        Encryption keys used to encrypt data.
        """
        return pulumi.get(self, "datakey")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        The secret key used to sign requests.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Identifier for the user.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientCredentialsArn":
            suggest = "client_credentials_arn"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_credentials_arn: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param str client_credentials_arn: The secret manager ARN, which contains the client ID and client secret of the connected app.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh expired access token.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_credentials_arn is not None:
            pulumi.set(__self__, "client_credentials_arn", client_credentials_arn)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientCredentialsArn")
    def client_credentials_arn(self) -> Optional[str]:
        """
        The secret manager ARN, which contains the client ID and client secret of the connected app.
        """
        return pulumi.get(self, "client_credentials_arn")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthCredentials":
            suggest = "basic_auth_credentials"
        elif key == "oauthCredentials":
            suggest = "oauth_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials'] = None,
                 oauth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentialsArgs' basic_auth_credentials: The SAPOData basic authentication credentials.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsArgs' oauth_credentials: The SAPOData OAuth type authentication credentials.
        """
        if basic_auth_credentials is not None:
            pulumi.set(__self__, "basic_auth_credentials", basic_auth_credentials)
        if oauth_credentials is not None:
            pulumi.set(__self__, "oauth_credentials", oauth_credentials)

    @property
    @pulumi.getter(name="basicAuthCredentials")
    def basic_auth_credentials(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials']:
        """
        The SAPOData basic authentication credentials.
        """
        return pulumi.get(self, "basic_auth_credentials")

    @property
    @pulumi.getter(name="oauthCredentials")
    def oauth_credentials(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials']:
        """
        The SAPOData OAuth type authentication credentials.
        """
        return pulumi.get(self, "oauth_credentials")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh expired access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecretKey":
            suggest = "api_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret_key: str):
        """
        :param str api_secret_key: The Secret Access Key portion of the credentials.
        """
        pulumi.set(__self__, "api_secret_key", api_secret_key)

    @property
    @pulumi.getter(name="apiSecretKey")
    def api_secret_key(self) -> str:
        """
        The Secret Access Key portion of the credentials.
        """
        return pulumi.get(self, "api_secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password that corresponds to the user name.
        :param str username: Name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password that corresponds to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The credentials used to access protected Zendesk resources.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequestArgs' oauth_request: The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if oauth_request is not None:
            pulumi.set(__self__, "oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The credentials used to access protected Zendesk resources.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest']:
        """
        The OAuth requirement needed to request security tokens from the connector endpoint. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude'] = None,
                 custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector'] = None,
                 datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog'] = None,
                 dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace'] = None,
                 google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics'] = None,
                 honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode'] = None,
                 infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus'] = None,
                 marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo'] = None,
                 redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift'] = None,
                 salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData'] = None,
                 service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow'] = None,
                 singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular'] = None,
                 slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack'] = None,
                 snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake'] = None,
                 trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro'] = None,
                 veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva'] = None,
                 zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitudeArgs' amplitude: The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorArgs' custom_connector: The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadogArgs' datadog: Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatraceArgs' dynatrace: The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalyticsArgs' google_analytics: The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycodeArgs' honeycode: The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexusArgs' infor_nexus: The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketoArgs' marketo: Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshiftArgs' redshift: Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforceArgs' salesforce: The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataArgs' sapo_data: The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNowArgs' service_now: The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingularArgs' singular: Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlackArgs' slack: Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflakeArgs' snowflake: The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicroArgs' trendmicro: The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeevaArgs' veeva: Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendeskArgs' zendesk: Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        if amplitude is not None:
            pulumi.set(__self__, "amplitude", amplitude)
        if custom_connector is not None:
            pulumi.set(__self__, "custom_connector", custom_connector)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if dynatrace is not None:
            pulumi.set(__self__, "dynatrace", dynatrace)
        if google_analytics is not None:
            pulumi.set(__self__, "google_analytics", google_analytics)
        if honeycode is not None:
            pulumi.set(__self__, "honeycode", honeycode)
        if infor_nexus is not None:
            pulumi.set(__self__, "infor_nexus", infor_nexus)
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if redshift is not None:
            pulumi.set(__self__, "redshift", redshift)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if sapo_data is not None:
            pulumi.set(__self__, "sapo_data", sapo_data)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if singular is not None:
            pulumi.set(__self__, "singular", singular)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if snowflake is not None:
            pulumi.set(__self__, "snowflake", snowflake)
        if trendmicro is not None:
            pulumi.set(__self__, "trendmicro", trendmicro)
        if veeva is not None:
            pulumi.set(__self__, "veeva", veeva)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude']:
        """
        The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector']:
        """
        The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog']:
        """
        Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace']:
        """
        The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics']:
        """
        The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode']:
        """
        The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus']:
        """
        The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo']:
        """
        Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift']:
        """
        Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce']:
        """
        The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData']:
        """
        The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow']:
        """
        The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular']:
        """
        Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack']:
        """
        Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake']:
        """
        The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro']:
        """
        The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva']:
        """
        Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk']:
        """
        Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2Properties":
            suggest = "oauth2_properties"
        elif key == "profileProperties":
            suggest = "profile_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth2_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties'] = None,
                 profile_properties: Optional[Mapping[str, str]] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2PropertiesArgs' oauth2_properties: The OAuth 2.0 properties required for OAuth 2.0 authentication.
        :param Mapping[str, str] profile_properties: A map of properties that are required to create a profile for the custom connector.
        """
        if oauth2_properties is not None:
            pulumi.set(__self__, "oauth2_properties", oauth2_properties)
        if profile_properties is not None:
            pulumi.set(__self__, "profile_properties", profile_properties)

    @property
    @pulumi.getter(name="oauth2Properties")
    def oauth2_properties(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties']:
        """
        The OAuth 2.0 properties required for OAuth 2.0 authentication.
        """
        return pulumi.get(self, "oauth2_properties")

    @property
    @pulumi.getter(name="profileProperties")
    def profile_properties(self) -> Optional[Mapping[str, str]]:
        """
        A map of properties that are required to create a profile for the custom connector.
        """
        return pulumi.get(self, "profile_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2GrantType":
            suggest = "oauth2_grant_type"
        elif key == "tokenUrl":
            suggest = "token_url"
        elif key == "tokenUrlCustomProperties":
            suggest = "token_url_custom_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth2_grant_type: str,
                 token_url: str,
                 token_url_custom_properties: Optional[Mapping[str, str]] = None):
        """
        :param str oauth2_grant_type: The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication. One of: `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`.
        :param str token_url: The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        :param Mapping[str, str] token_url_custom_properties: Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        """
        pulumi.set(__self__, "oauth2_grant_type", oauth2_grant_type)
        pulumi.set(__self__, "token_url", token_url)
        if token_url_custom_properties is not None:
            pulumi.set(__self__, "token_url_custom_properties", token_url_custom_properties)

    @property
    @pulumi.getter(name="oauth2GrantType")
    def oauth2_grant_type(self) -> str:
        """
        The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication. One of: `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "oauth2_grant_type")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter(name="tokenUrlCustomProperties")
    def token_url_custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        """
        return pulumi.get(self, "token_url_custom_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "databaseUrl":
            suggest = "database_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 role_arn: str,
                 bucket_prefix: Optional[str] = None,
                 database_url: Optional[str] = None):
        """
        :param str bucket_name: The name of the Amazon S3 bucket associated with Snowflake.
        :param str role_arn: ARN of the IAM role.
        :param str bucket_prefix: The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        :param str database_url: The JDBC URL of the Amazon Redshift cluster.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if database_url is not None:
            pulumi.set(__self__, "database_url", database_url)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the Amazon S3 bucket associated with Snowflake.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the IAM role.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="databaseUrl")
    def database_url(self) -> Optional[str]:
        """
        The JDBC URL of the Amazon Redshift cluster.
        """
        return pulumi.get(self, "database_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"
        elif key == "isSandboxEnvironment":
            suggest = "is_sandbox_environment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: Optional[str] = None,
                 is_sandbox_environment: Optional[bool] = None):
        """
        :param str instance_url: The location of the Salesforce resource.
        :param bool is_sandbox_environment: Indicates whether the connector profile applies to a sandbox or production environment.
        """
        if instance_url is not None:
            pulumi.set(__self__, "instance_url", instance_url)
        if is_sandbox_environment is not None:
            pulumi.set(__self__, "is_sandbox_environment", is_sandbox_environment)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> Optional[str]:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")

    @property
    @pulumi.getter(name="isSandboxEnvironment")
    def is_sandbox_environment(self) -> Optional[bool]:
        """
        Indicates whether the connector profile applies to a sandbox or production environment.
        """
        return pulumi.get(self, "is_sandbox_environment")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationHostUrl":
            suggest = "application_host_url"
        elif key == "applicationServicePath":
            suggest = "application_service_path"
        elif key == "clientNumber":
            suggest = "client_number"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "logonLanguage":
            suggest = "logon_language"
        elif key == "oauthProperties":
            suggest = "oauth_properties"
        elif key == "privateLinkServiceName":
            suggest = "private_link_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_host_url: str,
                 application_service_path: str,
                 client_number: str,
                 port_number: int,
                 logon_language: Optional[str] = None,
                 oauth_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties'] = None,
                 private_link_service_name: Optional[str] = None):
        """
        :param str application_host_url: The location of the SAPOData resource.
        :param str application_service_path: The application path to catalog service.
        :param str client_number: The client number for the client creating the connection.
        :param int port_number: The port number of the SAPOData instance.
        :param str logon_language: The logon language of SAPOData instance.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthPropertiesArgs' oauth_properties: The SAPOData OAuth properties required for OAuth type authentication.
        :param str private_link_service_name: The Snowflake Private Link service name to be used for private data transfers.
        """
        pulumi.set(__self__, "application_host_url", application_host_url)
        pulumi.set(__self__, "application_service_path", application_service_path)
        pulumi.set(__self__, "client_number", client_number)
        pulumi.set(__self__, "port_number", port_number)
        if logon_language is not None:
            pulumi.set(__self__, "logon_language", logon_language)
        if oauth_properties is not None:
            pulumi.set(__self__, "oauth_properties", oauth_properties)
        if private_link_service_name is not None:
            pulumi.set(__self__, "private_link_service_name", private_link_service_name)

    @property
    @pulumi.getter(name="applicationHostUrl")
    def application_host_url(self) -> str:
        """
        The location of the SAPOData resource.
        """
        return pulumi.get(self, "application_host_url")

    @property
    @pulumi.getter(name="applicationServicePath")
    def application_service_path(self) -> str:
        """
        The application path to catalog service.
        """
        return pulumi.get(self, "application_service_path")

    @property
    @pulumi.getter(name="clientNumber")
    def client_number(self) -> str:
        """
        The client number for the client creating the connection.
        """
        return pulumi.get(self, "client_number")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> int:
        """
        The port number of the SAPOData instance.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="logonLanguage")
    def logon_language(self) -> Optional[str]:
        """
        The logon language of SAPOData instance.
        """
        return pulumi.get(self, "logon_language")

    @property
    @pulumi.getter(name="oauthProperties")
    def oauth_properties(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties']:
        """
        The SAPOData OAuth properties required for OAuth type authentication.
        """
        return pulumi.get(self, "oauth_properties")

    @property
    @pulumi.getter(name="privateLinkServiceName")
    def private_link_service_name(self) -> Optional[str]:
        """
        The Snowflake Private Link service name to be used for private data transfers.
        """
        return pulumi.get(self, "private_link_service_name")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCodeUrl":
            suggest = "auth_code_url"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code_url: str,
                 oauth_scopes: Sequence[str],
                 token_url: str):
        """
        :param str auth_code_url: The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        :param Sequence[str] oauth_scopes: The OAuth scopes required for OAuth type authentication.
        :param str token_url: The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        """
        pulumi.set(__self__, "auth_code_url", auth_code_url)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="authCodeUrl")
    def auth_code_url(self) -> str:
        """
        The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        """
        return pulumi.get(self, "auth_code_url")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        The OAuth scopes required for OAuth type authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "privateLinkServiceName":
            suggest = "private_link_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 stage: str,
                 warehouse: str,
                 account_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 private_link_service_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket_name: The name of the Amazon S3 bucket associated with Snowflake.
        :param str stage: Name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: `<Database>.<Schema>.<Stage Name>`.
        :param str warehouse: The name of the Snowflake warehouse.
        :param str account_name: The name of the account.
        :param str bucket_prefix: The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        :param str private_link_service_name: The Snowflake Private Link service name to be used for private data transfers.
        :param str region: AWS Region of the Snowflake account.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "stage", stage)
        pulumi.set(__self__, "warehouse", warehouse)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if private_link_service_name is not None:
            pulumi.set(__self__, "private_link_service_name", private_link_service_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the Amazon S3 bucket associated with Snowflake.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: `<Database>.<Schema>.<Stage Name>`.
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The name of the Snowflake warehouse.
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        The name of the account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="privateLinkServiceName")
    def private_link_service_name(self) -> Optional[str]:
        """
        The Snowflake Private Link service name to be used for private data transfers.
        """
        return pulumi.get(self, "private_link_service_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        AWS Region of the Snowflake account.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Salesforce resource.
        """
        pulumi.set(__self__, "instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Salesforce resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class FlowDestinationFlowConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorType":
            suggest = "connector_type"
        elif key == "destinationConnectorProperties":
            suggest = "destination_connector_properties"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "connectorProfileName":
            suggest = "connector_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_type: str,
                 destination_connector_properties: 'outputs.FlowDestinationFlowConfigDestinationConnectorProperties',
                 api_version: Optional[str] = None,
                 connector_profile_name: Optional[str] = None):
        """
        :param str connector_type: Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesArgs' destination_connector_properties: This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
        :param str api_version: API version that the destination connector uses.
        :param str connector_profile_name: Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "destination_connector_properties", destination_connector_properties)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connector_profile_name is not None:
            pulumi.set(__self__, "connector_profile_name", connector_profile_name)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="destinationConnectorProperties")
    def destination_connector_properties(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorProperties':
        """
        This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
        """
        return pulumi.get(self, "destination_connector_properties")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version that the destination connector uses.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[str]:
        """
        Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        return pulumi.get(self, "connector_profile_name")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "customerProfiles":
            suggest = "customer_profiles"
        elif key == "eventBridge":
            suggest = "event_bridge"
        elif key == "lookoutMetrics":
            suggest = "lookout_metrics"
        elif key == "sapoData":
            suggest = "sapo_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_connector: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector'] = None,
                 customer_profiles: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles'] = None,
                 event_bridge: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge'] = None,
                 honeycode: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode'] = None,
                 lookout_metrics: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics'] = None,
                 marketo: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo'] = None,
                 redshift: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift'] = None,
                 s3: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3'] = None,
                 salesforce: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData'] = None,
                 snowflake: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake'] = None,
                 upsolver: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver'] = None,
                 zendesk: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk'] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorArgs' custom_connector: Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfilesArgs' customer_profiles: Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeArgs' event_bridge: Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeArgs' honeycode: Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoArgs' marketo: Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftArgs' redshift: Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3Args' s3: Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceArgs' salesforce: Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataArgs' sapo_data: Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeArgs' snowflake: Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverArgs' upsolver: Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskArgs' zendesk: Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        if custom_connector is not None:
            pulumi.set(__self__, "custom_connector", custom_connector)
        if customer_profiles is not None:
            pulumi.set(__self__, "customer_profiles", customer_profiles)
        if event_bridge is not None:
            pulumi.set(__self__, "event_bridge", event_bridge)
        if honeycode is not None:
            pulumi.set(__self__, "honeycode", honeycode)
        if lookout_metrics is not None:
            pulumi.set(__self__, "lookout_metrics", lookout_metrics)
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if redshift is not None:
            pulumi.set(__self__, "redshift", redshift)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if sapo_data is not None:
            pulumi.set(__self__, "sapo_data", sapo_data)
        if snowflake is not None:
            pulumi.set(__self__, "snowflake", snowflake)
        if upsolver is not None:
            pulumi.set(__self__, "upsolver", upsolver)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector']:
        """
        Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter(name="customerProfiles")
    def customer_profiles(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles']:
        """
        Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
        """
        return pulumi.get(self, "customer_profiles")

    @property
    @pulumi.getter(name="eventBridge")
    def event_bridge(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge']:
        """
        Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
        """
        return pulumi.get(self, "event_bridge")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode']:
        """
        Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="lookoutMetrics")
    def lookout_metrics(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics']:
        return pulumi.get(self, "lookout_metrics")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo']:
        """
        Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift']:
        """
        Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3']:
        """
        Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce']:
        """
        Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData']:
        """
        Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake']:
        """
        Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def upsolver(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver']:
        """
        Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
        """
        return pulumi.get(self, "upsolver")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk']:
        """
        Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "customProperties":
            suggest = "custom_properties"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: str,
                 custom_properties: Optional[Mapping[str, str]] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str entity_name: Entity specified in the custom connector as a source in the flow.
        :param Mapping[str, str] custom_properties: Custom properties that are specific to the connector when it's used as a source in the flow. Maximum of 50 items.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        :param str write_operation_type: This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        pulumi.set(__self__, "entity_name", entity_name)
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)
        if id_field_names is not None:
            pulumi.set(__self__, "id_field_names", id_field_names)
        if write_operation_type is not None:
            pulumi.set(__self__, "write_operation_type", write_operation_type)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> str:
        """
        Entity specified in the custom connector as a source in the flow.
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Custom properties that are specific to the connector when it's used as a source in the flow. Maximum of 50 items.
        """
        return pulumi.get(self, "custom_properties")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "objectTypeName":
            suggest = "object_type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 object_type_name: Optional[str] = None):
        """
        :param str domain_name: Unique name of the Amazon Connect Customer Profiles domain.
        :param str object_type_name: Object specified in the Amazon Connect Customer Profiles flow destination.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        if object_type_name is not None:
            pulumi.set(__self__, "object_type_name", object_type_name)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        Unique name of the Amazon Connect Customer Profiles domain.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="objectTypeName")
    def object_type_name(self) -> Optional[str]:
        """
        Object specified in the Amazon Connect Customer Profiles flow destination.
        """
        return pulumi.get(self, "object_type_name")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        pulumi.set(__self__, "object", object)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        pulumi.set(__self__, "object", object)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        pulumi.set(__self__, "object", object)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateBucketName":
            suggest = "intermediate_bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_bucket_name: str,
                 object: str,
                 bucket_prefix: Optional[str] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig'] = None):
        """
        :param str intermediate_bucket_name: Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Snowflake.
        :param str object: Object specified in the Veeva flow source.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        pulumi.set(__self__, "intermediate_bucket_name", intermediate_bucket_name)
        pulumi.set(__self__, "object", object)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)

    @property
    @pulumi.getter(name="intermediateBucketName")
    def intermediate_bucket_name(self) -> str:
        """
        Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Snowflake.
        """
        return pulumi.get(self, "intermediate_bucket_name")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "s3OutputFormatConfig":
            suggest = "s3_output_format_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_prefix: Optional[str] = None,
                 s3_output_format_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig'] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigArgs' s3_output_format_config: Configuration that determines how Amazon AppFlow should format the flow output data when Upsolver is used as the destination. See Upsolver S3 Output Format Config for more details.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if s3_output_format_config is not None:
            pulumi.set(__self__, "s3_output_format_config", s3_output_format_config)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="s3OutputFormatConfig")
    def s3_output_format_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig']:
        """
        Configuration that determines how Amazon AppFlow should format the flow output data when Upsolver is used as the destination. See Upsolver S3 Output Format Config for more details.
        """
        return pulumi.get(self, "s3_output_format_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationConfig":
            suggest = "aggregation_config"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "prefixConfig":
            suggest = "prefix_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig'] = None,
                 file_type: Optional[str] = None,
                 prefix_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig'] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfigArgs' aggregation_config: Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        :param str file_type: File type that Amazon AppFlow places in the Upsolver Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfigArgs' prefix_config: Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        """
        if aggregation_config is not None:
            pulumi.set(__self__, "aggregation_config", aggregation_config)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if prefix_config is not None:
            pulumi.set(__self__, "prefix_config", prefix_config)

    @property
    @pulumi.getter(name="aggregationConfig")
    def aggregation_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig']:
        """
        Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        """
        return pulumi.get(self, "aggregation_config")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow places in the Upsolver Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter(name="prefixConfig")
    def prefix_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig']:
        """
        Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        """
        return pulumi.get(self, "prefix_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[str] = None):
        """
        :param str aggregation_type: Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        """
        Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        return pulumi.get(self, "aggregation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixFormat":
            suggest = "prefix_format"
        elif key == "prefixType":
            suggest = "prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_format: Optional[str] = None,
                 prefix_type: Optional[str] = None):
        """
        :param str prefix_format: Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        :param str prefix_type: Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        if prefix_format is not None:
            pulumi.set(__self__, "prefix_format", prefix_format)
        if prefix_type is not None:
            pulumi.set(__self__, "prefix_type", prefix_type)

    @property
    @pulumi.getter(name="prefixFormat")
    def prefix_format(self) -> Optional[str]:
        """
        Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        return pulumi.get(self, "prefix_format")

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[str]:
        """
        Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        return pulumi.get(self, "prefix_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        :param str write_operation_type: This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        pulumi.set(__self__, "object", object)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)
        if id_field_names is not None:
            pulumi.set(__self__, "id_field_names", id_field_names)
        if write_operation_type is not None:
            pulumi.set(__self__, "write_operation_type", write_operation_type)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectPath":
            suggest = "object_path"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "successResponseHandlingConfig":
            suggest = "success_response_handling_config"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_path: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 success_response_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig'] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object_path: Object path specified in the SAPOData flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfigArgs' success_response_handling_config: Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
        :param str write_operation_type: This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        pulumi.set(__self__, "object_path", object_path)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)
        if id_field_names is not None:
            pulumi.set(__self__, "id_field_names", id_field_names)
        if success_response_handling_config is not None:
            pulumi.set(__self__, "success_response_handling_config", success_response_handling_config)
        if write_operation_type is not None:
            pulumi.set(__self__, "write_operation_type", write_operation_type)

    @property
    @pulumi.getter(name="objectPath")
    def object_path(self) -> str:
        """
        Object path specified in the SAPOData flow source.
        """
        return pulumi.get(self, "object_path")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="successResponseHandlingConfig")
    def success_response_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig']:
        """
        Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
        """
        return pulumi.get(self, "success_response_handling_config")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateBucketName":
            suggest = "intermediate_bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_bucket_name: str,
                 object: str,
                 bucket_prefix: Optional[str] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig'] = None):
        """
        :param str intermediate_bucket_name: Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Snowflake.
        :param str object: Object specified in the Veeva flow source.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        pulumi.set(__self__, "intermediate_bucket_name", intermediate_bucket_name)
        pulumi.set(__self__, "object", object)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)

    @property
    @pulumi.getter(name="intermediateBucketName")
    def intermediate_bucket_name(self) -> str:
        """
        Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Snowflake.
        """
        return pulumi.get(self, "intermediate_bucket_name")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "s3OutputFormatConfig":
            suggest = "s3_output_format_config"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 s3_output_format_config: 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig',
                 bucket_prefix: Optional[str] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigArgs' s3_output_format_config: Configuration that determines how Amazon AppFlow should format the flow output data when Upsolver is used as the destination. See Upsolver S3 Output Format Config for more details.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "s3_output_format_config", s3_output_format_config)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="s3OutputFormatConfig")
    def s3_output_format_config(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig':
        """
        Configuration that determines how Amazon AppFlow should format the flow output data when Upsolver is used as the destination. See Upsolver S3 Output Format Config for more details.
        """
        return pulumi.get(self, "s3_output_format_config")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixConfig":
            suggest = "prefix_config"
        elif key == "aggregationConfig":
            suggest = "aggregation_config"
        elif key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_config: 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig',
                 aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig'] = None,
                 file_type: Optional[str] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfigArgs' prefix_config: Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfigArgs' aggregation_config: Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        :param str file_type: File type that Amazon AppFlow places in the Upsolver Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        pulumi.set(__self__, "prefix_config", prefix_config)
        if aggregation_config is not None:
            pulumi.set(__self__, "aggregation_config", aggregation_config)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)

    @property
    @pulumi.getter(name="prefixConfig")
    def prefix_config(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig':
        """
        Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        """
        return pulumi.get(self, "prefix_config")

    @property
    @pulumi.getter(name="aggregationConfig")
    def aggregation_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig']:
        """
        Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        """
        return pulumi.get(self, "aggregation_config")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow places in the Upsolver Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[str] = None):
        """
        :param str aggregation_type: Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        """
        Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        return pulumi.get(self, "aggregation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixType":
            suggest = "prefix_type"
        elif key == "prefixFormat":
            suggest = "prefix_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_type: str,
                 prefix_format: Optional[str] = None):
        """
        :param str prefix_type: Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        :param str prefix_format: Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        pulumi.set(__self__, "prefix_type", prefix_type)
        if prefix_format is not None:
            pulumi.set(__self__, "prefix_format", prefix_format)

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> str:
        """
        Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        return pulumi.get(self, "prefix_type")

    @property
    @pulumi.getter(name="prefixFormat")
    def prefix_format(self) -> Optional[str]:
        """
        Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        return pulumi.get(self, "prefix_format")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        :param str write_operation_type: This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        pulumi.set(__self__, "object", object)
        if error_handling_config is not None:
            pulumi.set(__self__, "error_handling_config", error_handling_config)
        if id_field_names is not None:
            pulumi.set(__self__, "id_field_names", id_field_names)
        if write_operation_type is not None:
            pulumi.set(__self__, "write_operation_type", write_operation_type)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        This specifies the type of write operation to be performed in Zendesk. When the value is `UPSERT`, then `id_field_names` is required. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            pulumi.set(__self__, "fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowSourceFlowConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorType":
            suggest = "connector_type"
        elif key == "sourceConnectorProperties":
            suggest = "source_connector_properties"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "connectorProfileName":
            suggest = "connector_profile_name"
        elif key == "incrementalPullConfig":
            suggest = "incremental_pull_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_type: str,
                 source_connector_properties: 'outputs.FlowSourceFlowConfigSourceConnectorProperties',
                 api_version: Optional[str] = None,
                 connector_profile_name: Optional[str] = None,
                 incremental_pull_config: Optional['outputs.FlowSourceFlowConfigIncrementalPullConfig'] = None):
        """
        :param str connector_type: Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesArgs' source_connector_properties: Information that is required to query a particular source connector. See Source Connector Properties for details.
        :param str api_version: API version that the destination connector uses.
        :param str connector_profile_name: Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        :param 'FlowSourceFlowConfigIncrementalPullConfigArgs' incremental_pull_config: Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
        """
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "source_connector_properties", source_connector_properties)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connector_profile_name is not None:
            pulumi.set(__self__, "connector_profile_name", connector_profile_name)
        if incremental_pull_config is not None:
            pulumi.set(__self__, "incremental_pull_config", incremental_pull_config)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="sourceConnectorProperties")
    def source_connector_properties(self) -> 'outputs.FlowSourceFlowConfigSourceConnectorProperties':
        """
        Information that is required to query a particular source connector. See Source Connector Properties for details.
        """
        return pulumi.get(self, "source_connector_properties")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version that the destination connector uses.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[str]:
        """
        Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        return pulumi.get(self, "connector_profile_name")

    @property
    @pulumi.getter(name="incrementalPullConfig")
    def incremental_pull_config(self) -> Optional['outputs.FlowSourceFlowConfigIncrementalPullConfig']:
        """
        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
        """
        return pulumi.get(self, "incremental_pull_config")


@pulumi.output_type
class FlowSourceFlowConfigIncrementalPullConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datetimeTypeFieldName":
            suggest = "datetime_type_field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigIncrementalPullConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigIncrementalPullConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigIncrementalPullConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datetime_type_field_name: Optional[str] = None):
        """
        :param str datetime_type_field_name: Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        if datetime_type_field_name is not None:
            pulumi.set(__self__, "datetime_type_field_name", datetime_type_field_name)

    @property
    @pulumi.getter(name="datetimeTypeFieldName")
    def datetime_type_field_name(self) -> Optional[str]:
        """
        Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        return pulumi.get(self, "datetime_type_field_name")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude'] = None,
                 custom_connector: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector'] = None,
                 datadog: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDatadog'] = None,
                 dynatrace: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace'] = None,
                 google_analytics: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics'] = None,
                 infor_nexus: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus'] = None,
                 marketo: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesMarketo'] = None,
                 s3: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3'] = None,
                 salesforce: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSapoData'] = None,
                 service_now: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow'] = None,
                 singular: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSingular'] = None,
                 slack: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSlack'] = None,
                 trendmicro: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro'] = None,
                 veeva: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesVeeva'] = None,
                 zendesk: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesZendesk'] = None):
        """
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesAmplitudeArgs' amplitude: Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesCustomConnectorArgs' custom_connector: Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesDatadogArgs' datadog: Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesDynatraceArgs' dynatrace: Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalyticsArgs' google_analytics: Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesInforNexusArgs' infor_nexus: Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesMarketoArgs' marketo: Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesS3Args' s3: Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSalesforceArgs' salesforce: Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSapoDataArgs' sapo_data: Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesServiceNowArgs' service_now: Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSingularArgs' singular: Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSlackArgs' slack: Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesTrendmicroArgs' trendmicro: Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesVeevaArgs' veeva: Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesZendeskArgs' zendesk: Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        if amplitude is not None:
            pulumi.set(__self__, "amplitude", amplitude)
        if custom_connector is not None:
            pulumi.set(__self__, "custom_connector", custom_connector)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if dynatrace is not None:
            pulumi.set(__self__, "dynatrace", dynatrace)
        if google_analytics is not None:
            pulumi.set(__self__, "google_analytics", google_analytics)
        if infor_nexus is not None:
            pulumi.set(__self__, "infor_nexus", infor_nexus)
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if sapo_data is not None:
            pulumi.set(__self__, "sapo_data", sapo_data)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if singular is not None:
            pulumi.set(__self__, "singular", singular)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if trendmicro is not None:
            pulumi.set(__self__, "trendmicro", trendmicro)
        if veeva is not None:
            pulumi.set(__self__, "veeva", veeva)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude']:
        """
        Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector']:
        """
        Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDatadog']:
        """
        Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace']:
        """
        Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics']:
        """
        Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus']:
        """
        Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesMarketo']:
        """
        Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3']:
        """
        Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce']:
        """
        Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSapoData']:
        """
        Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow']:
        """
        Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSingular']:
        """
        Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSlack']:
        """
        Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro']:
        """
        Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesVeeva']:
        """
        Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesZendesk']:
        """
        Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesAmplitude(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "customProperties":
            suggest = "custom_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: str,
                 custom_properties: Optional[Mapping[str, str]] = None):
        """
        :param str entity_name: Entity specified in the custom connector as a source in the flow.
        :param Mapping[str, str] custom_properties: Custom properties that are specific to the connector when it's used as a source in the flow. Maximum of 50 items.
        """
        pulumi.set(__self__, "entity_name", entity_name)
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> str:
        """
        Entity specified in the custom connector as a source in the flow.
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Custom properties that are specific to the connector when it's used as a source in the flow. Maximum of 50 items.
        """
        return pulumi.get(self, "custom_properties")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesDatadog(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesDynatrace(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesInforNexus(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesMarketo(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "s3InputFormatConfig":
            suggest = "s3_input_format_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_prefix: Optional[str] = None,
                 s3_input_format_config: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig'] = None):
        """
        :param str bucket_name: Amazon S3 bucket name where the source files are stored.
        :param str bucket_prefix: Object key for the Amazon S3 bucket in which the source files are stored.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfigArgs' s3_input_format_config: When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if s3_input_format_config is not None:
            pulumi.set(__self__, "s3_input_format_config", s3_input_format_config)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="s3InputFormatConfig")
    def s3_input_format_config(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig']:
        """
        When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
        """
        return pulumi.get(self, "s3_input_format_config")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3InputFileType":
            suggest = "s3_input_file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_input_file_type: Optional[str] = None):
        """
        :param str s3_input_file_type: File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
        """
        if s3_input_file_type is not None:
            pulumi.set(__self__, "s3_input_file_type", s3_input_file_type)

    @property
    @pulumi.getter(name="s3InputFileType")
    def s3_input_file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
        """
        return pulumi.get(self, "s3_input_file_type")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDynamicFieldUpdate":
            suggest = "enable_dynamic_field_update"
        elif key == "includeDeletedRecords":
            suggest = "include_deleted_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 enable_dynamic_field_update: Optional[bool] = None,
                 include_deleted_records: Optional[bool] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param bool enable_dynamic_field_update: Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        :param bool include_deleted_records: Whether Amazon AppFlow includes deleted files in the flow run.
        """
        pulumi.set(__self__, "object", object)
        if enable_dynamic_field_update is not None:
            pulumi.set(__self__, "enable_dynamic_field_update", enable_dynamic_field_update)
        if include_deleted_records is not None:
            pulumi.set(__self__, "include_deleted_records", include_deleted_records)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="enableDynamicFieldUpdate")
    def enable_dynamic_field_update(self) -> Optional[bool]:
        """
        Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        """
        return pulumi.get(self, "enable_dynamic_field_update")

    @property
    @pulumi.getter(name="includeDeletedRecords")
    def include_deleted_records(self) -> Optional[bool]:
        """
        Whether Amazon AppFlow includes deleted files in the flow run.
        """
        return pulumi.get(self, "include_deleted_records")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSapoData(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesServiceNow(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSingular(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSlack(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesVeeva(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentType":
            suggest = "document_type"
        elif key == "includeAllVersions":
            suggest = "include_all_versions"
        elif key == "includeRenditions":
            suggest = "include_renditions"
        elif key == "includeSourceFiles":
            suggest = "include_source_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesVeeva. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesVeeva.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesVeeva.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 document_type: Optional[str] = None,
                 include_all_versions: Optional[bool] = None,
                 include_renditions: Optional[bool] = None,
                 include_source_files: Optional[bool] = None):
        """
        :param str object: Object specified in the Veeva flow source.
        :param str document_type: Document type specified in the Veeva document extract flow.
        :param bool include_all_versions: Boolean value to include All Versions of files in Veeva document extract flow.
        :param bool include_renditions: Boolean value to include file renditions in Veeva document extract flow.
        :param bool include_source_files: Boolean value to include source files in Veeva document extract flow.
        """
        pulumi.set(__self__, "object", object)
        if document_type is not None:
            pulumi.set(__self__, "document_type", document_type)
        if include_all_versions is not None:
            pulumi.set(__self__, "include_all_versions", include_all_versions)
        if include_renditions is not None:
            pulumi.set(__self__, "include_renditions", include_renditions)
        if include_source_files is not None:
            pulumi.set(__self__, "include_source_files", include_source_files)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="documentType")
    def document_type(self) -> Optional[str]:
        """
        Document type specified in the Veeva document extract flow.
        """
        return pulumi.get(self, "document_type")

    @property
    @pulumi.getter(name="includeAllVersions")
    def include_all_versions(self) -> Optional[bool]:
        """
        Boolean value to include All Versions of files in Veeva document extract flow.
        """
        return pulumi.get(self, "include_all_versions")

    @property
    @pulumi.getter(name="includeRenditions")
    def include_renditions(self) -> Optional[bool]:
        """
        Boolean value to include file renditions in Veeva document extract flow.
        """
        return pulumi.get(self, "include_renditions")

    @property
    @pulumi.getter(name="includeSourceFiles")
    def include_source_files(self) -> Optional[bool]:
        """
        Boolean value to include source files in Veeva document extract flow.
        """
        return pulumi.get(self, "include_source_files")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesZendesk(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the Veeva flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the Veeva flow source.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceFields":
            suggest = "source_fields"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "connectorOperators":
            suggest = "connector_operators"
        elif key == "destinationField":
            suggest = "destination_field"
        elif key == "taskProperties":
            suggest = "task_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_fields: Sequence[str],
                 task_type: str,
                 connector_operators: Optional[Sequence['outputs.FlowTaskConnectorOperator']] = None,
                 destination_field: Optional[str] = None,
                 task_properties: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] source_fields: Source fields to which a particular task is applied.
        :param str task_type: Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
        :param Sequence['FlowTaskConnectorOperatorArgs'] connector_operators: Operation to be performed on the provided source fields. See Connector Operator for details.
        :param str destination_field: Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        :param Mapping[str, str] task_properties: Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
        """
        pulumi.set(__self__, "source_fields", source_fields)
        pulumi.set(__self__, "task_type", task_type)
        if connector_operators is not None:
            pulumi.set(__self__, "connector_operators", connector_operators)
        if destination_field is not None:
            pulumi.set(__self__, "destination_field", destination_field)
        if task_properties is not None:
            pulumi.set(__self__, "task_properties", task_properties)

    @property
    @pulumi.getter(name="sourceFields")
    def source_fields(self) -> Sequence[str]:
        """
        Source fields to which a particular task is applied.
        """
        return pulumi.get(self, "source_fields")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="connectorOperators")
    def connector_operators(self) -> Optional[Sequence['outputs.FlowTaskConnectorOperator']]:
        """
        Operation to be performed on the provided source fields. See Connector Operator for details.
        """
        return pulumi.get(self, "connector_operators")

    @property
    @pulumi.getter(name="destinationField")
    def destination_field(self) -> Optional[str]:
        """
        Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        """
        return pulumi.get(self, "destination_field")

    @property
    @pulumi.getter(name="taskProperties")
    def task_properties(self) -> Optional[Mapping[str, str]]:
        """
        Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
        """
        return pulumi.get(self, "task_properties")


@pulumi.output_type
class FlowTaskConnectorOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTaskConnectorOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTaskConnectorOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTaskConnectorOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional[str] = None,
                 custom_connector: Optional[str] = None,
                 datadog: Optional[str] = None,
                 dynatrace: Optional[str] = None,
                 google_analytics: Optional[str] = None,
                 infor_nexus: Optional[str] = None,
                 marketo: Optional[str] = None,
                 s3: Optional[str] = None,
                 salesforce: Optional[str] = None,
                 sapo_data: Optional[str] = None,
                 service_now: Optional[str] = None,
                 singular: Optional[str] = None,
                 slack: Optional[str] = None,
                 trendmicro: Optional[str] = None,
                 veeva: Optional[str] = None,
                 zendesk: Optional[str] = None):
        """
        :param str amplitude: Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        :param str custom_connector: Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str datadog: Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str dynatrace: Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str google_analytics: Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        :param str infor_nexus: Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str marketo: Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str s3: Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str salesforce: Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str sapo_data: Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str service_now: Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str singular: Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str slack: Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str trendmicro: Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str veeva: Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str zendesk: Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        if amplitude is not None:
            pulumi.set(__self__, "amplitude", amplitude)
        if custom_connector is not None:
            pulumi.set(__self__, "custom_connector", custom_connector)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if dynatrace is not None:
            pulumi.set(__self__, "dynatrace", dynatrace)
        if google_analytics is not None:
            pulumi.set(__self__, "google_analytics", google_analytics)
        if infor_nexus is not None:
            pulumi.set(__self__, "infor_nexus", infor_nexus)
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if sapo_data is not None:
            pulumi.set(__self__, "sapo_data", sapo_data)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if singular is not None:
            pulumi.set(__self__, "singular", singular)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if trendmicro is not None:
            pulumi.set(__self__, "trendmicro", trendmicro)
        if veeva is not None:
            pulumi.set(__self__, "veeva", veeva)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional[str]:
        """
        Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional[str]:
        """
        Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional[str]:
        """
        Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional[str]:
        """
        Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional[str]:
        """
        Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional[str]:
        """
        Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional[str]:
        """
        Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional[str]:
        """
        Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional[str]:
        """
        Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional[str]:
        """
        Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[str]:
        """
        Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional[str]:
        """
        Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional[str]:
        """
        Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional[str]:
        """
        Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional[str]:
        """
        Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional[str]:
        """
        Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowTriggerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "triggerProperties":
            suggest = "trigger_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: str,
                 trigger_properties: Optional['outputs.FlowTriggerConfigTriggerProperties'] = None):
        """
        :param str trigger_type: Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
        :param 'FlowTriggerConfigTriggerPropertiesArgs' trigger_properties: Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if trigger_properties is not None:
            pulumi.set(__self__, "trigger_properties", trigger_properties)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> str:
        """
        Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="triggerProperties")
    def trigger_properties(self) -> Optional['outputs.FlowTriggerConfigTriggerProperties']:
        """
        Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
        """
        return pulumi.get(self, "trigger_properties")


@pulumi.output_type
class FlowTriggerConfigTriggerProperties(dict):
    def __init__(__self__, *,
                 scheduled: Optional['outputs.FlowTriggerConfigTriggerPropertiesScheduled'] = None):
        if scheduled is not None:
            pulumi.set(__self__, "scheduled", scheduled)

    @property
    @pulumi.getter
    def scheduled(self) -> Optional['outputs.FlowTriggerConfigTriggerPropertiesScheduled']:
        return pulumi.get(self, "scheduled")


@pulumi.output_type
class FlowTriggerConfigTriggerPropertiesScheduled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleExpression":
            suggest = "schedule_expression"
        elif key == "dataPullMode":
            suggest = "data_pull_mode"
        elif key == "firstExecutionFrom":
            suggest = "first_execution_from"
        elif key == "scheduleEndTime":
            suggest = "schedule_end_time"
        elif key == "scheduleOffset":
            suggest = "schedule_offset"
        elif key == "scheduleStartTime":
            suggest = "schedule_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTriggerConfigTriggerPropertiesScheduled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTriggerConfigTriggerPropertiesScheduled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTriggerConfigTriggerPropertiesScheduled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_expression: str,
                 data_pull_mode: Optional[str] = None,
                 first_execution_from: Optional[str] = None,
                 schedule_end_time: Optional[str] = None,
                 schedule_offset: Optional[int] = None,
                 schedule_start_time: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str schedule_expression: Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
        :param str data_pull_mode: Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
        :param str first_execution_from: Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
        :param str schedule_end_time: Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        :param int schedule_offset: Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
        :param str schedule_start_time: Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        :param str timezone: Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
        """
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if data_pull_mode is not None:
            pulumi.set(__self__, "data_pull_mode", data_pull_mode)
        if first_execution_from is not None:
            pulumi.set(__self__, "first_execution_from", first_execution_from)
        if schedule_end_time is not None:
            pulumi.set(__self__, "schedule_end_time", schedule_end_time)
        if schedule_offset is not None:
            pulumi.set(__self__, "schedule_offset", schedule_offset)
        if schedule_start_time is not None:
            pulumi.set(__self__, "schedule_start_time", schedule_start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> str:
        """
        Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
        """
        return pulumi.get(self, "schedule_expression")

    @property
    @pulumi.getter(name="dataPullMode")
    def data_pull_mode(self) -> Optional[str]:
        """
        Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
        """
        return pulumi.get(self, "data_pull_mode")

    @property
    @pulumi.getter(name="firstExecutionFrom")
    def first_execution_from(self) -> Optional[str]:
        """
        Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "first_execution_from")

    @property
    @pulumi.getter(name="scheduleEndTime")
    def schedule_end_time(self) -> Optional[str]:
        """
        Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "schedule_end_time")

    @property
    @pulumi.getter(name="scheduleOffset")
    def schedule_offset(self) -> Optional[int]:
        """
        Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
        """
        return pulumi.get(self, "schedule_offset")

    @property
    @pulumi.getter(name="scheduleStartTime")
    def schedule_start_time(self) -> Optional[str]:
        """
        Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "schedule_start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
        """
        return pulumi.get(self, "timezone")


