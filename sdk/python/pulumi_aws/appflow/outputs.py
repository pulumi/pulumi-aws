# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ConnectorProfileConnectorProfileConfig',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk',
    'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest',
    'ConnectorProfileConnectorProfileConfigConnectorProfileProperties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva',
    'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk',
    'FlowDestinationFlowConfig',
    'FlowDestinationFlowConfigDestinationConnectorProperties',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk',
    'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig',
    'FlowSourceFlowConfig',
    'FlowSourceFlowConfigIncrementalPullConfig',
    'FlowSourceFlowConfigSourceConnectorProperties',
    'FlowSourceFlowConfigSourceConnectorPropertiesAmplitude',
    'FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector',
    'FlowSourceFlowConfigSourceConnectorPropertiesDatadog',
    'FlowSourceFlowConfigSourceConnectorPropertiesDynatrace',
    'FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics',
    'FlowSourceFlowConfigSourceConnectorPropertiesInforNexus',
    'FlowSourceFlowConfigSourceConnectorPropertiesMarketo',
    'FlowSourceFlowConfigSourceConnectorPropertiesS3',
    'FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig',
    'FlowSourceFlowConfigSourceConnectorPropertiesSalesforce',
    'FlowSourceFlowConfigSourceConnectorPropertiesSapoData',
    'FlowSourceFlowConfigSourceConnectorPropertiesServiceNow',
    'FlowSourceFlowConfigSourceConnectorPropertiesSingular',
    'FlowSourceFlowConfigSourceConnectorPropertiesSlack',
    'FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro',
    'FlowSourceFlowConfigSourceConnectorPropertiesVeeva',
    'FlowSourceFlowConfigSourceConnectorPropertiesZendesk',
    'FlowTask',
    'FlowTaskConnectorOperator',
    'FlowTriggerConfig',
    'FlowTriggerConfigTriggerProperties',
    'FlowTriggerConfigTriggerPropertiesScheduled',
]

@pulumi.output_type
class ConnectorProfileConnectorProfileConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorProfileCredentials":
            suggest = "connector_profile_credentials"
        elif key == "connectorProfileProperties":
            suggest = "connector_profile_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_profile_credentials: 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials',
                 connector_profile_properties: 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileProperties'):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsArgs' connector_profile_credentials: The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesArgs' connector_profile_properties: The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
        """
        ConnectorProfileConnectorProfileConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connector_profile_credentials=connector_profile_credentials,
            connector_profile_properties=connector_profile_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connector_profile_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials'] = None,
             connector_profile_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileProperties'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connector_profile_credentials is None and 'connectorProfileCredentials' in kwargs:
            connector_profile_credentials = kwargs['connectorProfileCredentials']
        if connector_profile_credentials is None:
            raise TypeError("Missing 'connector_profile_credentials' argument")
        if connector_profile_properties is None and 'connectorProfileProperties' in kwargs:
            connector_profile_properties = kwargs['connectorProfileProperties']
        if connector_profile_properties is None:
            raise TypeError("Missing 'connector_profile_properties' argument")

        _setter("connector_profile_credentials", connector_profile_credentials)
        _setter("connector_profile_properties", connector_profile_properties)

    @property
    @pulumi.getter(name="connectorProfileCredentials")
    def connector_profile_credentials(self) -> 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials':
        """
        The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "connector_profile_credentials")

    @property
    @pulumi.getter(name="connectorProfileProperties")
    def connector_profile_properties(self) -> 'outputs.ConnectorProfileConnectorProfileConfigConnectorProfileProperties':
        """
        The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
        """
        return pulumi.get(self, "connector_profile_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude'] = None,
                 custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector'] = None,
                 datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog'] = None,
                 dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace'] = None,
                 google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics'] = None,
                 honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode'] = None,
                 infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus'] = None,
                 marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo'] = None,
                 redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift'] = None,
                 salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce'] = None,
                 sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData'] = None,
                 service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow'] = None,
                 singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular'] = None,
                 slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack'] = None,
                 snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake'] = None,
                 trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro'] = None,
                 veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva'] = None,
                 zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitudeArgs' amplitude: The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorArgs' custom_connector: The connector-specific profile credentials required when using the custom connector. See Custom Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadogArgs' datadog: Connector-specific credentials required when using Datadog. See Datadog Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatraceArgs' dynatrace: The connector-specific credentials required when using Dynatrace. See Dynatrace Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsArgs' google_analytics: The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeArgs' honeycode: The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexusArgs' infor_nexus: The connector-specific credentials required when using Infor Nexus. See Infor Nexus Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoArgs' marketo: Connector-specific credentials required when using Marketo. See Marketo Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshiftArgs' redshift: Connector-specific credentials required when using Amazon Redshift. See Redshift Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceArgs' salesforce: The connector-specific credentials required when using Salesforce. See Salesforce Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataArgs' sapo_data: The connector-specific credentials required when using SAPOData. See SAPOData Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNowArgs' service_now: The connector-specific credentials required when using ServiceNow. See ServiceNow Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingularArgs' singular: Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackArgs' slack: Connector-specific credentials required when using Slack. See Slack Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflakeArgs' snowflake: The connector-specific credentials required when using Snowflake. See Snowflake Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicroArgs' trendmicro: The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeevaArgs' veeva: Connector-specific credentials required when using Veeva. See Veeva Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskArgs' zendesk: Connector-specific credentials required when using Zendesk. See Zendesk Connector Profile Credentials for more details.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amplitude=amplitude,
            custom_connector=custom_connector,
            datadog=datadog,
            dynatrace=dynatrace,
            google_analytics=google_analytics,
            honeycode=honeycode,
            infor_nexus=infor_nexus,
            marketo=marketo,
            redshift=redshift,
            salesforce=salesforce,
            sapo_data=sapo_data,
            service_now=service_now,
            singular=singular,
            slack=slack,
            snowflake=snowflake,
            trendmicro=trendmicro,
            veeva=veeva,
            zendesk=zendesk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude'] = None,
             custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector'] = None,
             datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog'] = None,
             dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace'] = None,
             google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics'] = None,
             honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode'] = None,
             infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus'] = None,
             marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo'] = None,
             redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift'] = None,
             salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce'] = None,
             sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData'] = None,
             service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow'] = None,
             singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular'] = None,
             slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack'] = None,
             snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake'] = None,
             trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro'] = None,
             veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva'] = None,
             zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_connector is None and 'customConnector' in kwargs:
            custom_connector = kwargs['customConnector']
        if google_analytics is None and 'googleAnalytics' in kwargs:
            google_analytics = kwargs['googleAnalytics']
        if infor_nexus is None and 'inforNexus' in kwargs:
            infor_nexus = kwargs['inforNexus']
        if sapo_data is None and 'sapoData' in kwargs:
            sapo_data = kwargs['sapoData']
        if service_now is None and 'serviceNow' in kwargs:
            service_now = kwargs['serviceNow']

        if amplitude is not None:
            _setter("amplitude", amplitude)
        if custom_connector is not None:
            _setter("custom_connector", custom_connector)
        if datadog is not None:
            _setter("datadog", datadog)
        if dynatrace is not None:
            _setter("dynatrace", dynatrace)
        if google_analytics is not None:
            _setter("google_analytics", google_analytics)
        if honeycode is not None:
            _setter("honeycode", honeycode)
        if infor_nexus is not None:
            _setter("infor_nexus", infor_nexus)
        if marketo is not None:
            _setter("marketo", marketo)
        if redshift is not None:
            _setter("redshift", redshift)
        if salesforce is not None:
            _setter("salesforce", salesforce)
        if sapo_data is not None:
            _setter("sapo_data", sapo_data)
        if service_now is not None:
            _setter("service_now", service_now)
        if singular is not None:
            _setter("singular", singular)
        if slack is not None:
            _setter("slack", slack)
        if snowflake is not None:
            _setter("snowflake", snowflake)
        if trendmicro is not None:
            _setter("trendmicro", trendmicro)
        if veeva is not None:
            _setter("veeva", veeva)
        if zendesk is not None:
            _setter("zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude']:
        """
        The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector']:
        """
        The connector-specific profile credentials required when using the custom connector. See Custom Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog']:
        """
        Connector-specific credentials required when using Datadog. See Datadog Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace']:
        """
        The connector-specific credentials required when using Dynatrace. See Dynatrace Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics']:
        """
        The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode']:
        """
        The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus']:
        """
        The connector-specific credentials required when using Infor Nexus. See Infor Nexus Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo']:
        """
        Connector-specific credentials required when using Marketo. See Marketo Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift']:
        """
        Connector-specific credentials required when using Amazon Redshift. See Redshift Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce']:
        """
        The connector-specific credentials required when using Salesforce. See Salesforce Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData']:
        """
        The connector-specific credentials required when using SAPOData. See SAPOData Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow']:
        """
        The connector-specific credentials required when using ServiceNow. See ServiceNow Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular']:
        """
        Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack']:
        """
        Connector-specific credentials required when using Slack. See Slack Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake']:
        """
        The connector-specific credentials required when using Snowflake. See Snowflake Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro']:
        """
        The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva']:
        """
        Connector-specific credentials required when using Veeva. See Veeva Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk']:
        """
        Connector-specific credentials required when using Zendesk. See Zendesk Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 secret_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str secret_key: The Secret Access Key portion of the credentials.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key=api_key,
            secret_key=secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key: Optional[str] = None,
             secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_key is None and 'apiKey' in kwargs:
            api_key = kwargs['apiKey']
        if api_key is None:
            raise TypeError("Missing 'api_key' argument")
        if secret_key is None and 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if secret_key is None:
            raise TypeError("Missing 'secret_key' argument")

        _setter("api_key", api_key)
        _setter("secret_key", secret_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        The Secret Access Key portion of the credentials.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationType":
            suggest = "authentication_type"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_type: str,
                 api_key: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey'] = None,
                 basic: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic'] = None,
                 custom: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom'] = None,
                 oauth2: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2'] = None):
        """
        :param str authentication_type: The authentication type that the custom connector uses for authenticating while creating a connector profile. One of: `APIKEY`, `BASIC`, `CUSTOM`, `OAUTH2`.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKeyArgs' api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasicArgs' basic: Basic credentials that are required for the authentication of the user.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustomArgs' custom: If the connector uses the custom authentication mechanism, this holds the required credentials.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2Args' oauth2: OAuth 2.0 credentials required for the authentication of the user.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_type=authentication_type,
            api_key=api_key,
            basic=basic,
            custom=custom,
            oauth2=oauth2,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_type: Optional[str] = None,
             api_key: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey'] = None,
             basic: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic'] = None,
             custom: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom'] = None,
             oauth2: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if api_key is None and 'apiKey' in kwargs:
            api_key = kwargs['apiKey']

        _setter("authentication_type", authentication_type)
        if api_key is not None:
            _setter("api_key", api_key)
        if basic is not None:
            _setter("basic", basic)
        if custom is not None:
            _setter("custom", custom)
        if oauth2 is not None:
            _setter("oauth2", oauth2)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type that the custom connector uses for authenticating while creating a connector profile. One of: `APIKEY`, `BASIC`, `CUSTOM`, `OAUTH2`.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey']:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic']:
        """
        Basic credentials that are required for the authentication of the user.
        """
        return pulumi.get(self, "basic")

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom']:
        """
        If the connector uses the custom authentication mechanism, this holds the required credentials.
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def oauth2(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2']:
        """
        OAuth 2.0 credentials required for the authentication of the user.
        """
        return pulumi.get(self, "oauth2")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecretKey":
            suggest = "api_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 api_secret_key: Optional[str] = None):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str api_secret_key: The API secret key required for API key authentication.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key=api_key,
            api_secret_key=api_secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key: Optional[str] = None,
             api_secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_key is None and 'apiKey' in kwargs:
            api_key = kwargs['apiKey']
        if api_key is None:
            raise TypeError("Missing 'api_key' argument")
        if api_secret_key is None and 'apiSecretKey' in kwargs:
            api_secret_key = kwargs['apiSecretKey']

        _setter("api_key", api_key)
        if api_secret_key is not None:
            _setter("api_secret_key", api_secret_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiSecretKey")
    def api_secret_key(self) -> Optional[str]:
        """
        The API secret key required for API key authentication.
        """
        return pulumi.get(self, "api_secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAuthenticationType":
            suggest = "custom_authentication_type"
        elif key == "credentialsMap":
            suggest = "credentials_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_authentication_type: str,
                 credentials_map: Optional[Mapping[str, str]] = None):
        """
        :param str custom_authentication_type: The custom authentication type that the connector uses.
        :param Mapping[str, str] credentials_map: A map that holds custom authentication credentials.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_authentication_type=custom_authentication_type,
            credentials_map=credentials_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_authentication_type: Optional[str] = None,
             credentials_map: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_authentication_type is None and 'customAuthenticationType' in kwargs:
            custom_authentication_type = kwargs['customAuthenticationType']
        if custom_authentication_type is None:
            raise TypeError("Missing 'custom_authentication_type' argument")
        if credentials_map is None and 'credentialsMap' in kwargs:
            credentials_map = kwargs['credentialsMap']

        _setter("custom_authentication_type", custom_authentication_type)
        if credentials_map is not None:
            _setter("credentials_map", credentials_map)

    @property
    @pulumi.getter(name="customAuthenticationType")
    def custom_authentication_type(self) -> str:
        """
        The custom authentication type that the connector uses.
        """
        return pulumi.get(self, "custom_authentication_type")

    @property
    @pulumi.getter(name="credentialsMap")
    def credentials_map(self) -> Optional[Mapping[str, str]]:
        """
        A map that holds custom authentication credentials.
        """
        return pulumi.get(self, "credentials_map")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The access token used to access the connector on your behalf.
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh an expired access token.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token=access_token,
            client_id=client_id,
            client_secret=client_secret,
            oauth_request=oauth_request,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token: Optional[str] = None,
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest'] = None,
             refresh_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']
        if refresh_token is None and 'refreshToken' in kwargs:
            refresh_token = kwargs['refreshToken']

        if access_token is not None:
            _setter("access_token", access_token)
        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh an expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "applicationKey":
            suggest = "application_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 application_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        :param str application_key: Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key=api_key,
            application_key=application_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key: Optional[str] = None,
             application_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_key is None and 'apiKey' in kwargs:
            api_key = kwargs['apiKey']
        if api_key is None:
            raise TypeError("Missing 'api_key' argument")
        if application_key is None and 'applicationKey' in kwargs:
            application_key = kwargs['applicationKey']
        if application_key is None:
            raise TypeError("Missing 'application_key' argument")

        _setter("api_key", api_key)
        _setter("application_key", application_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> str:
        """
        Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        """
        return pulumi.get(self, "application_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: The API tokens used by Dynatrace API to authenticate various API calls.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_token=api_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_token is None and 'apiToken' in kwargs:
            api_token = kwargs['apiToken']
        if api_token is None:
            raise TypeError("Missing 'api_token' argument")

        _setter("api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The API tokens used by Dynatrace API to authenticate various API calls.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh an expired access token.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            access_token=access_token,
            oauth_request=oauth_request,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest'] = None,
             refresh_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']
        if refresh_token is None and 'refreshToken' in kwargs:
            refresh_token = kwargs['refreshToken']

        _setter("client_id", client_id)
        _setter("client_secret", client_secret)
        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh an expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh an expired access token.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token=access_token,
            oauth_request=oauth_request,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest'] = None,
             refresh_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']
        if refresh_token is None and 'refreshToken' in kwargs:
            refresh_token = kwargs['refreshToken']

        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh an expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 datakey: str,
                 secret_access_key: str,
                 user_id: str):
        """
        :param str access_key_id: The Access Key portion of the credentials.
        :param str datakey: Encryption keys used to encrypt data.
        :param str secret_access_key: The secret key used to sign requests.
        :param str user_id: Identifier for the user.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key_id=access_key_id,
            datakey=datakey,
            secret_access_key=secret_access_key,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key_id: Optional[str] = None,
             datakey: Optional[str] = None,
             secret_access_key: Optional[str] = None,
             user_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_key_id is None and 'accessKeyId' in kwargs:
            access_key_id = kwargs['accessKeyId']
        if access_key_id is None:
            raise TypeError("Missing 'access_key_id' argument")
        if datakey is None:
            raise TypeError("Missing 'datakey' argument")
        if secret_access_key is None and 'secretAccessKey' in kwargs:
            secret_access_key = kwargs['secretAccessKey']
        if secret_access_key is None:
            raise TypeError("Missing 'secret_access_key' argument")
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']
        if user_id is None:
            raise TypeError("Missing 'user_id' argument")

        _setter("access_key_id", access_key_id)
        _setter("datakey", datakey)
        _setter("secret_access_key", secret_access_key)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        The Access Key portion of the credentials.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def datakey(self) -> str:
        """
        Encryption keys used to encrypt data.
        """
        return pulumi.get(self, "datakey")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        The secret key used to sign requests.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Identifier for the user.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            access_token=access_token,
            oauth_request=oauth_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']

        _setter("client_id", client_id)
        _setter("client_secret", client_secret)
        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientCredentialsArn":
            suggest = "client_credentials_arn"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_credentials_arn: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: The access token used to access the connector on your behalf.
        :param str client_credentials_arn: The secret manager ARN, which contains the client ID and client secret of the connected app.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh an expired access token.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token=access_token,
            client_credentials_arn=client_credentials_arn,
            oauth_request=oauth_request,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token: Optional[str] = None,
             client_credentials_arn: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest'] = None,
             refresh_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if client_credentials_arn is None and 'clientCredentialsArn' in kwargs:
            client_credentials_arn = kwargs['clientCredentialsArn']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']
        if refresh_token is None and 'refreshToken' in kwargs:
            refresh_token = kwargs['refreshToken']

        if access_token is not None:
            _setter("access_token", access_token)
        if client_credentials_arn is not None:
            _setter("client_credentials_arn", client_credentials_arn)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientCredentialsArn")
    def client_credentials_arn(self) -> Optional[str]:
        """
        The secret manager ARN, which contains the client ID and client secret of the connected app.
        """
        return pulumi.get(self, "client_credentials_arn")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh an expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthCredentials":
            suggest = "basic_auth_credentials"
        elif key == "oauthCredentials":
            suggest = "oauth_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials'] = None,
                 oauth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentialsArgs' basic_auth_credentials: The SAPOData basic authentication credentials.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsArgs' oauth_credentials: The SAPOData OAuth type authentication credentials.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            basic_auth_credentials=basic_auth_credentials,
            oauth_credentials=oauth_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             basic_auth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials'] = None,
             oauth_credentials: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if basic_auth_credentials is None and 'basicAuthCredentials' in kwargs:
            basic_auth_credentials = kwargs['basicAuthCredentials']
        if oauth_credentials is None and 'oauthCredentials' in kwargs:
            oauth_credentials = kwargs['oauthCredentials']

        if basic_auth_credentials is not None:
            _setter("basic_auth_credentials", basic_auth_credentials)
        if oauth_credentials is not None:
            _setter("oauth_credentials", oauth_credentials)

    @property
    @pulumi.getter(name="basicAuthCredentials")
    def basic_auth_credentials(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials']:
        """
        The SAPOData basic authentication credentials.
        """
        return pulumi.get(self, "basic_auth_credentials")

    @property
    @pulumi.getter(name="oauthCredentials")
    def oauth_credentials(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials']:
        """
        The SAPOData OAuth type authentication credentials.
        """
        return pulumi.get(self, "oauth_credentials")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest'] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        :param str refresh_token: The refresh token used to refresh an expired access token.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            access_token=access_token,
            oauth_request=oauth_request,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest'] = None,
             refresh_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']
        if refresh_token is None and 'refreshToken' in kwargs:
            refresh_token = kwargs['refreshToken']

        _setter("client_id", client_id)
        _setter("client_secret", client_secret)
        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The refresh token used to refresh an expired access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key=api_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_key is None and 'apiKey' in kwargs:
            api_key = kwargs['apiKey']
        if api_key is None:
            raise TypeError("Missing 'api_key' argument")

        _setter("api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            access_token=access_token,
            oauth_request=oauth_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']

        _setter("client_id", client_id)
        _setter("client_secret", client_secret)
        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecretKey":
            suggest = "api_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret_key: str):
        """
        :param str api_secret_key: The API secret key required for API key authentication.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_secret_key=api_secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_secret_key is None and 'apiSecretKey' in kwargs:
            api_secret_key = kwargs['apiSecretKey']
        if api_secret_key is None:
            raise TypeError("Missing 'api_secret_key' argument")

        _setter("api_secret_key", api_secret_key)

    @property
    @pulumi.getter(name="apiSecretKey")
    def api_secret_key(self) -> str:
        """
        The API secret key required for API key authentication.
        """
        return pulumi.get(self, "api_secret_key")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password to use to connect to a resource.
        :param str username: The username to use to connect to a resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use to connect to a resource.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use to connect to a resource.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "oauthRequest":
            suggest = "oauth_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest'] = None):
        """
        :param str client_id: The identifier for the desired client.
        :param str client_secret: The client secret used by the OAuth client to authenticate to the authorization server.
        :param str access_token: The access token used to access the connector on your behalf.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequestArgs' oauth_request: Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            access_token=access_token,
            oauth_request=oauth_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             access_token: Optional[str] = None,
             oauth_request: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if oauth_request is None and 'oauthRequest' in kwargs:
            oauth_request = kwargs['oauthRequest']

        _setter("client_id", client_id)
        _setter("client_secret", client_secret)
        if access_token is not None:
            _setter("access_token", access_token)
        if oauth_request is not None:
            _setter("oauth_request", oauth_request)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The identifier for the desired client.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret used by the OAuth client to authenticate to the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to access the connector on your behalf.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oauthRequest")
    def oauth_request(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest']:
        """
        Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
        """
        return pulumi.get(self, "oauth_request")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: Optional[str] = None,
                 redirect_uri: Optional[str] = None):
        """
        :param str auth_code: The code provided by the connector when it has been authenticated via the connected app.
        :param str redirect_uri: The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code=auth_code,
            redirect_uri=redirect_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code: Optional[str] = None,
             redirect_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code is None and 'authCode' in kwargs:
            auth_code = kwargs['authCode']
        if redirect_uri is None and 'redirectUri' in kwargs:
            redirect_uri = kwargs['redirectUri']

        if auth_code is not None:
            _setter("auth_code", auth_code)
        if redirect_uri is not None:
            _setter("redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[str]:
        """
        The code provided by the connector when it has been authenticated via the connected app.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[str]:
        """
        The URL to which the authentication server redirects the browser after authorization has been granted.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfileProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfileProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfileProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude'] = None,
                 custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector'] = None,
                 datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog'] = None,
                 dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace'] = None,
                 google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics'] = None,
                 honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode'] = None,
                 infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus'] = None,
                 marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo'] = None,
                 redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift'] = None,
                 salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData'] = None,
                 service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow'] = None,
                 singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular'] = None,
                 slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack'] = None,
                 snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake'] = None,
                 trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro'] = None,
                 veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva'] = None,
                 zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk'] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitudeArgs' amplitude: The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorArgs' custom_connector: The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadogArgs' datadog: Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatraceArgs' dynatrace: The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalyticsArgs' google_analytics: The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycodeArgs' honeycode: The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexusArgs' infor_nexus: The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketoArgs' marketo: Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshiftArgs' redshift: Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforceArgs' salesforce: The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataArgs' sapo_data: The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNowArgs' service_now: The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingularArgs' singular: Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlackArgs' slack: Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflakeArgs' snowflake: The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicroArgs' trendmicro: The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeevaArgs' veeva: Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendeskArgs' zendesk: Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfileProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amplitude=amplitude,
            custom_connector=custom_connector,
            datadog=datadog,
            dynatrace=dynatrace,
            google_analytics=google_analytics,
            honeycode=honeycode,
            infor_nexus=infor_nexus,
            marketo=marketo,
            redshift=redshift,
            salesforce=salesforce,
            sapo_data=sapo_data,
            service_now=service_now,
            singular=singular,
            slack=slack,
            snowflake=snowflake,
            trendmicro=trendmicro,
            veeva=veeva,
            zendesk=zendesk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amplitude: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude'] = None,
             custom_connector: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector'] = None,
             datadog: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog'] = None,
             dynatrace: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace'] = None,
             google_analytics: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics'] = None,
             honeycode: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode'] = None,
             infor_nexus: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus'] = None,
             marketo: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo'] = None,
             redshift: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift'] = None,
             salesforce: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce'] = None,
             sapo_data: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData'] = None,
             service_now: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow'] = None,
             singular: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular'] = None,
             slack: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack'] = None,
             snowflake: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake'] = None,
             trendmicro: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro'] = None,
             veeva: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva'] = None,
             zendesk: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_connector is None and 'customConnector' in kwargs:
            custom_connector = kwargs['customConnector']
        if google_analytics is None and 'googleAnalytics' in kwargs:
            google_analytics = kwargs['googleAnalytics']
        if infor_nexus is None and 'inforNexus' in kwargs:
            infor_nexus = kwargs['inforNexus']
        if sapo_data is None and 'sapoData' in kwargs:
            sapo_data = kwargs['sapoData']
        if service_now is None and 'serviceNow' in kwargs:
            service_now = kwargs['serviceNow']

        if amplitude is not None:
            _setter("amplitude", amplitude)
        if custom_connector is not None:
            _setter("custom_connector", custom_connector)
        if datadog is not None:
            _setter("datadog", datadog)
        if dynatrace is not None:
            _setter("dynatrace", dynatrace)
        if google_analytics is not None:
            _setter("google_analytics", google_analytics)
        if honeycode is not None:
            _setter("honeycode", honeycode)
        if infor_nexus is not None:
            _setter("infor_nexus", infor_nexus)
        if marketo is not None:
            _setter("marketo", marketo)
        if redshift is not None:
            _setter("redshift", redshift)
        if salesforce is not None:
            _setter("salesforce", salesforce)
        if sapo_data is not None:
            _setter("sapo_data", sapo_data)
        if service_now is not None:
            _setter("service_now", service_now)
        if singular is not None:
            _setter("singular", singular)
        if slack is not None:
            _setter("slack", slack)
        if snowflake is not None:
            _setter("snowflake", snowflake)
        if trendmicro is not None:
            _setter("trendmicro", trendmicro)
        if veeva is not None:
            _setter("veeva", veeva)
        if zendesk is not None:
            _setter("zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude']:
        """
        The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector']:
        """
        The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog']:
        """
        Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace']:
        """
        The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics']:
        """
        The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode']:
        """
        The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus']:
        """
        The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo']:
        """
        Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift']:
        """
        Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce']:
        """
        The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData']:
        """
        The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow']:
        """
        The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular']:
        """
        Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack']:
        """
        Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake']:
        """
        The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro']:
        """
        The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva']:
        """
        Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk']:
        """
        Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2Properties":
            suggest = "oauth2_properties"
        elif key == "profileProperties":
            suggest = "profile_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth2_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties'] = None,
                 profile_properties: Optional[Mapping[str, str]] = None):
        """
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2PropertiesArgs' oauth2_properties: The OAuth 2.0 properties required for OAuth 2.0 authentication.
        :param Mapping[str, str] profile_properties: A map of properties that are required to create a profile for the custom connector.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oauth2_properties=oauth2_properties,
            profile_properties=profile_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oauth2_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties'] = None,
             profile_properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oauth2_properties is None and 'oauth2Properties' in kwargs:
            oauth2_properties = kwargs['oauth2Properties']
        if profile_properties is None and 'profileProperties' in kwargs:
            profile_properties = kwargs['profileProperties']

        if oauth2_properties is not None:
            _setter("oauth2_properties", oauth2_properties)
        if profile_properties is not None:
            _setter("profile_properties", profile_properties)

    @property
    @pulumi.getter(name="oauth2Properties")
    def oauth2_properties(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties']:
        """
        The OAuth 2.0 properties required for OAuth 2.0 authentication.
        """
        return pulumi.get(self, "oauth2_properties")

    @property
    @pulumi.getter(name="profileProperties")
    def profile_properties(self) -> Optional[Mapping[str, str]]:
        """
        A map of properties that are required to create a profile for the custom connector.
        """
        return pulumi.get(self, "profile_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2GrantType":
            suggest = "oauth2_grant_type"
        elif key == "tokenUrl":
            suggest = "token_url"
        elif key == "tokenUrlCustomProperties":
            suggest = "token_url_custom_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth2_grant_type: str,
                 token_url: str,
                 token_url_custom_properties: Optional[Mapping[str, str]] = None):
        """
        :param str oauth2_grant_type: The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication. One of: `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`.
        :param str token_url: The token URL required for OAuth 2.0 authentication.
        :param Mapping[str, str] token_url_custom_properties: Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oauth2_grant_type=oauth2_grant_type,
            token_url=token_url,
            token_url_custom_properties=token_url_custom_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oauth2_grant_type: Optional[str] = None,
             token_url: Optional[str] = None,
             token_url_custom_properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oauth2_grant_type is None and 'oauth2GrantType' in kwargs:
            oauth2_grant_type = kwargs['oauth2GrantType']
        if oauth2_grant_type is None:
            raise TypeError("Missing 'oauth2_grant_type' argument")
        if token_url is None and 'tokenUrl' in kwargs:
            token_url = kwargs['tokenUrl']
        if token_url is None:
            raise TypeError("Missing 'token_url' argument")
        if token_url_custom_properties is None and 'tokenUrlCustomProperties' in kwargs:
            token_url_custom_properties = kwargs['tokenUrlCustomProperties']

        _setter("oauth2_grant_type", oauth2_grant_type)
        _setter("token_url", token_url)
        if token_url_custom_properties is not None:
            _setter("token_url_custom_properties", token_url_custom_properties)

    @property
    @pulumi.getter(name="oauth2GrantType")
    def oauth2_grant_type(self) -> str:
        """
        The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication. One of: `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "oauth2_grant_type")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token URL required for OAuth 2.0 authentication.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter(name="tokenUrlCustomProperties")
    def token_url_custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        """
        return pulumi.get(self, "token_url_custom_properties")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "clusterIdentifier":
            suggest = "cluster_identifier"
        elif key == "dataApiRoleArn":
            suggest = "data_api_role_arn"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "databaseUrl":
            suggest = "database_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 role_arn: str,
                 bucket_prefix: Optional[str] = None,
                 cluster_identifier: Optional[str] = None,
                 data_api_role_arn: Optional[str] = None,
                 database_name: Optional[str] = None,
                 database_url: Optional[str] = None):
        """
        :param str bucket_name: A name for the associated Amazon S3 bucket.
        :param str role_arn: ARN of the IAM role.
        :param str bucket_prefix: The object key for the destination bucket in which Amazon AppFlow places the files.
        :param str cluster_identifier: The unique ID that's assigned to an Amazon Redshift cluster.
        :param str data_api_role_arn: ARN of the IAM role that permits AppFlow to access the database through Data API.
        :param str database_name: The name of an Amazon Redshift database.
        :param str database_url: The JDBC URL of the Amazon Redshift cluster.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            role_arn=role_arn,
            bucket_prefix=bucket_prefix,
            cluster_identifier=cluster_identifier,
            data_api_role_arn=data_api_role_arn,
            database_name=database_name,
            database_url=database_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             role_arn: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             cluster_identifier: Optional[str] = None,
             data_api_role_arn: Optional[str] = None,
             database_name: Optional[str] = None,
             database_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if cluster_identifier is None and 'clusterIdentifier' in kwargs:
            cluster_identifier = kwargs['clusterIdentifier']
        if data_api_role_arn is None and 'dataApiRoleArn' in kwargs:
            data_api_role_arn = kwargs['dataApiRoleArn']
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_url is None and 'databaseUrl' in kwargs:
            database_url = kwargs['databaseUrl']

        _setter("bucket_name", bucket_name)
        _setter("role_arn", role_arn)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if cluster_identifier is not None:
            _setter("cluster_identifier", cluster_identifier)
        if data_api_role_arn is not None:
            _setter("data_api_role_arn", data_api_role_arn)
        if database_name is not None:
            _setter("database_name", database_name)
        if database_url is not None:
            _setter("database_url", database_url)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        A name for the associated Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the IAM role.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        The object key for the destination bucket in which Amazon AppFlow places the files.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> Optional[str]:
        """
        The unique ID that's assigned to an Amazon Redshift cluster.
        """
        return pulumi.get(self, "cluster_identifier")

    @property
    @pulumi.getter(name="dataApiRoleArn")
    def data_api_role_arn(self) -> Optional[str]:
        """
        ARN of the IAM role that permits AppFlow to access the database through Data API.
        """
        return pulumi.get(self, "data_api_role_arn")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of an Amazon Redshift database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="databaseUrl")
    def database_url(self) -> Optional[str]:
        """
        The JDBC URL of the Amazon Redshift cluster.
        """
        return pulumi.get(self, "database_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"
        elif key == "isSandboxEnvironment":
            suggest = "is_sandbox_environment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: Optional[str] = None,
                 is_sandbox_environment: Optional[bool] = None):
        """
        :param str instance_url: The location of the Datadog resource.
        :param bool is_sandbox_environment: Indicates whether the connector profile applies to a sandbox or production environment.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
            is_sandbox_environment=is_sandbox_environment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             is_sandbox_environment: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if is_sandbox_environment is None and 'isSandboxEnvironment' in kwargs:
            is_sandbox_environment = kwargs['isSandboxEnvironment']

        if instance_url is not None:
            _setter("instance_url", instance_url)
        if is_sandbox_environment is not None:
            _setter("is_sandbox_environment", is_sandbox_environment)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> Optional[str]:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")

    @property
    @pulumi.getter(name="isSandboxEnvironment")
    def is_sandbox_environment(self) -> Optional[bool]:
        """
        Indicates whether the connector profile applies to a sandbox or production environment.
        """
        return pulumi.get(self, "is_sandbox_environment")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationHostUrl":
            suggest = "application_host_url"
        elif key == "applicationServicePath":
            suggest = "application_service_path"
        elif key == "clientNumber":
            suggest = "client_number"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "logonLanguage":
            suggest = "logon_language"
        elif key == "oauthProperties":
            suggest = "oauth_properties"
        elif key == "privateLinkServiceName":
            suggest = "private_link_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_host_url: str,
                 application_service_path: str,
                 client_number: str,
                 port_number: int,
                 logon_language: Optional[str] = None,
                 oauth_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties'] = None,
                 private_link_service_name: Optional[str] = None):
        """
        :param str application_host_url: The location of the SAPOData resource.
        :param str application_service_path: The application path to catalog service.
        :param str client_number: The client number for the client creating the connection.
        :param int port_number: The port number of the SAPOData instance.
        :param str logon_language: The logon language of SAPOData instance.
        :param 'ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthPropertiesArgs' oauth_properties: The SAPOData OAuth properties required for OAuth type authentication.
        :param str private_link_service_name: The SAPOData Private Link service name to be used for private data transfers.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_host_url=application_host_url,
            application_service_path=application_service_path,
            client_number=client_number,
            port_number=port_number,
            logon_language=logon_language,
            oauth_properties=oauth_properties,
            private_link_service_name=private_link_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_host_url: Optional[str] = None,
             application_service_path: Optional[str] = None,
             client_number: Optional[str] = None,
             port_number: Optional[int] = None,
             logon_language: Optional[str] = None,
             oauth_properties: Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties'] = None,
             private_link_service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_host_url is None and 'applicationHostUrl' in kwargs:
            application_host_url = kwargs['applicationHostUrl']
        if application_host_url is None:
            raise TypeError("Missing 'application_host_url' argument")
        if application_service_path is None and 'applicationServicePath' in kwargs:
            application_service_path = kwargs['applicationServicePath']
        if application_service_path is None:
            raise TypeError("Missing 'application_service_path' argument")
        if client_number is None and 'clientNumber' in kwargs:
            client_number = kwargs['clientNumber']
        if client_number is None:
            raise TypeError("Missing 'client_number' argument")
        if port_number is None and 'portNumber' in kwargs:
            port_number = kwargs['portNumber']
        if port_number is None:
            raise TypeError("Missing 'port_number' argument")
        if logon_language is None and 'logonLanguage' in kwargs:
            logon_language = kwargs['logonLanguage']
        if oauth_properties is None and 'oauthProperties' in kwargs:
            oauth_properties = kwargs['oauthProperties']
        if private_link_service_name is None and 'privateLinkServiceName' in kwargs:
            private_link_service_name = kwargs['privateLinkServiceName']

        _setter("application_host_url", application_host_url)
        _setter("application_service_path", application_service_path)
        _setter("client_number", client_number)
        _setter("port_number", port_number)
        if logon_language is not None:
            _setter("logon_language", logon_language)
        if oauth_properties is not None:
            _setter("oauth_properties", oauth_properties)
        if private_link_service_name is not None:
            _setter("private_link_service_name", private_link_service_name)

    @property
    @pulumi.getter(name="applicationHostUrl")
    def application_host_url(self) -> str:
        """
        The location of the SAPOData resource.
        """
        return pulumi.get(self, "application_host_url")

    @property
    @pulumi.getter(name="applicationServicePath")
    def application_service_path(self) -> str:
        """
        The application path to catalog service.
        """
        return pulumi.get(self, "application_service_path")

    @property
    @pulumi.getter(name="clientNumber")
    def client_number(self) -> str:
        """
        The client number for the client creating the connection.
        """
        return pulumi.get(self, "client_number")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> int:
        """
        The port number of the SAPOData instance.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="logonLanguage")
    def logon_language(self) -> Optional[str]:
        """
        The logon language of SAPOData instance.
        """
        return pulumi.get(self, "logon_language")

    @property
    @pulumi.getter(name="oauthProperties")
    def oauth_properties(self) -> Optional['outputs.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties']:
        """
        The SAPOData OAuth properties required for OAuth type authentication.
        """
        return pulumi.get(self, "oauth_properties")

    @property
    @pulumi.getter(name="privateLinkServiceName")
    def private_link_service_name(self) -> Optional[str]:
        """
        The SAPOData Private Link service name to be used for private data transfers.
        """
        return pulumi.get(self, "private_link_service_name")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCodeUrl":
            suggest = "auth_code_url"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code_url: str,
                 oauth_scopes: Sequence[str],
                 token_url: str):
        """
        :param str auth_code_url: The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        :param Sequence[str] oauth_scopes: The OAuth scopes required for OAuth type authentication.
        :param str token_url: The token URL required for OAuth 2.0 authentication.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_code_url=auth_code_url,
            oauth_scopes=oauth_scopes,
            token_url=token_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_code_url: Optional[str] = None,
             oauth_scopes: Optional[Sequence[str]] = None,
             token_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_code_url is None and 'authCodeUrl' in kwargs:
            auth_code_url = kwargs['authCodeUrl']
        if auth_code_url is None:
            raise TypeError("Missing 'auth_code_url' argument")
        if oauth_scopes is None and 'oauthScopes' in kwargs:
            oauth_scopes = kwargs['oauthScopes']
        if oauth_scopes is None:
            raise TypeError("Missing 'oauth_scopes' argument")
        if token_url is None and 'tokenUrl' in kwargs:
            token_url = kwargs['tokenUrl']
        if token_url is None:
            raise TypeError("Missing 'token_url' argument")

        _setter("auth_code_url", auth_code_url)
        _setter("oauth_scopes", oauth_scopes)
        _setter("token_url", token_url)

    @property
    @pulumi.getter(name="authCodeUrl")
    def auth_code_url(self) -> str:
        """
        The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        """
        return pulumi.get(self, "auth_code_url")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        The OAuth scopes required for OAuth type authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        The token URL required for OAuth 2.0 authentication.
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "privateLinkServiceName":
            suggest = "private_link_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 stage: str,
                 warehouse: str,
                 account_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 private_link_service_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket_name: A name for the associated Amazon S3 bucket.
        :param str stage: Name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: `<Database>.<Schema>.<Stage Name>`.
        :param str warehouse: The name of the Snowflake warehouse.
        :param str account_name: The name of the account.
        :param str bucket_prefix: The object key for the destination bucket in which Amazon AppFlow places the files.
        :param str private_link_service_name: The SAPOData Private Link service name to be used for private data transfers.
        :param str region: AWS Region of the Snowflake account.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            stage=stage,
            warehouse=warehouse,
            account_name=account_name,
            bucket_prefix=bucket_prefix,
            private_link_service_name=private_link_service_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             stage: Optional[str] = None,
             warehouse: Optional[str] = None,
             account_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             private_link_service_name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if warehouse is None:
            raise TypeError("Missing 'warehouse' argument")
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if private_link_service_name is None and 'privateLinkServiceName' in kwargs:
            private_link_service_name = kwargs['privateLinkServiceName']

        _setter("bucket_name", bucket_name)
        _setter("stage", stage)
        _setter("warehouse", warehouse)
        if account_name is not None:
            _setter("account_name", account_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if private_link_service_name is not None:
            _setter("private_link_service_name", private_link_service_name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        A name for the associated Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: `<Database>.<Schema>.<Stage Name>`.
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The name of the Snowflake warehouse.
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        The name of the account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        The object key for the destination bucket in which Amazon AppFlow places the files.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="privateLinkServiceName")
    def private_link_service_name(self) -> Optional[str]:
        """
        The SAPOData Private Link service name to be used for private data transfers.
        """
        return pulumi.get(self, "private_link_service_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        AWS Region of the Snowflake account.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceUrl":
            suggest = "instance_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_url: str):
        """
        :param str instance_url: The location of the Datadog resource.
        """
        ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_url=instance_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_url is None and 'instanceUrl' in kwargs:
            instance_url = kwargs['instanceUrl']
        if instance_url is None:
            raise TypeError("Missing 'instance_url' argument")

        _setter("instance_url", instance_url)

    @property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> str:
        """
        The location of the Datadog resource.
        """
        return pulumi.get(self, "instance_url")


@pulumi.output_type
class FlowDestinationFlowConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorType":
            suggest = "connector_type"
        elif key == "destinationConnectorProperties":
            suggest = "destination_connector_properties"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "connectorProfileName":
            suggest = "connector_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_type: str,
                 destination_connector_properties: 'outputs.FlowDestinationFlowConfigDestinationConnectorProperties',
                 api_version: Optional[str] = None,
                 connector_profile_name: Optional[str] = None):
        """
        :param str connector_type: Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesArgs' destination_connector_properties: This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
        :param str api_version: API version that the destination connector uses.
        :param str connector_profile_name: Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        FlowDestinationFlowConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connector_type=connector_type,
            destination_connector_properties=destination_connector_properties,
            api_version=api_version,
            connector_profile_name=connector_profile_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connector_type: Optional[str] = None,
             destination_connector_properties: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorProperties'] = None,
             api_version: Optional[str] = None,
             connector_profile_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connector_type is None and 'connectorType' in kwargs:
            connector_type = kwargs['connectorType']
        if connector_type is None:
            raise TypeError("Missing 'connector_type' argument")
        if destination_connector_properties is None and 'destinationConnectorProperties' in kwargs:
            destination_connector_properties = kwargs['destinationConnectorProperties']
        if destination_connector_properties is None:
            raise TypeError("Missing 'destination_connector_properties' argument")
        if api_version is None and 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if connector_profile_name is None and 'connectorProfileName' in kwargs:
            connector_profile_name = kwargs['connectorProfileName']

        _setter("connector_type", connector_type)
        _setter("destination_connector_properties", destination_connector_properties)
        if api_version is not None:
            _setter("api_version", api_version)
        if connector_profile_name is not None:
            _setter("connector_profile_name", connector_profile_name)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="destinationConnectorProperties")
    def destination_connector_properties(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorProperties':
        """
        This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
        """
        return pulumi.get(self, "destination_connector_properties")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version that the destination connector uses.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[str]:
        """
        Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        return pulumi.get(self, "connector_profile_name")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "customerProfiles":
            suggest = "customer_profiles"
        elif key == "eventBridge":
            suggest = "event_bridge"
        elif key == "lookoutMetrics":
            suggest = "lookout_metrics"
        elif key == "sapoData":
            suggest = "sapo_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_connector: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector'] = None,
                 customer_profiles: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles'] = None,
                 event_bridge: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge'] = None,
                 honeycode: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode'] = None,
                 lookout_metrics: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics'] = None,
                 marketo: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo'] = None,
                 redshift: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift'] = None,
                 s3: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3'] = None,
                 salesforce: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData'] = None,
                 snowflake: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake'] = None,
                 upsolver: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver'] = None,
                 zendesk: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk'] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorArgs' custom_connector: Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfilesArgs' customer_profiles: Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeArgs' event_bridge: Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeArgs' honeycode: Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoArgs' marketo: Properties that are required to query Marketo. See Generic Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftArgs' redshift: Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3Args' s3: Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceArgs' salesforce: Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataArgs' sapo_data: Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeArgs' snowflake: Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverArgs' upsolver: Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskArgs' zendesk: Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_connector=custom_connector,
            customer_profiles=customer_profiles,
            event_bridge=event_bridge,
            honeycode=honeycode,
            lookout_metrics=lookout_metrics,
            marketo=marketo,
            redshift=redshift,
            s3=s3,
            salesforce=salesforce,
            sapo_data=sapo_data,
            snowflake=snowflake,
            upsolver=upsolver,
            zendesk=zendesk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_connector: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector'] = None,
             customer_profiles: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles'] = None,
             event_bridge: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge'] = None,
             honeycode: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode'] = None,
             lookout_metrics: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics'] = None,
             marketo: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo'] = None,
             redshift: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift'] = None,
             s3: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3'] = None,
             salesforce: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce'] = None,
             sapo_data: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData'] = None,
             snowflake: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake'] = None,
             upsolver: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver'] = None,
             zendesk: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_connector is None and 'customConnector' in kwargs:
            custom_connector = kwargs['customConnector']
        if customer_profiles is None and 'customerProfiles' in kwargs:
            customer_profiles = kwargs['customerProfiles']
        if event_bridge is None and 'eventBridge' in kwargs:
            event_bridge = kwargs['eventBridge']
        if lookout_metrics is None and 'lookoutMetrics' in kwargs:
            lookout_metrics = kwargs['lookoutMetrics']
        if sapo_data is None and 'sapoData' in kwargs:
            sapo_data = kwargs['sapoData']

        if custom_connector is not None:
            _setter("custom_connector", custom_connector)
        if customer_profiles is not None:
            _setter("customer_profiles", customer_profiles)
        if event_bridge is not None:
            _setter("event_bridge", event_bridge)
        if honeycode is not None:
            _setter("honeycode", honeycode)
        if lookout_metrics is not None:
            _setter("lookout_metrics", lookout_metrics)
        if marketo is not None:
            _setter("marketo", marketo)
        if redshift is not None:
            _setter("redshift", redshift)
        if s3 is not None:
            _setter("s3", s3)
        if salesforce is not None:
            _setter("salesforce", salesforce)
        if sapo_data is not None:
            _setter("sapo_data", sapo_data)
        if snowflake is not None:
            _setter("snowflake", snowflake)
        if upsolver is not None:
            _setter("upsolver", upsolver)
        if zendesk is not None:
            _setter("zendesk", zendesk)

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector']:
        """
        Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter(name="customerProfiles")
    def customer_profiles(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles']:
        """
        Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
        """
        return pulumi.get(self, "customer_profiles")

    @property
    @pulumi.getter(name="eventBridge")
    def event_bridge(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge']:
        """
        Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
        """
        return pulumi.get(self, "event_bridge")

    @property
    @pulumi.getter
    def honeycode(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode']:
        """
        Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
        """
        return pulumi.get(self, "honeycode")

    @property
    @pulumi.getter(name="lookoutMetrics")
    def lookout_metrics(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics']:
        return pulumi.get(self, "lookout_metrics")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo']:
        """
        Properties that are required to query Marketo. See Generic Destination Properties for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift']:
        """
        Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3']:
        """
        Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce']:
        """
        Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData']:
        """
        Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake']:
        """
        Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def upsolver(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver']:
        """
        Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
        """
        return pulumi.get(self, "upsolver")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk']:
        """
        Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "customProperties":
            suggest = "custom_properties"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: str,
                 custom_properties: Optional[Mapping[str, str]] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str entity_name: Entity specified in the custom connector as a destination in the flow.
        :param Mapping[str, str] custom_properties: Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        :param str write_operation_type: Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_name=entity_name,
            custom_properties=custom_properties,
            error_handling_config=error_handling_config,
            id_field_names=id_field_names,
            write_operation_type=write_operation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_name: Optional[str] = None,
             custom_properties: Optional[Mapping[str, str]] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig'] = None,
             id_field_names: Optional[Sequence[str]] = None,
             write_operation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_name is None and 'entityName' in kwargs:
            entity_name = kwargs['entityName']
        if entity_name is None:
            raise TypeError("Missing 'entity_name' argument")
        if custom_properties is None and 'customProperties' in kwargs:
            custom_properties = kwargs['customProperties']
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']
        if id_field_names is None and 'idFieldNames' in kwargs:
            id_field_names = kwargs['idFieldNames']
        if write_operation_type is None and 'writeOperationType' in kwargs:
            write_operation_type = kwargs['writeOperationType']

        _setter("entity_name", entity_name)
        if custom_properties is not None:
            _setter("custom_properties", custom_properties)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)
        if id_field_names is not None:
            _setter("id_field_names", id_field_names)
        if write_operation_type is not None:
            _setter("write_operation_type", write_operation_type)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> str:
        """
        Entity specified in the custom connector as a destination in the flow.
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
        """
        return pulumi.get(self, "custom_properties")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "objectTypeName":
            suggest = "object_type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 object_type_name: Optional[str] = None):
        """
        :param str domain_name: Unique name of the Amazon Connect Customer Profiles domain.
        :param str object_type_name: Object specified in the Amazon Connect Customer Profiles flow destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            object_type_name=object_type_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[str] = None,
             object_type_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if object_type_name is None and 'objectTypeName' in kwargs:
            object_type_name = kwargs['objectTypeName']

        _setter("domain_name", domain_name)
        if object_type_name is not None:
            _setter("object_type_name", object_type_name)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        Unique name of the Amazon Connect Customer Profiles domain.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="objectTypeName")
    def object_type_name(self) -> Optional[str]:
        """
        Object specified in the Amazon Connect Customer Profiles flow destination.
        """
        return pulumi.get(self, "object_type_name")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            error_handling_config=error_handling_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']

        _setter("object", object)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            error_handling_config=error_handling_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']

        _setter("object", object)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig'] = None):
        """
        :param str object: Object specified in the flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            error_handling_config=error_handling_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']

        _setter("object", object)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateBucketName":
            suggest = "intermediate_bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_bucket_name: str,
                 object: str,
                 bucket_prefix: Optional[str] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig'] = None):
        """
        :param str intermediate_bucket_name: Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        :param str object: Object specified in the flow destination.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            intermediate_bucket_name=intermediate_bucket_name,
            object=object,
            bucket_prefix=bucket_prefix,
            error_handling_config=error_handling_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             intermediate_bucket_name: Optional[str] = None,
             object: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if intermediate_bucket_name is None and 'intermediateBucketName' in kwargs:
            intermediate_bucket_name = kwargs['intermediateBucketName']
        if intermediate_bucket_name is None:
            raise TypeError("Missing 'intermediate_bucket_name' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']

        _setter("intermediate_bucket_name", intermediate_bucket_name)
        _setter("object", object)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)

    @property
    @pulumi.getter(name="intermediateBucketName")
    def intermediate_bucket_name(self) -> str:
        """
        Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        """
        return pulumi.get(self, "intermediate_bucket_name")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "s3OutputFormatConfig":
            suggest = "s3_output_format_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_prefix: Optional[str] = None,
                 s3_output_format_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig'] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigArgs' s3_output_format_config: Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            s3_output_format_config=s3_output_format_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             s3_output_format_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if s3_output_format_config is None and 's3OutputFormatConfig' in kwargs:
            s3_output_format_config = kwargs['s3OutputFormatConfig']

        _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if s3_output_format_config is not None:
            _setter("s3_output_format_config", s3_output_format_config)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="s3OutputFormatConfig")
    def s3_output_format_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig']:
        """
        Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
        """
        return pulumi.get(self, "s3_output_format_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationConfig":
            suggest = "aggregation_config"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "prefixConfig":
            suggest = "prefix_config"
        elif key == "preserveSourceDataTyping":
            suggest = "preserve_source_data_typing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig'] = None,
                 file_type: Optional[str] = None,
                 prefix_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig'] = None,
                 preserve_source_data_typing: Optional[bool] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfigArgs' aggregation_config: Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        :param str file_type: File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfigArgs' prefix_config: Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        :param bool preserve_source_data_typing: Whether the data types from the source system need to be preserved (Only valid for `Parquet` file type)
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_config=aggregation_config,
            file_type=file_type,
            prefix_config=prefix_config,
            preserve_source_data_typing=preserve_source_data_typing,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig'] = None,
             file_type: Optional[str] = None,
             prefix_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig'] = None,
             preserve_source_data_typing: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregation_config is None and 'aggregationConfig' in kwargs:
            aggregation_config = kwargs['aggregationConfig']
        if file_type is None and 'fileType' in kwargs:
            file_type = kwargs['fileType']
        if prefix_config is None and 'prefixConfig' in kwargs:
            prefix_config = kwargs['prefixConfig']
        if preserve_source_data_typing is None and 'preserveSourceDataTyping' in kwargs:
            preserve_source_data_typing = kwargs['preserveSourceDataTyping']

        if aggregation_config is not None:
            _setter("aggregation_config", aggregation_config)
        if file_type is not None:
            _setter("file_type", file_type)
        if prefix_config is not None:
            _setter("prefix_config", prefix_config)
        if preserve_source_data_typing is not None:
            _setter("preserve_source_data_typing", preserve_source_data_typing)

    @property
    @pulumi.getter(name="aggregationConfig")
    def aggregation_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig']:
        """
        Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        """
        return pulumi.get(self, "aggregation_config")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter(name="prefixConfig")
    def prefix_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig']:
        """
        Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        """
        return pulumi.get(self, "prefix_config")

    @property
    @pulumi.getter(name="preserveSourceDataTyping")
    def preserve_source_data_typing(self) -> Optional[bool]:
        """
        Whether the data types from the source system need to be preserved (Only valid for `Parquet` file type)
        """
        return pulumi.get(self, "preserve_source_data_typing")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[str] = None):
        """
        :param str aggregation_type: Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_type=aggregation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregation_type is None and 'aggregationType' in kwargs:
            aggregation_type = kwargs['aggregationType']

        if aggregation_type is not None:
            _setter("aggregation_type", aggregation_type)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        """
        Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        return pulumi.get(self, "aggregation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixFormat":
            suggest = "prefix_format"
        elif key == "prefixType":
            suggest = "prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_format: Optional[str] = None,
                 prefix_type: Optional[str] = None):
        """
        :param str prefix_format: Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        :param str prefix_type: Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix_format=prefix_format,
            prefix_type=prefix_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix_format: Optional[str] = None,
             prefix_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prefix_format is None and 'prefixFormat' in kwargs:
            prefix_format = kwargs['prefixFormat']
        if prefix_type is None and 'prefixType' in kwargs:
            prefix_type = kwargs['prefixType']

        if prefix_format is not None:
            _setter("prefix_format", prefix_format)
        if prefix_type is not None:
            _setter("prefix_type", prefix_type)

    @property
    @pulumi.getter(name="prefixFormat")
    def prefix_format(self) -> Optional[str]:
        """
        Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        return pulumi.get(self, "prefix_format")

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[str]:
        """
        Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        return pulumi.get(self, "prefix_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object: Object specified in the flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        :param str write_operation_type: Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            error_handling_config=error_handling_config,
            id_field_names=id_field_names,
            write_operation_type=write_operation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig'] = None,
             id_field_names: Optional[Sequence[str]] = None,
             write_operation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']
        if id_field_names is None and 'idFieldNames' in kwargs:
            id_field_names = kwargs['idFieldNames']
        if write_operation_type is None and 'writeOperationType' in kwargs:
            write_operation_type = kwargs['writeOperationType']

        _setter("object", object)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)
        if id_field_names is not None:
            _setter("id_field_names", id_field_names)
        if write_operation_type is not None:
            _setter("write_operation_type", write_operation_type)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectPath":
            suggest = "object_path"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "successResponseHandlingConfig":
            suggest = "success_response_handling_config"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_path: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 success_response_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig'] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object_path: Object path specified in the SAPOData flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfigArgs' success_response_handling_config: Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
        :param str write_operation_type: Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_path=object_path,
            error_handling_config=error_handling_config,
            id_field_names=id_field_names,
            success_response_handling_config=success_response_handling_config,
            write_operation_type=write_operation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_path: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig'] = None,
             id_field_names: Optional[Sequence[str]] = None,
             success_response_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig'] = None,
             write_operation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object_path is None and 'objectPath' in kwargs:
            object_path = kwargs['objectPath']
        if object_path is None:
            raise TypeError("Missing 'object_path' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']
        if id_field_names is None and 'idFieldNames' in kwargs:
            id_field_names = kwargs['idFieldNames']
        if success_response_handling_config is None and 'successResponseHandlingConfig' in kwargs:
            success_response_handling_config = kwargs['successResponseHandlingConfig']
        if write_operation_type is None and 'writeOperationType' in kwargs:
            write_operation_type = kwargs['writeOperationType']

        _setter("object_path", object_path)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)
        if id_field_names is not None:
            _setter("id_field_names", id_field_names)
        if success_response_handling_config is not None:
            _setter("success_response_handling_config", success_response_handling_config)
        if write_operation_type is not None:
            _setter("write_operation_type", write_operation_type)

    @property
    @pulumi.getter(name="objectPath")
    def object_path(self) -> str:
        """
        Object path specified in the SAPOData flow destination.
        """
        return pulumi.get(self, "object_path")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="successResponseHandlingConfig")
    def success_response_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig']:
        """
        Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
        """
        return pulumi.get(self, "success_response_handling_config")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateBucketName":
            suggest = "intermediate_bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "errorHandlingConfig":
            suggest = "error_handling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_bucket_name: str,
                 object: str,
                 bucket_prefix: Optional[str] = None,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig'] = None):
        """
        :param str intermediate_bucket_name: Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        :param str object: Object specified in the flow destination.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            intermediate_bucket_name=intermediate_bucket_name,
            object=object,
            bucket_prefix=bucket_prefix,
            error_handling_config=error_handling_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             intermediate_bucket_name: Optional[str] = None,
             object: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if intermediate_bucket_name is None and 'intermediateBucketName' in kwargs:
            intermediate_bucket_name = kwargs['intermediateBucketName']
        if intermediate_bucket_name is None:
            raise TypeError("Missing 'intermediate_bucket_name' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']

        _setter("intermediate_bucket_name", intermediate_bucket_name)
        _setter("object", object)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)

    @property
    @pulumi.getter(name="intermediateBucketName")
    def intermediate_bucket_name(self) -> str:
        """
        Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        """
        return pulumi.get(self, "intermediate_bucket_name")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "s3OutputFormatConfig":
            suggest = "s3_output_format_config"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 s3_output_format_config: 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig',
                 bucket_prefix: Optional[str] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigArgs' s3_output_format_config: Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            s3_output_format_config=s3_output_format_config,
            bucket_prefix=bucket_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             s3_output_format_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig'] = None,
             bucket_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if s3_output_format_config is None and 's3OutputFormatConfig' in kwargs:
            s3_output_format_config = kwargs['s3OutputFormatConfig']
        if s3_output_format_config is None:
            raise TypeError("Missing 's3_output_format_config' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']

        _setter("bucket_name", bucket_name)
        _setter("s3_output_format_config", s3_output_format_config)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="s3OutputFormatConfig")
    def s3_output_format_config(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig':
        """
        Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
        """
        return pulumi.get(self, "s3_output_format_config")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixConfig":
            suggest = "prefix_config"
        elif key == "aggregationConfig":
            suggest = "aggregation_config"
        elif key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_config: 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig',
                 aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig'] = None,
                 file_type: Optional[str] = None):
        """
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfigArgs' prefix_config: Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfigArgs' aggregation_config: Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        :param str file_type: File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix_config=prefix_config,
            aggregation_config=aggregation_config,
            file_type=file_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig'] = None,
             aggregation_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig'] = None,
             file_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prefix_config is None and 'prefixConfig' in kwargs:
            prefix_config = kwargs['prefixConfig']
        if prefix_config is None:
            raise TypeError("Missing 'prefix_config' argument")
        if aggregation_config is None and 'aggregationConfig' in kwargs:
            aggregation_config = kwargs['aggregationConfig']
        if file_type is None and 'fileType' in kwargs:
            file_type = kwargs['fileType']

        _setter("prefix_config", prefix_config)
        if aggregation_config is not None:
            _setter("aggregation_config", aggregation_config)
        if file_type is not None:
            _setter("file_type", file_type)

    @property
    @pulumi.getter(name="prefixConfig")
    def prefix_config(self) -> 'outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig':
        """
        Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
        """
        return pulumi.get(self, "prefix_config")

    @property
    @pulumi.getter(name="aggregationConfig")
    def aggregation_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig']:
        """
        Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
        """
        return pulumi.get(self, "aggregation_config")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[str] = None):
        """
        :param str aggregation_type: Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_type=aggregation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregation_type is None and 'aggregationType' in kwargs:
            aggregation_type = kwargs['aggregationType']

        if aggregation_type is not None:
            _setter("aggregation_type", aggregation_type)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        """
        Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
        """
        return pulumi.get(self, "aggregation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixType":
            suggest = "prefix_type"
        elif key == "prefixFormat":
            suggest = "prefix_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_type: str,
                 prefix_format: Optional[str] = None):
        """
        :param str prefix_type: Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        :param str prefix_format: Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix_type=prefix_type,
            prefix_format=prefix_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix_type: Optional[str] = None,
             prefix_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prefix_type is None and 'prefixType' in kwargs:
            prefix_type = kwargs['prefixType']
        if prefix_type is None:
            raise TypeError("Missing 'prefix_type' argument")
        if prefix_format is None and 'prefixFormat' in kwargs:
            prefix_format = kwargs['prefixFormat']

        _setter("prefix_type", prefix_type)
        if prefix_format is not None:
            _setter("prefix_format", prefix_format)

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> str:
        """
        Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
        """
        return pulumi.get(self, "prefix_type")

    @property
    @pulumi.getter(name="prefixFormat")
    def prefix_format(self) -> Optional[str]:
        """
        Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
        """
        return pulumi.get(self, "prefix_format")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorHandlingConfig":
            suggest = "error_handling_config"
        elif key == "idFieldNames":
            suggest = "id_field_names"
        elif key == "writeOperationType":
            suggest = "write_operation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig'] = None,
                 id_field_names: Optional[Sequence[str]] = None,
                 write_operation_type: Optional[str] = None):
        """
        :param str object: Object specified in the flow destination.
        :param 'FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfigArgs' error_handling_config: Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        :param Sequence[str] id_field_names: Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        :param str write_operation_type: Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            error_handling_config=error_handling_config,
            id_field_names=id_field_names,
            write_operation_type=write_operation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             error_handling_config: Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig'] = None,
             id_field_names: Optional[Sequence[str]] = None,
             write_operation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if error_handling_config is None and 'errorHandlingConfig' in kwargs:
            error_handling_config = kwargs['errorHandlingConfig']
        if id_field_names is None and 'idFieldNames' in kwargs:
            id_field_names = kwargs['idFieldNames']
        if write_operation_type is None and 'writeOperationType' in kwargs:
            write_operation_type = kwargs['writeOperationType']

        _setter("object", object)
        if error_handling_config is not None:
            _setter("error_handling_config", error_handling_config)
        if id_field_names is not None:
            _setter("id_field_names", id_field_names)
        if write_operation_type is not None:
            _setter("write_operation_type", write_operation_type)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="errorHandlingConfig")
    def error_handling_config(self) -> Optional['outputs.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig']:
        """
        Settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination. See Error Handling Config for more details.
        """
        return pulumi.get(self, "error_handling_config")

    @property
    @pulumi.getter(name="idFieldNames")
    def id_field_names(self) -> Optional[Sequence[str]]:
        """
        Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        """
        return pulumi.get(self, "id_field_names")

    @property
    @pulumi.getter(name="writeOperationType")
    def write_operation_type(self) -> Optional[str]:
        """
        Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
        """
        return pulumi.get(self, "write_operation_type")


@pulumi.output_type
class FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "failOnFirstDestinationError":
            suggest = "fail_on_first_destination_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 fail_on_first_destination_error: Optional[bool] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param bool fail_on_first_destination_error: If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            fail_on_first_destination_error=fail_on_first_destination_error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             fail_on_first_destination_error: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if fail_on_first_destination_error is None and 'failOnFirstDestinationError' in kwargs:
            fail_on_first_destination_error = kwargs['failOnFirstDestinationError']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if fail_on_first_destination_error is not None:
            _setter("fail_on_first_destination_error", fail_on_first_destination_error)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="failOnFirstDestinationError")
    def fail_on_first_destination_error(self) -> Optional[bool]:
        """
        If the flow should fail after the first instance of a failure when attempting to place data in the destination.
        """
        return pulumi.get(self, "fail_on_first_destination_error")


@pulumi.output_type
class FlowSourceFlowConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorType":
            suggest = "connector_type"
        elif key == "sourceConnectorProperties":
            suggest = "source_connector_properties"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "connectorProfileName":
            suggest = "connector_profile_name"
        elif key == "incrementalPullConfig":
            suggest = "incremental_pull_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_type: str,
                 source_connector_properties: 'outputs.FlowSourceFlowConfigSourceConnectorProperties',
                 api_version: Optional[str] = None,
                 connector_profile_name: Optional[str] = None,
                 incremental_pull_config: Optional['outputs.FlowSourceFlowConfigIncrementalPullConfig'] = None):
        """
        :param str connector_type: Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesArgs' source_connector_properties: Information that is required to query a particular source connector. See Source Connector Properties for details.
        :param str api_version: API version that the destination connector uses.
        :param str connector_profile_name: Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        :param 'FlowSourceFlowConfigIncrementalPullConfigArgs' incremental_pull_config: Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
        """
        FlowSourceFlowConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connector_type=connector_type,
            source_connector_properties=source_connector_properties,
            api_version=api_version,
            connector_profile_name=connector_profile_name,
            incremental_pull_config=incremental_pull_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connector_type: Optional[str] = None,
             source_connector_properties: Optional['outputs.FlowSourceFlowConfigSourceConnectorProperties'] = None,
             api_version: Optional[str] = None,
             connector_profile_name: Optional[str] = None,
             incremental_pull_config: Optional['outputs.FlowSourceFlowConfigIncrementalPullConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connector_type is None and 'connectorType' in kwargs:
            connector_type = kwargs['connectorType']
        if connector_type is None:
            raise TypeError("Missing 'connector_type' argument")
        if source_connector_properties is None and 'sourceConnectorProperties' in kwargs:
            source_connector_properties = kwargs['sourceConnectorProperties']
        if source_connector_properties is None:
            raise TypeError("Missing 'source_connector_properties' argument")
        if api_version is None and 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if connector_profile_name is None and 'connectorProfileName' in kwargs:
            connector_profile_name = kwargs['connectorProfileName']
        if incremental_pull_config is None and 'incrementalPullConfig' in kwargs:
            incremental_pull_config = kwargs['incrementalPullConfig']

        _setter("connector_type", connector_type)
        _setter("source_connector_properties", source_connector_properties)
        if api_version is not None:
            _setter("api_version", api_version)
        if connector_profile_name is not None:
            _setter("connector_profile_name", connector_profile_name)
        if incremental_pull_config is not None:
            _setter("incremental_pull_config", incremental_pull_config)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="sourceConnectorProperties")
    def source_connector_properties(self) -> 'outputs.FlowSourceFlowConfigSourceConnectorProperties':
        """
        Information that is required to query a particular source connector. See Source Connector Properties for details.
        """
        return pulumi.get(self, "source_connector_properties")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version that the destination connector uses.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[str]:
        """
        Name of the connector profile. This name must be unique for each connector profile in the AWS account.
        """
        return pulumi.get(self, "connector_profile_name")

    @property
    @pulumi.getter(name="incrementalPullConfig")
    def incremental_pull_config(self) -> Optional['outputs.FlowSourceFlowConfigIncrementalPullConfig']:
        """
        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
        """
        return pulumi.get(self, "incremental_pull_config")


@pulumi.output_type
class FlowSourceFlowConfigIncrementalPullConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datetimeTypeFieldName":
            suggest = "datetime_type_field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigIncrementalPullConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigIncrementalPullConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigIncrementalPullConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datetime_type_field_name: Optional[str] = None):
        """
        :param str datetime_type_field_name: Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        FlowSourceFlowConfigIncrementalPullConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datetime_type_field_name=datetime_type_field_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datetime_type_field_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datetime_type_field_name is None and 'datetimeTypeFieldName' in kwargs:
            datetime_type_field_name = kwargs['datetimeTypeFieldName']

        if datetime_type_field_name is not None:
            _setter("datetime_type_field_name", datetime_type_field_name)

    @property
    @pulumi.getter(name="datetimeTypeFieldName")
    def datetime_type_field_name(self) -> Optional[str]:
        """
        Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        return pulumi.get(self, "datetime_type_field_name")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude'] = None,
                 custom_connector: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector'] = None,
                 datadog: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDatadog'] = None,
                 dynatrace: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace'] = None,
                 google_analytics: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics'] = None,
                 infor_nexus: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus'] = None,
                 marketo: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesMarketo'] = None,
                 s3: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3'] = None,
                 salesforce: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce'] = None,
                 sapo_data: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSapoData'] = None,
                 service_now: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow'] = None,
                 singular: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSingular'] = None,
                 slack: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSlack'] = None,
                 trendmicro: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro'] = None,
                 veeva: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesVeeva'] = None,
                 zendesk: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesZendesk'] = None):
        """
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesAmplitudeArgs' amplitude: Information that is required for querying Amplitude. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesCustomConnectorArgs' custom_connector: Properties that are applied when the custom connector is being used as a source. See Custom Connector Source Properties.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesDatadogArgs' datadog: Information that is required for querying Datadog. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesDynatraceArgs' dynatrace: Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalyticsArgs' google_analytics: Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesInforNexusArgs' infor_nexus: Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesMarketoArgs' marketo: Information that is required for querying Marketo. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesS3Args' s3: Information that is required for querying Amazon S3. See S3 Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSalesforceArgs' salesforce: Information that is required for querying Salesforce. See Salesforce Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSapoDataArgs' sapo_data: Information that is required for querying SAPOData as a flow source. See SAPO Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesServiceNowArgs' service_now: Information that is required for querying ServiceNow. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSingularArgs' singular: Information that is required for querying Singular. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesSlackArgs' slack: Information that is required for querying Slack. See Generic Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesTrendmicroArgs' trendmicro: Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesVeevaArgs' veeva: Information that is required for querying Veeva. See Veeva Source Properties for more details.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesZendeskArgs' zendesk: Information that is required for querying Zendesk. See Generic Source Properties for more details.
        """
        FlowSourceFlowConfigSourceConnectorProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amplitude=amplitude,
            custom_connector=custom_connector,
            datadog=datadog,
            dynatrace=dynatrace,
            google_analytics=google_analytics,
            infor_nexus=infor_nexus,
            marketo=marketo,
            s3=s3,
            salesforce=salesforce,
            sapo_data=sapo_data,
            service_now=service_now,
            singular=singular,
            slack=slack,
            trendmicro=trendmicro,
            veeva=veeva,
            zendesk=zendesk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amplitude: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude'] = None,
             custom_connector: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector'] = None,
             datadog: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDatadog'] = None,
             dynatrace: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace'] = None,
             google_analytics: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics'] = None,
             infor_nexus: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus'] = None,
             marketo: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesMarketo'] = None,
             s3: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3'] = None,
             salesforce: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce'] = None,
             sapo_data: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSapoData'] = None,
             service_now: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow'] = None,
             singular: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSingular'] = None,
             slack: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSlack'] = None,
             trendmicro: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro'] = None,
             veeva: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesVeeva'] = None,
             zendesk: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesZendesk'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_connector is None and 'customConnector' in kwargs:
            custom_connector = kwargs['customConnector']
        if google_analytics is None and 'googleAnalytics' in kwargs:
            google_analytics = kwargs['googleAnalytics']
        if infor_nexus is None and 'inforNexus' in kwargs:
            infor_nexus = kwargs['inforNexus']
        if sapo_data is None and 'sapoData' in kwargs:
            sapo_data = kwargs['sapoData']
        if service_now is None and 'serviceNow' in kwargs:
            service_now = kwargs['serviceNow']

        if amplitude is not None:
            _setter("amplitude", amplitude)
        if custom_connector is not None:
            _setter("custom_connector", custom_connector)
        if datadog is not None:
            _setter("datadog", datadog)
        if dynatrace is not None:
            _setter("dynatrace", dynatrace)
        if google_analytics is not None:
            _setter("google_analytics", google_analytics)
        if infor_nexus is not None:
            _setter("infor_nexus", infor_nexus)
        if marketo is not None:
            _setter("marketo", marketo)
        if s3 is not None:
            _setter("s3", s3)
        if salesforce is not None:
            _setter("salesforce", salesforce)
        if sapo_data is not None:
            _setter("sapo_data", sapo_data)
        if service_now is not None:
            _setter("service_now", service_now)
        if singular is not None:
            _setter("singular", singular)
        if slack is not None:
            _setter("slack", slack)
        if trendmicro is not None:
            _setter("trendmicro", trendmicro)
        if veeva is not None:
            _setter("veeva", veeva)
        if zendesk is not None:
            _setter("zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude']:
        """
        Information that is required for querying Amplitude. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector']:
        """
        Properties that are applied when the custom connector is being used as a source. See Custom Connector Source Properties.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDatadog']:
        """
        Information that is required for querying Datadog. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace']:
        """
        Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics']:
        """
        Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus']:
        """
        Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesMarketo']:
        """
        Information that is required for querying Marketo. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3']:
        """
        Information that is required for querying Amazon S3. See S3 Source Properties for more details.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce']:
        """
        Information that is required for querying Salesforce. See Salesforce Source Properties for more details.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSapoData']:
        """
        Information that is required for querying SAPOData as a flow source. See SAPO Source Properties for more details.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow']:
        """
        Information that is required for querying ServiceNow. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSingular']:
        """
        Information that is required for querying Singular. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesSlack']:
        """
        Information that is required for querying Slack. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro']:
        """
        Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesVeeva']:
        """
        Information that is required for querying Veeva. See Veeva Source Properties for more details.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesZendesk']:
        """
        Information that is required for querying Zendesk. See Generic Source Properties for more details.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesAmplitude(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesAmplitude._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "customProperties":
            suggest = "custom_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: str,
                 custom_properties: Optional[Mapping[str, str]] = None):
        """
        :param str entity_name: Entity specified in the custom connector as a destination in the flow.
        :param Mapping[str, str] custom_properties: Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_name=entity_name,
            custom_properties=custom_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_name: Optional[str] = None,
             custom_properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_name is None and 'entityName' in kwargs:
            entity_name = kwargs['entityName']
        if entity_name is None:
            raise TypeError("Missing 'entity_name' argument")
        if custom_properties is None and 'customProperties' in kwargs:
            custom_properties = kwargs['customProperties']

        _setter("entity_name", entity_name)
        if custom_properties is not None:
            _setter("custom_properties", custom_properties)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> str:
        """
        Entity specified in the custom connector as a destination in the flow.
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
        """
        return pulumi.get(self, "custom_properties")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesDatadog(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesDatadog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesDynatrace(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesDynatrace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesInforNexus(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesInforNexus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesMarketo(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesMarketo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "s3InputFormatConfig":
            suggest = "s3_input_format_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_prefix: Optional[str] = None,
                 s3_input_format_config: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig'] = None):
        """
        :param str bucket_name: Name of the Amazon S3 bucket.
        :param str bucket_prefix: Amazon S3 bucket prefix.
        :param 'FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfigArgs' s3_input_format_config: When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_prefix=bucket_prefix,
            s3_input_format_config=s3_input_format_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_prefix: Optional[str] = None,
             s3_input_format_config: Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if bucket_prefix is None and 'bucketPrefix' in kwargs:
            bucket_prefix = kwargs['bucketPrefix']
        if s3_input_format_config is None and 's3InputFormatConfig' in kwargs:
            s3_input_format_config = kwargs['s3InputFormatConfig']

        _setter("bucket_name", bucket_name)
        if bucket_prefix is not None:
            _setter("bucket_prefix", bucket_prefix)
        if s3_input_format_config is not None:
            _setter("s3_input_format_config", s3_input_format_config)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        Amazon S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter(name="s3InputFormatConfig")
    def s3_input_format_config(self) -> Optional['outputs.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig']:
        """
        When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
        """
        return pulumi.get(self, "s3_input_format_config")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3InputFileType":
            suggest = "s3_input_file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_input_file_type: Optional[str] = None):
        """
        :param str s3_input_file_type: File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_input_file_type=s3_input_file_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_input_file_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3_input_file_type is None and 's3InputFileType' in kwargs:
            s3_input_file_type = kwargs['s3InputFileType']

        if s3_input_file_type is not None:
            _setter("s3_input_file_type", s3_input_file_type)

    @property
    @pulumi.getter(name="s3InputFileType")
    def s3_input_file_type(self) -> Optional[str]:
        """
        File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
        """
        return pulumi.get(self, "s3_input_file_type")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDynamicFieldUpdate":
            suggest = "enable_dynamic_field_update"
        elif key == "includeDeletedRecords":
            suggest = "include_deleted_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 enable_dynamic_field_update: Optional[bool] = None,
                 include_deleted_records: Optional[bool] = None):
        """
        :param str object: Object specified in the flow destination.
        :param bool enable_dynamic_field_update: Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        :param bool include_deleted_records: Whether Amazon AppFlow includes deleted files in the flow run.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesSalesforce._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            enable_dynamic_field_update=enable_dynamic_field_update,
            include_deleted_records=include_deleted_records,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             enable_dynamic_field_update: Optional[bool] = None,
             include_deleted_records: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if enable_dynamic_field_update is None and 'enableDynamicFieldUpdate' in kwargs:
            enable_dynamic_field_update = kwargs['enableDynamicFieldUpdate']
        if include_deleted_records is None and 'includeDeletedRecords' in kwargs:
            include_deleted_records = kwargs['includeDeletedRecords']

        _setter("object", object)
        if enable_dynamic_field_update is not None:
            _setter("enable_dynamic_field_update", enable_dynamic_field_update)
        if include_deleted_records is not None:
            _setter("include_deleted_records", include_deleted_records)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="enableDynamicFieldUpdate")
    def enable_dynamic_field_update(self) -> Optional[bool]:
        """
        Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        """
        return pulumi.get(self, "enable_dynamic_field_update")

    @property
    @pulumi.getter(name="includeDeletedRecords")
    def include_deleted_records(self) -> Optional[bool]:
        """
        Whether Amazon AppFlow includes deleted files in the flow run.
        """
        return pulumi.get(self, "include_deleted_records")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSapoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectPath":
            suggest = "object_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesSapoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSapoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesSapoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_path: str):
        """
        :param str object_path: Object path specified in the SAPOData flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesSapoData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_path=object_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object_path is None and 'objectPath' in kwargs:
            object_path = kwargs['objectPath']
        if object_path is None:
            raise TypeError("Missing 'object_path' argument")

        _setter("object_path", object_path)

    @property
    @pulumi.getter(name="objectPath")
    def object_path(self) -> str:
        """
        Object path specified in the SAPOData flow destination.
        """
        return pulumi.get(self, "object_path")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesServiceNow(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesServiceNow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSingular(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesSingular._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesSlack(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesSlack._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesVeeva(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentType":
            suggest = "document_type"
        elif key == "includeAllVersions":
            suggest = "include_all_versions"
        elif key == "includeRenditions":
            suggest = "include_renditions"
        elif key == "includeSourceFiles":
            suggest = "include_source_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowSourceFlowConfigSourceConnectorPropertiesVeeva. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesVeeva.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowSourceFlowConfigSourceConnectorPropertiesVeeva.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 document_type: Optional[str] = None,
                 include_all_versions: Optional[bool] = None,
                 include_renditions: Optional[bool] = None,
                 include_source_files: Optional[bool] = None):
        """
        :param str object: Object specified in the flow destination.
        :param str document_type: Document type specified in the Veeva document extract flow.
        :param bool include_all_versions: Boolean value to include All Versions of files in Veeva document extract flow.
        :param bool include_renditions: Boolean value to include file renditions in Veeva document extract flow.
        :param bool include_source_files: Boolean value to include source files in Veeva document extract flow.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesVeeva._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            document_type=document_type,
            include_all_versions=include_all_versions,
            include_renditions=include_renditions,
            include_source_files=include_source_files,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             document_type: Optional[str] = None,
             include_all_versions: Optional[bool] = None,
             include_renditions: Optional[bool] = None,
             include_source_files: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if document_type is None and 'documentType' in kwargs:
            document_type = kwargs['documentType']
        if include_all_versions is None and 'includeAllVersions' in kwargs:
            include_all_versions = kwargs['includeAllVersions']
        if include_renditions is None and 'includeRenditions' in kwargs:
            include_renditions = kwargs['includeRenditions']
        if include_source_files is None and 'includeSourceFiles' in kwargs:
            include_source_files = kwargs['includeSourceFiles']

        _setter("object", object)
        if document_type is not None:
            _setter("document_type", document_type)
        if include_all_versions is not None:
            _setter("include_all_versions", include_all_versions)
        if include_renditions is not None:
            _setter("include_renditions", include_renditions)
        if include_source_files is not None:
            _setter("include_source_files", include_source_files)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="documentType")
    def document_type(self) -> Optional[str]:
        """
        Document type specified in the Veeva document extract flow.
        """
        return pulumi.get(self, "document_type")

    @property
    @pulumi.getter(name="includeAllVersions")
    def include_all_versions(self) -> Optional[bool]:
        """
        Boolean value to include All Versions of files in Veeva document extract flow.
        """
        return pulumi.get(self, "include_all_versions")

    @property
    @pulumi.getter(name="includeRenditions")
    def include_renditions(self) -> Optional[bool]:
        """
        Boolean value to include file renditions in Veeva document extract flow.
        """
        return pulumi.get(self, "include_renditions")

    @property
    @pulumi.getter(name="includeSourceFiles")
    def include_source_files(self) -> Optional[bool]:
        """
        Boolean value to include source files in Veeva document extract flow.
        """
        return pulumi.get(self, "include_source_files")


@pulumi.output_type
class FlowSourceFlowConfigSourceConnectorPropertiesZendesk(dict):
    def __init__(__self__, *,
                 object: str):
        """
        :param str object: Object specified in the flow destination.
        """
        FlowSourceFlowConfigSourceConnectorPropertiesZendesk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")

        _setter("object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Object specified in the flow destination.
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class FlowTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceFields":
            suggest = "source_fields"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "connectorOperators":
            suggest = "connector_operators"
        elif key == "destinationField":
            suggest = "destination_field"
        elif key == "taskProperties":
            suggest = "task_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_fields: Sequence[str],
                 task_type: str,
                 connector_operators: Optional[Sequence['outputs.FlowTaskConnectorOperator']] = None,
                 destination_field: Optional[str] = None,
                 task_properties: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] source_fields: Source fields to which a particular task is applied.
        :param str task_type: Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
        :param Sequence['FlowTaskConnectorOperatorArgs'] connector_operators: Operation to be performed on the provided source fields. See Connector Operator for details.
        :param str destination_field: Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        :param Mapping[str, str] task_properties: Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
        """
        FlowTask._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_fields=source_fields,
            task_type=task_type,
            connector_operators=connector_operators,
            destination_field=destination_field,
            task_properties=task_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_fields: Optional[Sequence[str]] = None,
             task_type: Optional[str] = None,
             connector_operators: Optional[Sequence['outputs.FlowTaskConnectorOperator']] = None,
             destination_field: Optional[str] = None,
             task_properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_fields is None and 'sourceFields' in kwargs:
            source_fields = kwargs['sourceFields']
        if source_fields is None:
            raise TypeError("Missing 'source_fields' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if connector_operators is None and 'connectorOperators' in kwargs:
            connector_operators = kwargs['connectorOperators']
        if destination_field is None and 'destinationField' in kwargs:
            destination_field = kwargs['destinationField']
        if task_properties is None and 'taskProperties' in kwargs:
            task_properties = kwargs['taskProperties']

        _setter("source_fields", source_fields)
        _setter("task_type", task_type)
        if connector_operators is not None:
            _setter("connector_operators", connector_operators)
        if destination_field is not None:
            _setter("destination_field", destination_field)
        if task_properties is not None:
            _setter("task_properties", task_properties)

    @property
    @pulumi.getter(name="sourceFields")
    def source_fields(self) -> Sequence[str]:
        """
        Source fields to which a particular task is applied.
        """
        return pulumi.get(self, "source_fields")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="connectorOperators")
    def connector_operators(self) -> Optional[Sequence['outputs.FlowTaskConnectorOperator']]:
        """
        Operation to be performed on the provided source fields. See Connector Operator for details.
        """
        return pulumi.get(self, "connector_operators")

    @property
    @pulumi.getter(name="destinationField")
    def destination_field(self) -> Optional[str]:
        """
        Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        """
        return pulumi.get(self, "destination_field")

    @property
    @pulumi.getter(name="taskProperties")
    def task_properties(self) -> Optional[Mapping[str, str]]:
        """
        Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
        """
        return pulumi.get(self, "task_properties")


@pulumi.output_type
class FlowTaskConnectorOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConnector":
            suggest = "custom_connector"
        elif key == "googleAnalytics":
            suggest = "google_analytics"
        elif key == "inforNexus":
            suggest = "infor_nexus"
        elif key == "sapoData":
            suggest = "sapo_data"
        elif key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTaskConnectorOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTaskConnectorOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTaskConnectorOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amplitude: Optional[str] = None,
                 custom_connector: Optional[str] = None,
                 datadog: Optional[str] = None,
                 dynatrace: Optional[str] = None,
                 google_analytics: Optional[str] = None,
                 infor_nexus: Optional[str] = None,
                 marketo: Optional[str] = None,
                 s3: Optional[str] = None,
                 salesforce: Optional[str] = None,
                 sapo_data: Optional[str] = None,
                 service_now: Optional[str] = None,
                 singular: Optional[str] = None,
                 slack: Optional[str] = None,
                 trendmicro: Optional[str] = None,
                 veeva: Optional[str] = None,
                 zendesk: Optional[str] = None):
        """
        :param str amplitude: Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        :param str custom_connector: Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str datadog: Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str dynatrace: Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str google_analytics: Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        :param str infor_nexus: Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str marketo: Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str s3: Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str salesforce: Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str sapo_data: Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str service_now: Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str singular: Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str slack: Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str trendmicro: Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str veeva: Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        :param str zendesk: Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        FlowTaskConnectorOperator._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amplitude=amplitude,
            custom_connector=custom_connector,
            datadog=datadog,
            dynatrace=dynatrace,
            google_analytics=google_analytics,
            infor_nexus=infor_nexus,
            marketo=marketo,
            s3=s3,
            salesforce=salesforce,
            sapo_data=sapo_data,
            service_now=service_now,
            singular=singular,
            slack=slack,
            trendmicro=trendmicro,
            veeva=veeva,
            zendesk=zendesk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amplitude: Optional[str] = None,
             custom_connector: Optional[str] = None,
             datadog: Optional[str] = None,
             dynatrace: Optional[str] = None,
             google_analytics: Optional[str] = None,
             infor_nexus: Optional[str] = None,
             marketo: Optional[str] = None,
             s3: Optional[str] = None,
             salesforce: Optional[str] = None,
             sapo_data: Optional[str] = None,
             service_now: Optional[str] = None,
             singular: Optional[str] = None,
             slack: Optional[str] = None,
             trendmicro: Optional[str] = None,
             veeva: Optional[str] = None,
             zendesk: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_connector is None and 'customConnector' in kwargs:
            custom_connector = kwargs['customConnector']
        if google_analytics is None and 'googleAnalytics' in kwargs:
            google_analytics = kwargs['googleAnalytics']
        if infor_nexus is None and 'inforNexus' in kwargs:
            infor_nexus = kwargs['inforNexus']
        if sapo_data is None and 'sapoData' in kwargs:
            sapo_data = kwargs['sapoData']
        if service_now is None and 'serviceNow' in kwargs:
            service_now = kwargs['serviceNow']

        if amplitude is not None:
            _setter("amplitude", amplitude)
        if custom_connector is not None:
            _setter("custom_connector", custom_connector)
        if datadog is not None:
            _setter("datadog", datadog)
        if dynatrace is not None:
            _setter("dynatrace", dynatrace)
        if google_analytics is not None:
            _setter("google_analytics", google_analytics)
        if infor_nexus is not None:
            _setter("infor_nexus", infor_nexus)
        if marketo is not None:
            _setter("marketo", marketo)
        if s3 is not None:
            _setter("s3", s3)
        if salesforce is not None:
            _setter("salesforce", salesforce)
        if sapo_data is not None:
            _setter("sapo_data", sapo_data)
        if service_now is not None:
            _setter("service_now", service_now)
        if singular is not None:
            _setter("singular", singular)
        if slack is not None:
            _setter("slack", slack)
        if trendmicro is not None:
            _setter("trendmicro", trendmicro)
        if veeva is not None:
            _setter("veeva", veeva)
        if zendesk is not None:
            _setter("zendesk", zendesk)

    @property
    @pulumi.getter
    def amplitude(self) -> Optional[str]:
        """
        Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
        """
        return pulumi.get(self, "amplitude")

    @property
    @pulumi.getter(name="customConnector")
    def custom_connector(self) -> Optional[str]:
        """
        Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "custom_connector")

    @property
    @pulumi.getter
    def datadog(self) -> Optional[str]:
        """
        Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "datadog")

    @property
    @pulumi.getter
    def dynatrace(self) -> Optional[str]:
        """
        Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "dynatrace")

    @property
    @pulumi.getter(name="googleAnalytics")
    def google_analytics(self) -> Optional[str]:
        """
        Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
        """
        return pulumi.get(self, "google_analytics")

    @property
    @pulumi.getter(name="inforNexus")
    def infor_nexus(self) -> Optional[str]:
        """
        Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "infor_nexus")

    @property
    @pulumi.getter
    def marketo(self) -> Optional[str]:
        """
        Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional[str]:
        """
        Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional[str]:
        """
        Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="sapoData")
    def sapo_data(self) -> Optional[str]:
        """
        Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "sapo_data")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[str]:
        """
        Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def singular(self) -> Optional[str]:
        """
        Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "singular")

    @property
    @pulumi.getter
    def slack(self) -> Optional[str]:
        """
        Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "slack")

    @property
    @pulumi.getter
    def trendmicro(self) -> Optional[str]:
        """
        Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "trendmicro")

    @property
    @pulumi.getter
    def veeva(self) -> Optional[str]:
        """
        Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "veeva")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional[str]:
        """
        Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
        """
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class FlowTriggerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "triggerProperties":
            suggest = "trigger_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: str,
                 trigger_properties: Optional['outputs.FlowTriggerConfigTriggerProperties'] = None):
        """
        :param str trigger_type: Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
        :param 'FlowTriggerConfigTriggerPropertiesArgs' trigger_properties: Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
        """
        FlowTriggerConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trigger_type=trigger_type,
            trigger_properties=trigger_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trigger_type: Optional[str] = None,
             trigger_properties: Optional['outputs.FlowTriggerConfigTriggerProperties'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if trigger_type is None and 'triggerType' in kwargs:
            trigger_type = kwargs['triggerType']
        if trigger_type is None:
            raise TypeError("Missing 'trigger_type' argument")
        if trigger_properties is None and 'triggerProperties' in kwargs:
            trigger_properties = kwargs['triggerProperties']

        _setter("trigger_type", trigger_type)
        if trigger_properties is not None:
            _setter("trigger_properties", trigger_properties)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> str:
        """
        Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="triggerProperties")
    def trigger_properties(self) -> Optional['outputs.FlowTriggerConfigTriggerProperties']:
        """
        Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
        """
        return pulumi.get(self, "trigger_properties")


@pulumi.output_type
class FlowTriggerConfigTriggerProperties(dict):
    def __init__(__self__, *,
                 scheduled: Optional['outputs.FlowTriggerConfigTriggerPropertiesScheduled'] = None):
        FlowTriggerConfigTriggerProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scheduled=scheduled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scheduled: Optional['outputs.FlowTriggerConfigTriggerPropertiesScheduled'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if scheduled is not None:
            _setter("scheduled", scheduled)

    @property
    @pulumi.getter
    def scheduled(self) -> Optional['outputs.FlowTriggerConfigTriggerPropertiesScheduled']:
        return pulumi.get(self, "scheduled")


@pulumi.output_type
class FlowTriggerConfigTriggerPropertiesScheduled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleExpression":
            suggest = "schedule_expression"
        elif key == "dataPullMode":
            suggest = "data_pull_mode"
        elif key == "firstExecutionFrom":
            suggest = "first_execution_from"
        elif key == "scheduleEndTime":
            suggest = "schedule_end_time"
        elif key == "scheduleOffset":
            suggest = "schedule_offset"
        elif key == "scheduleStartTime":
            suggest = "schedule_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTriggerConfigTriggerPropertiesScheduled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTriggerConfigTriggerPropertiesScheduled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTriggerConfigTriggerPropertiesScheduled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_expression: str,
                 data_pull_mode: Optional[str] = None,
                 first_execution_from: Optional[str] = None,
                 schedule_end_time: Optional[str] = None,
                 schedule_offset: Optional[int] = None,
                 schedule_start_time: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str schedule_expression: Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
        :param str data_pull_mode: Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
        :param str first_execution_from: Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
        :param str schedule_end_time: Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        :param int schedule_offset: Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
        :param str schedule_start_time: Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        :param str timezone: Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
        """
        FlowTriggerConfigTriggerPropertiesScheduled._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedule_expression=schedule_expression,
            data_pull_mode=data_pull_mode,
            first_execution_from=first_execution_from,
            schedule_end_time=schedule_end_time,
            schedule_offset=schedule_offset,
            schedule_start_time=schedule_start_time,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedule_expression: Optional[str] = None,
             data_pull_mode: Optional[str] = None,
             first_execution_from: Optional[str] = None,
             schedule_end_time: Optional[str] = None,
             schedule_offset: Optional[int] = None,
             schedule_start_time: Optional[str] = None,
             timezone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schedule_expression is None and 'scheduleExpression' in kwargs:
            schedule_expression = kwargs['scheduleExpression']
        if schedule_expression is None:
            raise TypeError("Missing 'schedule_expression' argument")
        if data_pull_mode is None and 'dataPullMode' in kwargs:
            data_pull_mode = kwargs['dataPullMode']
        if first_execution_from is None and 'firstExecutionFrom' in kwargs:
            first_execution_from = kwargs['firstExecutionFrom']
        if schedule_end_time is None and 'scheduleEndTime' in kwargs:
            schedule_end_time = kwargs['scheduleEndTime']
        if schedule_offset is None and 'scheduleOffset' in kwargs:
            schedule_offset = kwargs['scheduleOffset']
        if schedule_start_time is None and 'scheduleStartTime' in kwargs:
            schedule_start_time = kwargs['scheduleStartTime']

        _setter("schedule_expression", schedule_expression)
        if data_pull_mode is not None:
            _setter("data_pull_mode", data_pull_mode)
        if first_execution_from is not None:
            _setter("first_execution_from", first_execution_from)
        if schedule_end_time is not None:
            _setter("schedule_end_time", schedule_end_time)
        if schedule_offset is not None:
            _setter("schedule_offset", schedule_offset)
        if schedule_start_time is not None:
            _setter("schedule_start_time", schedule_start_time)
        if timezone is not None:
            _setter("timezone", timezone)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> str:
        """
        Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
        """
        return pulumi.get(self, "schedule_expression")

    @property
    @pulumi.getter(name="dataPullMode")
    def data_pull_mode(self) -> Optional[str]:
        """
        Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
        """
        return pulumi.get(self, "data_pull_mode")

    @property
    @pulumi.getter(name="firstExecutionFrom")
    def first_execution_from(self) -> Optional[str]:
        """
        Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "first_execution_from")

    @property
    @pulumi.getter(name="scheduleEndTime")
    def schedule_end_time(self) -> Optional[str]:
        """
        Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "schedule_end_time")

    @property
    @pulumi.getter(name="scheduleOffset")
    def schedule_offset(self) -> Optional[int]:
        """
        Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
        """
        return pulumi.get(self, "schedule_offset")

    @property
    @pulumi.getter(name="scheduleStartTime")
    def schedule_start_time(self) -> Optional[str]:
        """
        Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
        """
        return pulumi.get(self, "schedule_start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
        """
        return pulumi.get(self, "timezone")


