# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ScheduledQueryErrorReportConfiguration',
    'ScheduledQueryErrorReportConfigurationS3Configuration',
    'ScheduledQueryLastRunSummary',
    'ScheduledQueryLastRunSummaryErrorReportLocation',
    'ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation',
    'ScheduledQueryLastRunSummaryExecutionStat',
    'ScheduledQueryLastRunSummaryQueryInsightsResponse',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverage',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRange',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis',
    'ScheduledQueryNotificationConfiguration',
    'ScheduledQueryNotificationConfigurationSnsConfiguration',
    'ScheduledQueryRecentlyFailedRun',
    'ScheduledQueryRecentlyFailedRunErrorReportLocation',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation',
    'ScheduledQueryRecentlyFailedRunExecutionStat',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponse',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis',
    'ScheduledQueryScheduleConfiguration',
    'ScheduledQueryTargetConfiguration',
    'ScheduledQueryTargetConfigurationTimestreamConfiguration',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping',
    'ScheduledQueryTimeouts',
]

@pulumi.output_type
class ScheduledQueryErrorReportConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Configuration":
            suggest = "s3_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryErrorReportConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryErrorReportConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryErrorReportConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_configuration: 'outputs.ScheduledQueryErrorReportConfigurationS3Configuration'):
        pulumi.set(__self__, "s3_configuration", s3_configuration)

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> 'outputs.ScheduledQueryErrorReportConfigurationS3Configuration':
        return pulumi.get(self, "s3_configuration")


@pulumi.output_type
class ScheduledQueryErrorReportConfigurationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "encryptionOption":
            suggest = "encryption_option"
        elif key == "objectKeyPrefix":
            suggest = "object_key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryErrorReportConfigurationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryErrorReportConfigurationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryErrorReportConfigurationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 encryption_option: Optional[_builtins.str] = None,
                 object_key_prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_option")

    @_builtins.property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "object_key_prefix")


@pulumi.output_type
class ScheduledQueryLastRunSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorReportLocations":
            suggest = "error_report_locations"
        elif key == "executionStats":
            suggest = "execution_stats"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "invocationTime":
            suggest = "invocation_time"
        elif key == "queryInsightsResponses":
            suggest = "query_insights_responses"
        elif key == "runStatus":
            suggest = "run_status"
        elif key == "triggerTime":
            suggest = "trigger_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_report_locations: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryErrorReportLocation']] = None,
                 execution_stats: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryExecutionStat']] = None,
                 failure_reason: Optional[_builtins.str] = None,
                 invocation_time: Optional[_builtins.str] = None,
                 query_insights_responses: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponse']] = None,
                 run_status: Optional[_builtins.str] = None,
                 trigger_time: Optional[_builtins.str] = None):
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @_builtins.property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryErrorReportLocation']]:
        return pulumi.get(self, "error_report_locations")

    @_builtins.property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryExecutionStat']]:
        return pulumi.get(self, "execution_stats")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invocation_time")

    @_builtins.property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponse']]:
        return pulumi.get(self, "query_insights_responses")

    @_builtins.property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_status")

    @_builtins.property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger_time")


@pulumi.output_type
class ScheduledQueryLastRunSummaryErrorReportLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3ReportLocations":
            suggest = "s3_report_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryErrorReportLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryErrorReportLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryErrorReportLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_report_locations: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation']] = None):
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @_builtins.property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation']]:
        return pulumi.get(self, "s3_report_locations")


@pulumi.output_type
class ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectKey":
            suggest = "object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 object_key: Optional[_builtins.str] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "object_key")


@pulumi.output_type
class ScheduledQueryLastRunSummaryExecutionStat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bytesMetered":
            suggest = "bytes_metered"
        elif key == "cumulativeBytesScanned":
            suggest = "cumulative_bytes_scanned"
        elif key == "dataWrites":
            suggest = "data_writes"
        elif key == "executionTimeInMillis":
            suggest = "execution_time_in_millis"
        elif key == "queryResultRows":
            suggest = "query_result_rows"
        elif key == "recordsIngested":
            suggest = "records_ingested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryExecutionStat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryExecutionStat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryExecutionStat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bytes_metered: Optional[_builtins.int] = None,
                 cumulative_bytes_scanned: Optional[_builtins.int] = None,
                 data_writes: Optional[_builtins.int] = None,
                 execution_time_in_millis: Optional[_builtins.int] = None,
                 query_result_rows: Optional[_builtins.int] = None,
                 records_ingested: Optional[_builtins.int] = None):
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @_builtins.property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "bytes_metered")

    @_builtins.property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cumulative_bytes_scanned")

    @_builtins.property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "data_writes")

    @_builtins.property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "execution_time_in_millis")

    @_builtins.property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "query_result_rows")

    @_builtins.property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "records_ingested")


@pulumi.output_type
class ScheduledQueryLastRunSummaryQueryInsightsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputBytes":
            suggest = "output_bytes"
        elif key == "outputRows":
            suggest = "output_rows"
        elif key == "querySpatialCoverages":
            suggest = "query_spatial_coverages"
        elif key == "queryTableCount":
            suggest = "query_table_count"
        elif key == "queryTemporalRanges":
            suggest = "query_temporal_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryQueryInsightsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_bytes: Optional[_builtins.int] = None,
                 output_rows: Optional[_builtins.int] = None,
                 query_spatial_coverages: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverage']] = None,
                 query_table_count: Optional[_builtins.int] = None,
                 query_temporal_ranges: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRange']] = None):
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @_builtins.property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "output_bytes")

    @_builtins.property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "output_rows")

    @_builtins.property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverage']]:
        return pulumi.get(self, "query_spatial_coverages")

    @_builtins.property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "query_table_count")

    @_builtins.property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRange']]:
        return pulumi.get(self, "query_temporal_ranges")


@pulumi.output_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverage(dict):
    def __init__(__self__, *,
                 maxes: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis']] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis']]:
        return pulumi.get(self, "maxes")


@pulumi.output_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionKeys":
            suggest = "partition_keys"
        elif key == "tableArn":
            suggest = "table_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_keys: Optional[Sequence[_builtins.str]] = None,
                 table_arn: Optional[_builtins.str] = None,
                 value: Optional[_builtins.float] = None):
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "partition_keys")

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRange(dict):
    def __init__(__self__, *,
                 maxes: Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis']] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[Sequence['outputs.ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis']]:
        return pulumi.get(self, "maxes")


@pulumi.output_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableArn":
            suggest = "table_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_arn: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduledQueryNotificationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snsConfiguration":
            suggest = "sns_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryNotificationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryNotificationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryNotificationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sns_configuration: 'outputs.ScheduledQueryNotificationConfigurationSnsConfiguration'):
        pulumi.set(__self__, "sns_configuration", sns_configuration)

    @_builtins.property
    @pulumi.getter(name="snsConfiguration")
    def sns_configuration(self) -> 'outputs.ScheduledQueryNotificationConfigurationSnsConfiguration':
        return pulumi.get(self, "sns_configuration")


@pulumi.output_type
class ScheduledQueryNotificationConfigurationSnsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryNotificationConfigurationSnsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryNotificationConfigurationSnsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryNotificationConfigurationSnsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_arn: _builtins.str):
        pulumi.set(__self__, "topic_arn", topic_arn)

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> _builtins.str:
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRun(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorReportLocations":
            suggest = "error_report_locations"
        elif key == "executionStats":
            suggest = "execution_stats"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "invocationTime":
            suggest = "invocation_time"
        elif key == "queryInsightsResponses":
            suggest = "query_insights_responses"
        elif key == "runStatus":
            suggest = "run_status"
        elif key == "triggerTime":
            suggest = "trigger_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRun. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRun.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRun.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_report_locations: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunErrorReportLocation']] = None,
                 execution_stats: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunExecutionStat']] = None,
                 failure_reason: Optional[_builtins.str] = None,
                 invocation_time: Optional[_builtins.str] = None,
                 query_insights_responses: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponse']] = None,
                 run_status: Optional[_builtins.str] = None,
                 trigger_time: Optional[_builtins.str] = None):
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @_builtins.property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunErrorReportLocation']]:
        return pulumi.get(self, "error_report_locations")

    @_builtins.property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunExecutionStat']]:
        return pulumi.get(self, "execution_stats")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invocation_time")

    @_builtins.property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponse']]:
        return pulumi.get(self, "query_insights_responses")

    @_builtins.property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_status")

    @_builtins.property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger_time")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunErrorReportLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3ReportLocations":
            suggest = "s3_report_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunErrorReportLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunErrorReportLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunErrorReportLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_report_locations: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation']] = None):
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @_builtins.property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation']]:
        return pulumi.get(self, "s3_report_locations")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectKey":
            suggest = "object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 object_key: Optional[_builtins.str] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "object_key")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunExecutionStat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bytesMetered":
            suggest = "bytes_metered"
        elif key == "cumulativeBytesScanned":
            suggest = "cumulative_bytes_scanned"
        elif key == "dataWrites":
            suggest = "data_writes"
        elif key == "executionTimeInMillis":
            suggest = "execution_time_in_millis"
        elif key == "queryResultRows":
            suggest = "query_result_rows"
        elif key == "recordsIngested":
            suggest = "records_ingested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunExecutionStat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunExecutionStat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunExecutionStat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bytes_metered: Optional[_builtins.int] = None,
                 cumulative_bytes_scanned: Optional[_builtins.int] = None,
                 data_writes: Optional[_builtins.int] = None,
                 execution_time_in_millis: Optional[_builtins.int] = None,
                 query_result_rows: Optional[_builtins.int] = None,
                 records_ingested: Optional[_builtins.int] = None):
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @_builtins.property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "bytes_metered")

    @_builtins.property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cumulative_bytes_scanned")

    @_builtins.property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "data_writes")

    @_builtins.property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "execution_time_in_millis")

    @_builtins.property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "query_result_rows")

    @_builtins.property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "records_ingested")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputBytes":
            suggest = "output_bytes"
        elif key == "outputRows":
            suggest = "output_rows"
        elif key == "querySpatialCoverages":
            suggest = "query_spatial_coverages"
        elif key == "queryTableCount":
            suggest = "query_table_count"
        elif key == "queryTemporalRanges":
            suggest = "query_temporal_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunQueryInsightsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_bytes: Optional[_builtins.int] = None,
                 output_rows: Optional[_builtins.int] = None,
                 query_spatial_coverages: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage']] = None,
                 query_table_count: Optional[_builtins.int] = None,
                 query_temporal_ranges: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange']] = None):
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @_builtins.property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "output_bytes")

    @_builtins.property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "output_rows")

    @_builtins.property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage']]:
        return pulumi.get(self, "query_spatial_coverages")

    @_builtins.property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "query_table_count")

    @_builtins.property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange']]:
        return pulumi.get(self, "query_temporal_ranges")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage(dict):
    def __init__(__self__, *,
                 maxes: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis']] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis']]:
        return pulumi.get(self, "maxes")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionKeys":
            suggest = "partition_keys"
        elif key == "tableArn":
            suggest = "table_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_keys: Optional[Sequence[_builtins.str]] = None,
                 table_arn: Optional[_builtins.str] = None,
                 value: Optional[_builtins.float] = None):
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "partition_keys")

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange(dict):
    def __init__(__self__, *,
                 maxes: Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis']] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[Sequence['outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis']]:
        return pulumi.get(self, "maxes")


@pulumi.output_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableArn":
            suggest = "table_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_arn: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_arn")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduledQueryScheduleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleExpression":
            suggest = "schedule_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryScheduleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryScheduleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryScheduleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_expression: _builtins.str):
        pulumi.set(__self__, "schedule_expression", schedule_expression)

    @_builtins.property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> _builtins.str:
        return pulumi.get(self, "schedule_expression")


@pulumi.output_type
class ScheduledQueryTargetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestreamConfiguration":
            suggest = "timestream_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timestream_configuration: Optional['outputs.ScheduledQueryTargetConfigurationTimestreamConfiguration'] = None):
        if timestream_configuration is not None:
            pulumi.set(__self__, "timestream_configuration", timestream_configuration)

    @_builtins.property
    @pulumi.getter(name="timestreamConfiguration")
    def timestream_configuration(self) -> Optional['outputs.ScheduledQueryTargetConfigurationTimestreamConfiguration']:
        return pulumi.get(self, "timestream_configuration")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "timeColumn":
            suggest = "time_column"
        elif key == "dimensionMappings":
            suggest = "dimension_mappings"
        elif key == "measureNameColumn":
            suggest = "measure_name_column"
        elif key == "mixedMeasureMappings":
            suggest = "mixed_measure_mappings"
        elif key == "multiMeasureMappings":
            suggest = "multi_measure_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 table_name: _builtins.str,
                 time_column: _builtins.str,
                 dimension_mappings: Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping']] = None,
                 measure_name_column: Optional[_builtins.str] = None,
                 mixed_measure_mappings: Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping']] = None,
                 multi_measure_mappings: Optional['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings'] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "time_column", time_column)
        if dimension_mappings is not None:
            pulumi.set(__self__, "dimension_mappings", dimension_mappings)
        if measure_name_column is not None:
            pulumi.set(__self__, "measure_name_column", measure_name_column)
        if mixed_measure_mappings is not None:
            pulumi.set(__self__, "mixed_measure_mappings", mixed_measure_mappings)
        if multi_measure_mappings is not None:
            pulumi.set(__self__, "multi_measure_mappings", multi_measure_mappings)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="timeColumn")
    def time_column(self) -> _builtins.str:
        return pulumi.get(self, "time_column")

    @_builtins.property
    @pulumi.getter(name="dimensionMappings")
    def dimension_mappings(self) -> Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping']]:
        return pulumi.get(self, "dimension_mappings")

    @_builtins.property
    @pulumi.getter(name="measureNameColumn")
    def measure_name_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "measure_name_column")

    @_builtins.property
    @pulumi.getter(name="mixedMeasureMappings")
    def mixed_measure_mappings(self) -> Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping']]:
        return pulumi.get(self, "mixed_measure_mappings")

    @_builtins.property
    @pulumi.getter(name="multiMeasureMappings")
    def multi_measure_mappings(self) -> Optional['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings']:
        return pulumi.get(self, "multi_measure_mappings")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionValueType":
            suggest = "dimension_value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_value_type: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "dimension_value_type", dimension_value_type)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dimensionValueType")
    def dimension_value_type(self) -> _builtins.str:
        return pulumi.get(self, "dimension_value_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureValueType":
            suggest = "measure_value_type"
        elif key == "measureName":
            suggest = "measure_name"
        elif key == "multiMeasureAttributeMappings":
            suggest = "multi_measure_attribute_mappings"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "targetMeasureName":
            suggest = "target_measure_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 measure_value_type: _builtins.str,
                 measure_name: Optional[_builtins.str] = None,
                 multi_measure_attribute_mappings: Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping']] = None,
                 source_column: Optional[_builtins.str] = None,
                 target_measure_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        if measure_name is not None:
            pulumi.set(__self__, "measure_name", measure_name)
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if source_column is not None:
            pulumi.set(__self__, "source_column", source_column)
        if target_measure_name is not None:
            pulumi.set(__self__, "target_measure_name", target_measure_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> _builtins.str:
        return pulumi.get(self, "measure_value_type")

    @_builtins.property
    @pulumi.getter(name="measureName")
    def measure_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "measure_name")

    @_builtins.property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping']]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_column")

    @_builtins.property
    @pulumi.getter(name="targetMeasureName")
    def target_measure_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_measure_name")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureValueType":
            suggest = "measure_value_type"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "targetMultiMeasureAttributeName":
            suggest = "target_multi_measure_attribute_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 measure_value_type: _builtins.str,
                 source_column: _builtins.str,
                 target_multi_measure_attribute_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> _builtins.str:
        return pulumi.get(self, "measure_value_type")

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> _builtins.str:
        return pulumi.get(self, "source_column")

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_multi_measure_attribute_name")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiMeasureAttributeMappings":
            suggest = "multi_measure_attribute_mappings"
        elif key == "targetMultiMeasureName":
            suggest = "target_multi_measure_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multi_measure_attribute_mappings: Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping']] = None,
                 target_multi_measure_name: Optional[_builtins.str] = None):
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if target_multi_measure_name is not None:
            pulumi.set(__self__, "target_multi_measure_name", target_multi_measure_name)

    @_builtins.property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[Sequence['outputs.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping']]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureName")
    def target_multi_measure_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_multi_measure_name")


@pulumi.output_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureValueType":
            suggest = "measure_value_type"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "targetMultiMeasureAttributeName":
            suggest = "target_multi_measure_attribute_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 measure_value_type: _builtins.str,
                 source_column: _builtins.str,
                 target_multi_measure_attribute_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> _builtins.str:
        return pulumi.get(self, "measure_value_type")

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> _builtins.str:
        return pulumi.get(self, "source_column")

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_multi_measure_attribute_name")


@pulumi.output_type
class ScheduledQueryTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


