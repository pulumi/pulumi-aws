# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ScheduledQueryErrorReportConfigurationArgs',
    'ScheduledQueryErrorReportConfigurationArgsDict',
    'ScheduledQueryErrorReportConfigurationS3ConfigurationArgs',
    'ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict',
    'ScheduledQueryLastRunSummaryArgs',
    'ScheduledQueryLastRunSummaryArgsDict',
    'ScheduledQueryLastRunSummaryErrorReportLocationArgs',
    'ScheduledQueryLastRunSummaryErrorReportLocationArgsDict',
    'ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs',
    'ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict',
    'ScheduledQueryLastRunSummaryExecutionStatArgs',
    'ScheduledQueryLastRunSummaryExecutionStatArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict',
    'ScheduledQueryNotificationConfigurationArgs',
    'ScheduledQueryNotificationConfigurationArgsDict',
    'ScheduledQueryNotificationConfigurationSnsConfigurationArgs',
    'ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict',
    'ScheduledQueryRecentlyFailedRunArgs',
    'ScheduledQueryRecentlyFailedRunArgsDict',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationArgs',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict',
    'ScheduledQueryRecentlyFailedRunExecutionStatArgs',
    'ScheduledQueryRecentlyFailedRunExecutionStatArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict',
    'ScheduledQueryScheduleConfigurationArgs',
    'ScheduledQueryScheduleConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationArgs',
    'ScheduledQueryTargetConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict',
    'ScheduledQueryTimeoutsArgs',
    'ScheduledQueryTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class ScheduledQueryErrorReportConfigurationArgsDict(TypedDict):
        s3_configuration: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict']
elif False:
    ScheduledQueryErrorReportConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryErrorReportConfigurationArgs:
    def __init__(__self__, *,
                 s3_configuration: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']):
        pulumi.set(__self__, "s3_configuration", s3_configuration)

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']:
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']):
        pulumi.set(self, "s3_configuration", value)


if not MYPY:
    class ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        encryption_option: NotRequired[pulumi.Input[_builtins.str]]
        object_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryErrorReportConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 encryption_option: Optional[pulumi.Input[_builtins.str]] = None,
                 object_key_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_option", value)

    @_builtins.property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "object_key_prefix")

    @object_key_prefix.setter
    def object_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_key_prefix", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryArgsDict(TypedDict):
        error_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgsDict']]]]
        execution_stats: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgsDict']]]]
        failure_reason: NotRequired[pulumi.Input[_builtins.str]]
        invocation_time: NotRequired[pulumi.Input[_builtins.str]]
        query_insights_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict']]]]
        run_status: NotRequired[pulumi.Input[_builtins.str]]
        trigger_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryLastRunSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryArgs:
    def __init__(__self__, *,
                 error_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]] = None,
                 execution_stats: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]] = None,
                 failure_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 invocation_time: Optional[pulumi.Input[_builtins.str]] = None,
                 query_insights_responses: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]] = None,
                 run_status: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_time: Optional[pulumi.Input[_builtins.str]] = None):
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @_builtins.property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]]:
        return pulumi.get(self, "error_report_locations")

    @error_report_locations.setter
    def error_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]]):
        pulumi.set(self, "error_report_locations", value)

    @_builtins.property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]]:
        return pulumi.get(self, "execution_stats")

    @execution_stats.setter
    def execution_stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]]):
        pulumi.set(self, "execution_stats", value)

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failure_reason", value)

    @_builtins.property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invocation_time")

    @invocation_time.setter
    def invocation_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_time", value)

    @_builtins.property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]]:
        return pulumi.get(self, "query_insights_responses")

    @query_insights_responses.setter
    def query_insights_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]]):
        pulumi.set(self, "query_insights_responses", value)

    @_builtins.property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "run_status")

    @run_status.setter
    def run_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_status", value)

    @_builtins.property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trigger_time")

    @trigger_time.setter
    def trigger_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_time", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryErrorReportLocationArgsDict(TypedDict):
        s3_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict']]]]
elif False:
    ScheduledQueryLastRunSummaryErrorReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryErrorReportLocationArgs:
    def __init__(__self__, *,
                 s3_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]] = None):
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @_builtins.property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]]:
        return pulumi.get(self, "s3_report_locations")

    @s3_report_locations.setter
    def s3_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]]):
        pulumi.set(self, "s3_report_locations", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        object_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 object_key: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "object_key")

    @object_key.setter
    def object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_key", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryExecutionStatArgsDict(TypedDict):
        bytes_metered: NotRequired[pulumi.Input[_builtins.int]]
        cumulative_bytes_scanned: NotRequired[pulumi.Input[_builtins.int]]
        data_writes: NotRequired[pulumi.Input[_builtins.int]]
        execution_time_in_millis: NotRequired[pulumi.Input[_builtins.int]]
        query_result_rows: NotRequired[pulumi.Input[_builtins.int]]
        records_ingested: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ScheduledQueryLastRunSummaryExecutionStatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryExecutionStatArgs:
    def __init__(__self__, *,
                 bytes_metered: Optional[pulumi.Input[_builtins.int]] = None,
                 cumulative_bytes_scanned: Optional[pulumi.Input[_builtins.int]] = None,
                 data_writes: Optional[pulumi.Input[_builtins.int]] = None,
                 execution_time_in_millis: Optional[pulumi.Input[_builtins.int]] = None,
                 query_result_rows: Optional[pulumi.Input[_builtins.int]] = None,
                 records_ingested: Optional[pulumi.Input[_builtins.int]] = None):
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @_builtins.property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bytes_metered")

    @bytes_metered.setter
    def bytes_metered(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bytes_metered", value)

    @_builtins.property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cumulative_bytes_scanned")

    @cumulative_bytes_scanned.setter
    def cumulative_bytes_scanned(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cumulative_bytes_scanned", value)

    @_builtins.property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "data_writes")

    @data_writes.setter
    def data_writes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_writes", value)

    @_builtins.property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "execution_time_in_millis")

    @execution_time_in_millis.setter
    def execution_time_in_millis(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "execution_time_in_millis", value)

    @_builtins.property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "query_result_rows")

    @query_result_rows.setter
    def query_result_rows(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "query_result_rows", value)

    @_builtins.property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "records_ingested")

    @records_ingested.setter
    def records_ingested(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "records_ingested", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict(TypedDict):
        output_bytes: NotRequired[pulumi.Input[_builtins.int]]
        output_rows: NotRequired[pulumi.Input[_builtins.int]]
        query_spatial_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict']]]]
        query_table_count: NotRequired[pulumi.Input[_builtins.int]]
        query_temporal_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict']]]]
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseArgs:
    def __init__(__self__, *,
                 output_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 output_rows: Optional[pulumi.Input[_builtins.int]] = None,
                 query_spatial_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]] = None,
                 query_table_count: Optional[pulumi.Input[_builtins.int]] = None,
                 query_temporal_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]] = None):
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @_builtins.property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "output_bytes")

    @output_bytes.setter
    def output_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "output_bytes", value)

    @_builtins.property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "output_rows")

    @output_rows.setter
    def output_rows(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "output_rows", value)

    @_builtins.property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]]:
        return pulumi.get(self, "query_spatial_coverages")

    @query_spatial_coverages.setter
    def query_spatial_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]]):
        pulumi.set(self, "query_spatial_coverages", value)

    @_builtins.property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "query_table_count")

    @query_table_count.setter
    def query_table_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "query_table_count", value)

    @_builtins.property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]]:
        return pulumi.get(self, "query_temporal_ranges")

    @query_temporal_ranges.setter
    def query_temporal_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]]):
        pulumi.set(self, "query_temporal_ranges", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict']]]]
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]:
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict(TypedDict):
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs:
    def __init__(__self__, *,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "partition_keys", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict']]]]
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]:
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict(TypedDict):
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs:
    def __init__(__self__, *,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryNotificationConfigurationArgsDict(TypedDict):
        sns_configuration: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict']
elif False:
    ScheduledQueryNotificationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryNotificationConfigurationArgs:
    def __init__(__self__, *,
                 sns_configuration: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']):
        pulumi.set(__self__, "sns_configuration", sns_configuration)

    @_builtins.property
    @pulumi.getter(name="snsConfiguration")
    def sns_configuration(self) -> pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']:
        return pulumi.get(self, "sns_configuration")

    @sns_configuration.setter
    def sns_configuration(self, value: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']):
        pulumi.set(self, "sns_configuration", value)


if not MYPY:
    class ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict(TypedDict):
        topic_arn: pulumi.Input[_builtins.str]
elif False:
    ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryNotificationConfigurationSnsConfigurationArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "topic_arn", topic_arn)

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_arn", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunArgsDict(TypedDict):
        error_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict']]]]
        execution_stats: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgsDict']]]]
        failure_reason: NotRequired[pulumi.Input[_builtins.str]]
        invocation_time: NotRequired[pulumi.Input[_builtins.str]]
        query_insights_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict']]]]
        run_status: NotRequired[pulumi.Input[_builtins.str]]
        trigger_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryRecentlyFailedRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunArgs:
    def __init__(__self__, *,
                 error_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]] = None,
                 execution_stats: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]] = None,
                 failure_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 invocation_time: Optional[pulumi.Input[_builtins.str]] = None,
                 query_insights_responses: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]] = None,
                 run_status: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_time: Optional[pulumi.Input[_builtins.str]] = None):
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @_builtins.property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]]:
        return pulumi.get(self, "error_report_locations")

    @error_report_locations.setter
    def error_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]]):
        pulumi.set(self, "error_report_locations", value)

    @_builtins.property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]]:
        return pulumi.get(self, "execution_stats")

    @execution_stats.setter
    def execution_stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]]):
        pulumi.set(self, "execution_stats", value)

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failure_reason", value)

    @_builtins.property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invocation_time")

    @invocation_time.setter
    def invocation_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_time", value)

    @_builtins.property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]]:
        return pulumi.get(self, "query_insights_responses")

    @query_insights_responses.setter
    def query_insights_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]]):
        pulumi.set(self, "query_insights_responses", value)

    @_builtins.property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "run_status")

    @run_status.setter
    def run_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_status", value)

    @_builtins.property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trigger_time")

    @trigger_time.setter
    def trigger_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_time", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict(TypedDict):
        s3_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict']]]]
elif False:
    ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunErrorReportLocationArgs:
    def __init__(__self__, *,
                 s3_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]] = None):
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @_builtins.property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]]:
        return pulumi.get(self, "s3_report_locations")

    @s3_report_locations.setter
    def s3_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]]):
        pulumi.set(self, "s3_report_locations", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        object_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 object_key: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "object_key")

    @object_key.setter
    def object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_key", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunExecutionStatArgsDict(TypedDict):
        bytes_metered: NotRequired[pulumi.Input[_builtins.int]]
        cumulative_bytes_scanned: NotRequired[pulumi.Input[_builtins.int]]
        data_writes: NotRequired[pulumi.Input[_builtins.int]]
        execution_time_in_millis: NotRequired[pulumi.Input[_builtins.int]]
        query_result_rows: NotRequired[pulumi.Input[_builtins.int]]
        records_ingested: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ScheduledQueryRecentlyFailedRunExecutionStatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunExecutionStatArgs:
    def __init__(__self__, *,
                 bytes_metered: Optional[pulumi.Input[_builtins.int]] = None,
                 cumulative_bytes_scanned: Optional[pulumi.Input[_builtins.int]] = None,
                 data_writes: Optional[pulumi.Input[_builtins.int]] = None,
                 execution_time_in_millis: Optional[pulumi.Input[_builtins.int]] = None,
                 query_result_rows: Optional[pulumi.Input[_builtins.int]] = None,
                 records_ingested: Optional[pulumi.Input[_builtins.int]] = None):
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @_builtins.property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bytes_metered")

    @bytes_metered.setter
    def bytes_metered(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bytes_metered", value)

    @_builtins.property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cumulative_bytes_scanned")

    @cumulative_bytes_scanned.setter
    def cumulative_bytes_scanned(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cumulative_bytes_scanned", value)

    @_builtins.property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "data_writes")

    @data_writes.setter
    def data_writes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_writes", value)

    @_builtins.property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "execution_time_in_millis")

    @execution_time_in_millis.setter
    def execution_time_in_millis(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "execution_time_in_millis", value)

    @_builtins.property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "query_result_rows")

    @query_result_rows.setter
    def query_result_rows(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "query_result_rows", value)

    @_builtins.property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "records_ingested")

    @records_ingested.setter
    def records_ingested(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "records_ingested", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict(TypedDict):
        output_bytes: NotRequired[pulumi.Input[_builtins.int]]
        output_rows: NotRequired[pulumi.Input[_builtins.int]]
        query_spatial_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict']]]]
        query_table_count: NotRequired[pulumi.Input[_builtins.int]]
        query_temporal_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict']]]]
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs:
    def __init__(__self__, *,
                 output_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 output_rows: Optional[pulumi.Input[_builtins.int]] = None,
                 query_spatial_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]] = None,
                 query_table_count: Optional[pulumi.Input[_builtins.int]] = None,
                 query_temporal_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]] = None):
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @_builtins.property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "output_bytes")

    @output_bytes.setter
    def output_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "output_bytes", value)

    @_builtins.property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "output_rows")

    @output_rows.setter
    def output_rows(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "output_rows", value)

    @_builtins.property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]]:
        return pulumi.get(self, "query_spatial_coverages")

    @query_spatial_coverages.setter
    def query_spatial_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]]):
        pulumi.set(self, "query_spatial_coverages", value)

    @_builtins.property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "query_table_count")

    @query_table_count.setter
    def query_table_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "query_table_count", value)

    @_builtins.property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]]:
        return pulumi.get(self, "query_temporal_ranges")

    @query_temporal_ranges.setter
    def query_temporal_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]]):
        pulumi.set(self, "query_temporal_ranges", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict']]]]
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]:
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict(TypedDict):
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs:
    def __init__(__self__, *,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "partition_keys", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict']]]]
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]] = None):
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @_builtins.property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]:
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict(TypedDict):
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs:
    def __init__(__self__, *,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryScheduleConfigurationArgsDict(TypedDict):
        schedule_expression: pulumi.Input[_builtins.str]
elif False:
    ScheduledQueryScheduleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryScheduleConfigurationArgs:
    def __init__(__self__, *,
                 schedule_expression: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "schedule_expression", schedule_expression)

    @_builtins.property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule_expression", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationArgsDict(TypedDict):
        timestream_configuration: NotRequired[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict']]
elif False:
    ScheduledQueryTargetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationArgs:
    def __init__(__self__, *,
                 timestream_configuration: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']] = None):
        if timestream_configuration is not None:
            pulumi.set(__self__, "timestream_configuration", timestream_configuration)

    @_builtins.property
    @pulumi.getter(name="timestreamConfiguration")
    def timestream_configuration(self) -> Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']]:
        return pulumi.get(self, "timestream_configuration")

    @timestream_configuration.setter
    def timestream_configuration(self, value: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']]):
        pulumi.set(self, "timestream_configuration", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        time_column: pulumi.Input[_builtins.str]
        dimension_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict']]]]
        measure_name_column: NotRequired[pulumi.Input[_builtins.str]]
        mixed_measure_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict']]]]
        multi_measure_mappings: NotRequired[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict']]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 time_column: pulumi.Input[_builtins.str],
                 dimension_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]] = None,
                 measure_name_column: Optional[pulumi.Input[_builtins.str]] = None,
                 mixed_measure_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]] = None,
                 multi_measure_mappings: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "time_column", time_column)
        if dimension_mappings is not None:
            pulumi.set(__self__, "dimension_mappings", dimension_mappings)
        if measure_name_column is not None:
            pulumi.set(__self__, "measure_name_column", measure_name_column)
        if mixed_measure_mappings is not None:
            pulumi.set(__self__, "mixed_measure_mappings", mixed_measure_mappings)
        if multi_measure_mappings is not None:
            pulumi.set(__self__, "multi_measure_mappings", multi_measure_mappings)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="timeColumn")
    def time_column(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "time_column")

    @time_column.setter
    def time_column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_column", value)

    @_builtins.property
    @pulumi.getter(name="dimensionMappings")
    def dimension_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]]:
        return pulumi.get(self, "dimension_mappings")

    @dimension_mappings.setter
    def dimension_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]]):
        pulumi.set(self, "dimension_mappings", value)

    @_builtins.property
    @pulumi.getter(name="measureNameColumn")
    def measure_name_column(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "measure_name_column")

    @measure_name_column.setter
    def measure_name_column(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure_name_column", value)

    @_builtins.property
    @pulumi.getter(name="mixedMeasureMappings")
    def mixed_measure_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]]:
        return pulumi.get(self, "mixed_measure_mappings")

    @mixed_measure_mappings.setter
    def mixed_measure_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]]):
        pulumi.set(self, "mixed_measure_mappings", value)

    @_builtins.property
    @pulumi.getter(name="multiMeasureMappings")
    def multi_measure_mappings(self) -> Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']]:
        return pulumi.get(self, "multi_measure_mappings")

    @multi_measure_mappings.setter
    def multi_measure_mappings(self, value: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']]):
        pulumi.set(self, "multi_measure_mappings", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict(TypedDict):
        dimension_value_type: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs:
    def __init__(__self__, *,
                 dimension_value_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "dimension_value_type", dimension_value_type)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dimensionValueType")
    def dimension_value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "dimension_value_type")

    @dimension_value_type.setter
    def dimension_value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dimension_value_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[_builtins.str]
        measure_name: NotRequired[pulumi.Input[_builtins.str]]
        multi_measure_attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict']]]]
        source_column: NotRequired[pulumi.Input[_builtins.str]]
        target_measure_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[_builtins.str],
                 measure_name: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_measure_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]] = None,
                 source_column: Optional[pulumi.Input[_builtins.str]] = None,
                 target_measure_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        if measure_name is not None:
            pulumi.set(__self__, "measure_name", measure_name)
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if source_column is not None:
            pulumi.set(__self__, "source_column", source_column)
        if target_measure_name is not None:
            pulumi.set(__self__, "target_measure_name", target_measure_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "measure_value_type", value)

    @_builtins.property
    @pulumi.getter(name="measureName")
    def measure_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "measure_name")

    @measure_name.setter
    def measure_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure_name", value)

    @_builtins.property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_column", value)

    @_builtins.property
    @pulumi.getter(name="targetMeasureName")
    def target_measure_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_measure_name")

    @target_measure_name.setter
    def target_measure_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_measure_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[_builtins.str]
        source_column: pulumi.Input[_builtins.str]
        target_multi_measure_attribute_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[_builtins.str],
                 source_column: pulumi.Input[_builtins.str],
                 target_multi_measure_attribute_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "measure_value_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_column", value)

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_multi_measure_attribute_name")

    @target_multi_measure_attribute_name.setter
    def target_multi_measure_attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_multi_measure_attribute_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict(TypedDict):
        multi_measure_attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict']]]]
        target_multi_measure_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs:
    def __init__(__self__, *,
                 multi_measure_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]] = None,
                 target_multi_measure_name: Optional[pulumi.Input[_builtins.str]] = None):
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if target_multi_measure_name is not None:
            pulumi.set(__self__, "target_multi_measure_name", target_multi_measure_name)

    @_builtins.property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureName")
    def target_multi_measure_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_multi_measure_name")

    @target_multi_measure_name.setter
    def target_multi_measure_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_multi_measure_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[_builtins.str]
        source_column: pulumi.Input[_builtins.str]
        target_multi_measure_attribute_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[_builtins.str],
                 source_column: pulumi.Input[_builtins.str],
                 target_multi_measure_attribute_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @_builtins.property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "measure_value_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_column", value)

    @_builtins.property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_multi_measure_attribute_name")

    @target_multi_measure_attribute_name.setter
    def target_multi_measure_attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_multi_measure_attribute_name", value)


if not MYPY:
    class ScheduledQueryTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ScheduledQueryTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


