# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ScheduledQueryErrorReportConfigurationArgs',
    'ScheduledQueryErrorReportConfigurationArgsDict',
    'ScheduledQueryErrorReportConfigurationS3ConfigurationArgs',
    'ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict',
    'ScheduledQueryLastRunSummaryArgs',
    'ScheduledQueryLastRunSummaryArgsDict',
    'ScheduledQueryLastRunSummaryErrorReportLocationArgs',
    'ScheduledQueryLastRunSummaryErrorReportLocationArgsDict',
    'ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs',
    'ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict',
    'ScheduledQueryLastRunSummaryExecutionStatArgs',
    'ScheduledQueryLastRunSummaryExecutionStatArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs',
    'ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict',
    'ScheduledQueryNotificationConfigurationArgs',
    'ScheduledQueryNotificationConfigurationArgsDict',
    'ScheduledQueryNotificationConfigurationSnsConfigurationArgs',
    'ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict',
    'ScheduledQueryRecentlyFailedRunArgs',
    'ScheduledQueryRecentlyFailedRunArgsDict',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationArgs',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs',
    'ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict',
    'ScheduledQueryRecentlyFailedRunExecutionStatArgs',
    'ScheduledQueryRecentlyFailedRunExecutionStatArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs',
    'ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict',
    'ScheduledQueryScheduleConfigurationArgs',
    'ScheduledQueryScheduleConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationArgs',
    'ScheduledQueryTargetConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs',
    'ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict',
    'ScheduledQueryTimeoutsArgs',
    'ScheduledQueryTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class ScheduledQueryErrorReportConfigurationArgsDict(TypedDict):
        s3_configuration: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict']
        """
        Configuration block for the S3 configuration for the error reports. See below.
        """
elif False:
    ScheduledQueryErrorReportConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryErrorReportConfigurationArgs:
    def __init__(__self__, *,
                 s3_configuration: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']):
        """
        :param pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs'] s3_configuration: Configuration block for the S3 configuration for the error reports. See below.
        """
        pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']:
        """
        Configuration block for the S3 configuration for the error reports. See below.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: pulumi.Input['ScheduledQueryErrorReportConfigurationS3ConfigurationArgs']):
        pulumi.set(self, "s3_configuration", value)


if not MYPY:
    class ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Name of the S3 bucket under which error reports will be created.
        """
        encryption_option: NotRequired[pulumi.Input[str]]
        """
        Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose `SSE_S3` as default. Valid values are `SSE_S3`, `SSE_KMS`.
        """
        object_key_prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix for the error report key.
        """
elif False:
    ScheduledQueryErrorReportConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryErrorReportConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 encryption_option: Optional[pulumi.Input[str]] = None,
                 object_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Name of the S3 bucket under which error reports will be created.
        :param pulumi.Input[str] encryption_option: Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose `SSE_S3` as default. Valid values are `SSE_S3`, `SSE_KMS`.
        :param pulumi.Input[str] object_key_prefix: Prefix for the error report key.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Name of the S3 bucket under which error reports will be created.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose `SSE_S3` as default. Valid values are `SSE_S3`, `SSE_KMS`.
        """
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_option", value)

    @property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix for the error report key.
        """
        return pulumi.get(self, "object_key_prefix")

    @object_key_prefix.setter
    def object_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key_prefix", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryArgsDict(TypedDict):
        error_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgsDict']]]]
        """
        S3 location for error report.
        """
        execution_stats: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgsDict']]]]
        """
        Statistics for a single scheduled query run.
        """
        failure_reason: NotRequired[pulumi.Input[str]]
        """
        Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        """
        invocation_time: NotRequired[pulumi.Input[str]]
        """
        InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        """
        query_insights_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict']]]]
        """
        Various insights and metrics related to the run summary of the scheduled query.
        """
        run_status: NotRequired[pulumi.Input[str]]
        """
        Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        """
        trigger_time: NotRequired[pulumi.Input[str]]
        """
        Actual time when the query was run.
        """
elif False:
    ScheduledQueryLastRunSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryArgs:
    def __init__(__self__, *,
                 error_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]] = None,
                 execution_stats: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 invocation_time: Optional[pulumi.Input[str]] = None,
                 query_insights_responses: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]] = None,
                 run_status: Optional[pulumi.Input[str]] = None,
                 trigger_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]] error_report_locations: S3 location for error report.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]] execution_stats: Statistics for a single scheduled query run.
        :param pulumi.Input[str] failure_reason: Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        :param pulumi.Input[str] invocation_time: InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]] query_insights_responses: Various insights and metrics related to the run summary of the scheduled query.
        :param pulumi.Input[str] run_status: Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        :param pulumi.Input[str] trigger_time: Actual time when the query was run.
        """
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]]:
        """
        S3 location for error report.
        """
        return pulumi.get(self, "error_report_locations")

    @error_report_locations.setter
    def error_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationArgs']]]]):
        pulumi.set(self, "error_report_locations", value)

    @property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]]:
        """
        Statistics for a single scheduled query run.
        """
        return pulumi.get(self, "execution_stats")

    @execution_stats.setter
    def execution_stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryExecutionStatArgs']]]]):
        pulumi.set(self, "execution_stats", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[pulumi.Input[str]]:
        """
        InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        """
        return pulumi.get(self, "invocation_time")

    @invocation_time.setter
    def invocation_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_time", value)

    @property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]]:
        """
        Various insights and metrics related to the run summary of the scheduled query.
        """
        return pulumi.get(self, "query_insights_responses")

    @query_insights_responses.setter
    def query_insights_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseArgs']]]]):
        pulumi.set(self, "query_insights_responses", value)

    @property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        """
        return pulumi.get(self, "run_status")

    @run_status.setter
    def run_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_status", value)

    @property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[pulumi.Input[str]]:
        """
        Actual time when the query was run.
        """
        return pulumi.get(self, "trigger_time")

    @trigger_time.setter
    def trigger_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_time", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryErrorReportLocationArgsDict(TypedDict):
        s3_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict']]]]
        """
        S3 location where error reports are written.
        """
elif False:
    ScheduledQueryLastRunSummaryErrorReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryErrorReportLocationArgs:
    def __init__(__self__, *,
                 s3_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]] s3_report_locations: S3 location where error reports are written.
        """
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]]:
        """
        S3 location where error reports are written.
        """
        return pulumi.get(self, "s3_report_locations")

    @s3_report_locations.setter
    def s3_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs']]]]):
        pulumi.set(self, "s3_report_locations", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        S3 bucket name.
        """
        object_key: NotRequired[pulumi.Input[str]]
        """
        S3 key.
        """
elif False:
    ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryErrorReportLocationS3ReportLocationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 object_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: S3 bucket name.
        :param pulumi.Input[str] object_key: S3 key.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        S3 bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[pulumi.Input[str]]:
        """
        S3 key.
        """
        return pulumi.get(self, "object_key")

    @object_key.setter
    def object_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryExecutionStatArgsDict(TypedDict):
        bytes_metered: NotRequired[pulumi.Input[int]]
        """
        Bytes metered for a single scheduled query run.
        """
        cumulative_bytes_scanned: NotRequired[pulumi.Input[int]]
        """
        Bytes scanned for a single scheduled query run.
        """
        data_writes: NotRequired[pulumi.Input[int]]
        """
        Data writes metered for records ingested in a single scheduled query run.
        """
        execution_time_in_millis: NotRequired[pulumi.Input[int]]
        """
        Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        """
        query_result_rows: NotRequired[pulumi.Input[int]]
        """
        Number of rows present in the output from running a query before ingestion to destination data source.
        """
        records_ingested: NotRequired[pulumi.Input[int]]
        """
        Number of records ingested for a single scheduled query run.
        """
elif False:
    ScheduledQueryLastRunSummaryExecutionStatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryExecutionStatArgs:
    def __init__(__self__, *,
                 bytes_metered: Optional[pulumi.Input[int]] = None,
                 cumulative_bytes_scanned: Optional[pulumi.Input[int]] = None,
                 data_writes: Optional[pulumi.Input[int]] = None,
                 execution_time_in_millis: Optional[pulumi.Input[int]] = None,
                 query_result_rows: Optional[pulumi.Input[int]] = None,
                 records_ingested: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bytes_metered: Bytes metered for a single scheduled query run.
        :param pulumi.Input[int] cumulative_bytes_scanned: Bytes scanned for a single scheduled query run.
        :param pulumi.Input[int] data_writes: Data writes metered for records ingested in a single scheduled query run.
        :param pulumi.Input[int] execution_time_in_millis: Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        :param pulumi.Input[int] query_result_rows: Number of rows present in the output from running a query before ingestion to destination data source.
        :param pulumi.Input[int] records_ingested: Number of records ingested for a single scheduled query run.
        """
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[pulumi.Input[int]]:
        """
        Bytes metered for a single scheduled query run.
        """
        return pulumi.get(self, "bytes_metered")

    @bytes_metered.setter
    def bytes_metered(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_metered", value)

    @property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[pulumi.Input[int]]:
        """
        Bytes scanned for a single scheduled query run.
        """
        return pulumi.get(self, "cumulative_bytes_scanned")

    @cumulative_bytes_scanned.setter
    def cumulative_bytes_scanned(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cumulative_bytes_scanned", value)

    @property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[pulumi.Input[int]]:
        """
        Data writes metered for records ingested in a single scheduled query run.
        """
        return pulumi.get(self, "data_writes")

    @data_writes.setter
    def data_writes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_writes", value)

    @property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[pulumi.Input[int]]:
        """
        Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        """
        return pulumi.get(self, "execution_time_in_millis")

    @execution_time_in_millis.setter
    def execution_time_in_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "execution_time_in_millis", value)

    @property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Number of rows present in the output from running a query before ingestion to destination data source.
        """
        return pulumi.get(self, "query_result_rows")

    @query_result_rows.setter
    def query_result_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_result_rows", value)

    @property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records ingested for a single scheduled query run.
        """
        return pulumi.get(self, "records_ingested")

    @records_ingested.setter
    def records_ingested(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "records_ingested", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict(TypedDict):
        output_bytes: NotRequired[pulumi.Input[int]]
        """
        Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        """
        output_rows: NotRequired[pulumi.Input[int]]
        """
        Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        """
        query_spatial_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict']]]]
        """
        Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        """
        query_table_count: NotRequired[pulumi.Input[int]]
        """
        Number of tables in the query.
        """
        query_temporal_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict']]]]
        """
        Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseArgs:
    def __init__(__self__, *,
                 output_bytes: Optional[pulumi.Input[int]] = None,
                 output_rows: Optional[pulumi.Input[int]] = None,
                 query_spatial_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]] = None,
                 query_table_count: Optional[pulumi.Input[int]] = None,
                 query_temporal_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]] = None):
        """
        :param pulumi.Input[int] output_bytes: Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        :param pulumi.Input[int] output_rows: Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]] query_spatial_coverages: Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        :param pulumi.Input[int] query_table_count: Number of tables in the query.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]] query_temporal_ranges: Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        """
        return pulumi.get(self, "output_bytes")

    @output_bytes.setter
    def output_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_bytes", value)

    @property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        """
        return pulumi.get(self, "output_rows")

    @output_rows.setter
    def output_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_rows", value)

    @property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]]:
        """
        Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        """
        return pulumi.get(self, "query_spatial_coverages")

    @query_spatial_coverages.setter
    def query_spatial_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs']]]]):
        pulumi.set(self, "query_spatial_coverages", value)

    @property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of tables in the query.
        """
        return pulumi.get(self, "query_table_count")

    @query_table_count.setter
    def query_table_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_table_count", value)

    @property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]]:
        """
        Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
        return pulumi.get(self, "query_temporal_ranges")

    @query_temporal_ranges.setter
    def query_temporal_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs']]]]):
        pulumi.set(self, "query_temporal_ranges", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict']]]]
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]] maxes: Insights into the most sub-optimal performing table on the temporal axis:
        """
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]:
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict(TypedDict):
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        """
        table_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the table which is queried with the largest time range.
        """
        value: NotRequired[pulumi.Input[float]]
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQuerySpatialCoverageMaxisArgs:
    def __init__(__self__, *,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 table_arn: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] partition_keys: Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        :param pulumi.Input[str] table_arn: ARN of the table which is queried with the largest time range.
        :param pulumi.Input[float] value: Maximum duration in nanoseconds between the start and end of the query.
        """
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        """
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "partition_keys", value)

    @property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the table which is queried with the largest time range.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_arn", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict']]]]
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]] maxes: Insights into the most sub-optimal performing table on the temporal axis:
        """
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]:
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict(TypedDict):
        table_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the table which is queried with the largest time range.
        """
        value: NotRequired[pulumi.Input[int]]
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
elif False:
    ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryLastRunSummaryQueryInsightsResponseQueryTemporalRangeMaxisArgs:
    def __init__(__self__, *,
                 table_arn: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] table_arn: ARN of the table which is queried with the largest time range.
        :param pulumi.Input[int] value: Maximum duration in nanoseconds between the start and end of the query.
        """
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the table which is queried with the largest time range.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_arn", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryNotificationConfigurationArgsDict(TypedDict):
        sns_configuration: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict']
        """
        Configuration block for details about the Amazon Simple Notification Service (SNS) configuration. See below.
        """
elif False:
    ScheduledQueryNotificationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryNotificationConfigurationArgs:
    def __init__(__self__, *,
                 sns_configuration: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']):
        """
        :param pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs'] sns_configuration: Configuration block for details about the Amazon Simple Notification Service (SNS) configuration. See below.
        """
        pulumi.set(__self__, "sns_configuration", sns_configuration)

    @property
    @pulumi.getter(name="snsConfiguration")
    def sns_configuration(self) -> pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']:
        """
        Configuration block for details about the Amazon Simple Notification Service (SNS) configuration. See below.
        """
        return pulumi.get(self, "sns_configuration")

    @sns_configuration.setter
    def sns_configuration(self, value: pulumi.Input['ScheduledQueryNotificationConfigurationSnsConfigurationArgs']):
        pulumi.set(self, "sns_configuration", value)


if not MYPY:
    class ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict(TypedDict):
        topic_arn: pulumi.Input[str]
        """
        SNS topic ARN that the scheduled query status notifications will be sent to.
        """
elif False:
    ScheduledQueryNotificationConfigurationSnsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryNotificationConfigurationSnsConfigurationArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] topic_arn: SNS topic ARN that the scheduled query status notifications will be sent to.
        """
        pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[str]:
        """
        SNS topic ARN that the scheduled query status notifications will be sent to.
        """
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_arn", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunArgsDict(TypedDict):
        error_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict']]]]
        """
        S3 location for error report.
        """
        execution_stats: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgsDict']]]]
        """
        Statistics for a single scheduled query run.
        """
        failure_reason: NotRequired[pulumi.Input[str]]
        """
        Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        """
        invocation_time: NotRequired[pulumi.Input[str]]
        """
        InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        """
        query_insights_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict']]]]
        """
        Various insights and metrics related to the run summary of the scheduled query.
        """
        run_status: NotRequired[pulumi.Input[str]]
        """
        Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        """
        trigger_time: NotRequired[pulumi.Input[str]]
        """
        Actual time when the query was run.
        """
elif False:
    ScheduledQueryRecentlyFailedRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunArgs:
    def __init__(__self__, *,
                 error_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]] = None,
                 execution_stats: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 invocation_time: Optional[pulumi.Input[str]] = None,
                 query_insights_responses: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]] = None,
                 run_status: Optional[pulumi.Input[str]] = None,
                 trigger_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]] error_report_locations: S3 location for error report.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]] execution_stats: Statistics for a single scheduled query run.
        :param pulumi.Input[str] failure_reason: Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        :param pulumi.Input[str] invocation_time: InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]] query_insights_responses: Various insights and metrics related to the run summary of the scheduled query.
        :param pulumi.Input[str] run_status: Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        :param pulumi.Input[str] trigger_time: Actual time when the query was run.
        """
        if error_report_locations is not None:
            pulumi.set(__self__, "error_report_locations", error_report_locations)
        if execution_stats is not None:
            pulumi.set(__self__, "execution_stats", execution_stats)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if invocation_time is not None:
            pulumi.set(__self__, "invocation_time", invocation_time)
        if query_insights_responses is not None:
            pulumi.set(__self__, "query_insights_responses", query_insights_responses)
        if run_status is not None:
            pulumi.set(__self__, "run_status", run_status)
        if trigger_time is not None:
            pulumi.set(__self__, "trigger_time", trigger_time)

    @property
    @pulumi.getter(name="errorReportLocations")
    def error_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]]:
        """
        S3 location for error report.
        """
        return pulumi.get(self, "error_report_locations")

    @error_report_locations.setter
    def error_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationArgs']]]]):
        pulumi.set(self, "error_report_locations", value)

    @property
    @pulumi.getter(name="executionStats")
    def execution_stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]]:
        """
        Statistics for a single scheduled query run.
        """
        return pulumi.get(self, "execution_stats")

    @execution_stats.setter
    def execution_stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunExecutionStatArgs']]]]):
        pulumi.set(self, "execution_stats", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="invocationTime")
    def invocation_time(self) -> Optional[pulumi.Input[str]]:
        """
        InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter `@scheduled_runtime` can be used in the query to get the value.
        """
        return pulumi.get(self, "invocation_time")

    @invocation_time.setter
    def invocation_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_time", value)

    @property
    @pulumi.getter(name="queryInsightsResponses")
    def query_insights_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]]:
        """
        Various insights and metrics related to the run summary of the scheduled query.
        """
        return pulumi.get(self, "query_insights_responses")

    @query_insights_responses.setter
    def query_insights_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs']]]]):
        pulumi.set(self, "query_insights_responses", value)

    @property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of a scheduled query run. Valid values: `AUTO_TRIGGER_SUCCESS`, `AUTO_TRIGGER_FAILURE`, `MANUAL_TRIGGER_SUCCESS`, `MANUAL_TRIGGER_FAILURE`.
        """
        return pulumi.get(self, "run_status")

    @run_status.setter
    def run_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_status", value)

    @property
    @pulumi.getter(name="triggerTime")
    def trigger_time(self) -> Optional[pulumi.Input[str]]:
        """
        Actual time when the query was run.
        """
        return pulumi.get(self, "trigger_time")

    @trigger_time.setter
    def trigger_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_time", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict(TypedDict):
        s3_report_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict']]]]
        """
        S3 location where error reports are written.
        """
elif False:
    ScheduledQueryRecentlyFailedRunErrorReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunErrorReportLocationArgs:
    def __init__(__self__, *,
                 s3_report_locations: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]] s3_report_locations: S3 location where error reports are written.
        """
        if s3_report_locations is not None:
            pulumi.set(__self__, "s3_report_locations", s3_report_locations)

    @property
    @pulumi.getter(name="s3ReportLocations")
    def s3_report_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]]:
        """
        S3 location where error reports are written.
        """
        return pulumi.get(self, "s3_report_locations")

    @s3_report_locations.setter
    def s3_report_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs']]]]):
        pulumi.set(self, "s3_report_locations", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        S3 bucket name.
        """
        object_key: NotRequired[pulumi.Input[str]]
        """
        S3 key.
        """
elif False:
    ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunErrorReportLocationS3ReportLocationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 object_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: S3 bucket name.
        :param pulumi.Input[str] object_key: S3 key.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        S3 bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[pulumi.Input[str]]:
        """
        S3 key.
        """
        return pulumi.get(self, "object_key")

    @object_key.setter
    def object_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunExecutionStatArgsDict(TypedDict):
        bytes_metered: NotRequired[pulumi.Input[int]]
        """
        Bytes metered for a single scheduled query run.
        """
        cumulative_bytes_scanned: NotRequired[pulumi.Input[int]]
        """
        Bytes scanned for a single scheduled query run.
        """
        data_writes: NotRequired[pulumi.Input[int]]
        """
        Data writes metered for records ingested in a single scheduled query run.
        """
        execution_time_in_millis: NotRequired[pulumi.Input[int]]
        """
        Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        """
        query_result_rows: NotRequired[pulumi.Input[int]]
        """
        Number of rows present in the output from running a query before ingestion to destination data source.
        """
        records_ingested: NotRequired[pulumi.Input[int]]
        """
        Number of records ingested for a single scheduled query run.
        """
elif False:
    ScheduledQueryRecentlyFailedRunExecutionStatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunExecutionStatArgs:
    def __init__(__self__, *,
                 bytes_metered: Optional[pulumi.Input[int]] = None,
                 cumulative_bytes_scanned: Optional[pulumi.Input[int]] = None,
                 data_writes: Optional[pulumi.Input[int]] = None,
                 execution_time_in_millis: Optional[pulumi.Input[int]] = None,
                 query_result_rows: Optional[pulumi.Input[int]] = None,
                 records_ingested: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bytes_metered: Bytes metered for a single scheduled query run.
        :param pulumi.Input[int] cumulative_bytes_scanned: Bytes scanned for a single scheduled query run.
        :param pulumi.Input[int] data_writes: Data writes metered for records ingested in a single scheduled query run.
        :param pulumi.Input[int] execution_time_in_millis: Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        :param pulumi.Input[int] query_result_rows: Number of rows present in the output from running a query before ingestion to destination data source.
        :param pulumi.Input[int] records_ingested: Number of records ingested for a single scheduled query run.
        """
        if bytes_metered is not None:
            pulumi.set(__self__, "bytes_metered", bytes_metered)
        if cumulative_bytes_scanned is not None:
            pulumi.set(__self__, "cumulative_bytes_scanned", cumulative_bytes_scanned)
        if data_writes is not None:
            pulumi.set(__self__, "data_writes", data_writes)
        if execution_time_in_millis is not None:
            pulumi.set(__self__, "execution_time_in_millis", execution_time_in_millis)
        if query_result_rows is not None:
            pulumi.set(__self__, "query_result_rows", query_result_rows)
        if records_ingested is not None:
            pulumi.set(__self__, "records_ingested", records_ingested)

    @property
    @pulumi.getter(name="bytesMetered")
    def bytes_metered(self) -> Optional[pulumi.Input[int]]:
        """
        Bytes metered for a single scheduled query run.
        """
        return pulumi.get(self, "bytes_metered")

    @bytes_metered.setter
    def bytes_metered(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_metered", value)

    @property
    @pulumi.getter(name="cumulativeBytesScanned")
    def cumulative_bytes_scanned(self) -> Optional[pulumi.Input[int]]:
        """
        Bytes scanned for a single scheduled query run.
        """
        return pulumi.get(self, "cumulative_bytes_scanned")

    @cumulative_bytes_scanned.setter
    def cumulative_bytes_scanned(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cumulative_bytes_scanned", value)

    @property
    @pulumi.getter(name="dataWrites")
    def data_writes(self) -> Optional[pulumi.Input[int]]:
        """
        Data writes metered for records ingested in a single scheduled query run.
        """
        return pulumi.get(self, "data_writes")

    @data_writes.setter
    def data_writes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_writes", value)

    @property
    @pulumi.getter(name="executionTimeInMillis")
    def execution_time_in_millis(self) -> Optional[pulumi.Input[int]]:
        """
        Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        """
        return pulumi.get(self, "execution_time_in_millis")

    @execution_time_in_millis.setter
    def execution_time_in_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "execution_time_in_millis", value)

    @property
    @pulumi.getter(name="queryResultRows")
    def query_result_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Number of rows present in the output from running a query before ingestion to destination data source.
        """
        return pulumi.get(self, "query_result_rows")

    @query_result_rows.setter
    def query_result_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_result_rows", value)

    @property
    @pulumi.getter(name="recordsIngested")
    def records_ingested(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records ingested for a single scheduled query run.
        """
        return pulumi.get(self, "records_ingested")

    @records_ingested.setter
    def records_ingested(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "records_ingested", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict(TypedDict):
        output_bytes: NotRequired[pulumi.Input[int]]
        """
        Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        """
        output_rows: NotRequired[pulumi.Input[int]]
        """
        Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        """
        query_spatial_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict']]]]
        """
        Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        """
        query_table_count: NotRequired[pulumi.Input[int]]
        """
        Number of tables in the query.
        """
        query_temporal_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict']]]]
        """
        Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseArgs:
    def __init__(__self__, *,
                 output_bytes: Optional[pulumi.Input[int]] = None,
                 output_rows: Optional[pulumi.Input[int]] = None,
                 query_spatial_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]] = None,
                 query_table_count: Optional[pulumi.Input[int]] = None,
                 query_temporal_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]] = None):
        """
        :param pulumi.Input[int] output_bytes: Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        :param pulumi.Input[int] output_rows: Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]] query_spatial_coverages: Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        :param pulumi.Input[int] query_table_count: Number of tables in the query.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]] query_temporal_ranges: Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
        if output_bytes is not None:
            pulumi.set(__self__, "output_bytes", output_bytes)
        if output_rows is not None:
            pulumi.set(__self__, "output_rows", output_rows)
        if query_spatial_coverages is not None:
            pulumi.set(__self__, "query_spatial_coverages", query_spatial_coverages)
        if query_table_count is not None:
            pulumi.set(__self__, "query_table_count", query_table_count)
        if query_temporal_ranges is not None:
            pulumi.set(__self__, "query_temporal_ranges", query_temporal_ranges)

    @property
    @pulumi.getter(name="outputBytes")
    def output_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
        """
        return pulumi.get(self, "output_bytes")

    @output_bytes.setter
    def output_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_bytes", value)

    @property
    @pulumi.getter(name="outputRows")
    def output_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
        """
        return pulumi.get(self, "output_rows")

    @output_rows.setter
    def output_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_rows", value)

    @property
    @pulumi.getter(name="querySpatialCoverages")
    def query_spatial_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]]:
        """
        Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
        """
        return pulumi.get(self, "query_spatial_coverages")

    @query_spatial_coverages.setter
    def query_spatial_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs']]]]):
        pulumi.set(self, "query_spatial_coverages", value)

    @property
    @pulumi.getter(name="queryTableCount")
    def query_table_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of tables in the query.
        """
        return pulumi.get(self, "query_table_count")

    @query_table_count.setter
    def query_table_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_table_count", value)

    @property
    @pulumi.getter(name="queryTemporalRanges")
    def query_temporal_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]]:
        """
        Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
        """
        return pulumi.get(self, "query_temporal_ranges")

    @query_temporal_ranges.setter
    def query_temporal_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs']]]]):
        pulumi.set(self, "query_temporal_ranges", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict']]]]
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]] maxes: Insights into the most sub-optimal performing table on the temporal axis:
        """
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]:
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict(TypedDict):
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        """
        table_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the table which is queried with the largest time range.
        """
        value: NotRequired[pulumi.Input[float]]
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverageMaxisArgs:
    def __init__(__self__, *,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 table_arn: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] partition_keys: Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        :param pulumi.Input[str] table_arn: ARN of the table which is queried with the largest time range.
        :param pulumi.Input[float] value: Maximum duration in nanoseconds between the start and end of the query.
        """
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Partition key used for partitioning, which can be a default measure_name or a customer defined partition key.
        """
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "partition_keys", value)

    @property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the table which is queried with the largest time range.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_arn", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict(TypedDict):
        maxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict']]]]
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeArgs:
    def __init__(__self__, *,
                 maxes: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]] maxes: Insights into the most sub-optimal performing table on the temporal axis:
        """
        if maxes is not None:
            pulumi.set(__self__, "maxes", maxes)

    @property
    @pulumi.getter
    def maxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]:
        """
        Insights into the most sub-optimal performing table on the temporal axis:
        """
        return pulumi.get(self, "maxes")

    @maxes.setter
    def maxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs']]]]):
        pulumi.set(self, "maxes", value)


if not MYPY:
    class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict(TypedDict):
        table_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the table which is queried with the largest time range.
        """
        value: NotRequired[pulumi.Input[int]]
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
elif False:
    ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRangeMaxisArgs:
    def __init__(__self__, *,
                 table_arn: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] table_arn: ARN of the table which is queried with the largest time range.
        :param pulumi.Input[int] value: Maximum duration in nanoseconds between the start and end of the query.
        """
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the table which is queried with the largest time range.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_arn", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration in nanoseconds between the start and end of the query.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduledQueryScheduleConfigurationArgsDict(TypedDict):
        schedule_expression: pulumi.Input[str]
        """
        When to trigger the scheduled query run. This can be a cron expression or a rate expression.
        """
elif False:
    ScheduledQueryScheduleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryScheduleConfigurationArgs:
    def __init__(__self__, *,
                 schedule_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] schedule_expression: When to trigger the scheduled query run. This can be a cron expression or a rate expression.
        """
        pulumi.set(__self__, "schedule_expression", schedule_expression)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> pulumi.Input[str]:
        """
        When to trigger the scheduled query run. This can be a cron expression or a rate expression.
        """
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_expression", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationArgsDict(TypedDict):
        timestream_configuration: NotRequired[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict']]
        """
        Configuration block for information needed to write data into the Timestream database and table. See below.
        """
elif False:
    ScheduledQueryTargetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationArgs:
    def __init__(__self__, *,
                 timestream_configuration: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']] = None):
        """
        :param pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs'] timestream_configuration: Configuration block for information needed to write data into the Timestream database and table. See below.
        """
        if timestream_configuration is not None:
            pulumi.set(__self__, "timestream_configuration", timestream_configuration)

    @property
    @pulumi.getter(name="timestreamConfiguration")
    def timestream_configuration(self) -> Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']]:
        """
        Configuration block for information needed to write data into the Timestream database and table. See below.
        """
        return pulumi.get(self, "timestream_configuration")

    @timestream_configuration.setter
    def timestream_configuration(self, value: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationArgs']]):
        pulumi.set(self, "timestream_configuration", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of Timestream database to which the query result will be written.
        """
        table_name: pulumi.Input[str]
        """
        Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        """
        time_column: pulumi.Input[str]
        """
        Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        """
        dimension_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict']]]]
        """
        Configuration block for mapping of column(s) from the query result to the dimension in the destination table. See below.
        """
        measure_name_column: NotRequired[pulumi.Input[str]]
        """
        Name of the measure column.
        """
        mixed_measure_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict']]]]
        """
        Configuration block for how to map measures to multi-measure records. See below.
        """
        multi_measure_mappings: NotRequired[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict']]
        """
        Configuration block for multi-measure mappings. Only one of `mixed_measure_mappings` or `multi_measure_mappings` can be provided. `multi_measure_mappings` can be used to ingest data as multi measures in the derived table. See below.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 time_column: pulumi.Input[str],
                 dimension_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]] = None,
                 measure_name_column: Optional[pulumi.Input[str]] = None,
                 mixed_measure_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]] = None,
                 multi_measure_mappings: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']] = None):
        """
        :param pulumi.Input[str] database_name: Name of Timestream database to which the query result will be written.
        :param pulumi.Input[str] table_name: Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        :param pulumi.Input[str] time_column: Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]] dimension_mappings: Configuration block for mapping of column(s) from the query result to the dimension in the destination table. See below.
        :param pulumi.Input[str] measure_name_column: Name of the measure column.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]] mixed_measure_mappings: Configuration block for how to map measures to multi-measure records. See below.
        :param pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs'] multi_measure_mappings: Configuration block for multi-measure mappings. Only one of `mixed_measure_mappings` or `multi_measure_mappings` can be provided. `multi_measure_mappings` can be used to ingest data as multi measures in the derived table. See below.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "time_column", time_column)
        if dimension_mappings is not None:
            pulumi.set(__self__, "dimension_mappings", dimension_mappings)
        if measure_name_column is not None:
            pulumi.set(__self__, "measure_name_column", measure_name_column)
        if mixed_measure_mappings is not None:
            pulumi.set(__self__, "mixed_measure_mappings", mixed_measure_mappings)
        if multi_measure_mappings is not None:
            pulumi.set(__self__, "multi_measure_mappings", multi_measure_mappings)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of Timestream database to which the query result will be written.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="timeColumn")
    def time_column(self) -> pulumi.Input[str]:
        """
        Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        """
        return pulumi.get(self, "time_column")

    @time_column.setter
    def time_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_column", value)

    @property
    @pulumi.getter(name="dimensionMappings")
    def dimension_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]]:
        """
        Configuration block for mapping of column(s) from the query result to the dimension in the destination table. See below.
        """
        return pulumi.get(self, "dimension_mappings")

    @dimension_mappings.setter
    def dimension_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs']]]]):
        pulumi.set(self, "dimension_mappings", value)

    @property
    @pulumi.getter(name="measureNameColumn")
    def measure_name_column(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the measure column.
        """
        return pulumi.get(self, "measure_name_column")

    @measure_name_column.setter
    def measure_name_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measure_name_column", value)

    @property
    @pulumi.getter(name="mixedMeasureMappings")
    def mixed_measure_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]]:
        """
        Configuration block for how to map measures to multi-measure records. See below.
        """
        return pulumi.get(self, "mixed_measure_mappings")

    @mixed_measure_mappings.setter
    def mixed_measure_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs']]]]):
        pulumi.set(self, "mixed_measure_mappings", value)

    @property
    @pulumi.getter(name="multiMeasureMappings")
    def multi_measure_mappings(self) -> Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']]:
        """
        Configuration block for multi-measure mappings. Only one of `mixed_measure_mappings` or `multi_measure_mappings` can be provided. `multi_measure_mappings` can be used to ingest data as multi measures in the derived table. See below.
        """
        return pulumi.get(self, "multi_measure_mappings")

    @multi_measure_mappings.setter
    def multi_measure_mappings(self, value: Optional[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs']]):
        pulumi.set(self, "multi_measure_mappings", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict(TypedDict):
        dimension_value_type: pulumi.Input[str]
        """
        Type for the dimension. Valid value: `VARCHAR`.
        """
        name: pulumi.Input[str]
        """
        Column name from query result.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs:
    def __init__(__self__, *,
                 dimension_value_type: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dimension_value_type: Type for the dimension. Valid value: `VARCHAR`.
        :param pulumi.Input[str] name: Column name from query result.
        """
        pulumi.set(__self__, "dimension_value_type", dimension_value_type)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dimensionValueType")
    def dimension_value_type(self) -> pulumi.Input[str]:
        """
        Type for the dimension. Valid value: `VARCHAR`.
        """
        return pulumi.get(self, "dimension_value_type")

    @dimension_value_type.setter
    def dimension_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension_value_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Column name from query result.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[str]
        """
        Type of the value that is to be read from `source_column`. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `MULTI`.
        """
        measure_name: NotRequired[pulumi.Input[str]]
        """
        Refers to the value of measure_name in a result row. This field is required if `measure_name_column` is provided.
        """
        multi_measure_attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict']]]]
        """
        Configuration block for attribute mappings for `MULTI` value measures. Required when `measure_value_type` is `MULTI`. See below.
        """
        source_column: NotRequired[pulumi.Input[str]]
        """
        Source column from which measure-value is to be read for result materialization.
        """
        target_measure_name: NotRequired[pulumi.Input[str]]
        """
        Target measure name to be used. If not provided, the target measure name by default is `measure_name`, if provided, or `source_column` otherwise.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[str],
                 measure_name: Optional[pulumi.Input[str]] = None,
                 multi_measure_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]] = None,
                 source_column: Optional[pulumi.Input[str]] = None,
                 target_measure_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] measure_value_type: Type of the value that is to be read from `source_column`. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `MULTI`.
        :param pulumi.Input[str] measure_name: Refers to the value of measure_name in a result row. This field is required if `measure_name_column` is provided.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]] multi_measure_attribute_mappings: Configuration block for attribute mappings for `MULTI` value measures. Required when `measure_value_type` is `MULTI`. See below.
        :param pulumi.Input[str] source_column: Source column from which measure-value is to be read for result materialization.
        :param pulumi.Input[str] target_measure_name: Target measure name to be used. If not provided, the target measure name by default is `measure_name`, if provided, or `source_column` otherwise.
        """
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        if measure_name is not None:
            pulumi.set(__self__, "measure_name", measure_name)
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if source_column is not None:
            pulumi.set(__self__, "source_column", source_column)
        if target_measure_name is not None:
            pulumi.set(__self__, "target_measure_name", target_measure_name)

    @property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[str]:
        """
        Type of the value that is to be read from `source_column`. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `MULTI`.
        """
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure_value_type", value)

    @property
    @pulumi.getter(name="measureName")
    def measure_name(self) -> Optional[pulumi.Input[str]]:
        """
        Refers to the value of measure_name in a result row. This field is required if `measure_name_column` is provided.
        """
        return pulumi.get(self, "measure_name")

    @measure_name.setter
    def measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measure_name", value)

    @property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]]:
        """
        Configuration block for attribute mappings for `MULTI` value measures. Required when `measure_value_type` is `MULTI`. See below.
        """
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs']]]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional[pulumi.Input[str]]:
        """
        Source column from which measure-value is to be read for result materialization.
        """
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_column", value)

    @property
    @pulumi.getter(name="targetMeasureName")
    def target_measure_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target measure name to be used. If not provided, the target measure name by default is `measure_name`, if provided, or `source_column` otherwise.
        """
        return pulumi.get(self, "target_measure_name")

    @target_measure_name.setter
    def target_measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_measure_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[str]
        """
        Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        """
        source_column: pulumi.Input[str]
        """
        Source column from where the attribute value is to be read.
        """
        target_multi_measure_attribute_name: NotRequired[pulumi.Input[str]]
        """
        Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMixedMeasureMappingMultiMeasureAttributeMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[str],
                 source_column: pulumi.Input[str],
                 target_multi_measure_attribute_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] measure_value_type: Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        :param pulumi.Input[str] source_column: Source column from where the attribute value is to be read.
        :param pulumi.Input[str] target_multi_measure_attribute_name: Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[str]:
        """
        Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        """
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure_value_type", value)

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> pulumi.Input[str]:
        """
        Source column from where the attribute value is to be read.
        """
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_column", value)

    @property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
        return pulumi.get(self, "target_multi_measure_attribute_name")

    @target_multi_measure_attribute_name.setter
    def target_multi_measure_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_multi_measure_attribute_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict(TypedDict):
        multi_measure_attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict']]]]
        """
        Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes. See above.
        """
        target_multi_measure_name: NotRequired[pulumi.Input[str]]
        """
        Name of the target multi-measure name in the derived table. This input is required when `measure_name_column` is not provided. If `measure_name_column` is provided, then the value from that column will be used as the multi-measure name.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs:
    def __init__(__self__, *,
                 multi_measure_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]] = None,
                 target_multi_measure_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]] multi_measure_attribute_mappings: Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes. See above.
        :param pulumi.Input[str] target_multi_measure_name: Name of the target multi-measure name in the derived table. This input is required when `measure_name_column` is not provided. If `measure_name_column` is provided, then the value from that column will be used as the multi-measure name.
        """
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if target_multi_measure_name is not None:
            pulumi.set(__self__, "target_multi_measure_name", target_multi_measure_name)

    @property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]]:
        """
        Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes. See above.
        """
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs']]]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @property
    @pulumi.getter(name="targetMultiMeasureName")
    def target_multi_measure_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target multi-measure name in the derived table. This input is required when `measure_name_column` is not provided. If `measure_name_column` is provided, then the value from that column will be used as the multi-measure name.
        """
        return pulumi.get(self, "target_multi_measure_name")

    @target_multi_measure_name.setter
    def target_multi_measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_multi_measure_name", value)


if not MYPY:
    class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict(TypedDict):
        measure_value_type: pulumi.Input[str]
        """
        Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        """
        source_column: pulumi.Input[str]
        """
        Source column from where the attribute value is to be read.
        """
        target_multi_measure_attribute_name: NotRequired[pulumi.Input[str]]
        """
        Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
elif False:
    ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input[str],
                 source_column: pulumi.Input[str],
                 target_multi_measure_attribute_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] measure_value_type: Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        :param pulumi.Input[str] source_column: Source column from where the attribute value is to be read.
        :param pulumi.Input[str] target_multi_measure_attribute_name: Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input[str]:
        """
        Type of the attribute to be read from the source column. Valid values are `BIGINT`, `BOOLEAN`, `DOUBLE`, `VARCHAR`, `TIMESTAMP`.
        """
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure_value_type", value)

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> pulumi.Input[str]:
        """
        Source column from where the attribute value is to be read.
        """
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_column", value)

    @property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom name to be used for attribute name in derived table. If not provided, `source_column` is used.
        """
        return pulumi.get(self, "target_multi_measure_attribute_name")

    @target_multi_measure_attribute_name.setter
    def target_multi_measure_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_multi_measure_attribute_name", value)


if not MYPY:
    class ScheduledQueryTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ScheduledQueryTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


