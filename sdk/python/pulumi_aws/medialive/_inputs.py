# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ChannelCdiInputSpecificationArgs',
    'ChannelDestinationArgs',
    'ChannelDestinationMediaPackageSettingArgs',
    'ChannelDestinationMultiplexSettingsArgs',
    'ChannelDestinationSettingArgs',
    'ChannelEncoderSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionArgs',
    'ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs',
    'ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs',
    'ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs',
    'ChannelEncoderSettingsAvailBlankingArgs',
    'ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs',
    'ChannelEncoderSettingsCaptionDescriptionArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs',
    'ChannelEncoderSettingsGlobalConfigurationArgs',
    'ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs',
    'ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs',
    'ChannelEncoderSettingsMotionGraphicsConfigurationArgs',
    'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs',
    'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs',
    'ChannelEncoderSettingsNielsenConfigurationArgs',
    'ChannelEncoderSettingsOutputGroupArgs',
    'ChannelEncoderSettingsOutputGroupOutputArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs',
    'ChannelEncoderSettingsTimecodeConfigArgs',
    'ChannelEncoderSettingsVideoDescriptionArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs',
    'ChannelInputAttachmentArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs',
    'ChannelInputAttachmentInputSettingsArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs',
    'ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs',
    'ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs',
    'ChannelInputAttachmentInputSettingsVideoSelectorArgs',
    'ChannelInputSpecificationArgs',
    'ChannelMaintenanceArgs',
    'ChannelVpcArgs',
    'InputDestinationArgs',
    'InputInputDeviceArgs',
    'InputMediaConnectFlowArgs',
    'InputSecurityGroupWhitelistRuleArgs',
    'InputSourceArgs',
    'InputVpcArgs',
    'MultiplexMultiplexSettingsArgs',
    'MultiplexProgramMultiplexProgramSettingsArgs',
    'MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs',
    'MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs',
    'MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs',
]

@pulumi.input_type
class ChannelCdiInputSpecificationArgs:
    def __init__(__self__, *,
                 resolution: pulumi.Input[str]):
        """
        :param pulumi.Input[str] resolution: Maximum CDI input resolution.
        """
        ChannelCdiInputSpecificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolution: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resolution is None:
            raise TypeError("Missing 'resolution' argument")

        _setter("resolution", resolution)

    @property
    @pulumi.getter
    def resolution(self) -> pulumi.Input[str]:
        """
        Maximum CDI input resolution.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input[str]):
        pulumi.set(self, "resolution", value)


@pulumi.input_type
class ChannelDestinationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 media_package_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationMediaPackageSettingArgs']]]] = None,
                 multiplex_settings: Optional[pulumi.Input['ChannelDestinationMultiplexSettingsArgs']] = None,
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationSettingArgs']]]] = None):
        """
        :param pulumi.Input[str] id: User-specified id. Ths is used in an output group or an output.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelDestinationMediaPackageSettingArgs']]] media_package_settings: Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
        :param pulumi.Input['ChannelDestinationMultiplexSettingsArgs'] multiplex_settings: Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelDestinationSettingArgs']]] settings: Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
        """
        ChannelDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            media_package_settings=media_package_settings,
            multiplex_settings=multiplex_settings,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             media_package_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationMediaPackageSettingArgs']]]] = None,
             multiplex_settings: Optional[pulumi.Input['ChannelDestinationMultiplexSettingsArgs']] = None,
             settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationSettingArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if media_package_settings is None and 'mediaPackageSettings' in kwargs:
            media_package_settings = kwargs['mediaPackageSettings']
        if multiplex_settings is None and 'multiplexSettings' in kwargs:
            multiplex_settings = kwargs['multiplexSettings']

        _setter("id", id)
        if media_package_settings is not None:
            _setter("media_package_settings", media_package_settings)
        if multiplex_settings is not None:
            _setter("multiplex_settings", multiplex_settings)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        User-specified id. Ths is used in an output group or an output.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="mediaPackageSettings")
    def media_package_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationMediaPackageSettingArgs']]]]:
        """
        Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
        """
        return pulumi.get(self, "media_package_settings")

    @media_package_settings.setter
    def media_package_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationMediaPackageSettingArgs']]]]):
        pulumi.set(self, "media_package_settings", value)

    @property
    @pulumi.getter(name="multiplexSettings")
    def multiplex_settings(self) -> Optional[pulumi.Input['ChannelDestinationMultiplexSettingsArgs']]:
        """
        Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
        """
        return pulumi.get(self, "multiplex_settings")

    @multiplex_settings.setter
    def multiplex_settings(self, value: Optional[pulumi.Input['ChannelDestinationMultiplexSettingsArgs']]):
        pulumi.set(self, "multiplex_settings", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationSettingArgs']]]]:
        """
        Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelDestinationSettingArgs']]]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ChannelDestinationMediaPackageSettingArgs:
    def __init__(__self__, *,
                 channel_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] channel_id: ID of the channel in MediaPackage that is the destination for this output group.
        """
        ChannelDestinationMediaPackageSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_id=channel_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_id is None and 'channelId' in kwargs:
            channel_id = kwargs['channelId']
        if channel_id is None:
            raise TypeError("Missing 'channel_id' argument")

        _setter("channel_id", channel_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Input[str]:
        """
        ID of the channel in MediaPackage that is the destination for this output group.
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel_id", value)


@pulumi.input_type
class ChannelDestinationMultiplexSettingsArgs:
    def __init__(__self__, *,
                 multiplex_id: pulumi.Input[str],
                 program_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] multiplex_id: The ID of the Multiplex that the encoder is providing output to.
        :param pulumi.Input[str] program_name: The program name of the Multiplex program that the encoder is providing output to.
        """
        ChannelDestinationMultiplexSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            multiplex_id=multiplex_id,
            program_name=program_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             multiplex_id: Optional[pulumi.Input[str]] = None,
             program_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if multiplex_id is None and 'multiplexId' in kwargs:
            multiplex_id = kwargs['multiplexId']
        if multiplex_id is None:
            raise TypeError("Missing 'multiplex_id' argument")
        if program_name is None and 'programName' in kwargs:
            program_name = kwargs['programName']
        if program_name is None:
            raise TypeError("Missing 'program_name' argument")

        _setter("multiplex_id", multiplex_id)
        _setter("program_name", program_name)

    @property
    @pulumi.getter(name="multiplexId")
    def multiplex_id(self) -> pulumi.Input[str]:
        """
        The ID of the Multiplex that the encoder is providing output to.
        """
        return pulumi.get(self, "multiplex_id")

    @multiplex_id.setter
    def multiplex_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "multiplex_id", value)

    @property
    @pulumi.getter(name="programName")
    def program_name(self) -> pulumi.Input[str]:
        """
        The program name of the Multiplex program that the encoder is providing output to.
        """
        return pulumi.get(self, "program_name")

    @program_name.setter
    def program_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "program_name", value)


@pulumi.input_type
class ChannelDestinationSettingArgs:
    def __init__(__self__, *,
                 password_param: Optional[pulumi.Input[str]] = None,
                 stream_name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] stream_name: Stream name RTMP destinations (URLs of type rtmp://)
        :param pulumi.Input[str] url: A URL specifying a destination.
        :param pulumi.Input[str] username: Username for destination.
        """
        ChannelDestinationSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            stream_name=stream_name,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[pulumi.Input[str]] = None,
             stream_name: Optional[pulumi.Input[str]] = None,
             url: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']

        if password_param is not None:
            _setter("password_param", password_param)
        if stream_name is not None:
            _setter("stream_name", stream_name)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[pulumi.Input[str]]:
        """
        Stream name RTMP destinations (URLs of type rtmp://)
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL specifying a destination.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for destination.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsArgs:
    def __init__(__self__, *,
                 output_groups: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupArgs']]],
                 timecode_config: pulumi.Input['ChannelEncoderSettingsTimecodeConfigArgs'],
                 audio_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionArgs']]]] = None,
                 avail_blanking: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingArgs']] = None,
                 caption_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionArgs']]]] = None,
                 global_configuration: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationArgs']] = None,
                 motion_graphics_configuration: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationArgs']] = None,
                 nielsen_configuration: Optional[pulumi.Input['ChannelEncoderSettingsNielsenConfigurationArgs']] = None,
                 video_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsVideoDescriptionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupArgs']]] output_groups: Output groups for the channel. See Output Groups for more details.
        :param pulumi.Input['ChannelEncoderSettingsTimecodeConfigArgs'] timecode_config: Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionArgs']]] audio_descriptions: Audio descriptions for the channel. See Audio Descriptions for more details.
        :param pulumi.Input['ChannelEncoderSettingsAvailBlankingArgs'] avail_blanking: Settings for ad avail blanking. See Avail Blanking for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionArgs']]] caption_descriptions: Caption Descriptions. See Caption Descriptions for more details.
        :param pulumi.Input['ChannelEncoderSettingsGlobalConfigurationArgs'] global_configuration: Configuration settings that apply to the event as a whole. See Global Configuration for more details.
        :param pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationArgs'] motion_graphics_configuration: Settings for motion graphics. See Motion Graphics Configuration for more details.
        :param pulumi.Input['ChannelEncoderSettingsNielsenConfigurationArgs'] nielsen_configuration: Nielsen configuration settings. See Nielsen Configuration for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsVideoDescriptionArgs']]] video_descriptions: Video Descriptions. See Video Descriptions for more details.
        """
        ChannelEncoderSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_groups=output_groups,
            timecode_config=timecode_config,
            audio_descriptions=audio_descriptions,
            avail_blanking=avail_blanking,
            caption_descriptions=caption_descriptions,
            global_configuration=global_configuration,
            motion_graphics_configuration=motion_graphics_configuration,
            nielsen_configuration=nielsen_configuration,
            video_descriptions=video_descriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupArgs']]]] = None,
             timecode_config: Optional[pulumi.Input['ChannelEncoderSettingsTimecodeConfigArgs']] = None,
             audio_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionArgs']]]] = None,
             avail_blanking: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingArgs']] = None,
             caption_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionArgs']]]] = None,
             global_configuration: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationArgs']] = None,
             motion_graphics_configuration: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationArgs']] = None,
             nielsen_configuration: Optional[pulumi.Input['ChannelEncoderSettingsNielsenConfigurationArgs']] = None,
             video_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsVideoDescriptionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_groups is None and 'outputGroups' in kwargs:
            output_groups = kwargs['outputGroups']
        if output_groups is None:
            raise TypeError("Missing 'output_groups' argument")
        if timecode_config is None and 'timecodeConfig' in kwargs:
            timecode_config = kwargs['timecodeConfig']
        if timecode_config is None:
            raise TypeError("Missing 'timecode_config' argument")
        if audio_descriptions is None and 'audioDescriptions' in kwargs:
            audio_descriptions = kwargs['audioDescriptions']
        if avail_blanking is None and 'availBlanking' in kwargs:
            avail_blanking = kwargs['availBlanking']
        if caption_descriptions is None and 'captionDescriptions' in kwargs:
            caption_descriptions = kwargs['captionDescriptions']
        if global_configuration is None and 'globalConfiguration' in kwargs:
            global_configuration = kwargs['globalConfiguration']
        if motion_graphics_configuration is None and 'motionGraphicsConfiguration' in kwargs:
            motion_graphics_configuration = kwargs['motionGraphicsConfiguration']
        if nielsen_configuration is None and 'nielsenConfiguration' in kwargs:
            nielsen_configuration = kwargs['nielsenConfiguration']
        if video_descriptions is None and 'videoDescriptions' in kwargs:
            video_descriptions = kwargs['videoDescriptions']

        _setter("output_groups", output_groups)
        _setter("timecode_config", timecode_config)
        if audio_descriptions is not None:
            _setter("audio_descriptions", audio_descriptions)
        if avail_blanking is not None:
            _setter("avail_blanking", avail_blanking)
        if caption_descriptions is not None:
            _setter("caption_descriptions", caption_descriptions)
        if global_configuration is not None:
            _setter("global_configuration", global_configuration)
        if motion_graphics_configuration is not None:
            _setter("motion_graphics_configuration", motion_graphics_configuration)
        if nielsen_configuration is not None:
            _setter("nielsen_configuration", nielsen_configuration)
        if video_descriptions is not None:
            _setter("video_descriptions", video_descriptions)

    @property
    @pulumi.getter(name="outputGroups")
    def output_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupArgs']]]:
        """
        Output groups for the channel. See Output Groups for more details.
        """
        return pulumi.get(self, "output_groups")

    @output_groups.setter
    def output_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupArgs']]]):
        pulumi.set(self, "output_groups", value)

    @property
    @pulumi.getter(name="timecodeConfig")
    def timecode_config(self) -> pulumi.Input['ChannelEncoderSettingsTimecodeConfigArgs']:
        """
        Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
        """
        return pulumi.get(self, "timecode_config")

    @timecode_config.setter
    def timecode_config(self, value: pulumi.Input['ChannelEncoderSettingsTimecodeConfigArgs']):
        pulumi.set(self, "timecode_config", value)

    @property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionArgs']]]]:
        """
        Audio descriptions for the channel. See Audio Descriptions for more details.
        """
        return pulumi.get(self, "audio_descriptions")

    @audio_descriptions.setter
    def audio_descriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionArgs']]]]):
        pulumi.set(self, "audio_descriptions", value)

    @property
    @pulumi.getter(name="availBlanking")
    def avail_blanking(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingArgs']]:
        """
        Settings for ad avail blanking. See Avail Blanking for more details.
        """
        return pulumi.get(self, "avail_blanking")

    @avail_blanking.setter
    def avail_blanking(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingArgs']]):
        pulumi.set(self, "avail_blanking", value)

    @property
    @pulumi.getter(name="captionDescriptions")
    def caption_descriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionArgs']]]]:
        """
        Caption Descriptions. See Caption Descriptions for more details.
        """
        return pulumi.get(self, "caption_descriptions")

    @caption_descriptions.setter
    def caption_descriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionArgs']]]]):
        pulumi.set(self, "caption_descriptions", value)

    @property
    @pulumi.getter(name="globalConfiguration")
    def global_configuration(self) -> Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationArgs']]:
        """
        Configuration settings that apply to the event as a whole. See Global Configuration for more details.
        """
        return pulumi.get(self, "global_configuration")

    @global_configuration.setter
    def global_configuration(self, value: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationArgs']]):
        pulumi.set(self, "global_configuration", value)

    @property
    @pulumi.getter(name="motionGraphicsConfiguration")
    def motion_graphics_configuration(self) -> Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationArgs']]:
        """
        Settings for motion graphics. See Motion Graphics Configuration for more details.
        """
        return pulumi.get(self, "motion_graphics_configuration")

    @motion_graphics_configuration.setter
    def motion_graphics_configuration(self, value: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationArgs']]):
        pulumi.set(self, "motion_graphics_configuration", value)

    @property
    @pulumi.getter(name="nielsenConfiguration")
    def nielsen_configuration(self) -> Optional[pulumi.Input['ChannelEncoderSettingsNielsenConfigurationArgs']]:
        """
        Nielsen configuration settings. See Nielsen Configuration for more details.
        """
        return pulumi.get(self, "nielsen_configuration")

    @nielsen_configuration.setter
    def nielsen_configuration(self, value: Optional[pulumi.Input['ChannelEncoderSettingsNielsenConfigurationArgs']]):
        pulumi.set(self, "nielsen_configuration", value)

    @property
    @pulumi.getter(name="videoDescriptions")
    def video_descriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsVideoDescriptionArgs']]]]:
        """
        Video Descriptions. See Video Descriptions for more details.
        """
        return pulumi.get(self, "video_descriptions")

    @video_descriptions.setter
    def video_descriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsVideoDescriptionArgs']]]]):
        pulumi.set(self, "video_descriptions", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionArgs:
    def __init__(__self__, *,
                 audio_selector_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 audio_normalization_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs']] = None,
                 audio_type: Optional[pulumi.Input[str]] = None,
                 audio_type_control: Optional[pulumi.Input[str]] = None,
                 audio_watermark_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs']] = None,
                 codec_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs']] = None,
                 language_code: Optional[pulumi.Input[str]] = None,
                 language_code_control: Optional[pulumi.Input[str]] = None,
                 remix_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs']] = None,
                 stream_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audio_selector_name: The name of the audio selector used as the source for this AudioDescription.
        :param pulumi.Input[str] name: The name of this audio description.
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs'] audio_normalization_settings: Advanced audio normalization settings. See Audio Normalization Settings for more details.
        :param pulumi.Input[str] audio_type: Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
        :param pulumi.Input[str] audio_type_control: Determined how audio type is determined.
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs'] audio_watermark_settings: Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs'] codec_settings: Audio codec settings. See Audio Codec Settings for more details.
        :param pulumi.Input[str] language_code: Selects a specific three-letter language code from within an audio source.
        :param pulumi.Input[str] stream_name: Stream name RTMP destinations (URLs of type rtmp://)
        """
        ChannelEncoderSettingsAudioDescriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selector_name=audio_selector_name,
            name=name,
            audio_normalization_settings=audio_normalization_settings,
            audio_type=audio_type,
            audio_type_control=audio_type_control,
            audio_watermark_settings=audio_watermark_settings,
            codec_settings=codec_settings,
            language_code=language_code,
            language_code_control=language_code_control,
            remix_settings=remix_settings,
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selector_name: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             audio_normalization_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs']] = None,
             audio_type: Optional[pulumi.Input[str]] = None,
             audio_type_control: Optional[pulumi.Input[str]] = None,
             audio_watermark_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs']] = None,
             codec_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs']] = None,
             language_code: Optional[pulumi.Input[str]] = None,
             language_code_control: Optional[pulumi.Input[str]] = None,
             remix_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs']] = None,
             stream_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selector_name is None and 'audioSelectorName' in kwargs:
            audio_selector_name = kwargs['audioSelectorName']
        if audio_selector_name is None:
            raise TypeError("Missing 'audio_selector_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if audio_normalization_settings is None and 'audioNormalizationSettings' in kwargs:
            audio_normalization_settings = kwargs['audioNormalizationSettings']
        if audio_type is None and 'audioType' in kwargs:
            audio_type = kwargs['audioType']
        if audio_type_control is None and 'audioTypeControl' in kwargs:
            audio_type_control = kwargs['audioTypeControl']
        if audio_watermark_settings is None and 'audioWatermarkSettings' in kwargs:
            audio_watermark_settings = kwargs['audioWatermarkSettings']
        if codec_settings is None and 'codecSettings' in kwargs:
            codec_settings = kwargs['codecSettings']
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code_control is None and 'languageCodeControl' in kwargs:
            language_code_control = kwargs['languageCodeControl']
        if remix_settings is None and 'remixSettings' in kwargs:
            remix_settings = kwargs['remixSettings']
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']

        _setter("audio_selector_name", audio_selector_name)
        _setter("name", name)
        if audio_normalization_settings is not None:
            _setter("audio_normalization_settings", audio_normalization_settings)
        if audio_type is not None:
            _setter("audio_type", audio_type)
        if audio_type_control is not None:
            _setter("audio_type_control", audio_type_control)
        if audio_watermark_settings is not None:
            _setter("audio_watermark_settings", audio_watermark_settings)
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_code_control is not None:
            _setter("language_code_control", language_code_control)
        if remix_settings is not None:
            _setter("remix_settings", remix_settings)
        if stream_name is not None:
            _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> pulumi.Input[str]:
        """
        The name of the audio selector used as the source for this AudioDescription.
        """
        return pulumi.get(self, "audio_selector_name")

    @audio_selector_name.setter
    def audio_selector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "audio_selector_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of this audio description.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="audioNormalizationSettings")
    def audio_normalization_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs']]:
        """
        Advanced audio normalization settings. See Audio Normalization Settings for more details.
        """
        return pulumi.get(self, "audio_normalization_settings")

    @audio_normalization_settings.setter
    def audio_normalization_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs']]):
        pulumi.set(self, "audio_normalization_settings", value)

    @property
    @pulumi.getter(name="audioType")
    def audio_type(self) -> Optional[pulumi.Input[str]]:
        """
        Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
        """
        return pulumi.get(self, "audio_type")

    @audio_type.setter
    def audio_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_type", value)

    @property
    @pulumi.getter(name="audioTypeControl")
    def audio_type_control(self) -> Optional[pulumi.Input[str]]:
        """
        Determined how audio type is determined.
        """
        return pulumi.get(self, "audio_type_control")

    @audio_type_control.setter
    def audio_type_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_type_control", value)

    @property
    @pulumi.getter(name="audioWatermarkSettings")
    def audio_watermark_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs']]:
        """
        Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
        """
        return pulumi.get(self, "audio_watermark_settings")

    @audio_watermark_settings.setter
    def audio_watermark_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs']]):
        pulumi.set(self, "audio_watermark_settings", value)

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs']]:
        """
        Audio codec settings. See Audio Codec Settings for more details.
        """
        return pulumi.get(self, "codec_settings")

    @codec_settings.setter
    def codec_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs']]):
        pulumi.set(self, "codec_settings", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[str]]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "language_code_control")

    @language_code_control.setter
    def language_code_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code_control", value)

    @property
    @pulumi.getter(name="remixSettings")
    def remix_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs']]:
        return pulumi.get(self, "remix_settings")

    @remix_settings.setter
    def remix_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs']]):
        pulumi.set(self, "remix_settings", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[pulumi.Input[str]]:
        """
        Stream name RTMP destinations (URLs of type rtmp://)
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_name", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 algorithm_control: Optional[pulumi.Input[str]] = None,
                 target_lkfs: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] algorithm: Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
        :param pulumi.Input[str] algorithm_control: Algorithm control for the audio description.
        :param pulumi.Input[float] target_lkfs: Target LKFS (loudness) to adjust volume to.
        """
        ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            algorithm_control=algorithm_control,
            target_lkfs=target_lkfs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[str]] = None,
             algorithm_control: Optional[pulumi.Input[str]] = None,
             target_lkfs: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if algorithm_control is None and 'algorithmControl' in kwargs:
            algorithm_control = kwargs['algorithmControl']
        if target_lkfs is None and 'targetLkfs' in kwargs:
            target_lkfs = kwargs['targetLkfs']

        if algorithm is not None:
            _setter("algorithm", algorithm)
        if algorithm_control is not None:
            _setter("algorithm_control", algorithm_control)
        if target_lkfs is not None:
            _setter("target_lkfs", target_lkfs)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="algorithmControl")
    def algorithm_control(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm control for the audio description.
        """
        return pulumi.get(self, "algorithm_control")

    @algorithm_control.setter
    def algorithm_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm_control", value)

    @property
    @pulumi.getter(name="targetLkfs")
    def target_lkfs(self) -> Optional[pulumi.Input[float]]:
        """
        Target LKFS (loudness) to adjust volume to.
        """
        return pulumi.get(self, "target_lkfs")

    @target_lkfs.setter
    def target_lkfs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "target_lkfs", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs:
    def __init__(__self__, *,
                 nielsen_watermarks_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs']] = None):
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_watermarks_settings=nielsen_watermarks_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_watermarks_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if nielsen_watermarks_settings is None and 'nielsenWatermarksSettings' in kwargs:
            nielsen_watermarks_settings = kwargs['nielsenWatermarksSettings']

        if nielsen_watermarks_settings is not None:
            _setter("nielsen_watermarks_settings", nielsen_watermarks_settings)

    @property
    @pulumi.getter(name="nielsenWatermarksSettings")
    def nielsen_watermarks_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs']]:
        return pulumi.get(self, "nielsen_watermarks_settings")

    @nielsen_watermarks_settings.setter
    def nielsen_watermarks_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs']]):
        pulumi.set(self, "nielsen_watermarks_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs:
    def __init__(__self__, *,
                 nielsen_cbet_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs']] = None,
                 nielsen_distribution_type: Optional[pulumi.Input[str]] = None,
                 nielsen_naes_ii_nw_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs']]]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs'] nielsen_cbet_settings: Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
        :param pulumi.Input[str] nielsen_distribution_type: Distribution types to assign to the watermarks. Options are `PROGRAM_CONTENT` and `FINAL_DISTRIBUTOR`.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs']]] nielsen_naes_ii_nw_settings: Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_cbet_settings=nielsen_cbet_settings,
            nielsen_distribution_type=nielsen_distribution_type,
            nielsen_naes_ii_nw_settings=nielsen_naes_ii_nw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_cbet_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs']] = None,
             nielsen_distribution_type: Optional[pulumi.Input[str]] = None,
             nielsen_naes_ii_nw_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if nielsen_cbet_settings is None and 'nielsenCbetSettings' in kwargs:
            nielsen_cbet_settings = kwargs['nielsenCbetSettings']
        if nielsen_distribution_type is None and 'nielsenDistributionType' in kwargs:
            nielsen_distribution_type = kwargs['nielsenDistributionType']
        if nielsen_naes_ii_nw_settings is None and 'nielsenNaesIiNwSettings' in kwargs:
            nielsen_naes_ii_nw_settings = kwargs['nielsenNaesIiNwSettings']

        if nielsen_cbet_settings is not None:
            _setter("nielsen_cbet_settings", nielsen_cbet_settings)
        if nielsen_distribution_type is not None:
            _setter("nielsen_distribution_type", nielsen_distribution_type)
        if nielsen_naes_ii_nw_settings is not None:
            _setter("nielsen_naes_ii_nw_settings", nielsen_naes_ii_nw_settings)

    @property
    @pulumi.getter(name="nielsenCbetSettings")
    def nielsen_cbet_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs']]:
        """
        Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
        """
        return pulumi.get(self, "nielsen_cbet_settings")

    @nielsen_cbet_settings.setter
    def nielsen_cbet_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs']]):
        pulumi.set(self, "nielsen_cbet_settings", value)

    @property
    @pulumi.getter(name="nielsenDistributionType")
    def nielsen_distribution_type(self) -> Optional[pulumi.Input[str]]:
        """
        Distribution types to assign to the watermarks. Options are `PROGRAM_CONTENT` and `FINAL_DISTRIBUTOR`.
        """
        return pulumi.get(self, "nielsen_distribution_type")

    @nielsen_distribution_type.setter
    def nielsen_distribution_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_distribution_type", value)

    @property
    @pulumi.getter(name="nielsenNaesIiNwSettings")
    def nielsen_naes_ii_nw_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs']]]]:
        """
        Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
        """
        return pulumi.get(self, "nielsen_naes_ii_nw_settings")

    @nielsen_naes_ii_nw_settings.setter
    def nielsen_naes_ii_nw_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs']]]]):
        pulumi.set(self, "nielsen_naes_ii_nw_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs:
    def __init__(__self__, *,
                 cbet_check_digit_string: pulumi.Input[str],
                 cbet_stepaside: pulumi.Input[str],
                 csid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cbet_stepaside: Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
        :param pulumi.Input[str] csid: CBET source ID to use in the watermark.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cbet_check_digit_string=cbet_check_digit_string,
            cbet_stepaside=cbet_stepaside,
            csid=csid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cbet_check_digit_string: Optional[pulumi.Input[str]] = None,
             cbet_stepaside: Optional[pulumi.Input[str]] = None,
             csid: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cbet_check_digit_string is None and 'cbetCheckDigitString' in kwargs:
            cbet_check_digit_string = kwargs['cbetCheckDigitString']
        if cbet_check_digit_string is None:
            raise TypeError("Missing 'cbet_check_digit_string' argument")
        if cbet_stepaside is None and 'cbetStepaside' in kwargs:
            cbet_stepaside = kwargs['cbetStepaside']
        if cbet_stepaside is None:
            raise TypeError("Missing 'cbet_stepaside' argument")
        if csid is None:
            raise TypeError("Missing 'csid' argument")

        _setter("cbet_check_digit_string", cbet_check_digit_string)
        _setter("cbet_stepaside", cbet_stepaside)
        _setter("csid", csid)

    @property
    @pulumi.getter(name="cbetCheckDigitString")
    def cbet_check_digit_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cbet_check_digit_string")

    @cbet_check_digit_string.setter
    def cbet_check_digit_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "cbet_check_digit_string", value)

    @property
    @pulumi.getter(name="cbetStepaside")
    def cbet_stepaside(self) -> pulumi.Input[str]:
        """
        Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
        """
        return pulumi.get(self, "cbet_stepaside")

    @cbet_stepaside.setter
    def cbet_stepaside(self, value: pulumi.Input[str]):
        pulumi.set(self, "cbet_stepaside", value)

    @property
    @pulumi.getter
    def csid(self) -> pulumi.Input[str]:
        """
        CBET source ID to use in the watermark.
        """
        return pulumi.get(self, "csid")

    @csid.setter
    def csid(self, value: pulumi.Input[str]):
        pulumi.set(self, "csid", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs:
    def __init__(__self__, *,
                 check_digit_string: pulumi.Input[str],
                 sid: pulumi.Input[float]):
        """
        :param pulumi.Input[float] sid: The Nielsen Source ID to include in the watermark.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_digit_string=check_digit_string,
            sid=sid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_digit_string: Optional[pulumi.Input[str]] = None,
             sid: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if check_digit_string is None and 'checkDigitString' in kwargs:
            check_digit_string = kwargs['checkDigitString']
        if check_digit_string is None:
            raise TypeError("Missing 'check_digit_string' argument")
        if sid is None:
            raise TypeError("Missing 'sid' argument")

        _setter("check_digit_string", check_digit_string)
        _setter("sid", sid)

    @property
    @pulumi.getter(name="checkDigitString")
    def check_digit_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "check_digit_string")

    @check_digit_string.setter
    def check_digit_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "check_digit_string", value)

    @property
    @pulumi.getter
    def sid(self) -> pulumi.Input[float]:
        """
        The Nielsen Source ID to include in the watermark.
        """
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: pulumi.Input[float]):
        pulumi.set(self, "sid", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs:
    def __init__(__self__, *,
                 aac_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs']] = None,
                 ac3_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs']] = None,
                 eac3_atmos_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs']] = None,
                 eac3_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs']] = None,
                 mp2_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs']] = None,
                 pass_through_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs']] = None,
                 wav_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs'] aac_settings: Aac Settings. See AAC Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs'] ac3_settings: Ac3 Settings. See AC3 Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs'] eac3_atmos_settings: Eac3 Atmos Settings. See EAC3 Atmos Settings
        :param pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs'] eac3_settings: Eac3 Settings. See EAC3 Settings
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aac_settings=aac_settings,
            ac3_settings=ac3_settings,
            eac3_atmos_settings=eac3_atmos_settings,
            eac3_settings=eac3_settings,
            mp2_settings=mp2_settings,
            pass_through_settings=pass_through_settings,
            wav_settings=wav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aac_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs']] = None,
             ac3_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs']] = None,
             eac3_atmos_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs']] = None,
             eac3_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs']] = None,
             mp2_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs']] = None,
             pass_through_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs']] = None,
             wav_settings: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aac_settings is None and 'aacSettings' in kwargs:
            aac_settings = kwargs['aacSettings']
        if ac3_settings is None and 'ac3Settings' in kwargs:
            ac3_settings = kwargs['ac3Settings']
        if eac3_atmos_settings is None and 'eac3AtmosSettings' in kwargs:
            eac3_atmos_settings = kwargs['eac3AtmosSettings']
        if eac3_settings is None and 'eac3Settings' in kwargs:
            eac3_settings = kwargs['eac3Settings']
        if mp2_settings is None and 'mp2Settings' in kwargs:
            mp2_settings = kwargs['mp2Settings']
        if pass_through_settings is None and 'passThroughSettings' in kwargs:
            pass_through_settings = kwargs['passThroughSettings']
        if wav_settings is None and 'wavSettings' in kwargs:
            wav_settings = kwargs['wavSettings']

        if aac_settings is not None:
            _setter("aac_settings", aac_settings)
        if ac3_settings is not None:
            _setter("ac3_settings", ac3_settings)
        if eac3_atmos_settings is not None:
            _setter("eac3_atmos_settings", eac3_atmos_settings)
        if eac3_settings is not None:
            _setter("eac3_settings", eac3_settings)
        if mp2_settings is not None:
            _setter("mp2_settings", mp2_settings)
        if pass_through_settings is not None:
            _setter("pass_through_settings", pass_through_settings)
        if wav_settings is not None:
            _setter("wav_settings", wav_settings)

    @property
    @pulumi.getter(name="aacSettings")
    def aac_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs']]:
        """
        Aac Settings. See AAC Settings for more details.
        """
        return pulumi.get(self, "aac_settings")

    @aac_settings.setter
    def aac_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs']]):
        pulumi.set(self, "aac_settings", value)

    @property
    @pulumi.getter(name="ac3Settings")
    def ac3_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs']]:
        """
        Ac3 Settings. See AC3 Settings for more details.
        """
        return pulumi.get(self, "ac3_settings")

    @ac3_settings.setter
    def ac3_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs']]):
        pulumi.set(self, "ac3_settings", value)

    @property
    @pulumi.getter(name="eac3AtmosSettings")
    def eac3_atmos_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs']]:
        """
        Eac3 Atmos Settings. See EAC3 Atmos Settings
        """
        return pulumi.get(self, "eac3_atmos_settings")

    @eac3_atmos_settings.setter
    def eac3_atmos_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs']]):
        pulumi.set(self, "eac3_atmos_settings", value)

    @property
    @pulumi.getter(name="eac3Settings")
    def eac3_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs']]:
        """
        Eac3 Settings. See EAC3 Settings
        """
        return pulumi.get(self, "eac3_settings")

    @eac3_settings.setter
    def eac3_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs']]):
        pulumi.set(self, "eac3_settings", value)

    @property
    @pulumi.getter(name="mp2Settings")
    def mp2_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs']]:
        return pulumi.get(self, "mp2_settings")

    @mp2_settings.setter
    def mp2_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs']]):
        pulumi.set(self, "mp2_settings", value)

    @property
    @pulumi.getter(name="passThroughSettings")
    def pass_through_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs']]:
        return pulumi.get(self, "pass_through_settings")

    @pass_through_settings.setter
    def pass_through_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs']]):
        pulumi.set(self, "pass_through_settings", value)

    @property
    @pulumi.getter(name="wavSettings")
    def wav_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs']]:
        return pulumi.get(self, "wav_settings")

    @wav_settings.setter
    def wav_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs']]):
        pulumi.set(self, "wav_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[float]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 input_type: Optional[pulumi.Input[str]] = None,
                 profile: Optional[pulumi.Input[str]] = None,
                 rate_control_mode: Optional[pulumi.Input[str]] = None,
                 raw_format: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None,
                 spec: Optional[pulumi.Input[str]] = None,
                 vbr_quality: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[str] input_type: Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
        :param pulumi.Input[str] profile: AAC profile.
        :param pulumi.Input[str] rate_control_mode: The rate control mode.
        :param pulumi.Input[str] raw_format: Sets LATM/LOAS AAC output for raw containers.
        :param pulumi.Input[float] sample_rate: Sample rate in Hz.
        :param pulumi.Input[str] spec: Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
        :param pulumi.Input[str] vbr_quality: VBR Quality Level - Only used if rateControlMode is VBR.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            input_type=input_type,
            profile=profile,
            rate_control_mode=rate_control_mode,
            raw_format=raw_format,
            sample_rate=sample_rate,
            spec=spec,
            vbr_quality=vbr_quality,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[pulumi.Input[float]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             input_type: Optional[pulumi.Input[str]] = None,
             profile: Optional[pulumi.Input[str]] = None,
             rate_control_mode: Optional[pulumi.Input[str]] = None,
             raw_format: Optional[pulumi.Input[str]] = None,
             sample_rate: Optional[pulumi.Input[float]] = None,
             spec: Optional[pulumi.Input[str]] = None,
             vbr_quality: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if input_type is None and 'inputType' in kwargs:
            input_type = kwargs['inputType']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if raw_format is None and 'rawFormat' in kwargs:
            raw_format = kwargs['rawFormat']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']
        if vbr_quality is None and 'vbrQuality' in kwargs:
            vbr_quality = kwargs['vbrQuality']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if input_type is not None:
            _setter("input_type", input_type)
        if profile is not None:
            _setter("profile", profile)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if raw_format is not None:
            _setter("raw_format", raw_format)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)
        if spec is not None:
            _setter("spec", spec)
        if vbr_quality is not None:
            _setter("vbr_quality", vbr_quality)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[float]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter(name="inputType")
    def input_type(self) -> Optional[pulumi.Input[str]]:
        """
        Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
        """
        return pulumi.get(self, "input_type")

    @input_type.setter
    def input_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_type", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @rate_control_mode.setter
    def rate_control_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_control_mode", value)

    @property
    @pulumi.getter(name="rawFormat")
    def raw_format(self) -> Optional[pulumi.Input[str]]:
        """
        Sets LATM/LOAS AAC output for raw containers.
        """
        return pulumi.get(self, "raw_format")

    @raw_format.setter
    def raw_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_format", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[str]]:
        """
        Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter(name="vbrQuality")
    def vbr_quality(self) -> Optional[pulumi.Input[str]]:
        """
        VBR Quality Level - Only used if rateControlMode is VBR.
        """
        return pulumi.get(self, "vbr_quality")

    @vbr_quality.setter
    def vbr_quality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vbr_quality", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[float]] = None,
                 bitstream_mode: Optional[pulumi.Input[str]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 dialnorm: Optional[pulumi.Input[int]] = None,
                 drc_profile: Optional[pulumi.Input[str]] = None,
                 lfe_filter: Optional[pulumi.Input[str]] = None,
                 metadata_control: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] bitstream_mode: Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[int] dialnorm: Sets the dialnorm of the output.
        :param pulumi.Input[str] drc_profile: If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
        :param pulumi.Input[str] lfe_filter: When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        :param pulumi.Input[str] metadata_control: Metadata control.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_profile=drc_profile,
            lfe_filter=lfe_filter,
            metadata_control=metadata_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[pulumi.Input[float]] = None,
             bitstream_mode: Optional[pulumi.Input[str]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             dialnorm: Optional[pulumi.Input[int]] = None,
             drc_profile: Optional[pulumi.Input[str]] = None,
             lfe_filter: Optional[pulumi.Input[str]] = None,
             metadata_control: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bitstream_mode is None and 'bitstreamMode' in kwargs:
            bitstream_mode = kwargs['bitstreamMode']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if drc_profile is None and 'drcProfile' in kwargs:
            drc_profile = kwargs['drcProfile']
        if lfe_filter is None and 'lfeFilter' in kwargs:
            lfe_filter = kwargs['lfeFilter']
        if metadata_control is None and 'metadataControl' in kwargs:
            metadata_control = kwargs['metadataControl']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_profile is not None:
            _setter("drc_profile", drc_profile)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[float]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        """
        return pulumi.get(self, "bitstream_mode")

    @bitstream_mode.setter
    def bitstream_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitstream_mode", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @dialnorm.setter
    def dialnorm(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dialnorm", value)

    @property
    @pulumi.getter(name="drcProfile")
    def drc_profile(self) -> Optional[pulumi.Input[str]]:
        """
        If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
        """
        return pulumi.get(self, "drc_profile")

    @drc_profile.setter
    def drc_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drc_profile", value)

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[pulumi.Input[str]]:
        """
        When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        """
        return pulumi.get(self, "lfe_filter")

    @lfe_filter.setter
    def lfe_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lfe_filter", value)

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[pulumi.Input[str]]:
        """
        Metadata control.
        """
        return pulumi.get(self, "metadata_control")

    @metadata_control.setter
    def metadata_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_control", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[float]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 dialnorm: Optional[pulumi.Input[float]] = None,
                 drc_line: Optional[pulumi.Input[str]] = None,
                 drc_rf: Optional[pulumi.Input[str]] = None,
                 height_trim: Optional[pulumi.Input[float]] = None,
                 surround_trim: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[float] dialnorm: Sets the dialnorm of the output.
        :param pulumi.Input[str] drc_line: Sets the Dolby dynamic range compression profile.
        :param pulumi.Input[str] drc_rf: Sets the profile for heavy Dolby dynamic range compression.
        :param pulumi.Input[float] height_trim: Height dimensional trim.
        :param pulumi.Input[float] surround_trim: Surround dimensional trim.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            height_trim=height_trim,
            surround_trim=surround_trim,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[pulumi.Input[float]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             dialnorm: Optional[pulumi.Input[float]] = None,
             drc_line: Optional[pulumi.Input[str]] = None,
             drc_rf: Optional[pulumi.Input[str]] = None,
             height_trim: Optional[pulumi.Input[float]] = None,
             surround_trim: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if drc_line is None and 'drcLine' in kwargs:
            drc_line = kwargs['drcLine']
        if drc_rf is None and 'drcRf' in kwargs:
            drc_rf = kwargs['drcRf']
        if height_trim is None and 'heightTrim' in kwargs:
            height_trim = kwargs['heightTrim']
        if surround_trim is None and 'surroundTrim' in kwargs:
            surround_trim = kwargs['surroundTrim']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if height_trim is not None:
            _setter("height_trim", height_trim)
        if surround_trim is not None:
            _setter("surround_trim", surround_trim)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[float]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[pulumi.Input[float]]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @dialnorm.setter
    def dialnorm(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dialnorm", value)

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the Dolby dynamic range compression profile.
        """
        return pulumi.get(self, "drc_line")

    @drc_line.setter
    def drc_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drc_line", value)

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the profile for heavy Dolby dynamic range compression.
        """
        return pulumi.get(self, "drc_rf")

    @drc_rf.setter
    def drc_rf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drc_rf", value)

    @property
    @pulumi.getter(name="heightTrim")
    def height_trim(self) -> Optional[pulumi.Input[float]]:
        """
        Height dimensional trim.
        """
        return pulumi.get(self, "height_trim")

    @height_trim.setter
    def height_trim(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "height_trim", value)

    @property
    @pulumi.getter(name="surroundTrim")
    def surround_trim(self) -> Optional[pulumi.Input[float]]:
        """
        Surround dimensional trim.
        """
        return pulumi.get(self, "surround_trim")

    @surround_trim.setter
    def surround_trim(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "surround_trim", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs:
    def __init__(__self__, *,
                 attenuation_control: Optional[pulumi.Input[str]] = None,
                 bitrate: Optional[pulumi.Input[float]] = None,
                 bitstream_mode: Optional[pulumi.Input[str]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 dc_filter: Optional[pulumi.Input[str]] = None,
                 dialnorm: Optional[pulumi.Input[int]] = None,
                 drc_line: Optional[pulumi.Input[str]] = None,
                 drc_rf: Optional[pulumi.Input[str]] = None,
                 lfe_control: Optional[pulumi.Input[str]] = None,
                 lfe_filter: Optional[pulumi.Input[str]] = None,
                 lo_ro_center_mix_level: Optional[pulumi.Input[float]] = None,
                 lo_ro_surround_mix_level: Optional[pulumi.Input[float]] = None,
                 lt_rt_center_mix_level: Optional[pulumi.Input[float]] = None,
                 lt_rt_surround_mix_level: Optional[pulumi.Input[float]] = None,
                 metadata_control: Optional[pulumi.Input[str]] = None,
                 passthrough_control: Optional[pulumi.Input[str]] = None,
                 phase_control: Optional[pulumi.Input[str]] = None,
                 stereo_downmix: Optional[pulumi.Input[str]] = None,
                 surround_ex_mode: Optional[pulumi.Input[str]] = None,
                 surround_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attenuation_control: Sets the attenuation control.
        :param pulumi.Input[float] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] bitstream_mode: Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[int] dialnorm: Sets the dialnorm of the output.
        :param pulumi.Input[str] drc_line: Sets the Dolby dynamic range compression profile.
        :param pulumi.Input[str] drc_rf: Sets the profile for heavy Dolby dynamic range compression.
        :param pulumi.Input[str] lfe_filter: When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        :param pulumi.Input[str] metadata_control: Metadata control.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attenuation_control=attenuation_control,
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dc_filter=dc_filter,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            lfe_control=lfe_control,
            lfe_filter=lfe_filter,
            lo_ro_center_mix_level=lo_ro_center_mix_level,
            lo_ro_surround_mix_level=lo_ro_surround_mix_level,
            lt_rt_center_mix_level=lt_rt_center_mix_level,
            lt_rt_surround_mix_level=lt_rt_surround_mix_level,
            metadata_control=metadata_control,
            passthrough_control=passthrough_control,
            phase_control=phase_control,
            stereo_downmix=stereo_downmix,
            surround_ex_mode=surround_ex_mode,
            surround_mode=surround_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attenuation_control: Optional[pulumi.Input[str]] = None,
             bitrate: Optional[pulumi.Input[float]] = None,
             bitstream_mode: Optional[pulumi.Input[str]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             dc_filter: Optional[pulumi.Input[str]] = None,
             dialnorm: Optional[pulumi.Input[int]] = None,
             drc_line: Optional[pulumi.Input[str]] = None,
             drc_rf: Optional[pulumi.Input[str]] = None,
             lfe_control: Optional[pulumi.Input[str]] = None,
             lfe_filter: Optional[pulumi.Input[str]] = None,
             lo_ro_center_mix_level: Optional[pulumi.Input[float]] = None,
             lo_ro_surround_mix_level: Optional[pulumi.Input[float]] = None,
             lt_rt_center_mix_level: Optional[pulumi.Input[float]] = None,
             lt_rt_surround_mix_level: Optional[pulumi.Input[float]] = None,
             metadata_control: Optional[pulumi.Input[str]] = None,
             passthrough_control: Optional[pulumi.Input[str]] = None,
             phase_control: Optional[pulumi.Input[str]] = None,
             stereo_downmix: Optional[pulumi.Input[str]] = None,
             surround_ex_mode: Optional[pulumi.Input[str]] = None,
             surround_mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attenuation_control is None and 'attenuationControl' in kwargs:
            attenuation_control = kwargs['attenuationControl']
        if bitstream_mode is None and 'bitstreamMode' in kwargs:
            bitstream_mode = kwargs['bitstreamMode']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if dc_filter is None and 'dcFilter' in kwargs:
            dc_filter = kwargs['dcFilter']
        if drc_line is None and 'drcLine' in kwargs:
            drc_line = kwargs['drcLine']
        if drc_rf is None and 'drcRf' in kwargs:
            drc_rf = kwargs['drcRf']
        if lfe_control is None and 'lfeControl' in kwargs:
            lfe_control = kwargs['lfeControl']
        if lfe_filter is None and 'lfeFilter' in kwargs:
            lfe_filter = kwargs['lfeFilter']
        if lo_ro_center_mix_level is None and 'loRoCenterMixLevel' in kwargs:
            lo_ro_center_mix_level = kwargs['loRoCenterMixLevel']
        if lo_ro_surround_mix_level is None and 'loRoSurroundMixLevel' in kwargs:
            lo_ro_surround_mix_level = kwargs['loRoSurroundMixLevel']
        if lt_rt_center_mix_level is None and 'ltRtCenterMixLevel' in kwargs:
            lt_rt_center_mix_level = kwargs['ltRtCenterMixLevel']
        if lt_rt_surround_mix_level is None and 'ltRtSurroundMixLevel' in kwargs:
            lt_rt_surround_mix_level = kwargs['ltRtSurroundMixLevel']
        if metadata_control is None and 'metadataControl' in kwargs:
            metadata_control = kwargs['metadataControl']
        if passthrough_control is None and 'passthroughControl' in kwargs:
            passthrough_control = kwargs['passthroughControl']
        if phase_control is None and 'phaseControl' in kwargs:
            phase_control = kwargs['phaseControl']
        if stereo_downmix is None and 'stereoDownmix' in kwargs:
            stereo_downmix = kwargs['stereoDownmix']
        if surround_ex_mode is None and 'surroundExMode' in kwargs:
            surround_ex_mode = kwargs['surroundExMode']
        if surround_mode is None and 'surroundMode' in kwargs:
            surround_mode = kwargs['surroundMode']

        if attenuation_control is not None:
            _setter("attenuation_control", attenuation_control)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dc_filter is not None:
            _setter("dc_filter", dc_filter)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if lfe_control is not None:
            _setter("lfe_control", lfe_control)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if lo_ro_center_mix_level is not None:
            _setter("lo_ro_center_mix_level", lo_ro_center_mix_level)
        if lo_ro_surround_mix_level is not None:
            _setter("lo_ro_surround_mix_level", lo_ro_surround_mix_level)
        if lt_rt_center_mix_level is not None:
            _setter("lt_rt_center_mix_level", lt_rt_center_mix_level)
        if lt_rt_surround_mix_level is not None:
            _setter("lt_rt_surround_mix_level", lt_rt_surround_mix_level)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)
        if passthrough_control is not None:
            _setter("passthrough_control", passthrough_control)
        if phase_control is not None:
            _setter("phase_control", phase_control)
        if stereo_downmix is not None:
            _setter("stereo_downmix", stereo_downmix)
        if surround_ex_mode is not None:
            _setter("surround_ex_mode", surround_ex_mode)
        if surround_mode is not None:
            _setter("surround_mode", surround_mode)

    @property
    @pulumi.getter(name="attenuationControl")
    def attenuation_control(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the attenuation control.
        """
        return pulumi.get(self, "attenuation_control")

    @attenuation_control.setter
    def attenuation_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attenuation_control", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[float]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        """
        return pulumi.get(self, "bitstream_mode")

    @bitstream_mode.setter
    def bitstream_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bitstream_mode", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter(name="dcFilter")
    def dc_filter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dc_filter")

    @dc_filter.setter
    def dc_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dc_filter", value)

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @dialnorm.setter
    def dialnorm(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dialnorm", value)

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the Dolby dynamic range compression profile.
        """
        return pulumi.get(self, "drc_line")

    @drc_line.setter
    def drc_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drc_line", value)

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the profile for heavy Dolby dynamic range compression.
        """
        return pulumi.get(self, "drc_rf")

    @drc_rf.setter
    def drc_rf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drc_rf", value)

    @property
    @pulumi.getter(name="lfeControl")
    def lfe_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lfe_control")

    @lfe_control.setter
    def lfe_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lfe_control", value)

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[pulumi.Input[str]]:
        """
        When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        """
        return pulumi.get(self, "lfe_filter")

    @lfe_filter.setter
    def lfe_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lfe_filter", value)

    @property
    @pulumi.getter(name="loRoCenterMixLevel")
    def lo_ro_center_mix_level(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lo_ro_center_mix_level")

    @lo_ro_center_mix_level.setter
    def lo_ro_center_mix_level(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lo_ro_center_mix_level", value)

    @property
    @pulumi.getter(name="loRoSurroundMixLevel")
    def lo_ro_surround_mix_level(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lo_ro_surround_mix_level")

    @lo_ro_surround_mix_level.setter
    def lo_ro_surround_mix_level(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lo_ro_surround_mix_level", value)

    @property
    @pulumi.getter(name="ltRtCenterMixLevel")
    def lt_rt_center_mix_level(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lt_rt_center_mix_level")

    @lt_rt_center_mix_level.setter
    def lt_rt_center_mix_level(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt_rt_center_mix_level", value)

    @property
    @pulumi.getter(name="ltRtSurroundMixLevel")
    def lt_rt_surround_mix_level(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "lt_rt_surround_mix_level")

    @lt_rt_surround_mix_level.setter
    def lt_rt_surround_mix_level(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lt_rt_surround_mix_level", value)

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[pulumi.Input[str]]:
        """
        Metadata control.
        """
        return pulumi.get(self, "metadata_control")

    @metadata_control.setter
    def metadata_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_control", value)

    @property
    @pulumi.getter(name="passthroughControl")
    def passthrough_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "passthrough_control")

    @passthrough_control.setter
    def passthrough_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passthrough_control", value)

    @property
    @pulumi.getter(name="phaseControl")
    def phase_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "phase_control")

    @phase_control.setter
    def phase_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase_control", value)

    @property
    @pulumi.getter(name="stereoDownmix")
    def stereo_downmix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stereo_downmix")

    @stereo_downmix.setter
    def stereo_downmix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stereo_downmix", value)

    @property
    @pulumi.getter(name="surroundExMode")
    def surround_ex_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "surround_ex_mode")

    @surround_ex_mode.setter
    def surround_ex_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "surround_ex_mode", value)

    @property
    @pulumi.getter(name="surroundMode")
    def surround_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "surround_mode")

    @surround_mode.setter
    def surround_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "surround_mode", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[float]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[float] sample_rate: Sample rate in Hz.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[pulumi.Input[float]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             sample_rate: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[float]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs:
    def __init__(__self__, *,
                 bit_depth: Optional[pulumi.Input[float]] = None,
                 coding_mode: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param pulumi.Input[float] sample_rate: Sample rate in Hz.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bit_depth=bit_depth,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bit_depth: Optional[pulumi.Input[float]] = None,
             coding_mode: Optional[pulumi.Input[str]] = None,
             sample_rate: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bit_depth is None and 'bitDepth' in kwargs:
            bit_depth = kwargs['bitDepth']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']

        if bit_depth is not None:
            _setter("bit_depth", bit_depth)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter(name="bitDepth")
    def bit_depth(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "bit_depth")

    @bit_depth.setter
    def bit_depth(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bit_depth", value)

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @coding_mode.setter
    def coding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coding_mode", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs:
    def __init__(__self__, *,
                 channel_mappings: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs']]],
                 channels_in: Optional[pulumi.Input[int]] = None,
                 channels_out: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsAudioDescriptionRemixSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_mappings=channel_mappings,
            channels_in=channels_in,
            channels_out=channels_out,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs']]]] = None,
             channels_in: Optional[pulumi.Input[int]] = None,
             channels_out: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_mappings is None and 'channelMappings' in kwargs:
            channel_mappings = kwargs['channelMappings']
        if channel_mappings is None:
            raise TypeError("Missing 'channel_mappings' argument")
        if channels_in is None and 'channelsIn' in kwargs:
            channels_in = kwargs['channelsIn']
        if channels_out is None and 'channelsOut' in kwargs:
            channels_out = kwargs['channelsOut']

        _setter("channel_mappings", channel_mappings)
        if channels_in is not None:
            _setter("channels_in", channels_in)
        if channels_out is not None:
            _setter("channels_out", channels_out)

    @property
    @pulumi.getter(name="channelMappings")
    def channel_mappings(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs']]]:
        return pulumi.get(self, "channel_mappings")

    @channel_mappings.setter
    def channel_mappings(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs']]]):
        pulumi.set(self, "channel_mappings", value)

    @property
    @pulumi.getter(name="channelsIn")
    def channels_in(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "channels_in")

    @channels_in.setter
    def channels_in(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channels_in", value)

    @property
    @pulumi.getter(name="channelsOut")
    def channels_out(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "channels_out")

    @channels_out.setter
    def channels_out(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channels_out", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs:
    def __init__(__self__, *,
                 input_channel_levels: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs']]],
                 output_channel: pulumi.Input[int]):
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_channel_levels=input_channel_levels,
            output_channel=output_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_channel_levels: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs']]]] = None,
             output_channel: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_channel_levels is None and 'inputChannelLevels' in kwargs:
            input_channel_levels = kwargs['inputChannelLevels']
        if input_channel_levels is None:
            raise TypeError("Missing 'input_channel_levels' argument")
        if output_channel is None and 'outputChannel' in kwargs:
            output_channel = kwargs['outputChannel']
        if output_channel is None:
            raise TypeError("Missing 'output_channel' argument")

        _setter("input_channel_levels", input_channel_levels)
        _setter("output_channel", output_channel)

    @property
    @pulumi.getter(name="inputChannelLevels")
    def input_channel_levels(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs']]]:
        return pulumi.get(self, "input_channel_levels")

    @input_channel_levels.setter
    def input_channel_levels(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs']]]):
        pulumi.set(self, "input_channel_levels", value)

    @property
    @pulumi.getter(name="outputChannel")
    def output_channel(self) -> pulumi.Input[int]:
        return pulumi.get(self, "output_channel")

    @output_channel.setter
    def output_channel(self, value: pulumi.Input[int]):
        pulumi.set(self, "output_channel", value)


@pulumi.input_type
class ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs:
    def __init__(__self__, *,
                 gain: pulumi.Input[int],
                 input_channel: pulumi.Input[int]):
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gain=gain,
            input_channel=input_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gain: Optional[pulumi.Input[int]] = None,
             input_channel: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if gain is None:
            raise TypeError("Missing 'gain' argument")
        if input_channel is None and 'inputChannel' in kwargs:
            input_channel = kwargs['inputChannel']
        if input_channel is None:
            raise TypeError("Missing 'input_channel' argument")

        _setter("gain", gain)
        _setter("input_channel", input_channel)

    @property
    @pulumi.getter
    def gain(self) -> pulumi.Input[int]:
        return pulumi.get(self, "gain")

    @gain.setter
    def gain(self, value: pulumi.Input[int]):
        pulumi.set(self, "gain", value)

    @property
    @pulumi.getter(name="inputChannel")
    def input_channel(self) -> pulumi.Input[int]:
        return pulumi.get(self, "input_channel")

    @input_channel.setter
    def input_channel(self, value: pulumi.Input[int]):
        pulumi.set(self, "input_channel", value)


@pulumi.input_type
class ChannelEncoderSettingsAvailBlankingArgs:
    def __init__(__self__, *,
                 avail_blanking_image: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs'] avail_blanking_image: Blanking image to be used. See Avail Blanking Image for more details.
        :param pulumi.Input[str] state: When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
        """
        ChannelEncoderSettingsAvailBlankingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            avail_blanking_image=avail_blanking_image,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             avail_blanking_image: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs']] = None,
             state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if avail_blanking_image is None and 'availBlankingImage' in kwargs:
            avail_blanking_image = kwargs['availBlankingImage']

        if avail_blanking_image is not None:
            _setter("avail_blanking_image", avail_blanking_image)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="availBlankingImage")
    def avail_blanking_image(self) -> Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs']]:
        """
        Blanking image to be used. See Avail Blanking Image for more details.
        """
        return pulumi.get(self, "avail_blanking_image")

    @avail_blanking_image.setter
    def avail_blanking_image(self, value: Optional[pulumi.Input['ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs']]):
        pulumi.set(self, "avail_blanking_image", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: . Username to be used.
        """
        ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionArgs:
    def __init__(__self__, *,
                 caption_selector_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 accessibility: Optional[pulumi.Input[str]] = None,
                 destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs']] = None,
                 language_code: Optional[pulumi.Input[str]] = None,
                 language_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] caption_selector_name: Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
        :param pulumi.Input[str] name: Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
        :param pulumi.Input[str] accessibility: Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs'] destination_settings: Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
        :param pulumi.Input[str] language_code: ISO 639-2 three-digit code.
        :param pulumi.Input[str] language_description: Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        ChannelEncoderSettingsCaptionDescriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caption_selector_name=caption_selector_name,
            name=name,
            accessibility=accessibility,
            destination_settings=destination_settings,
            language_code=language_code,
            language_description=language_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caption_selector_name: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             accessibility: Optional[pulumi.Input[str]] = None,
             destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs']] = None,
             language_code: Optional[pulumi.Input[str]] = None,
             language_description: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if caption_selector_name is None and 'captionSelectorName' in kwargs:
            caption_selector_name = kwargs['captionSelectorName']
        if caption_selector_name is None:
            raise TypeError("Missing 'caption_selector_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if destination_settings is None and 'destinationSettings' in kwargs:
            destination_settings = kwargs['destinationSettings']
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_description is None and 'languageDescription' in kwargs:
            language_description = kwargs['languageDescription']

        _setter("caption_selector_name", caption_selector_name)
        _setter("name", name)
        if accessibility is not None:
            _setter("accessibility", accessibility)
        if destination_settings is not None:
            _setter("destination_settings", destination_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_description is not None:
            _setter("language_description", language_description)

    @property
    @pulumi.getter(name="captionSelectorName")
    def caption_selector_name(self) -> pulumi.Input[str]:
        """
        Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
        """
        return pulumi.get(self, "caption_selector_name")

    @caption_selector_name.setter
    def caption_selector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "caption_selector_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def accessibility(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
        """
        return pulumi.get(self, "accessibility")

    @accessibility.setter
    def accessibility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "accessibility", value)

    @property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs']]:
        """
        Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
        """
        return pulumi.get(self, "destination_settings")

    @destination_settings.setter
    def destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs']]):
        pulumi.set(self, "destination_settings", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[str]]:
        """
        ISO 639-2 three-digit code.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        return pulumi.get(self, "language_description")

    @language_description.setter
    def language_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_description", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs:
    def __init__(__self__, *,
                 arib_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs']] = None,
                 burn_in_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs']] = None,
                 dvb_sub_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs']] = None,
                 ebu_tt_d_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs']] = None,
                 embedded_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs']] = None,
                 embedded_plus_scte20_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs']] = None,
                 rtmp_caption_info_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs']] = None,
                 scte20_plus_embedded_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs']] = None,
                 scte27_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs']] = None,
                 smpte_tt_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs']] = None,
                 teletext_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs']] = None,
                 ttml_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs']] = None,
                 webvtt_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs'] arib_destination_settings: ARIB Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs'] burn_in_destination_settings: Burn In Destination Settings. See Burn In Destination Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs'] dvb_sub_destination_settings: DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs'] ebu_tt_d_destination_settings: EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs'] embedded_destination_settings: Embedded Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs'] embedded_plus_scte20_destination_settings: Embedded Plus SCTE20 Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs'] rtmp_caption_info_destination_settings: RTMP Caption Info Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs'] scte20_plus_embedded_destination_settings: SCTE20 Plus Embedded Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs'] scte27_destination_settings: SCTE27 Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs'] smpte_tt_destination_settings: SMPTE TT Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs'] teletext_destination_settings: Teletext Destination Settings.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs'] ttml_destination_settings: TTML Destination Settings. See TTML Destination Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs'] webvtt_destination_settings: WebVTT Destination Settings. See WebVTT Destination Settings for more details.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arib_destination_settings=arib_destination_settings,
            burn_in_destination_settings=burn_in_destination_settings,
            dvb_sub_destination_settings=dvb_sub_destination_settings,
            ebu_tt_d_destination_settings=ebu_tt_d_destination_settings,
            embedded_destination_settings=embedded_destination_settings,
            embedded_plus_scte20_destination_settings=embedded_plus_scte20_destination_settings,
            rtmp_caption_info_destination_settings=rtmp_caption_info_destination_settings,
            scte20_plus_embedded_destination_settings=scte20_plus_embedded_destination_settings,
            scte27_destination_settings=scte27_destination_settings,
            smpte_tt_destination_settings=smpte_tt_destination_settings,
            teletext_destination_settings=teletext_destination_settings,
            ttml_destination_settings=ttml_destination_settings,
            webvtt_destination_settings=webvtt_destination_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arib_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs']] = None,
             burn_in_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs']] = None,
             dvb_sub_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs']] = None,
             ebu_tt_d_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs']] = None,
             embedded_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs']] = None,
             embedded_plus_scte20_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs']] = None,
             rtmp_caption_info_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs']] = None,
             scte20_plus_embedded_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs']] = None,
             scte27_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs']] = None,
             smpte_tt_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs']] = None,
             teletext_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs']] = None,
             ttml_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs']] = None,
             webvtt_destination_settings: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arib_destination_settings is None and 'aribDestinationSettings' in kwargs:
            arib_destination_settings = kwargs['aribDestinationSettings']
        if burn_in_destination_settings is None and 'burnInDestinationSettings' in kwargs:
            burn_in_destination_settings = kwargs['burnInDestinationSettings']
        if dvb_sub_destination_settings is None and 'dvbSubDestinationSettings' in kwargs:
            dvb_sub_destination_settings = kwargs['dvbSubDestinationSettings']
        if ebu_tt_d_destination_settings is None and 'ebuTtDDestinationSettings' in kwargs:
            ebu_tt_d_destination_settings = kwargs['ebuTtDDestinationSettings']
        if embedded_destination_settings is None and 'embeddedDestinationSettings' in kwargs:
            embedded_destination_settings = kwargs['embeddedDestinationSettings']
        if embedded_plus_scte20_destination_settings is None and 'embeddedPlusScte20DestinationSettings' in kwargs:
            embedded_plus_scte20_destination_settings = kwargs['embeddedPlusScte20DestinationSettings']
        if rtmp_caption_info_destination_settings is None and 'rtmpCaptionInfoDestinationSettings' in kwargs:
            rtmp_caption_info_destination_settings = kwargs['rtmpCaptionInfoDestinationSettings']
        if scte20_plus_embedded_destination_settings is None and 'scte20PlusEmbeddedDestinationSettings' in kwargs:
            scte20_plus_embedded_destination_settings = kwargs['scte20PlusEmbeddedDestinationSettings']
        if scte27_destination_settings is None and 'scte27DestinationSettings' in kwargs:
            scte27_destination_settings = kwargs['scte27DestinationSettings']
        if smpte_tt_destination_settings is None and 'smpteTtDestinationSettings' in kwargs:
            smpte_tt_destination_settings = kwargs['smpteTtDestinationSettings']
        if teletext_destination_settings is None and 'teletextDestinationSettings' in kwargs:
            teletext_destination_settings = kwargs['teletextDestinationSettings']
        if ttml_destination_settings is None and 'ttmlDestinationSettings' in kwargs:
            ttml_destination_settings = kwargs['ttmlDestinationSettings']
        if webvtt_destination_settings is None and 'webvttDestinationSettings' in kwargs:
            webvtt_destination_settings = kwargs['webvttDestinationSettings']

        if arib_destination_settings is not None:
            _setter("arib_destination_settings", arib_destination_settings)
        if burn_in_destination_settings is not None:
            _setter("burn_in_destination_settings", burn_in_destination_settings)
        if dvb_sub_destination_settings is not None:
            _setter("dvb_sub_destination_settings", dvb_sub_destination_settings)
        if ebu_tt_d_destination_settings is not None:
            _setter("ebu_tt_d_destination_settings", ebu_tt_d_destination_settings)
        if embedded_destination_settings is not None:
            _setter("embedded_destination_settings", embedded_destination_settings)
        if embedded_plus_scte20_destination_settings is not None:
            _setter("embedded_plus_scte20_destination_settings", embedded_plus_scte20_destination_settings)
        if rtmp_caption_info_destination_settings is not None:
            _setter("rtmp_caption_info_destination_settings", rtmp_caption_info_destination_settings)
        if scte20_plus_embedded_destination_settings is not None:
            _setter("scte20_plus_embedded_destination_settings", scte20_plus_embedded_destination_settings)
        if scte27_destination_settings is not None:
            _setter("scte27_destination_settings", scte27_destination_settings)
        if smpte_tt_destination_settings is not None:
            _setter("smpte_tt_destination_settings", smpte_tt_destination_settings)
        if teletext_destination_settings is not None:
            _setter("teletext_destination_settings", teletext_destination_settings)
        if ttml_destination_settings is not None:
            _setter("ttml_destination_settings", ttml_destination_settings)
        if webvtt_destination_settings is not None:
            _setter("webvtt_destination_settings", webvtt_destination_settings)

    @property
    @pulumi.getter(name="aribDestinationSettings")
    def arib_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs']]:
        """
        ARIB Destination Settings.
        """
        return pulumi.get(self, "arib_destination_settings")

    @arib_destination_settings.setter
    def arib_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs']]):
        pulumi.set(self, "arib_destination_settings", value)

    @property
    @pulumi.getter(name="burnInDestinationSettings")
    def burn_in_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs']]:
        """
        Burn In Destination Settings. See Burn In Destination Settings for more details.
        """
        return pulumi.get(self, "burn_in_destination_settings")

    @burn_in_destination_settings.setter
    def burn_in_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs']]):
        pulumi.set(self, "burn_in_destination_settings", value)

    @property
    @pulumi.getter(name="dvbSubDestinationSettings")
    def dvb_sub_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs']]:
        """
        DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
        """
        return pulumi.get(self, "dvb_sub_destination_settings")

    @dvb_sub_destination_settings.setter
    def dvb_sub_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs']]):
        pulumi.set(self, "dvb_sub_destination_settings", value)

    @property
    @pulumi.getter(name="ebuTtDDestinationSettings")
    def ebu_tt_d_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs']]:
        """
        EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
        """
        return pulumi.get(self, "ebu_tt_d_destination_settings")

    @ebu_tt_d_destination_settings.setter
    def ebu_tt_d_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs']]):
        pulumi.set(self, "ebu_tt_d_destination_settings", value)

    @property
    @pulumi.getter(name="embeddedDestinationSettings")
    def embedded_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs']]:
        """
        Embedded Destination Settings.
        """
        return pulumi.get(self, "embedded_destination_settings")

    @embedded_destination_settings.setter
    def embedded_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs']]):
        pulumi.set(self, "embedded_destination_settings", value)

    @property
    @pulumi.getter(name="embeddedPlusScte20DestinationSettings")
    def embedded_plus_scte20_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs']]:
        """
        Embedded Plus SCTE20 Destination Settings.
        """
        return pulumi.get(self, "embedded_plus_scte20_destination_settings")

    @embedded_plus_scte20_destination_settings.setter
    def embedded_plus_scte20_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs']]):
        pulumi.set(self, "embedded_plus_scte20_destination_settings", value)

    @property
    @pulumi.getter(name="rtmpCaptionInfoDestinationSettings")
    def rtmp_caption_info_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs']]:
        """
        RTMP Caption Info Destination Settings.
        """
        return pulumi.get(self, "rtmp_caption_info_destination_settings")

    @rtmp_caption_info_destination_settings.setter
    def rtmp_caption_info_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs']]):
        pulumi.set(self, "rtmp_caption_info_destination_settings", value)

    @property
    @pulumi.getter(name="scte20PlusEmbeddedDestinationSettings")
    def scte20_plus_embedded_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs']]:
        """
        SCTE20 Plus Embedded Destination Settings.
        """
        return pulumi.get(self, "scte20_plus_embedded_destination_settings")

    @scte20_plus_embedded_destination_settings.setter
    def scte20_plus_embedded_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs']]):
        pulumi.set(self, "scte20_plus_embedded_destination_settings", value)

    @property
    @pulumi.getter(name="scte27DestinationSettings")
    def scte27_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs']]:
        """
        SCTE27 Destination Settings.
        """
        return pulumi.get(self, "scte27_destination_settings")

    @scte27_destination_settings.setter
    def scte27_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs']]):
        pulumi.set(self, "scte27_destination_settings", value)

    @property
    @pulumi.getter(name="smpteTtDestinationSettings")
    def smpte_tt_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs']]:
        """
        SMPTE TT Destination Settings.
        """
        return pulumi.get(self, "smpte_tt_destination_settings")

    @smpte_tt_destination_settings.setter
    def smpte_tt_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs']]):
        pulumi.set(self, "smpte_tt_destination_settings", value)

    @property
    @pulumi.getter(name="teletextDestinationSettings")
    def teletext_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs']]:
        """
        Teletext Destination Settings.
        """
        return pulumi.get(self, "teletext_destination_settings")

    @teletext_destination_settings.setter
    def teletext_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs']]):
        pulumi.set(self, "teletext_destination_settings", value)

    @property
    @pulumi.getter(name="ttmlDestinationSettings")
    def ttml_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs']]:
        """
        TTML Destination Settings. See TTML Destination Settings for more details.
        """
        return pulumi.get(self, "ttml_destination_settings")

    @ttml_destination_settings.setter
    def ttml_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs']]):
        pulumi.set(self, "ttml_destination_settings", value)

    @property
    @pulumi.getter(name="webvttDestinationSettings")
    def webvtt_destination_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs']]:
        """
        WebVTT Destination Settings. See WebVTT Destination Settings for more details.
        """
        return pulumi.get(self, "webvtt_destination_settings")

    @webvtt_destination_settings.setter
    def webvtt_destination_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs']]):
        pulumi.set(self, "webvtt_destination_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs:
    def __init__(__self__, *,
                 outline_color: pulumi.Input[str],
                 teletext_grid_control: pulumi.Input[str],
                 alignment: Optional[pulumi.Input[str]] = None,
                 background_color: Optional[pulumi.Input[str]] = None,
                 background_opacity: Optional[pulumi.Input[int]] = None,
                 font: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs']] = None,
                 font_color: Optional[pulumi.Input[str]] = None,
                 font_opacity: Optional[pulumi.Input[int]] = None,
                 font_resolution: Optional[pulumi.Input[int]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 outline_size: Optional[pulumi.Input[int]] = None,
                 shadow_color: Optional[pulumi.Input[str]] = None,
                 shadow_opacity: Optional[pulumi.Input[int]] = None,
                 shadow_x_offset: Optional[pulumi.Input[int]] = None,
                 shadow_y_offset: Optional[pulumi.Input[int]] = None,
                 x_position: Optional[pulumi.Input[int]] = None,
                 y_position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] outline_color: Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] teletext_grid_control: Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        :param pulumi.Input[str] alignment: If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting smart justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] background_color: Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] background_opacity: Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs'] font: External font file used for caption burn-in. File extension must be ttf or tte. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        :param pulumi.Input[str] font_color: Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] font_opacity: Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] font_resolution: Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] font_size: When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] outline_size: Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] shadow_color: Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_opacity: Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_x_offset: Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_y_offset: Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] x_position: Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] y_position: Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            outline_color=outline_color,
            teletext_grid_control=teletext_grid_control,
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             outline_color: Optional[pulumi.Input[str]] = None,
             teletext_grid_control: Optional[pulumi.Input[str]] = None,
             alignment: Optional[pulumi.Input[str]] = None,
             background_color: Optional[pulumi.Input[str]] = None,
             background_opacity: Optional[pulumi.Input[int]] = None,
             font: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs']] = None,
             font_color: Optional[pulumi.Input[str]] = None,
             font_opacity: Optional[pulumi.Input[int]] = None,
             font_resolution: Optional[pulumi.Input[int]] = None,
             font_size: Optional[pulumi.Input[str]] = None,
             outline_size: Optional[pulumi.Input[int]] = None,
             shadow_color: Optional[pulumi.Input[str]] = None,
             shadow_opacity: Optional[pulumi.Input[int]] = None,
             shadow_x_offset: Optional[pulumi.Input[int]] = None,
             shadow_y_offset: Optional[pulumi.Input[int]] = None,
             x_position: Optional[pulumi.Input[int]] = None,
             y_position: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if outline_color is None and 'outlineColor' in kwargs:
            outline_color = kwargs['outlineColor']
        if outline_color is None:
            raise TypeError("Missing 'outline_color' argument")
        if teletext_grid_control is None and 'teletextGridControl' in kwargs:
            teletext_grid_control = kwargs['teletextGridControl']
        if teletext_grid_control is None:
            raise TypeError("Missing 'teletext_grid_control' argument")
        if background_color is None and 'backgroundColor' in kwargs:
            background_color = kwargs['backgroundColor']
        if background_opacity is None and 'backgroundOpacity' in kwargs:
            background_opacity = kwargs['backgroundOpacity']
        if font_color is None and 'fontColor' in kwargs:
            font_color = kwargs['fontColor']
        if font_opacity is None and 'fontOpacity' in kwargs:
            font_opacity = kwargs['fontOpacity']
        if font_resolution is None and 'fontResolution' in kwargs:
            font_resolution = kwargs['fontResolution']
        if font_size is None and 'fontSize' in kwargs:
            font_size = kwargs['fontSize']
        if outline_size is None and 'outlineSize' in kwargs:
            outline_size = kwargs['outlineSize']
        if shadow_color is None and 'shadowColor' in kwargs:
            shadow_color = kwargs['shadowColor']
        if shadow_opacity is None and 'shadowOpacity' in kwargs:
            shadow_opacity = kwargs['shadowOpacity']
        if shadow_x_offset is None and 'shadowXOffset' in kwargs:
            shadow_x_offset = kwargs['shadowXOffset']
        if shadow_y_offset is None and 'shadowYOffset' in kwargs:
            shadow_y_offset = kwargs['shadowYOffset']
        if x_position is None and 'xPosition' in kwargs:
            x_position = kwargs['xPosition']
        if y_position is None and 'yPosition' in kwargs:
            y_position = kwargs['yPosition']

        _setter("outline_color", outline_color)
        _setter("teletext_grid_control", teletext_grid_control)
        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> pulumi.Input[str]:
        """
        Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_color")

    @outline_color.setter
    def outline_color(self, value: pulumi.Input[str]):
        pulumi.set(self, "outline_color", value)

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> pulumi.Input[str]:
        """
        Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        """
        return pulumi.get(self, "teletext_grid_control")

    @teletext_grid_control.setter
    def teletext_grid_control(self, value: pulumi.Input[str]):
        pulumi.set(self, "teletext_grid_control", value)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[pulumi.Input[str]]:
        """
        If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting smart justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "alignment")

    @alignment.setter
    def alignment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_opacity")

    @background_opacity.setter
    def background_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_opacity", value)

    @property
    @pulumi.getter
    def font(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs']]:
        """
        External font file used for caption burn-in. File extension must be ttf or tte. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        """
        return pulumi.get(self, "font")

    @font.setter
    def font(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs']]):
        pulumi.set(self, "font", value)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_opacity")

    @font_opacity.setter
    def font_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_opacity", value)

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[pulumi.Input[int]]:
        """
        Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_resolution")

    @font_resolution.setter
    def font_resolution(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_resolution", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_size")

    @outline_size.setter
    def outline_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "outline_size", value)

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_color")

    @shadow_color.setter
    def shadow_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shadow_color", value)

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_opacity")

    @shadow_opacity.setter
    def shadow_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_opacity", value)

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_x_offset")

    @shadow_x_offset.setter
    def shadow_x_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_x_offset", value)

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_y_offset")

    @shadow_y_offset.setter
    def shadow_y_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_y_offset", value)

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x_position", value)

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y_position", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: Username to be used.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs:
    def __init__(__self__, *,
                 alignment: Optional[pulumi.Input[str]] = None,
                 background_color: Optional[pulumi.Input[str]] = None,
                 background_opacity: Optional[pulumi.Input[int]] = None,
                 font: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs']] = None,
                 font_color: Optional[pulumi.Input[str]] = None,
                 font_opacity: Optional[pulumi.Input[int]] = None,
                 font_resolution: Optional[pulumi.Input[int]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 outline_color: Optional[pulumi.Input[str]] = None,
                 outline_size: Optional[pulumi.Input[int]] = None,
                 shadow_color: Optional[pulumi.Input[str]] = None,
                 shadow_opacity: Optional[pulumi.Input[int]] = None,
                 shadow_x_offset: Optional[pulumi.Input[int]] = None,
                 shadow_y_offset: Optional[pulumi.Input[int]] = None,
                 teletext_grid_control: Optional[pulumi.Input[str]] = None,
                 x_position: Optional[pulumi.Input[int]] = None,
                 y_position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] alignment: If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting smart justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] background_color: Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] background_opacity: Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs'] font: External font file used for caption burn-in. File extension must be ttf or tte. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        :param pulumi.Input[str] font_color: Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] font_opacity: Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] font_resolution: Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] font_size: When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] outline_color: Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] outline_size: Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] shadow_color: Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_opacity: Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_x_offset: Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] shadow_y_offset: Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[str] teletext_grid_control: Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        :param pulumi.Input[int] x_position: Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param pulumi.Input[int] y_position: Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_color=outline_color,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            teletext_grid_control=teletext_grid_control,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alignment: Optional[pulumi.Input[str]] = None,
             background_color: Optional[pulumi.Input[str]] = None,
             background_opacity: Optional[pulumi.Input[int]] = None,
             font: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs']] = None,
             font_color: Optional[pulumi.Input[str]] = None,
             font_opacity: Optional[pulumi.Input[int]] = None,
             font_resolution: Optional[pulumi.Input[int]] = None,
             font_size: Optional[pulumi.Input[str]] = None,
             outline_color: Optional[pulumi.Input[str]] = None,
             outline_size: Optional[pulumi.Input[int]] = None,
             shadow_color: Optional[pulumi.Input[str]] = None,
             shadow_opacity: Optional[pulumi.Input[int]] = None,
             shadow_x_offset: Optional[pulumi.Input[int]] = None,
             shadow_y_offset: Optional[pulumi.Input[int]] = None,
             teletext_grid_control: Optional[pulumi.Input[str]] = None,
             x_position: Optional[pulumi.Input[int]] = None,
             y_position: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if background_color is None and 'backgroundColor' in kwargs:
            background_color = kwargs['backgroundColor']
        if background_opacity is None and 'backgroundOpacity' in kwargs:
            background_opacity = kwargs['backgroundOpacity']
        if font_color is None and 'fontColor' in kwargs:
            font_color = kwargs['fontColor']
        if font_opacity is None and 'fontOpacity' in kwargs:
            font_opacity = kwargs['fontOpacity']
        if font_resolution is None and 'fontResolution' in kwargs:
            font_resolution = kwargs['fontResolution']
        if font_size is None and 'fontSize' in kwargs:
            font_size = kwargs['fontSize']
        if outline_color is None and 'outlineColor' in kwargs:
            outline_color = kwargs['outlineColor']
        if outline_size is None and 'outlineSize' in kwargs:
            outline_size = kwargs['outlineSize']
        if shadow_color is None and 'shadowColor' in kwargs:
            shadow_color = kwargs['shadowColor']
        if shadow_opacity is None and 'shadowOpacity' in kwargs:
            shadow_opacity = kwargs['shadowOpacity']
        if shadow_x_offset is None and 'shadowXOffset' in kwargs:
            shadow_x_offset = kwargs['shadowXOffset']
        if shadow_y_offset is None and 'shadowYOffset' in kwargs:
            shadow_y_offset = kwargs['shadowYOffset']
        if teletext_grid_control is None and 'teletextGridControl' in kwargs:
            teletext_grid_control = kwargs['teletextGridControl']
        if x_position is None and 'xPosition' in kwargs:
            x_position = kwargs['xPosition']
        if y_position is None and 'yPosition' in kwargs:
            y_position = kwargs['yPosition']

        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_color is not None:
            _setter("outline_color", outline_color)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if teletext_grid_control is not None:
            _setter("teletext_grid_control", teletext_grid_control)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[pulumi.Input[str]]:
        """
        If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting smart justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "alignment")

    @alignment.setter
    def alignment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_opacity")

    @background_opacity.setter
    def background_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_opacity", value)

    @property
    @pulumi.getter
    def font(self) -> Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs']]:
        """
        External font file used for caption burn-in. File extension must be ttf or tte. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        """
        return pulumi.get(self, "font")

    @font.setter
    def font(self, value: Optional[pulumi.Input['ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs']]):
        pulumi.set(self, "font", value)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_opacity")

    @font_opacity.setter
    def font_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_opacity", value)

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[pulumi.Input[int]]:
        """
        Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_resolution")

    @font_resolution.setter
    def font_resolution(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_resolution", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_color")

    @outline_color.setter
    def outline_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outline_color", value)

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_size")

    @outline_size.setter
    def outline_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "outline_size", value)

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_color")

    @shadow_color.setter
    def shadow_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shadow_color", value)

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_opacity")

    @shadow_opacity.setter
    def shadow_opacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_opacity", value)

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_x_offset")

    @shadow_x_offset.setter
    def shadow_x_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_x_offset", value)

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_y_offset")

    @shadow_y_offset.setter
    def shadow_y_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shadow_y_offset", value)

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        """
        return pulumi.get(self, "teletext_grid_control")

    @teletext_grid_control.setter
    def teletext_grid_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "teletext_grid_control", value)

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x_position", value)

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y_position", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: Username to be used.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs:
    def __init__(__self__, *,
                 copyright_holder: Optional[pulumi.Input[str]] = None,
                 fill_line_gap: Optional[pulumi.Input[str]] = None,
                 font_family: Optional[pulumi.Input[str]] = None,
                 style_control: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] copyright_holder: Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
        :param pulumi.Input[str] fill_line_gap: Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
        :param pulumi.Input[str] font_family: Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to monospaced. (If styleControl is set to exclude, the font family is always set to monospaced.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as Arial), or a generic font family (such as serif), or default (to let the downstream player choose the font). - Leave blank to set the family to monospace.
        :param pulumi.Input[str] style_control: Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to monospaced. Do not include any other style information.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copyright_holder=copyright_holder,
            fill_line_gap=fill_line_gap,
            font_family=font_family,
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copyright_holder: Optional[pulumi.Input[str]] = None,
             fill_line_gap: Optional[pulumi.Input[str]] = None,
             font_family: Optional[pulumi.Input[str]] = None,
             style_control: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if copyright_holder is None and 'copyrightHolder' in kwargs:
            copyright_holder = kwargs['copyrightHolder']
        if fill_line_gap is None and 'fillLineGap' in kwargs:
            fill_line_gap = kwargs['fillLineGap']
        if font_family is None and 'fontFamily' in kwargs:
            font_family = kwargs['fontFamily']
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']

        if copyright_holder is not None:
            _setter("copyright_holder", copyright_holder)
        if fill_line_gap is not None:
            _setter("fill_line_gap", fill_line_gap)
        if font_family is not None:
            _setter("font_family", font_family)
        if style_control is not None:
            _setter("style_control", style_control)

    @property
    @pulumi.getter(name="copyrightHolder")
    def copyright_holder(self) -> Optional[pulumi.Input[str]]:
        """
        Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
        """
        return pulumi.get(self, "copyright_holder")

    @copyright_holder.setter
    def copyright_holder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "copyright_holder", value)

    @property
    @pulumi.getter(name="fillLineGap")
    def fill_line_gap(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
        """
        return pulumi.get(self, "fill_line_gap")

    @fill_line_gap.setter
    def fill_line_gap(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_line_gap", value)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to monospaced. (If styleControl is set to exclude, the font family is always set to monospaced.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as Arial), or a generic font family (such as serif), or default (to let the downstream player choose the font). - Leave blank to set the family to monospace.
        """
        return pulumi.get(self, "font_family")

    @font_family.setter
    def font_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_family", value)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to monospaced. Do not include any other style information.
        """
        return pulumi.get(self, "style_control")

    @style_control.setter
    def style_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "style_control", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs:
    def __init__(__self__, *,
                 style_control: pulumi.Input[str]):
        """
        :param pulumi.Input[str] style_control: This field is not currently supported and will not affect the output styling. Leave the default value.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']
        if style_control is None:
            raise TypeError("Missing 'style_control' argument")

        _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> pulumi.Input[str]:
        """
        This field is not currently supported and will not affect the output styling. Leave the default value.
        """
        return pulumi.get(self, "style_control")

    @style_control.setter
    def style_control(self, value: pulumi.Input[str]):
        pulumi.set(self, "style_control", value)


@pulumi.input_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs:
    def __init__(__self__, *,
                 style_control: pulumi.Input[str]):
        """
        :param pulumi.Input[str] style_control: Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\\_STYLE\\_DATA - Dont pass through the style. The output captions will not contain any font styling information.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']
        if style_control is None:
            raise TypeError("Missing 'style_control' argument")

        _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> pulumi.Input[str]:
        """
        Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\\_STYLE\\_DATA - Dont pass through the style. The output captions will not contain any font styling information.
        """
        return pulumi.get(self, "style_control")

    @style_control.setter
    def style_control(self, value: pulumi.Input[str]):
        pulumi.set(self, "style_control", value)


@pulumi.input_type
class ChannelEncoderSettingsGlobalConfigurationArgs:
    def __init__(__self__, *,
                 initial_audio_gain: Optional[pulumi.Input[int]] = None,
                 input_end_action: Optional[pulumi.Input[str]] = None,
                 input_loss_behavior: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs']] = None,
                 output_locking_mode: Optional[pulumi.Input[str]] = None,
                 output_timing_source: Optional[pulumi.Input[str]] = None,
                 support_low_framerate_inputs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] initial_audio_gain: Value to set the initial audio gain for the Live Event.
        :param pulumi.Input[str] input_end_action: Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When none is configured the encoder will transcode either black, a solid color, or a user specified slate images per the Input Loss Behavior configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
        :param pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs'] input_loss_behavior: Settings for system actions when input is lost. See Input Loss Behavior for more details.
        :param pulumi.Input[str] output_locking_mode: Indicates how MediaLive pipelines are synchronized. PIPELINE\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
        :param pulumi.Input[str] output_timing_source: Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
        :param pulumi.Input[str] support_low_framerate_inputs: Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
        """
        ChannelEncoderSettingsGlobalConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            initial_audio_gain=initial_audio_gain,
            input_end_action=input_end_action,
            input_loss_behavior=input_loss_behavior,
            output_locking_mode=output_locking_mode,
            output_timing_source=output_timing_source,
            support_low_framerate_inputs=support_low_framerate_inputs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             initial_audio_gain: Optional[pulumi.Input[int]] = None,
             input_end_action: Optional[pulumi.Input[str]] = None,
             input_loss_behavior: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs']] = None,
             output_locking_mode: Optional[pulumi.Input[str]] = None,
             output_timing_source: Optional[pulumi.Input[str]] = None,
             support_low_framerate_inputs: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if initial_audio_gain is None and 'initialAudioGain' in kwargs:
            initial_audio_gain = kwargs['initialAudioGain']
        if input_end_action is None and 'inputEndAction' in kwargs:
            input_end_action = kwargs['inputEndAction']
        if input_loss_behavior is None and 'inputLossBehavior' in kwargs:
            input_loss_behavior = kwargs['inputLossBehavior']
        if output_locking_mode is None and 'outputLockingMode' in kwargs:
            output_locking_mode = kwargs['outputLockingMode']
        if output_timing_source is None and 'outputTimingSource' in kwargs:
            output_timing_source = kwargs['outputTimingSource']
        if support_low_framerate_inputs is None and 'supportLowFramerateInputs' in kwargs:
            support_low_framerate_inputs = kwargs['supportLowFramerateInputs']

        if initial_audio_gain is not None:
            _setter("initial_audio_gain", initial_audio_gain)
        if input_end_action is not None:
            _setter("input_end_action", input_end_action)
        if input_loss_behavior is not None:
            _setter("input_loss_behavior", input_loss_behavior)
        if output_locking_mode is not None:
            _setter("output_locking_mode", output_locking_mode)
        if output_timing_source is not None:
            _setter("output_timing_source", output_timing_source)
        if support_low_framerate_inputs is not None:
            _setter("support_low_framerate_inputs", support_low_framerate_inputs)

    @property
    @pulumi.getter(name="initialAudioGain")
    def initial_audio_gain(self) -> Optional[pulumi.Input[int]]:
        """
        Value to set the initial audio gain for the Live Event.
        """
        return pulumi.get(self, "initial_audio_gain")

    @initial_audio_gain.setter
    def initial_audio_gain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_audio_gain", value)

    @property
    @pulumi.getter(name="inputEndAction")
    def input_end_action(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When none is configured the encoder will transcode either black, a solid color, or a user specified slate images per the Input Loss Behavior configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
        """
        return pulumi.get(self, "input_end_action")

    @input_end_action.setter
    def input_end_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_end_action", value)

    @property
    @pulumi.getter(name="inputLossBehavior")
    def input_loss_behavior(self) -> Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs']]:
        """
        Settings for system actions when input is lost. See Input Loss Behavior for more details.
        """
        return pulumi.get(self, "input_loss_behavior")

    @input_loss_behavior.setter
    def input_loss_behavior(self, value: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs']]):
        pulumi.set(self, "input_loss_behavior", value)

    @property
    @pulumi.getter(name="outputLockingMode")
    def output_locking_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how MediaLive pipelines are synchronized. PIPELINE\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
        """
        return pulumi.get(self, "output_locking_mode")

    @output_locking_mode.setter
    def output_locking_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_locking_mode", value)

    @property
    @pulumi.getter(name="outputTimingSource")
    def output_timing_source(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
        """
        return pulumi.get(self, "output_timing_source")

    @output_timing_source.setter
    def output_timing_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_timing_source", value)

    @property
    @pulumi.getter(name="supportLowFramerateInputs")
    def support_low_framerate_inputs(self) -> Optional[pulumi.Input[str]]:
        """
        Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
        """
        return pulumi.get(self, "support_low_framerate_inputs")

    @support_low_framerate_inputs.setter
    def support_low_framerate_inputs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_low_framerate_inputs", value)


@pulumi.input_type
class ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs:
    def __init__(__self__, *,
                 black_frame_msec: Optional[pulumi.Input[int]] = None,
                 input_loss_image_color: Optional[pulumi.Input[str]] = None,
                 input_loss_image_slate: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs']] = None,
                 input_loss_image_type: Optional[pulumi.Input[str]] = None,
                 repeat_frame_msec: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_frame_msec=black_frame_msec,
            input_loss_image_color=input_loss_image_color,
            input_loss_image_slate=input_loss_image_slate,
            input_loss_image_type=input_loss_image_type,
            repeat_frame_msec=repeat_frame_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_frame_msec: Optional[pulumi.Input[int]] = None,
             input_loss_image_color: Optional[pulumi.Input[str]] = None,
             input_loss_image_slate: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs']] = None,
             input_loss_image_type: Optional[pulumi.Input[str]] = None,
             repeat_frame_msec: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if black_frame_msec is None and 'blackFrameMsec' in kwargs:
            black_frame_msec = kwargs['blackFrameMsec']
        if input_loss_image_color is None and 'inputLossImageColor' in kwargs:
            input_loss_image_color = kwargs['inputLossImageColor']
        if input_loss_image_slate is None and 'inputLossImageSlate' in kwargs:
            input_loss_image_slate = kwargs['inputLossImageSlate']
        if input_loss_image_type is None and 'inputLossImageType' in kwargs:
            input_loss_image_type = kwargs['inputLossImageType']
        if repeat_frame_msec is None and 'repeatFrameMsec' in kwargs:
            repeat_frame_msec = kwargs['repeatFrameMsec']

        if black_frame_msec is not None:
            _setter("black_frame_msec", black_frame_msec)
        if input_loss_image_color is not None:
            _setter("input_loss_image_color", input_loss_image_color)
        if input_loss_image_slate is not None:
            _setter("input_loss_image_slate", input_loss_image_slate)
        if input_loss_image_type is not None:
            _setter("input_loss_image_type", input_loss_image_type)
        if repeat_frame_msec is not None:
            _setter("repeat_frame_msec", repeat_frame_msec)

    @property
    @pulumi.getter(name="blackFrameMsec")
    def black_frame_msec(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "black_frame_msec")

    @black_frame_msec.setter
    def black_frame_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "black_frame_msec", value)

    @property
    @pulumi.getter(name="inputLossImageColor")
    def input_loss_image_color(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "input_loss_image_color")

    @input_loss_image_color.setter
    def input_loss_image_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_image_color", value)

    @property
    @pulumi.getter(name="inputLossImageSlate")
    def input_loss_image_slate(self) -> Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs']]:
        return pulumi.get(self, "input_loss_image_slate")

    @input_loss_image_slate.setter
    def input_loss_image_slate(self, value: Optional[pulumi.Input['ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs']]):
        pulumi.set(self, "input_loss_image_slate", value)

    @property
    @pulumi.getter(name="inputLossImageType")
    def input_loss_image_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "input_loss_image_type")

    @input_loss_image_type.setter
    def input_loss_image_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_image_type", value)

    @property
    @pulumi.getter(name="repeatFrameMsec")
    def repeat_frame_msec(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "repeat_frame_msec")

    @repeat_frame_msec.setter
    def repeat_frame_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repeat_frame_msec", value)


@pulumi.input_type
class ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: . Username to be used.
        """
        ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsMotionGraphicsConfigurationArgs:
    def __init__(__self__, *,
                 motion_graphics_settings: pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs'],
                 motion_graphics_insertion: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs'] motion_graphics_settings: Motion Graphics Settings. See Motion Graphics Settings for more details.
        :param pulumi.Input[str] motion_graphics_insertion: Motion Graphics Insertion.
        """
        ChannelEncoderSettingsMotionGraphicsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            motion_graphics_settings=motion_graphics_settings,
            motion_graphics_insertion=motion_graphics_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             motion_graphics_settings: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs']] = None,
             motion_graphics_insertion: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if motion_graphics_settings is None and 'motionGraphicsSettings' in kwargs:
            motion_graphics_settings = kwargs['motionGraphicsSettings']
        if motion_graphics_settings is None:
            raise TypeError("Missing 'motion_graphics_settings' argument")
        if motion_graphics_insertion is None and 'motionGraphicsInsertion' in kwargs:
            motion_graphics_insertion = kwargs['motionGraphicsInsertion']

        _setter("motion_graphics_settings", motion_graphics_settings)
        if motion_graphics_insertion is not None:
            _setter("motion_graphics_insertion", motion_graphics_insertion)

    @property
    @pulumi.getter(name="motionGraphicsSettings")
    def motion_graphics_settings(self) -> pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs']:
        """
        Motion Graphics Settings. See Motion Graphics Settings for more details.
        """
        return pulumi.get(self, "motion_graphics_settings")

    @motion_graphics_settings.setter
    def motion_graphics_settings(self, value: pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs']):
        pulumi.set(self, "motion_graphics_settings", value)

    @property
    @pulumi.getter(name="motionGraphicsInsertion")
    def motion_graphics_insertion(self) -> Optional[pulumi.Input[str]]:
        """
        Motion Graphics Insertion.
        """
        return pulumi.get(self, "motion_graphics_insertion")

    @motion_graphics_insertion.setter
    def motion_graphics_insertion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "motion_graphics_insertion", value)


@pulumi.input_type
class ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs:
    def __init__(__self__, *,
                 html_motion_graphics_settings: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs'] html_motion_graphics_settings: Html Motion Graphics Settings.
        """
        ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            html_motion_graphics_settings=html_motion_graphics_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             html_motion_graphics_settings: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if html_motion_graphics_settings is None and 'htmlMotionGraphicsSettings' in kwargs:
            html_motion_graphics_settings = kwargs['htmlMotionGraphicsSettings']

        if html_motion_graphics_settings is not None:
            _setter("html_motion_graphics_settings", html_motion_graphics_settings)

    @property
    @pulumi.getter(name="htmlMotionGraphicsSettings")
    def html_motion_graphics_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs']]:
        """
        Html Motion Graphics Settings.
        """
        return pulumi.get(self, "html_motion_graphics_settings")

    @html_motion_graphics_settings.setter
    def html_motion_graphics_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs']]):
        pulumi.set(self, "html_motion_graphics_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsNielsenConfigurationArgs:
    def __init__(__self__, *,
                 distributor_id: Optional[pulumi.Input[str]] = None,
                 nielsen_pcm_to_id3_tagging: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] distributor_id: Enter the Distributor ID assigned to your organization by Nielsen.
        :param pulumi.Input[str] nielsen_pcm_to_id3_tagging: Enables Nielsen PCM to ID3 tagging.
        """
        ChannelEncoderSettingsNielsenConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distributor_id=distributor_id,
            nielsen_pcm_to_id3_tagging=nielsen_pcm_to_id3_tagging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distributor_id: Optional[pulumi.Input[str]] = None,
             nielsen_pcm_to_id3_tagging: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distributor_id is None and 'distributorId' in kwargs:
            distributor_id = kwargs['distributorId']
        if nielsen_pcm_to_id3_tagging is None and 'nielsenPcmToId3Tagging' in kwargs:
            nielsen_pcm_to_id3_tagging = kwargs['nielsenPcmToId3Tagging']

        if distributor_id is not None:
            _setter("distributor_id", distributor_id)
        if nielsen_pcm_to_id3_tagging is not None:
            _setter("nielsen_pcm_to_id3_tagging", nielsen_pcm_to_id3_tagging)

    @property
    @pulumi.getter(name="distributorId")
    def distributor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Enter the Distributor ID assigned to your organization by Nielsen.
        """
        return pulumi.get(self, "distributor_id")

    @distributor_id.setter
    def distributor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "distributor_id", value)

    @property
    @pulumi.getter(name="nielsenPcmToId3Tagging")
    def nielsen_pcm_to_id3_tagging(self) -> Optional[pulumi.Input[str]]:
        """
        Enables Nielsen PCM to ID3 tagging.
        """
        return pulumi.get(self, "nielsen_pcm_to_id3_tagging")

    @nielsen_pcm_to_id3_tagging.setter
    def nielsen_pcm_to_id3_tagging(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_pcm_to_id3_tagging", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupArgs:
    def __init__(__self__, *,
                 output_group_settings: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs'],
                 outputs: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs'] output_group_settings: Settings associated with the output group. See Output Group Settings for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputArgs']]] outputs: List of outputs. See Outputs for more details.
        :param pulumi.Input[str] name: Custom output group name defined by the user.
        """
        ChannelEncoderSettingsOutputGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_group_settings=output_group_settings,
            outputs=outputs,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs']] = None,
             outputs: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_group_settings is None and 'outputGroupSettings' in kwargs:
            output_group_settings = kwargs['outputGroupSettings']
        if output_group_settings is None:
            raise TypeError("Missing 'output_group_settings' argument")
        if outputs is None:
            raise TypeError("Missing 'outputs' argument")

        _setter("output_group_settings", output_group_settings)
        _setter("outputs", outputs)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="outputGroupSettings")
    def output_group_settings(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs']:
        """
        Settings associated with the output group. See Output Group Settings for more details.
        """
        return pulumi.get(self, "output_group_settings")

    @output_group_settings.setter
    def output_group_settings(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs']):
        pulumi.set(self, "output_group_settings", value)

    @property
    @pulumi.getter
    def outputs(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputArgs']]]:
        """
        List of outputs. See Outputs for more details.
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputArgs']]]):
        pulumi.set(self, "outputs", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom output group name defined by the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputArgs:
    def __init__(__self__, *,
                 output_settings: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs'],
                 audio_description_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 caption_description_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_name: Optional[pulumi.Input[str]] = None,
                 video_description_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs'] output_settings: Settings for output. See Output Settings for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audio_description_names: The names of the audio descriptions used as audio sources for the output.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] caption_description_names: The names of the caption descriptions used as caption sources for the output.
        :param pulumi.Input[str] output_name: The name used to identify an output.
        :param pulumi.Input[str] video_description_name: The name of the video description used as video source for the output.
        """
        ChannelEncoderSettingsOutputGroupOutputArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_settings=output_settings,
            audio_description_names=audio_description_names,
            caption_description_names=caption_description_names,
            output_name=output_name,
            video_description_name=video_description_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs']] = None,
             audio_description_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             caption_description_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             output_name: Optional[pulumi.Input[str]] = None,
             video_description_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_settings is None and 'outputSettings' in kwargs:
            output_settings = kwargs['outputSettings']
        if output_settings is None:
            raise TypeError("Missing 'output_settings' argument")
        if audio_description_names is None and 'audioDescriptionNames' in kwargs:
            audio_description_names = kwargs['audioDescriptionNames']
        if caption_description_names is None and 'captionDescriptionNames' in kwargs:
            caption_description_names = kwargs['captionDescriptionNames']
        if output_name is None and 'outputName' in kwargs:
            output_name = kwargs['outputName']
        if video_description_name is None and 'videoDescriptionName' in kwargs:
            video_description_name = kwargs['videoDescriptionName']

        _setter("output_settings", output_settings)
        if audio_description_names is not None:
            _setter("audio_description_names", audio_description_names)
        if caption_description_names is not None:
            _setter("caption_description_names", caption_description_names)
        if output_name is not None:
            _setter("output_name", output_name)
        if video_description_name is not None:
            _setter("video_description_name", video_description_name)

    @property
    @pulumi.getter(name="outputSettings")
    def output_settings(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs']:
        """
        Settings for output. See Output Settings for more details.
        """
        return pulumi.get(self, "output_settings")

    @output_settings.setter
    def output_settings(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs']):
        pulumi.set(self, "output_settings", value)

    @property
    @pulumi.getter(name="audioDescriptionNames")
    def audio_description_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of the audio descriptions used as audio sources for the output.
        """
        return pulumi.get(self, "audio_description_names")

    @audio_description_names.setter
    def audio_description_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "audio_description_names", value)

    @property
    @pulumi.getter(name="captionDescriptionNames")
    def caption_description_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of the caption descriptions used as caption sources for the output.
        """
        return pulumi.get(self, "caption_description_names")

    @caption_description_names.setter
    def caption_description_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "caption_description_names", value)

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name used to identify an output.
        """
        return pulumi.get(self, "output_name")

    @output_name.setter
    def output_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_name", value)

    @property
    @pulumi.getter(name="videoDescriptionName")
    def video_description_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the video description used as video source for the output.
        """
        return pulumi.get(self, "video_description_name")

    @video_description_name.setter
    def video_description_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_description_name", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs:
    def __init__(__self__, *,
                 archive_group_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs']]]] = None,
                 frame_capture_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs']] = None,
                 hls_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs']] = None,
                 media_package_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs']] = None,
                 ms_smooth_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs']] = None,
                 multiplex_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs']] = None,
                 rtmp_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs']] = None,
                 udp_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs']]] archive_group_settings: Archive group settings. See Archive Group Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs'] media_package_group_settings: Media package group settings. See Media Package Group Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs'] rtmp_group_settings: RTMP group settings. See RTMP Group Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_group_settings=archive_group_settings,
            frame_capture_group_settings=frame_capture_group_settings,
            hls_group_settings=hls_group_settings,
            media_package_group_settings=media_package_group_settings,
            ms_smooth_group_settings=ms_smooth_group_settings,
            multiplex_group_settings=multiplex_group_settings,
            rtmp_group_settings=rtmp_group_settings,
            udp_group_settings=udp_group_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_group_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs']]]] = None,
             frame_capture_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs']] = None,
             hls_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs']] = None,
             media_package_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs']] = None,
             ms_smooth_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs']] = None,
             multiplex_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs']] = None,
             rtmp_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs']] = None,
             udp_group_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_group_settings is None and 'archiveGroupSettings' in kwargs:
            archive_group_settings = kwargs['archiveGroupSettings']
        if frame_capture_group_settings is None and 'frameCaptureGroupSettings' in kwargs:
            frame_capture_group_settings = kwargs['frameCaptureGroupSettings']
        if hls_group_settings is None and 'hlsGroupSettings' in kwargs:
            hls_group_settings = kwargs['hlsGroupSettings']
        if media_package_group_settings is None and 'mediaPackageGroupSettings' in kwargs:
            media_package_group_settings = kwargs['mediaPackageGroupSettings']
        if ms_smooth_group_settings is None and 'msSmoothGroupSettings' in kwargs:
            ms_smooth_group_settings = kwargs['msSmoothGroupSettings']
        if multiplex_group_settings is None and 'multiplexGroupSettings' in kwargs:
            multiplex_group_settings = kwargs['multiplexGroupSettings']
        if rtmp_group_settings is None and 'rtmpGroupSettings' in kwargs:
            rtmp_group_settings = kwargs['rtmpGroupSettings']
        if udp_group_settings is None and 'udpGroupSettings' in kwargs:
            udp_group_settings = kwargs['udpGroupSettings']

        if archive_group_settings is not None:
            _setter("archive_group_settings", archive_group_settings)
        if frame_capture_group_settings is not None:
            _setter("frame_capture_group_settings", frame_capture_group_settings)
        if hls_group_settings is not None:
            _setter("hls_group_settings", hls_group_settings)
        if media_package_group_settings is not None:
            _setter("media_package_group_settings", media_package_group_settings)
        if ms_smooth_group_settings is not None:
            _setter("ms_smooth_group_settings", ms_smooth_group_settings)
        if multiplex_group_settings is not None:
            _setter("multiplex_group_settings", multiplex_group_settings)
        if rtmp_group_settings is not None:
            _setter("rtmp_group_settings", rtmp_group_settings)
        if udp_group_settings is not None:
            _setter("udp_group_settings", udp_group_settings)

    @property
    @pulumi.getter(name="archiveGroupSettings")
    def archive_group_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs']]]]:
        """
        Archive group settings. See Archive Group Settings for more details.
        """
        return pulumi.get(self, "archive_group_settings")

    @archive_group_settings.setter
    def archive_group_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs']]]]):
        pulumi.set(self, "archive_group_settings", value)

    @property
    @pulumi.getter(name="frameCaptureGroupSettings")
    def frame_capture_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs']]:
        return pulumi.get(self, "frame_capture_group_settings")

    @frame_capture_group_settings.setter
    def frame_capture_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs']]):
        pulumi.set(self, "frame_capture_group_settings", value)

    @property
    @pulumi.getter(name="hlsGroupSettings")
    def hls_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs']]:
        return pulumi.get(self, "hls_group_settings")

    @hls_group_settings.setter
    def hls_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs']]):
        pulumi.set(self, "hls_group_settings", value)

    @property
    @pulumi.getter(name="mediaPackageGroupSettings")
    def media_package_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs']]:
        """
        Media package group settings. See Media Package Group Settings for more details.
        """
        return pulumi.get(self, "media_package_group_settings")

    @media_package_group_settings.setter
    def media_package_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs']]):
        pulumi.set(self, "media_package_group_settings", value)

    @property
    @pulumi.getter(name="msSmoothGroupSettings")
    def ms_smooth_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs']]:
        return pulumi.get(self, "ms_smooth_group_settings")

    @ms_smooth_group_settings.setter
    def ms_smooth_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs']]):
        pulumi.set(self, "ms_smooth_group_settings", value)

    @property
    @pulumi.getter(name="multiplexGroupSettings")
    def multiplex_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs']]:
        return pulumi.get(self, "multiplex_group_settings")

    @multiplex_group_settings.setter
    def multiplex_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs']]):
        pulumi.set(self, "multiplex_group_settings", value)

    @property
    @pulumi.getter(name="rtmpGroupSettings")
    def rtmp_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs']]:
        """
        RTMP group settings. See RTMP Group Settings for more details.
        """
        return pulumi.get(self, "rtmp_group_settings")

    @rtmp_group_settings.setter
    def rtmp_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs']]):
        pulumi.set(self, "rtmp_group_settings", value)

    @property
    @pulumi.getter(name="udpGroupSettings")
    def udp_group_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs']]:
        return pulumi.get(self, "udp_group_settings")

    @udp_group_settings.setter
    def udp_group_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs']]):
        pulumi.set(self, "udp_group_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs'],
                 archive_cdn_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs']] = None,
                 rollover_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs'] destination: A director and base filename where archive files should be written. See Destination for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs'] archive_cdn_settings: Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
        :param pulumi.Input[int] rollover_interval: Number of seconds to write to archive file before closing and starting a new one.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            archive_cdn_settings=archive_cdn_settings,
            rollover_interval=rollover_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs']] = None,
             archive_cdn_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs']] = None,
             rollover_interval: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if archive_cdn_settings is None and 'archiveCdnSettings' in kwargs:
            archive_cdn_settings = kwargs['archiveCdnSettings']
        if rollover_interval is None and 'rolloverInterval' in kwargs:
            rollover_interval = kwargs['rolloverInterval']

        _setter("destination", destination)
        if archive_cdn_settings is not None:
            _setter("archive_cdn_settings", archive_cdn_settings)
        if rollover_interval is not None:
            _setter("rollover_interval", rollover_interval)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs']:
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="archiveCdnSettings")
    def archive_cdn_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs']]:
        """
        Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
        """
        return pulumi.get(self, "archive_cdn_settings")

    @archive_cdn_settings.setter
    def archive_cdn_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs']]):
        pulumi.set(self, "archive_cdn_settings", value)

    @property
    @pulumi.getter(name="rolloverInterval")
    def rollover_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to write to archive file before closing and starting a new one.
        """
        return pulumi.get(self, "rollover_interval")

    @rollover_interval.setter
    def rollover_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rollover_interval", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs:
    def __init__(__self__, *,
                 archive_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs'] archive_s3_settings: Archive S3 Settings. See Archive S3 Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_s3_settings=archive_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_s3_settings is None and 'archiveS3Settings' in kwargs:
            archive_s3_settings = kwargs['archiveS3Settings']

        if archive_s3_settings is not None:
            _setter("archive_s3_settings", archive_s3_settings)

    @property
    @pulumi.getter(name="archiveS3Settings")
    def archive_s3_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs']]:
        """
        Archive S3 Settings. See Archive S3 Settings for more details.
        """
        return pulumi.get(self, "archive_s3_settings")

    @archive_s3_settings.setter
    def archive_s3_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs']]):
        pulumi.set(self, "archive_s3_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs:
    def __init__(__self__, *,
                 canned_acl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs'],
                 frame_capture_cdn_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs'] destination: A director and base filename where archive files should be written. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            frame_capture_cdn_settings=frame_capture_cdn_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs']] = None,
             frame_capture_cdn_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if frame_capture_cdn_settings is None and 'frameCaptureCdnSettings' in kwargs:
            frame_capture_cdn_settings = kwargs['frameCaptureCdnSettings']

        _setter("destination", destination)
        if frame_capture_cdn_settings is not None:
            _setter("frame_capture_cdn_settings", frame_capture_cdn_settings)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs']:
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="frameCaptureCdnSettings")
    def frame_capture_cdn_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs']]:
        return pulumi.get(self, "frame_capture_cdn_settings")

    @frame_capture_cdn_settings.setter
    def frame_capture_cdn_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs']]):
        pulumi.set(self, "frame_capture_cdn_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs:
    def __init__(__self__, *,
                 frame_capture_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs']] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_s3_settings=frame_capture_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if frame_capture_s3_settings is None and 'frameCaptureS3Settings' in kwargs:
            frame_capture_s3_settings = kwargs['frameCaptureS3Settings']

        if frame_capture_s3_settings is not None:
            _setter("frame_capture_s3_settings", frame_capture_s3_settings)

    @property
    @pulumi.getter(name="frameCaptureS3Settings")
    def frame_capture_s3_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs']]:
        return pulumi.get(self, "frame_capture_s3_settings")

    @frame_capture_s3_settings.setter
    def frame_capture_s3_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs']]):
        pulumi.set(self, "frame_capture_s3_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs:
    def __init__(__self__, *,
                 canned_acl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs'],
                 ad_markers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 base_url_content: Optional[pulumi.Input[str]] = None,
                 base_url_content1: Optional[pulumi.Input[str]] = None,
                 base_url_manifest: Optional[pulumi.Input[str]] = None,
                 base_url_manifest1: Optional[pulumi.Input[str]] = None,
                 caption_language_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs']]]] = None,
                 caption_language_setting: Optional[pulumi.Input[str]] = None,
                 client_cache: Optional[pulumi.Input[str]] = None,
                 codec_specification: Optional[pulumi.Input[str]] = None,
                 constant_iv: Optional[pulumi.Input[str]] = None,
                 directory_structure: Optional[pulumi.Input[str]] = None,
                 discontinuity_tags: Optional[pulumi.Input[str]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 hls_cdn_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs']]]] = None,
                 hls_id3_segment_tagging: Optional[pulumi.Input[str]] = None,
                 iframe_only_playlists: Optional[pulumi.Input[str]] = None,
                 incomplete_segment_behavior: Optional[pulumi.Input[str]] = None,
                 index_n_segments: Optional[pulumi.Input[int]] = None,
                 input_loss_action: Optional[pulumi.Input[str]] = None,
                 iv_in_manifest: Optional[pulumi.Input[str]] = None,
                 iv_source: Optional[pulumi.Input[str]] = None,
                 keep_segments: Optional[pulumi.Input[int]] = None,
                 key_format: Optional[pulumi.Input[str]] = None,
                 key_format_versions: Optional[pulumi.Input[str]] = None,
                 key_provider_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs']] = None,
                 manifest_compression: Optional[pulumi.Input[str]] = None,
                 manifest_duration_format: Optional[pulumi.Input[str]] = None,
                 min_segment_length: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 output_selection: Optional[pulumi.Input[str]] = None,
                 program_date_time: Optional[pulumi.Input[str]] = None,
                 program_date_time_clock: Optional[pulumi.Input[str]] = None,
                 program_date_time_period: Optional[pulumi.Input[int]] = None,
                 redundant_manifest: Optional[pulumi.Input[str]] = None,
                 segment_length: Optional[pulumi.Input[int]] = None,
                 segments_per_subdirectory: Optional[pulumi.Input[int]] = None,
                 stream_inf_resolution: Optional[pulumi.Input[str]] = None,
                 timed_metadata_id3_frame: Optional[pulumi.Input[str]] = None,
                 timed_metadata_id3_period: Optional[pulumi.Input[int]] = None,
                 timestamp_delta_milliseconds: Optional[pulumi.Input[int]] = None,
                 ts_file_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs'] destination: A director and base filename where archive files should be written. See Destination for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ad_markers: The ad marker type for this output group.
        :param pulumi.Input[str] input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param pulumi.Input[str] timed_metadata_id3_frame: Indicates ID3 frame that has the timecode.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            ad_markers=ad_markers,
            base_url_content=base_url_content,
            base_url_content1=base_url_content1,
            base_url_manifest=base_url_manifest,
            base_url_manifest1=base_url_manifest1,
            caption_language_mappings=caption_language_mappings,
            caption_language_setting=caption_language_setting,
            client_cache=client_cache,
            codec_specification=codec_specification,
            constant_iv=constant_iv,
            directory_structure=directory_structure,
            discontinuity_tags=discontinuity_tags,
            encryption_type=encryption_type,
            hls_cdn_settings=hls_cdn_settings,
            hls_id3_segment_tagging=hls_id3_segment_tagging,
            iframe_only_playlists=iframe_only_playlists,
            incomplete_segment_behavior=incomplete_segment_behavior,
            index_n_segments=index_n_segments,
            input_loss_action=input_loss_action,
            iv_in_manifest=iv_in_manifest,
            iv_source=iv_source,
            keep_segments=keep_segments,
            key_format=key_format,
            key_format_versions=key_format_versions,
            key_provider_settings=key_provider_settings,
            manifest_compression=manifest_compression,
            manifest_duration_format=manifest_duration_format,
            min_segment_length=min_segment_length,
            mode=mode,
            output_selection=output_selection,
            program_date_time=program_date_time,
            program_date_time_clock=program_date_time_clock,
            program_date_time_period=program_date_time_period,
            redundant_manifest=redundant_manifest,
            segment_length=segment_length,
            segments_per_subdirectory=segments_per_subdirectory,
            stream_inf_resolution=stream_inf_resolution,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
            timestamp_delta_milliseconds=timestamp_delta_milliseconds,
            ts_file_mode=ts_file_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs']] = None,
             ad_markers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             base_url_content: Optional[pulumi.Input[str]] = None,
             base_url_content1: Optional[pulumi.Input[str]] = None,
             base_url_manifest: Optional[pulumi.Input[str]] = None,
             base_url_manifest1: Optional[pulumi.Input[str]] = None,
             caption_language_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs']]]] = None,
             caption_language_setting: Optional[pulumi.Input[str]] = None,
             client_cache: Optional[pulumi.Input[str]] = None,
             codec_specification: Optional[pulumi.Input[str]] = None,
             constant_iv: Optional[pulumi.Input[str]] = None,
             directory_structure: Optional[pulumi.Input[str]] = None,
             discontinuity_tags: Optional[pulumi.Input[str]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             hls_cdn_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs']]]] = None,
             hls_id3_segment_tagging: Optional[pulumi.Input[str]] = None,
             iframe_only_playlists: Optional[pulumi.Input[str]] = None,
             incomplete_segment_behavior: Optional[pulumi.Input[str]] = None,
             index_n_segments: Optional[pulumi.Input[int]] = None,
             input_loss_action: Optional[pulumi.Input[str]] = None,
             iv_in_manifest: Optional[pulumi.Input[str]] = None,
             iv_source: Optional[pulumi.Input[str]] = None,
             keep_segments: Optional[pulumi.Input[int]] = None,
             key_format: Optional[pulumi.Input[str]] = None,
             key_format_versions: Optional[pulumi.Input[str]] = None,
             key_provider_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs']] = None,
             manifest_compression: Optional[pulumi.Input[str]] = None,
             manifest_duration_format: Optional[pulumi.Input[str]] = None,
             min_segment_length: Optional[pulumi.Input[int]] = None,
             mode: Optional[pulumi.Input[str]] = None,
             output_selection: Optional[pulumi.Input[str]] = None,
             program_date_time: Optional[pulumi.Input[str]] = None,
             program_date_time_clock: Optional[pulumi.Input[str]] = None,
             program_date_time_period: Optional[pulumi.Input[int]] = None,
             redundant_manifest: Optional[pulumi.Input[str]] = None,
             segment_length: Optional[pulumi.Input[int]] = None,
             segments_per_subdirectory: Optional[pulumi.Input[int]] = None,
             stream_inf_resolution: Optional[pulumi.Input[str]] = None,
             timed_metadata_id3_frame: Optional[pulumi.Input[str]] = None,
             timed_metadata_id3_period: Optional[pulumi.Input[int]] = None,
             timestamp_delta_milliseconds: Optional[pulumi.Input[int]] = None,
             ts_file_mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if ad_markers is None and 'adMarkers' in kwargs:
            ad_markers = kwargs['adMarkers']
        if base_url_content is None and 'baseUrlContent' in kwargs:
            base_url_content = kwargs['baseUrlContent']
        if base_url_content1 is None and 'baseUrlContent1' in kwargs:
            base_url_content1 = kwargs['baseUrlContent1']
        if base_url_manifest is None and 'baseUrlManifest' in kwargs:
            base_url_manifest = kwargs['baseUrlManifest']
        if base_url_manifest1 is None and 'baseUrlManifest1' in kwargs:
            base_url_manifest1 = kwargs['baseUrlManifest1']
        if caption_language_mappings is None and 'captionLanguageMappings' in kwargs:
            caption_language_mappings = kwargs['captionLanguageMappings']
        if caption_language_setting is None and 'captionLanguageSetting' in kwargs:
            caption_language_setting = kwargs['captionLanguageSetting']
        if client_cache is None and 'clientCache' in kwargs:
            client_cache = kwargs['clientCache']
        if codec_specification is None and 'codecSpecification' in kwargs:
            codec_specification = kwargs['codecSpecification']
        if constant_iv is None and 'constantIv' in kwargs:
            constant_iv = kwargs['constantIv']
        if directory_structure is None and 'directoryStructure' in kwargs:
            directory_structure = kwargs['directoryStructure']
        if discontinuity_tags is None and 'discontinuityTags' in kwargs:
            discontinuity_tags = kwargs['discontinuityTags']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if hls_cdn_settings is None and 'hlsCdnSettings' in kwargs:
            hls_cdn_settings = kwargs['hlsCdnSettings']
        if hls_id3_segment_tagging is None and 'hlsId3SegmentTagging' in kwargs:
            hls_id3_segment_tagging = kwargs['hlsId3SegmentTagging']
        if iframe_only_playlists is None and 'iframeOnlyPlaylists' in kwargs:
            iframe_only_playlists = kwargs['iframeOnlyPlaylists']
        if incomplete_segment_behavior is None and 'incompleteSegmentBehavior' in kwargs:
            incomplete_segment_behavior = kwargs['incompleteSegmentBehavior']
        if index_n_segments is None and 'indexNSegments' in kwargs:
            index_n_segments = kwargs['indexNSegments']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if iv_in_manifest is None and 'ivInManifest' in kwargs:
            iv_in_manifest = kwargs['ivInManifest']
        if iv_source is None and 'ivSource' in kwargs:
            iv_source = kwargs['ivSource']
        if keep_segments is None and 'keepSegments' in kwargs:
            keep_segments = kwargs['keepSegments']
        if key_format is None and 'keyFormat' in kwargs:
            key_format = kwargs['keyFormat']
        if key_format_versions is None and 'keyFormatVersions' in kwargs:
            key_format_versions = kwargs['keyFormatVersions']
        if key_provider_settings is None and 'keyProviderSettings' in kwargs:
            key_provider_settings = kwargs['keyProviderSettings']
        if manifest_compression is None and 'manifestCompression' in kwargs:
            manifest_compression = kwargs['manifestCompression']
        if manifest_duration_format is None and 'manifestDurationFormat' in kwargs:
            manifest_duration_format = kwargs['manifestDurationFormat']
        if min_segment_length is None and 'minSegmentLength' in kwargs:
            min_segment_length = kwargs['minSegmentLength']
        if output_selection is None and 'outputSelection' in kwargs:
            output_selection = kwargs['outputSelection']
        if program_date_time is None and 'programDateTime' in kwargs:
            program_date_time = kwargs['programDateTime']
        if program_date_time_clock is None and 'programDateTimeClock' in kwargs:
            program_date_time_clock = kwargs['programDateTimeClock']
        if program_date_time_period is None and 'programDateTimePeriod' in kwargs:
            program_date_time_period = kwargs['programDateTimePeriod']
        if redundant_manifest is None and 'redundantManifest' in kwargs:
            redundant_manifest = kwargs['redundantManifest']
        if segment_length is None and 'segmentLength' in kwargs:
            segment_length = kwargs['segmentLength']
        if segments_per_subdirectory is None and 'segmentsPerSubdirectory' in kwargs:
            segments_per_subdirectory = kwargs['segmentsPerSubdirectory']
        if stream_inf_resolution is None and 'streamInfResolution' in kwargs:
            stream_inf_resolution = kwargs['streamInfResolution']
        if timed_metadata_id3_frame is None and 'timedMetadataId3Frame' in kwargs:
            timed_metadata_id3_frame = kwargs['timedMetadataId3Frame']
        if timed_metadata_id3_period is None and 'timedMetadataId3Period' in kwargs:
            timed_metadata_id3_period = kwargs['timedMetadataId3Period']
        if timestamp_delta_milliseconds is None and 'timestampDeltaMilliseconds' in kwargs:
            timestamp_delta_milliseconds = kwargs['timestampDeltaMilliseconds']
        if ts_file_mode is None and 'tsFileMode' in kwargs:
            ts_file_mode = kwargs['tsFileMode']

        _setter("destination", destination)
        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if base_url_content is not None:
            _setter("base_url_content", base_url_content)
        if base_url_content1 is not None:
            _setter("base_url_content1", base_url_content1)
        if base_url_manifest is not None:
            _setter("base_url_manifest", base_url_manifest)
        if base_url_manifest1 is not None:
            _setter("base_url_manifest1", base_url_manifest1)
        if caption_language_mappings is not None:
            _setter("caption_language_mappings", caption_language_mappings)
        if caption_language_setting is not None:
            _setter("caption_language_setting", caption_language_setting)
        if client_cache is not None:
            _setter("client_cache", client_cache)
        if codec_specification is not None:
            _setter("codec_specification", codec_specification)
        if constant_iv is not None:
            _setter("constant_iv", constant_iv)
        if directory_structure is not None:
            _setter("directory_structure", directory_structure)
        if discontinuity_tags is not None:
            _setter("discontinuity_tags", discontinuity_tags)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if hls_cdn_settings is not None:
            _setter("hls_cdn_settings", hls_cdn_settings)
        if hls_id3_segment_tagging is not None:
            _setter("hls_id3_segment_tagging", hls_id3_segment_tagging)
        if iframe_only_playlists is not None:
            _setter("iframe_only_playlists", iframe_only_playlists)
        if incomplete_segment_behavior is not None:
            _setter("incomplete_segment_behavior", incomplete_segment_behavior)
        if index_n_segments is not None:
            _setter("index_n_segments", index_n_segments)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if iv_in_manifest is not None:
            _setter("iv_in_manifest", iv_in_manifest)
        if iv_source is not None:
            _setter("iv_source", iv_source)
        if keep_segments is not None:
            _setter("keep_segments", keep_segments)
        if key_format is not None:
            _setter("key_format", key_format)
        if key_format_versions is not None:
            _setter("key_format_versions", key_format_versions)
        if key_provider_settings is not None:
            _setter("key_provider_settings", key_provider_settings)
        if manifest_compression is not None:
            _setter("manifest_compression", manifest_compression)
        if manifest_duration_format is not None:
            _setter("manifest_duration_format", manifest_duration_format)
        if min_segment_length is not None:
            _setter("min_segment_length", min_segment_length)
        if mode is not None:
            _setter("mode", mode)
        if output_selection is not None:
            _setter("output_selection", output_selection)
        if program_date_time is not None:
            _setter("program_date_time", program_date_time)
        if program_date_time_clock is not None:
            _setter("program_date_time_clock", program_date_time_clock)
        if program_date_time_period is not None:
            _setter("program_date_time_period", program_date_time_period)
        if redundant_manifest is not None:
            _setter("redundant_manifest", redundant_manifest)
        if segment_length is not None:
            _setter("segment_length", segment_length)
        if segments_per_subdirectory is not None:
            _setter("segments_per_subdirectory", segments_per_subdirectory)
        if stream_inf_resolution is not None:
            _setter("stream_inf_resolution", stream_inf_resolution)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)
        if timestamp_delta_milliseconds is not None:
            _setter("timestamp_delta_milliseconds", timestamp_delta_milliseconds)
        if ts_file_mode is not None:
            _setter("ts_file_mode", ts_file_mode)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs']:
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ad marker type for this output group.
        """
        return pulumi.get(self, "ad_markers")

    @ad_markers.setter
    def ad_markers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ad_markers", value)

    @property
    @pulumi.getter(name="baseUrlContent")
    def base_url_content(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_url_content")

    @base_url_content.setter
    def base_url_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url_content", value)

    @property
    @pulumi.getter(name="baseUrlContent1")
    def base_url_content1(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_url_content1")

    @base_url_content1.setter
    def base_url_content1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url_content1", value)

    @property
    @pulumi.getter(name="baseUrlManifest")
    def base_url_manifest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_url_manifest")

    @base_url_manifest.setter
    def base_url_manifest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url_manifest", value)

    @property
    @pulumi.getter(name="baseUrlManifest1")
    def base_url_manifest1(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_url_manifest1")

    @base_url_manifest1.setter
    def base_url_manifest1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url_manifest1", value)

    @property
    @pulumi.getter(name="captionLanguageMappings")
    def caption_language_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs']]]]:
        return pulumi.get(self, "caption_language_mappings")

    @caption_language_mappings.setter
    def caption_language_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs']]]]):
        pulumi.set(self, "caption_language_mappings", value)

    @property
    @pulumi.getter(name="captionLanguageSetting")
    def caption_language_setting(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "caption_language_setting")

    @caption_language_setting.setter
    def caption_language_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caption_language_setting", value)

    @property
    @pulumi.getter(name="clientCache")
    def client_cache(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_cache")

    @client_cache.setter
    def client_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cache", value)

    @property
    @pulumi.getter(name="codecSpecification")
    def codec_specification(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "codec_specification")

    @codec_specification.setter
    def codec_specification(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec_specification", value)

    @property
    @pulumi.getter(name="constantIv")
    def constant_iv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "constant_iv")

    @constant_iv.setter
    def constant_iv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "constant_iv", value)

    @property
    @pulumi.getter(name="directoryStructure")
    def directory_structure(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory_structure")

    @directory_structure.setter
    def directory_structure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_structure", value)

    @property
    @pulumi.getter(name="discontinuityTags")
    def discontinuity_tags(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "discontinuity_tags")

    @discontinuity_tags.setter
    def discontinuity_tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discontinuity_tags", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter(name="hlsCdnSettings")
    def hls_cdn_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs']]]]:
        return pulumi.get(self, "hls_cdn_settings")

    @hls_cdn_settings.setter
    def hls_cdn_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs']]]]):
        pulumi.set(self, "hls_cdn_settings", value)

    @property
    @pulumi.getter(name="hlsId3SegmentTagging")
    def hls_id3_segment_tagging(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hls_id3_segment_tagging")

    @hls_id3_segment_tagging.setter
    def hls_id3_segment_tagging(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hls_id3_segment_tagging", value)

    @property
    @pulumi.getter(name="iframeOnlyPlaylists")
    def iframe_only_playlists(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iframe_only_playlists")

    @iframe_only_playlists.setter
    def iframe_only_playlists(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iframe_only_playlists", value)

    @property
    @pulumi.getter(name="incompleteSegmentBehavior")
    def incomplete_segment_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "incomplete_segment_behavior")

    @incomplete_segment_behavior.setter
    def incomplete_segment_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "incomplete_segment_behavior", value)

    @property
    @pulumi.getter(name="indexNSegments")
    def index_n_segments(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index_n_segments")

    @index_n_segments.setter
    def index_n_segments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index_n_segments", value)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @input_loss_action.setter
    def input_loss_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_action", value)

    @property
    @pulumi.getter(name="ivInManifest")
    def iv_in_manifest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iv_in_manifest")

    @iv_in_manifest.setter
    def iv_in_manifest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iv_in_manifest", value)

    @property
    @pulumi.getter(name="ivSource")
    def iv_source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iv_source")

    @iv_source.setter
    def iv_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iv_source", value)

    @property
    @pulumi.getter(name="keepSegments")
    def keep_segments(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "keep_segments")

    @keep_segments.setter
    def keep_segments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_segments", value)

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key_format")

    @key_format.setter
    def key_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_format", value)

    @property
    @pulumi.getter(name="keyFormatVersions")
    def key_format_versions(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key_format_versions")

    @key_format_versions.setter
    def key_format_versions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_format_versions", value)

    @property
    @pulumi.getter(name="keyProviderSettings")
    def key_provider_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs']]:
        return pulumi.get(self, "key_provider_settings")

    @key_provider_settings.setter
    def key_provider_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs']]):
        pulumi.set(self, "key_provider_settings", value)

    @property
    @pulumi.getter(name="manifestCompression")
    def manifest_compression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "manifest_compression")

    @manifest_compression.setter
    def manifest_compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manifest_compression", value)

    @property
    @pulumi.getter(name="manifestDurationFormat")
    def manifest_duration_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "manifest_duration_format")

    @manifest_duration_format.setter
    def manifest_duration_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manifest_duration_format", value)

    @property
    @pulumi.getter(name="minSegmentLength")
    def min_segment_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_segment_length")

    @min_segment_length.setter
    def min_segment_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_segment_length", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="outputSelection")
    def output_selection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "output_selection")

    @output_selection.setter
    def output_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_selection", value)

    @property
    @pulumi.getter(name="programDateTime")
    def program_date_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "program_date_time")

    @program_date_time.setter
    def program_date_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "program_date_time", value)

    @property
    @pulumi.getter(name="programDateTimeClock")
    def program_date_time_clock(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "program_date_time_clock")

    @program_date_time_clock.setter
    def program_date_time_clock(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "program_date_time_clock", value)

    @property
    @pulumi.getter(name="programDateTimePeriod")
    def program_date_time_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "program_date_time_period")

    @program_date_time_period.setter
    def program_date_time_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "program_date_time_period", value)

    @property
    @pulumi.getter(name="redundantManifest")
    def redundant_manifest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redundant_manifest")

    @redundant_manifest.setter
    def redundant_manifest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redundant_manifest", value)

    @property
    @pulumi.getter(name="segmentLength")
    def segment_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "segment_length")

    @segment_length.setter
    def segment_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "segment_length", value)

    @property
    @pulumi.getter(name="segmentsPerSubdirectory")
    def segments_per_subdirectory(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "segments_per_subdirectory")

    @segments_per_subdirectory.setter
    def segments_per_subdirectory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "segments_per_subdirectory", value)

    @property
    @pulumi.getter(name="streamInfResolution")
    def stream_inf_resolution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stream_inf_resolution")

    @stream_inf_resolution.setter
    def stream_inf_resolution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_inf_resolution", value)

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates ID3 frame that has the timecode.
        """
        return pulumi.get(self, "timed_metadata_id3_frame")

    @timed_metadata_id3_frame.setter
    def timed_metadata_id3_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_id3_frame", value)

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timed_metadata_id3_period")

    @timed_metadata_id3_period.setter
    def timed_metadata_id3_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timed_metadata_id3_period", value)

    @property
    @pulumi.getter(name="timestampDeltaMilliseconds")
    def timestamp_delta_milliseconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timestamp_delta_milliseconds")

    @timestamp_delta_milliseconds.setter
    def timestamp_delta_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timestamp_delta_milliseconds", value)

    @property
    @pulumi.getter(name="tsFileMode")
    def ts_file_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ts_file_mode")

    @ts_file_mode.setter
    def ts_file_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ts_file_mode", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs:
    def __init__(__self__, *,
                 caption_channel: pulumi.Input[int],
                 language_code: pulumi.Input[str],
                 language_description: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language_code: Selects a specific three-letter language code from within an audio source.
        :param pulumi.Input[str] language_description: Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caption_channel=caption_channel,
            language_code=language_code,
            language_description=language_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caption_channel: Optional[pulumi.Input[int]] = None,
             language_code: Optional[pulumi.Input[str]] = None,
             language_description: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if caption_channel is None and 'captionChannel' in kwargs:
            caption_channel = kwargs['captionChannel']
        if caption_channel is None:
            raise TypeError("Missing 'caption_channel' argument")
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if language_description is None and 'languageDescription' in kwargs:
            language_description = kwargs['languageDescription']
        if language_description is None:
            raise TypeError("Missing 'language_description' argument")

        _setter("caption_channel", caption_channel)
        _setter("language_code", language_code)
        _setter("language_description", language_description)

    @property
    @pulumi.getter(name="captionChannel")
    def caption_channel(self) -> pulumi.Input[int]:
        return pulumi.get(self, "caption_channel")

    @caption_channel.setter
    def caption_channel(self, value: pulumi.Input[int]):
        pulumi.set(self, "caption_channel", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> pulumi.Input[str]:
        """
        Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        return pulumi.get(self, "language_description")

    @language_description.setter
    def language_description(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_description", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs:
    def __init__(__self__, *,
                 hls_akamai_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs']] = None,
                 hls_basic_put_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs']] = None,
                 hls_media_store_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs']] = None,
                 hls_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs']] = None,
                 hls_webdav_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs']] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_akamai_settings=hls_akamai_settings,
            hls_basic_put_settings=hls_basic_put_settings,
            hls_media_store_settings=hls_media_store_settings,
            hls_s3_settings=hls_s3_settings,
            hls_webdav_settings=hls_webdav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_akamai_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs']] = None,
             hls_basic_put_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs']] = None,
             hls_media_store_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs']] = None,
             hls_s3_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs']] = None,
             hls_webdav_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_akamai_settings is None and 'hlsAkamaiSettings' in kwargs:
            hls_akamai_settings = kwargs['hlsAkamaiSettings']
        if hls_basic_put_settings is None and 'hlsBasicPutSettings' in kwargs:
            hls_basic_put_settings = kwargs['hlsBasicPutSettings']
        if hls_media_store_settings is None and 'hlsMediaStoreSettings' in kwargs:
            hls_media_store_settings = kwargs['hlsMediaStoreSettings']
        if hls_s3_settings is None and 'hlsS3Settings' in kwargs:
            hls_s3_settings = kwargs['hlsS3Settings']
        if hls_webdav_settings is None and 'hlsWebdavSettings' in kwargs:
            hls_webdav_settings = kwargs['hlsWebdavSettings']

        if hls_akamai_settings is not None:
            _setter("hls_akamai_settings", hls_akamai_settings)
        if hls_basic_put_settings is not None:
            _setter("hls_basic_put_settings", hls_basic_put_settings)
        if hls_media_store_settings is not None:
            _setter("hls_media_store_settings", hls_media_store_settings)
        if hls_s3_settings is not None:
            _setter("hls_s3_settings", hls_s3_settings)
        if hls_webdav_settings is not None:
            _setter("hls_webdav_settings", hls_webdav_settings)

    @property
    @pulumi.getter(name="hlsAkamaiSettings")
    def hls_akamai_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs']]:
        return pulumi.get(self, "hls_akamai_settings")

    @hls_akamai_settings.setter
    def hls_akamai_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs']]):
        pulumi.set(self, "hls_akamai_settings", value)

    @property
    @pulumi.getter(name="hlsBasicPutSettings")
    def hls_basic_put_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs']]:
        return pulumi.get(self, "hls_basic_put_settings")

    @hls_basic_put_settings.setter
    def hls_basic_put_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs']]):
        pulumi.set(self, "hls_basic_put_settings", value)

    @property
    @pulumi.getter(name="hlsMediaStoreSettings")
    def hls_media_store_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs']]:
        return pulumi.get(self, "hls_media_store_settings")

    @hls_media_store_settings.setter
    def hls_media_store_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs']]):
        pulumi.set(self, "hls_media_store_settings", value)

    @property
    @pulumi.getter(name="hlsS3Settings")
    def hls_s3_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs']]:
        return pulumi.get(self, "hls_s3_settings")

    @hls_s3_settings.setter
    def hls_s3_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs']]):
        pulumi.set(self, "hls_s3_settings", value)

    @property
    @pulumi.getter(name="hlsWebdavSettings")
    def hls_webdav_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs']]:
        return pulumi.get(self, "hls_webdav_settings")

    @hls_webdav_settings.setter
    def hls_webdav_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs']]):
        pulumi.set(self, "hls_webdav_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs:
    def __init__(__self__, *,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 filecache_duration: Optional[pulumi.Input[int]] = None,
                 http_transfer_mode: Optional[pulumi.Input[str]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None,
                 salt: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
            salt=salt,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             filecache_duration: Optional[pulumi.Input[int]] = None,
             http_transfer_mode: Optional[pulumi.Input[str]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             salt: Optional[pulumi.Input[str]] = None,
             token: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if http_transfer_mode is None and 'httpTransferMode' in kwargs:
            http_transfer_mode = kwargs['httpTransferMode']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if salt is not None:
            _setter("salt", salt)
        if token is not None:
            _setter("token", token)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filecache_duration")

    @filecache_duration.setter
    def filecache_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filecache_duration", value)

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_transfer_mode")

    @http_transfer_mode.setter
    def http_transfer_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_transfer_mode", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)

    @property
    @pulumi.getter
    def salt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "salt")

    @salt.setter
    def salt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "salt", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs:
    def __init__(__self__, *,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 filecache_duration: Optional[pulumi.Input[int]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             filecache_duration: Optional[pulumi.Input[int]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filecache_duration")

    @filecache_duration.setter
    def filecache_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filecache_duration", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs:
    def __init__(__self__, *,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 filecache_duration: Optional[pulumi.Input[int]] = None,
                 media_store_storage_class: Optional[pulumi.Input[str]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            media_store_storage_class=media_store_storage_class,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             filecache_duration: Optional[pulumi.Input[int]] = None,
             media_store_storage_class: Optional[pulumi.Input[str]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if media_store_storage_class is None and 'mediaStoreStorageClass' in kwargs:
            media_store_storage_class = kwargs['mediaStoreStorageClass']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if media_store_storage_class is not None:
            _setter("media_store_storage_class", media_store_storage_class)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filecache_duration")

    @filecache_duration.setter
    def filecache_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filecache_duration", value)

    @property
    @pulumi.getter(name="mediaStoreStorageClass")
    def media_store_storage_class(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "media_store_storage_class")

    @media_store_storage_class.setter
    def media_store_storage_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "media_store_storage_class", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs:
    def __init__(__self__, *,
                 canned_acl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs:
    def __init__(__self__, *,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 filecache_duration: Optional[pulumi.Input[int]] = None,
                 http_transfer_mode: Optional[pulumi.Input[str]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             filecache_duration: Optional[pulumi.Input[int]] = None,
             http_transfer_mode: Optional[pulumi.Input[str]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if http_transfer_mode is None and 'httpTransferMode' in kwargs:
            http_transfer_mode = kwargs['httpTransferMode']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filecache_duration")

    @filecache_duration.setter
    def filecache_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filecache_duration", value)

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_transfer_mode")

    @http_transfer_mode.setter
    def http_transfer_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_transfer_mode", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs:
    def __init__(__self__, *,
                 static_key_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs']]]] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_key_settings=static_key_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_key_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if static_key_settings is None and 'staticKeySettings' in kwargs:
            static_key_settings = kwargs['staticKeySettings']

        if static_key_settings is not None:
            _setter("static_key_settings", static_key_settings)

    @property
    @pulumi.getter(name="staticKeySettings")
    def static_key_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs']]]]:
        return pulumi.get(self, "static_key_settings")

    @static_key_settings.setter
    def static_key_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs']]]]):
        pulumi.set(self, "static_key_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs:
    def __init__(__self__, *,
                 static_key_value: pulumi.Input[str],
                 key_provider_server: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs']] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_key_value=static_key_value,
            key_provider_server=key_provider_server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_key_value: Optional[pulumi.Input[str]] = None,
             key_provider_server: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if static_key_value is None and 'staticKeyValue' in kwargs:
            static_key_value = kwargs['staticKeyValue']
        if static_key_value is None:
            raise TypeError("Missing 'static_key_value' argument")
        if key_provider_server is None and 'keyProviderServer' in kwargs:
            key_provider_server = kwargs['keyProviderServer']

        _setter("static_key_value", static_key_value)
        if key_provider_server is not None:
            _setter("key_provider_server", key_provider_server)

    @property
    @pulumi.getter(name="staticKeyValue")
    def static_key_value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "static_key_value")

    @static_key_value.setter
    def static_key_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "static_key_value", value)

    @property
    @pulumi.getter(name="keyProviderServer")
    def key_provider_server(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs']]:
        return pulumi.get(self, "key_provider_server")

    @key_provider_server.setter
    def key_provider_server(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs']]):
        pulumi.set(self, "key_provider_server", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: . Username to be used.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs']):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs'] destination: A director and base filename where archive files should be written. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs']:
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs'],
                 acquisition_point_id: Optional[pulumi.Input[str]] = None,
                 audio_only_timecode_control: Optional[pulumi.Input[str]] = None,
                 certificate_mode: Optional[pulumi.Input[str]] = None,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 event_id: Optional[pulumi.Input[str]] = None,
                 event_id_mode: Optional[pulumi.Input[str]] = None,
                 event_stop_behavior: Optional[pulumi.Input[str]] = None,
                 filecache_duration: Optional[pulumi.Input[int]] = None,
                 fragment_length: Optional[pulumi.Input[int]] = None,
                 input_loss_action: Optional[pulumi.Input[str]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None,
                 segmentation_mode: Optional[pulumi.Input[str]] = None,
                 send_delay_ms: Optional[pulumi.Input[int]] = None,
                 sparse_track_type: Optional[pulumi.Input[str]] = None,
                 stream_manifest_behavior: Optional[pulumi.Input[str]] = None,
                 timestamp_offset: Optional[pulumi.Input[str]] = None,
                 timestamp_offset_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs'] destination: A director and base filename where archive files should be written. See Destination for more details.
        :param pulumi.Input[str] certificate_mode: Setting to allow self signed or verified RTMP certificates.
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[str] input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            acquisition_point_id=acquisition_point_id,
            audio_only_timecode_control=audio_only_timecode_control,
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            event_id=event_id,
            event_id_mode=event_id_mode,
            event_stop_behavior=event_stop_behavior,
            filecache_duration=filecache_duration,
            fragment_length=fragment_length,
            input_loss_action=input_loss_action,
            num_retries=num_retries,
            restart_delay=restart_delay,
            segmentation_mode=segmentation_mode,
            send_delay_ms=send_delay_ms,
            sparse_track_type=sparse_track_type,
            stream_manifest_behavior=stream_manifest_behavior,
            timestamp_offset=timestamp_offset,
            timestamp_offset_mode=timestamp_offset_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs']] = None,
             acquisition_point_id: Optional[pulumi.Input[str]] = None,
             audio_only_timecode_control: Optional[pulumi.Input[str]] = None,
             certificate_mode: Optional[pulumi.Input[str]] = None,
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             event_id: Optional[pulumi.Input[str]] = None,
             event_id_mode: Optional[pulumi.Input[str]] = None,
             event_stop_behavior: Optional[pulumi.Input[str]] = None,
             filecache_duration: Optional[pulumi.Input[int]] = None,
             fragment_length: Optional[pulumi.Input[int]] = None,
             input_loss_action: Optional[pulumi.Input[str]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             segmentation_mode: Optional[pulumi.Input[str]] = None,
             send_delay_ms: Optional[pulumi.Input[int]] = None,
             sparse_track_type: Optional[pulumi.Input[str]] = None,
             stream_manifest_behavior: Optional[pulumi.Input[str]] = None,
             timestamp_offset: Optional[pulumi.Input[str]] = None,
             timestamp_offset_mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if acquisition_point_id is None and 'acquisitionPointId' in kwargs:
            acquisition_point_id = kwargs['acquisitionPointId']
        if audio_only_timecode_control is None and 'audioOnlyTimecodeControl' in kwargs:
            audio_only_timecode_control = kwargs['audioOnlyTimecodeControl']
        if certificate_mode is None and 'certificateMode' in kwargs:
            certificate_mode = kwargs['certificateMode']
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if event_id is None and 'eventId' in kwargs:
            event_id = kwargs['eventId']
        if event_id_mode is None and 'eventIdMode' in kwargs:
            event_id_mode = kwargs['eventIdMode']
        if event_stop_behavior is None and 'eventStopBehavior' in kwargs:
            event_stop_behavior = kwargs['eventStopBehavior']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if fragment_length is None and 'fragmentLength' in kwargs:
            fragment_length = kwargs['fragmentLength']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']
        if segmentation_mode is None and 'segmentationMode' in kwargs:
            segmentation_mode = kwargs['segmentationMode']
        if send_delay_ms is None and 'sendDelayMs' in kwargs:
            send_delay_ms = kwargs['sendDelayMs']
        if sparse_track_type is None and 'sparseTrackType' in kwargs:
            sparse_track_type = kwargs['sparseTrackType']
        if stream_manifest_behavior is None and 'streamManifestBehavior' in kwargs:
            stream_manifest_behavior = kwargs['streamManifestBehavior']
        if timestamp_offset is None and 'timestampOffset' in kwargs:
            timestamp_offset = kwargs['timestampOffset']
        if timestamp_offset_mode is None and 'timestampOffsetMode' in kwargs:
            timestamp_offset_mode = kwargs['timestampOffsetMode']

        _setter("destination", destination)
        if acquisition_point_id is not None:
            _setter("acquisition_point_id", acquisition_point_id)
        if audio_only_timecode_control is not None:
            _setter("audio_only_timecode_control", audio_only_timecode_control)
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if event_id is not None:
            _setter("event_id", event_id)
        if event_id_mode is not None:
            _setter("event_id_mode", event_id_mode)
        if event_stop_behavior is not None:
            _setter("event_stop_behavior", event_stop_behavior)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if fragment_length is not None:
            _setter("fragment_length", fragment_length)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if segmentation_mode is not None:
            _setter("segmentation_mode", segmentation_mode)
        if send_delay_ms is not None:
            _setter("send_delay_ms", send_delay_ms)
        if sparse_track_type is not None:
            _setter("sparse_track_type", sparse_track_type)
        if stream_manifest_behavior is not None:
            _setter("stream_manifest_behavior", stream_manifest_behavior)
        if timestamp_offset is not None:
            _setter("timestamp_offset", timestamp_offset)
        if timestamp_offset_mode is not None:
            _setter("timestamp_offset_mode", timestamp_offset_mode)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs']:
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="acquisitionPointId")
    def acquisition_point_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "acquisition_point_id")

    @acquisition_point_id.setter
    def acquisition_point_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acquisition_point_id", value)

    @property
    @pulumi.getter(name="audioOnlyTimecodeControl")
    def audio_only_timecode_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_only_timecode_control")

    @audio_only_timecode_control.setter
    def audio_only_timecode_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_only_timecode_control", value)

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Setting to allow self signed or verified RTMP certificates.
        """
        return pulumi.get(self, "certificate_mode")

    @certificate_mode.setter
    def certificate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_mode", value)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="eventId")
    def event_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_id")

    @event_id.setter
    def event_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_id", value)

    @property
    @pulumi.getter(name="eventIdMode")
    def event_id_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_id_mode")

    @event_id_mode.setter
    def event_id_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_id_mode", value)

    @property
    @pulumi.getter(name="eventStopBehavior")
    def event_stop_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_stop_behavior")

    @event_stop_behavior.setter
    def event_stop_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_stop_behavior", value)

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filecache_duration")

    @filecache_duration.setter
    def filecache_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filecache_duration", value)

    @property
    @pulumi.getter(name="fragmentLength")
    def fragment_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fragment_length")

    @fragment_length.setter
    def fragment_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fragment_length", value)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @input_loss_action.setter
    def input_loss_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_action", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)

    @property
    @pulumi.getter(name="segmentationMode")
    def segmentation_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segmentation_mode")

    @segmentation_mode.setter
    def segmentation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segmentation_mode", value)

    @property
    @pulumi.getter(name="sendDelayMs")
    def send_delay_ms(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "send_delay_ms")

    @send_delay_ms.setter
    def send_delay_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "send_delay_ms", value)

    @property
    @pulumi.getter(name="sparseTrackType")
    def sparse_track_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sparse_track_type")

    @sparse_track_type.setter
    def sparse_track_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sparse_track_type", value)

    @property
    @pulumi.getter(name="streamManifestBehavior")
    def stream_manifest_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stream_manifest_behavior")

    @stream_manifest_behavior.setter
    def stream_manifest_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_manifest_behavior", value)

    @property
    @pulumi.getter(name="timestampOffset")
    def timestamp_offset(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timestamp_offset")

    @timestamp_offset.setter
    def timestamp_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_offset", value)

    @property
    @pulumi.getter(name="timestampOffsetMode")
    def timestamp_offset_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timestamp_offset_mode")

    @timestamp_offset_mode.setter
    def timestamp_offset_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_offset_mode", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs:
    def __init__(__self__, *,
                 ad_markers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 authentication_scheme: Optional[pulumi.Input[str]] = None,
                 cache_full_behavior: Optional[pulumi.Input[str]] = None,
                 cache_length: Optional[pulumi.Input[int]] = None,
                 caption_data: Optional[pulumi.Input[str]] = None,
                 input_loss_action: Optional[pulumi.Input[str]] = None,
                 restart_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ad_markers: The ad marker type for this output group.
        :param pulumi.Input[str] authentication_scheme: Authentication scheme to use when connecting with CDN.
        :param pulumi.Input[str] cache_full_behavior: Controls behavior when content cache fills up.
        :param pulumi.Input[int] cache_length: Cache length in seconds, is used to calculate buffer size.
        :param pulumi.Input[str] caption_data: Controls the types of data that passes to onCaptionInfo outputs.
        :param pulumi.Input[str] input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param pulumi.Input[int] restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_markers=ad_markers,
            authentication_scheme=authentication_scheme,
            cache_full_behavior=cache_full_behavior,
            cache_length=cache_length,
            caption_data=caption_data,
            input_loss_action=input_loss_action,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_markers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             authentication_scheme: Optional[pulumi.Input[str]] = None,
             cache_full_behavior: Optional[pulumi.Input[str]] = None,
             cache_length: Optional[pulumi.Input[int]] = None,
             caption_data: Optional[pulumi.Input[str]] = None,
             input_loss_action: Optional[pulumi.Input[str]] = None,
             restart_delay: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ad_markers is None and 'adMarkers' in kwargs:
            ad_markers = kwargs['adMarkers']
        if authentication_scheme is None and 'authenticationScheme' in kwargs:
            authentication_scheme = kwargs['authenticationScheme']
        if cache_full_behavior is None and 'cacheFullBehavior' in kwargs:
            cache_full_behavior = kwargs['cacheFullBehavior']
        if cache_length is None and 'cacheLength' in kwargs:
            cache_length = kwargs['cacheLength']
        if caption_data is None and 'captionData' in kwargs:
            caption_data = kwargs['captionData']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if authentication_scheme is not None:
            _setter("authentication_scheme", authentication_scheme)
        if cache_full_behavior is not None:
            _setter("cache_full_behavior", cache_full_behavior)
        if cache_length is not None:
            _setter("cache_length", cache_length)
        if caption_data is not None:
            _setter("caption_data", caption_data)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ad marker type for this output group.
        """
        return pulumi.get(self, "ad_markers")

    @ad_markers.setter
    def ad_markers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ad_markers", value)

    @property
    @pulumi.getter(name="authenticationScheme")
    def authentication_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication scheme to use when connecting with CDN.
        """
        return pulumi.get(self, "authentication_scheme")

    @authentication_scheme.setter
    def authentication_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_scheme", value)

    @property
    @pulumi.getter(name="cacheFullBehavior")
    def cache_full_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Controls behavior when content cache fills up.
        """
        return pulumi.get(self, "cache_full_behavior")

    @cache_full_behavior.setter
    def cache_full_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_full_behavior", value)

    @property
    @pulumi.getter(name="cacheLength")
    def cache_length(self) -> Optional[pulumi.Input[int]]:
        """
        Cache length in seconds, is used to calculate buffer size.
        """
        return pulumi.get(self, "cache_length")

    @cache_length.setter
    def cache_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cache_length", value)

    @property
    @pulumi.getter(name="captionData")
    def caption_data(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the types of data that passes to onCaptionInfo outputs.
        """
        return pulumi.get(self, "caption_data")

    @caption_data.setter
    def caption_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caption_data", value)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @input_loss_action.setter
    def input_loss_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_action", value)

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @restart_delay.setter
    def restart_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restart_delay", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs:
    def __init__(__self__, *,
                 input_loss_action: Optional[pulumi.Input[str]] = None,
                 timed_metadata_id3_frame: Optional[pulumi.Input[str]] = None,
                 timed_metadata_id3_period: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] input_loss_action: Specifies behavior of last resort when input video os lost.
        :param pulumi.Input[str] timed_metadata_id3_frame: Indicates ID3 frame that has the timecode.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_action=input_loss_action,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_action: Optional[pulumi.Input[str]] = None,
             timed_metadata_id3_frame: Optional[pulumi.Input[str]] = None,
             timed_metadata_id3_period: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if timed_metadata_id3_frame is None and 'timedMetadataId3Frame' in kwargs:
            timed_metadata_id3_frame = kwargs['timedMetadataId3Frame']
        if timed_metadata_id3_period is None and 'timedMetadataId3Period' in kwargs:
            timed_metadata_id3_period = kwargs['timedMetadataId3Period']

        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies behavior of last resort when input video os lost.
        """
        return pulumi.get(self, "input_loss_action")

    @input_loss_action.setter
    def input_loss_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_loss_action", value)

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates ID3 frame that has the timecode.
        """
        return pulumi.get(self, "timed_metadata_id3_frame")

    @timed_metadata_id3_frame.setter
    def timed_metadata_id3_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_id3_frame", value)

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timed_metadata_id3_period")

    @timed_metadata_id3_period.setter
    def timed_metadata_id3_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timed_metadata_id3_period", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs:
    def __init__(__self__, *,
                 archive_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs']] = None,
                 frame_capture_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs']] = None,
                 hls_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs']] = None,
                 media_package_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs']] = None,
                 ms_smooth_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs']] = None,
                 multiplex_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs']] = None,
                 rtmp_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs']] = None,
                 udp_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs'] archive_output_settings: Archive output settings. See Archive Output Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs'] media_package_output_settings: Media package output settings. This can be set as an empty block.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs'] multiplex_output_settings: Multiplex output settings. See Multiplex Output Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs'] rtmp_output_settings: RTMP output settings. See RTMP Output Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs'] udp_output_settings: UDP output settings. See UDP Output Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_output_settings=archive_output_settings,
            frame_capture_output_settings=frame_capture_output_settings,
            hls_output_settings=hls_output_settings,
            media_package_output_settings=media_package_output_settings,
            ms_smooth_output_settings=ms_smooth_output_settings,
            multiplex_output_settings=multiplex_output_settings,
            rtmp_output_settings=rtmp_output_settings,
            udp_output_settings=udp_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs']] = None,
             frame_capture_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs']] = None,
             hls_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs']] = None,
             media_package_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs']] = None,
             ms_smooth_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs']] = None,
             multiplex_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs']] = None,
             rtmp_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs']] = None,
             udp_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_output_settings is None and 'archiveOutputSettings' in kwargs:
            archive_output_settings = kwargs['archiveOutputSettings']
        if frame_capture_output_settings is None and 'frameCaptureOutputSettings' in kwargs:
            frame_capture_output_settings = kwargs['frameCaptureOutputSettings']
        if hls_output_settings is None and 'hlsOutputSettings' in kwargs:
            hls_output_settings = kwargs['hlsOutputSettings']
        if media_package_output_settings is None and 'mediaPackageOutputSettings' in kwargs:
            media_package_output_settings = kwargs['mediaPackageOutputSettings']
        if ms_smooth_output_settings is None and 'msSmoothOutputSettings' in kwargs:
            ms_smooth_output_settings = kwargs['msSmoothOutputSettings']
        if multiplex_output_settings is None and 'multiplexOutputSettings' in kwargs:
            multiplex_output_settings = kwargs['multiplexOutputSettings']
        if rtmp_output_settings is None and 'rtmpOutputSettings' in kwargs:
            rtmp_output_settings = kwargs['rtmpOutputSettings']
        if udp_output_settings is None and 'udpOutputSettings' in kwargs:
            udp_output_settings = kwargs['udpOutputSettings']

        if archive_output_settings is not None:
            _setter("archive_output_settings", archive_output_settings)
        if frame_capture_output_settings is not None:
            _setter("frame_capture_output_settings", frame_capture_output_settings)
        if hls_output_settings is not None:
            _setter("hls_output_settings", hls_output_settings)
        if media_package_output_settings is not None:
            _setter("media_package_output_settings", media_package_output_settings)
        if ms_smooth_output_settings is not None:
            _setter("ms_smooth_output_settings", ms_smooth_output_settings)
        if multiplex_output_settings is not None:
            _setter("multiplex_output_settings", multiplex_output_settings)
        if rtmp_output_settings is not None:
            _setter("rtmp_output_settings", rtmp_output_settings)
        if udp_output_settings is not None:
            _setter("udp_output_settings", udp_output_settings)

    @property
    @pulumi.getter(name="archiveOutputSettings")
    def archive_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs']]:
        """
        Archive output settings. See Archive Output Settings for more details.
        """
        return pulumi.get(self, "archive_output_settings")

    @archive_output_settings.setter
    def archive_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs']]):
        pulumi.set(self, "archive_output_settings", value)

    @property
    @pulumi.getter(name="frameCaptureOutputSettings")
    def frame_capture_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs']]:
        return pulumi.get(self, "frame_capture_output_settings")

    @frame_capture_output_settings.setter
    def frame_capture_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs']]):
        pulumi.set(self, "frame_capture_output_settings", value)

    @property
    @pulumi.getter(name="hlsOutputSettings")
    def hls_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs']]:
        return pulumi.get(self, "hls_output_settings")

    @hls_output_settings.setter
    def hls_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs']]):
        pulumi.set(self, "hls_output_settings", value)

    @property
    @pulumi.getter(name="mediaPackageOutputSettings")
    def media_package_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs']]:
        """
        Media package output settings. This can be set as an empty block.
        """
        return pulumi.get(self, "media_package_output_settings")

    @media_package_output_settings.setter
    def media_package_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs']]):
        pulumi.set(self, "media_package_output_settings", value)

    @property
    @pulumi.getter(name="msSmoothOutputSettings")
    def ms_smooth_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs']]:
        return pulumi.get(self, "ms_smooth_output_settings")

    @ms_smooth_output_settings.setter
    def ms_smooth_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs']]):
        pulumi.set(self, "ms_smooth_output_settings", value)

    @property
    @pulumi.getter(name="multiplexOutputSettings")
    def multiplex_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs']]:
        """
        Multiplex output settings. See Multiplex Output Settings for more details.
        """
        return pulumi.get(self, "multiplex_output_settings")

    @multiplex_output_settings.setter
    def multiplex_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs']]):
        pulumi.set(self, "multiplex_output_settings", value)

    @property
    @pulumi.getter(name="rtmpOutputSettings")
    def rtmp_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs']]:
        """
        RTMP output settings. See RTMP Output Settings for more details.
        """
        return pulumi.get(self, "rtmp_output_settings")

    @rtmp_output_settings.setter
    def rtmp_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs']]):
        pulumi.set(self, "rtmp_output_settings", value)

    @property
    @pulumi.getter(name="udpOutputSettings")
    def udp_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs']]:
        """
        UDP output settings. See UDP Output Settings for more details.
        """
        return pulumi.get(self, "udp_output_settings")

    @udp_output_settings.setter
    def udp_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs']]):
        pulumi.set(self, "udp_output_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs:
    def __init__(__self__, *,
                 container_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs']] = None,
                 extension: Optional[pulumi.Input[str]] = None,
                 name_modifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs'] container_settings: Settings specific to the container type of the file. See Container Settings for more details.
        :param pulumi.Input[str] extension: Output file extension.
        :param pulumi.Input[str] name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_settings=container_settings,
            extension=extension,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs']] = None,
             extension: Optional[pulumi.Input[str]] = None,
             name_modifier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_settings is None and 'containerSettings' in kwargs:
            container_settings = kwargs['containerSettings']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if container_settings is not None:
            _setter("container_settings", container_settings)
        if extension is not None:
            _setter("extension", extension)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs']]:
        """
        Settings specific to the container type of the file. See Container Settings for more details.
        """
        return pulumi.get(self, "container_settings")

    @container_settings.setter
    def container_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs']]):
        pulumi.set(self, "container_settings", value)

    @property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[str]]:
        """
        Output file extension.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[pulumi.Input[str]]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")

    @name_modifier.setter
    def name_modifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_modifier", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs:
    def __init__(__self__, *,
                 m2ts_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs']] = None,
                 raw_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs'] m2ts_settings: M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs'] raw_settings: Raw Settings. This can be set as an empty block.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
            raw_settings=raw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs']] = None,
             raw_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m2ts_settings is None and 'm2tsSettings' in kwargs:
            m2ts_settings = kwargs['m2tsSettings']
        if raw_settings is None and 'rawSettings' in kwargs:
            raw_settings = kwargs['rawSettings']

        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)
        if raw_settings is not None:
            _setter("raw_settings", raw_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs']]:
        """
        M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        return pulumi.get(self, "m2ts_settings")

    @m2ts_settings.setter
    def m2ts_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs']]):
        pulumi.set(self, "m2ts_settings", value)

    @property
    @pulumi.getter(name="rawSettings")
    def raw_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs']]:
        """
        Raw Settings. This can be set as an empty block.
        """
        return pulumi.get(self, "raw_settings")

    @raw_settings.setter
    def raw_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs']]):
        pulumi.set(self, "raw_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs:
    def __init__(__self__, *,
                 absent_input_audio_behavior: Optional[pulumi.Input[str]] = None,
                 arib: Optional[pulumi.Input[str]] = None,
                 arib_captions_pid: Optional[pulumi.Input[str]] = None,
                 arib_captions_pid_control: Optional[pulumi.Input[str]] = None,
                 audio_buffer_model: Optional[pulumi.Input[str]] = None,
                 audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
                 audio_pids: Optional[pulumi.Input[str]] = None,
                 audio_stream_type: Optional[pulumi.Input[str]] = None,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 buffer_model: Optional[pulumi.Input[str]] = None,
                 cc_descriptor: Optional[pulumi.Input[str]] = None,
                 dvb_nit_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']] = None,
                 dvb_sdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']] = None,
                 dvb_sub_pids: Optional[pulumi.Input[str]] = None,
                 dvb_tdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']] = None,
                 dvb_teletext_pid: Optional[pulumi.Input[str]] = None,
                 ebif: Optional[pulumi.Input[str]] = None,
                 ebp_audio_interval: Optional[pulumi.Input[str]] = None,
                 ebp_lookahead_ms: Optional[pulumi.Input[int]] = None,
                 ebp_placement: Optional[pulumi.Input[str]] = None,
                 ecm_pid: Optional[pulumi.Input[str]] = None,
                 es_rate_in_pes: Optional[pulumi.Input[str]] = None,
                 etv_platform_pid: Optional[pulumi.Input[str]] = None,
                 etv_signal_pid: Optional[pulumi.Input[str]] = None,
                 fragment_time: Optional[pulumi.Input[float]] = None,
                 klv: Optional[pulumi.Input[str]] = None,
                 klv_data_pids: Optional[pulumi.Input[str]] = None,
                 nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
                 null_packet_bitrate: Optional[pulumi.Input[float]] = None,
                 pat_interval: Optional[pulumi.Input[int]] = None,
                 pcr_control: Optional[pulumi.Input[str]] = None,
                 pcr_period: Optional[pulumi.Input[int]] = None,
                 pcr_pid: Optional[pulumi.Input[str]] = None,
                 pmt_interval: Optional[pulumi.Input[int]] = None,
                 pmt_pid: Optional[pulumi.Input[str]] = None,
                 program_num: Optional[pulumi.Input[int]] = None,
                 rate_mode: Optional[pulumi.Input[str]] = None,
                 scte27_pids: Optional[pulumi.Input[str]] = None,
                 scte35_control: Optional[pulumi.Input[str]] = None,
                 scte35_pid: Optional[pulumi.Input[str]] = None,
                 segmentation_markers: Optional[pulumi.Input[str]] = None,
                 segmentation_style: Optional[pulumi.Input[str]] = None,
                 segmentation_time: Optional[pulumi.Input[float]] = None,
                 timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
                 timed_metadata_pid: Optional[pulumi.Input[str]] = None,
                 transport_stream_id: Optional[pulumi.Input[int]] = None,
                 video_pid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            absent_input_audio_behavior=absent_input_audio_behavior,
            arib=arib,
            arib_captions_pid=arib_captions_pid,
            arib_captions_pid_control=arib_captions_pid_control,
            audio_buffer_model=audio_buffer_model,
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            audio_stream_type=audio_stream_type,
            bitrate=bitrate,
            buffer_model=buffer_model,
            cc_descriptor=cc_descriptor,
            dvb_nit_settings=dvb_nit_settings,
            dvb_sdt_settings=dvb_sdt_settings,
            dvb_sub_pids=dvb_sub_pids,
            dvb_tdt_settings=dvb_tdt_settings,
            dvb_teletext_pid=dvb_teletext_pid,
            ebif=ebif,
            ebp_audio_interval=ebp_audio_interval,
            ebp_lookahead_ms=ebp_lookahead_ms,
            ebp_placement=ebp_placement,
            ecm_pid=ecm_pid,
            es_rate_in_pes=es_rate_in_pes,
            etv_platform_pid=etv_platform_pid,
            etv_signal_pid=etv_signal_pid,
            fragment_time=fragment_time,
            klv=klv,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            null_packet_bitrate=null_packet_bitrate,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            rate_mode=rate_mode,
            scte27_pids=scte27_pids,
            scte35_control=scte35_control,
            scte35_pid=scte35_pid,
            segmentation_markers=segmentation_markers,
            segmentation_style=segmentation_style,
            segmentation_time=segmentation_time,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             absent_input_audio_behavior: Optional[pulumi.Input[str]] = None,
             arib: Optional[pulumi.Input[str]] = None,
             arib_captions_pid: Optional[pulumi.Input[str]] = None,
             arib_captions_pid_control: Optional[pulumi.Input[str]] = None,
             audio_buffer_model: Optional[pulumi.Input[str]] = None,
             audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
             audio_pids: Optional[pulumi.Input[str]] = None,
             audio_stream_type: Optional[pulumi.Input[str]] = None,
             bitrate: Optional[pulumi.Input[int]] = None,
             buffer_model: Optional[pulumi.Input[str]] = None,
             cc_descriptor: Optional[pulumi.Input[str]] = None,
             dvb_nit_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']] = None,
             dvb_sdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']] = None,
             dvb_sub_pids: Optional[pulumi.Input[str]] = None,
             dvb_tdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']] = None,
             dvb_teletext_pid: Optional[pulumi.Input[str]] = None,
             ebif: Optional[pulumi.Input[str]] = None,
             ebp_audio_interval: Optional[pulumi.Input[str]] = None,
             ebp_lookahead_ms: Optional[pulumi.Input[int]] = None,
             ebp_placement: Optional[pulumi.Input[str]] = None,
             ecm_pid: Optional[pulumi.Input[str]] = None,
             es_rate_in_pes: Optional[pulumi.Input[str]] = None,
             etv_platform_pid: Optional[pulumi.Input[str]] = None,
             etv_signal_pid: Optional[pulumi.Input[str]] = None,
             fragment_time: Optional[pulumi.Input[float]] = None,
             klv: Optional[pulumi.Input[str]] = None,
             klv_data_pids: Optional[pulumi.Input[str]] = None,
             nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
             null_packet_bitrate: Optional[pulumi.Input[float]] = None,
             pat_interval: Optional[pulumi.Input[int]] = None,
             pcr_control: Optional[pulumi.Input[str]] = None,
             pcr_period: Optional[pulumi.Input[int]] = None,
             pcr_pid: Optional[pulumi.Input[str]] = None,
             pmt_interval: Optional[pulumi.Input[int]] = None,
             pmt_pid: Optional[pulumi.Input[str]] = None,
             program_num: Optional[pulumi.Input[int]] = None,
             rate_mode: Optional[pulumi.Input[str]] = None,
             scte27_pids: Optional[pulumi.Input[str]] = None,
             scte35_control: Optional[pulumi.Input[str]] = None,
             scte35_pid: Optional[pulumi.Input[str]] = None,
             segmentation_markers: Optional[pulumi.Input[str]] = None,
             segmentation_style: Optional[pulumi.Input[str]] = None,
             segmentation_time: Optional[pulumi.Input[float]] = None,
             timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
             timed_metadata_pid: Optional[pulumi.Input[str]] = None,
             transport_stream_id: Optional[pulumi.Input[int]] = None,
             video_pid: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if absent_input_audio_behavior is None and 'absentInputAudioBehavior' in kwargs:
            absent_input_audio_behavior = kwargs['absentInputAudioBehavior']
        if arib_captions_pid is None and 'aribCaptionsPid' in kwargs:
            arib_captions_pid = kwargs['aribCaptionsPid']
        if arib_captions_pid_control is None and 'aribCaptionsPidControl' in kwargs:
            arib_captions_pid_control = kwargs['aribCaptionsPidControl']
        if audio_buffer_model is None and 'audioBufferModel' in kwargs:
            audio_buffer_model = kwargs['audioBufferModel']
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if audio_stream_type is None and 'audioStreamType' in kwargs:
            audio_stream_type = kwargs['audioStreamType']
        if buffer_model is None and 'bufferModel' in kwargs:
            buffer_model = kwargs['bufferModel']
        if cc_descriptor is None and 'ccDescriptor' in kwargs:
            cc_descriptor = kwargs['ccDescriptor']
        if dvb_nit_settings is None and 'dvbNitSettings' in kwargs:
            dvb_nit_settings = kwargs['dvbNitSettings']
        if dvb_sdt_settings is None and 'dvbSdtSettings' in kwargs:
            dvb_sdt_settings = kwargs['dvbSdtSettings']
        if dvb_sub_pids is None and 'dvbSubPids' in kwargs:
            dvb_sub_pids = kwargs['dvbSubPids']
        if dvb_tdt_settings is None and 'dvbTdtSettings' in kwargs:
            dvb_tdt_settings = kwargs['dvbTdtSettings']
        if dvb_teletext_pid is None and 'dvbTeletextPid' in kwargs:
            dvb_teletext_pid = kwargs['dvbTeletextPid']
        if ebp_audio_interval is None and 'ebpAudioInterval' in kwargs:
            ebp_audio_interval = kwargs['ebpAudioInterval']
        if ebp_lookahead_ms is None and 'ebpLookaheadMs' in kwargs:
            ebp_lookahead_ms = kwargs['ebpLookaheadMs']
        if ebp_placement is None and 'ebpPlacement' in kwargs:
            ebp_placement = kwargs['ebpPlacement']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if es_rate_in_pes is None and 'esRateInPes' in kwargs:
            es_rate_in_pes = kwargs['esRateInPes']
        if etv_platform_pid is None and 'etvPlatformPid' in kwargs:
            etv_platform_pid = kwargs['etvPlatformPid']
        if etv_signal_pid is None and 'etvSignalPid' in kwargs:
            etv_signal_pid = kwargs['etvSignalPid']
        if fragment_time is None and 'fragmentTime' in kwargs:
            fragment_time = kwargs['fragmentTime']
        if klv_data_pids is None and 'klvDataPids' in kwargs:
            klv_data_pids = kwargs['klvDataPids']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if null_packet_bitrate is None and 'nullPacketBitrate' in kwargs:
            null_packet_bitrate = kwargs['nullPacketBitrate']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if rate_mode is None and 'rateMode' in kwargs:
            rate_mode = kwargs['rateMode']
        if scte27_pids is None and 'scte27Pids' in kwargs:
            scte27_pids = kwargs['scte27Pids']
        if scte35_control is None and 'scte35Control' in kwargs:
            scte35_control = kwargs['scte35Control']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if segmentation_markers is None and 'segmentationMarkers' in kwargs:
            segmentation_markers = kwargs['segmentationMarkers']
        if segmentation_style is None and 'segmentationStyle' in kwargs:
            segmentation_style = kwargs['segmentationStyle']
        if segmentation_time is None and 'segmentationTime' in kwargs:
            segmentation_time = kwargs['segmentationTime']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if absent_input_audio_behavior is not None:
            _setter("absent_input_audio_behavior", absent_input_audio_behavior)
        if arib is not None:
            _setter("arib", arib)
        if arib_captions_pid is not None:
            _setter("arib_captions_pid", arib_captions_pid)
        if arib_captions_pid_control is not None:
            _setter("arib_captions_pid_control", arib_captions_pid_control)
        if audio_buffer_model is not None:
            _setter("audio_buffer_model", audio_buffer_model)
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if audio_stream_type is not None:
            _setter("audio_stream_type", audio_stream_type)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buffer_model is not None:
            _setter("buffer_model", buffer_model)
        if cc_descriptor is not None:
            _setter("cc_descriptor", cc_descriptor)
        if dvb_nit_settings is not None:
            _setter("dvb_nit_settings", dvb_nit_settings)
        if dvb_sdt_settings is not None:
            _setter("dvb_sdt_settings", dvb_sdt_settings)
        if dvb_sub_pids is not None:
            _setter("dvb_sub_pids", dvb_sub_pids)
        if dvb_tdt_settings is not None:
            _setter("dvb_tdt_settings", dvb_tdt_settings)
        if dvb_teletext_pid is not None:
            _setter("dvb_teletext_pid", dvb_teletext_pid)
        if ebif is not None:
            _setter("ebif", ebif)
        if ebp_audio_interval is not None:
            _setter("ebp_audio_interval", ebp_audio_interval)
        if ebp_lookahead_ms is not None:
            _setter("ebp_lookahead_ms", ebp_lookahead_ms)
        if ebp_placement is not None:
            _setter("ebp_placement", ebp_placement)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if es_rate_in_pes is not None:
            _setter("es_rate_in_pes", es_rate_in_pes)
        if etv_platform_pid is not None:
            _setter("etv_platform_pid", etv_platform_pid)
        if etv_signal_pid is not None:
            _setter("etv_signal_pid", etv_signal_pid)
        if fragment_time is not None:
            _setter("fragment_time", fragment_time)
        if klv is not None:
            _setter("klv", klv)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if null_packet_bitrate is not None:
            _setter("null_packet_bitrate", null_packet_bitrate)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if rate_mode is not None:
            _setter("rate_mode", rate_mode)
        if scte27_pids is not None:
            _setter("scte27_pids", scte27_pids)
        if scte35_control is not None:
            _setter("scte35_control", scte35_control)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if segmentation_markers is not None:
            _setter("segmentation_markers", segmentation_markers)
        if segmentation_style is not None:
            _setter("segmentation_style", segmentation_style)
        if segmentation_time is not None:
            _setter("segmentation_time", segmentation_time)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="absentInputAudioBehavior")
    def absent_input_audio_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "absent_input_audio_behavior")

    @absent_input_audio_behavior.setter
    def absent_input_audio_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "absent_input_audio_behavior", value)

    @property
    @pulumi.getter
    def arib(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib")

    @arib.setter
    def arib(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib", value)

    @property
    @pulumi.getter(name="aribCaptionsPid")
    def arib_captions_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib_captions_pid")

    @arib_captions_pid.setter
    def arib_captions_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib_captions_pid", value)

    @property
    @pulumi.getter(name="aribCaptionsPidControl")
    def arib_captions_pid_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib_captions_pid_control")

    @arib_captions_pid_control.setter
    def arib_captions_pid_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib_captions_pid_control", value)

    @property
    @pulumi.getter(name="audioBufferModel")
    def audio_buffer_model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_buffer_model")

    @audio_buffer_model.setter
    def audio_buffer_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_buffer_model", value)

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "audio_frames_per_pes")

    @audio_frames_per_pes.setter
    def audio_frames_per_pes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_frames_per_pes", value)

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_pids")

    @audio_pids.setter
    def audio_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_pids", value)

    @property
    @pulumi.getter(name="audioStreamType")
    def audio_stream_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_stream_type")

    @audio_stream_type.setter
    def audio_stream_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_stream_type", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="bufferModel")
    def buffer_model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "buffer_model")

    @buffer_model.setter
    def buffer_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buffer_model", value)

    @property
    @pulumi.getter(name="ccDescriptor")
    def cc_descriptor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cc_descriptor")

    @cc_descriptor.setter
    def cc_descriptor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cc_descriptor", value)

    @property
    @pulumi.getter(name="dvbNitSettings")
    def dvb_nit_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']]:
        return pulumi.get(self, "dvb_nit_settings")

    @dvb_nit_settings.setter
    def dvb_nit_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']]):
        pulumi.set(self, "dvb_nit_settings", value)

    @property
    @pulumi.getter(name="dvbSdtSettings")
    def dvb_sdt_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']]:
        return pulumi.get(self, "dvb_sdt_settings")

    @dvb_sdt_settings.setter
    def dvb_sdt_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']]):
        pulumi.set(self, "dvb_sdt_settings", value)

    @property
    @pulumi.getter(name="dvbSubPids")
    def dvb_sub_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dvb_sub_pids")

    @dvb_sub_pids.setter
    def dvb_sub_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dvb_sub_pids", value)

    @property
    @pulumi.getter(name="dvbTdtSettings")
    def dvb_tdt_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']]:
        return pulumi.get(self, "dvb_tdt_settings")

    @dvb_tdt_settings.setter
    def dvb_tdt_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']]):
        pulumi.set(self, "dvb_tdt_settings", value)

    @property
    @pulumi.getter(name="dvbTeletextPid")
    def dvb_teletext_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dvb_teletext_pid")

    @dvb_teletext_pid.setter
    def dvb_teletext_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dvb_teletext_pid", value)

    @property
    @pulumi.getter
    def ebif(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebif")

    @ebif.setter
    def ebif(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebif", value)

    @property
    @pulumi.getter(name="ebpAudioInterval")
    def ebp_audio_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebp_audio_interval")

    @ebp_audio_interval.setter
    def ebp_audio_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebp_audio_interval", value)

    @property
    @pulumi.getter(name="ebpLookaheadMs")
    def ebp_lookahead_ms(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebp_lookahead_ms")

    @ebp_lookahead_ms.setter
    def ebp_lookahead_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebp_lookahead_ms", value)

    @property
    @pulumi.getter(name="ebpPlacement")
    def ebp_placement(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebp_placement")

    @ebp_placement.setter
    def ebp_placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebp_placement", value)

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ecm_pid")

    @ecm_pid.setter
    def ecm_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ecm_pid", value)

    @property
    @pulumi.getter(name="esRateInPes")
    def es_rate_in_pes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "es_rate_in_pes")

    @es_rate_in_pes.setter
    def es_rate_in_pes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "es_rate_in_pes", value)

    @property
    @pulumi.getter(name="etvPlatformPid")
    def etv_platform_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "etv_platform_pid")

    @etv_platform_pid.setter
    def etv_platform_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "etv_platform_pid", value)

    @property
    @pulumi.getter(name="etvSignalPid")
    def etv_signal_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "etv_signal_pid")

    @etv_signal_pid.setter
    def etv_signal_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "etv_signal_pid", value)

    @property
    @pulumi.getter(name="fragmentTime")
    def fragment_time(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "fragment_time")

    @fragment_time.setter
    def fragment_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "fragment_time", value)

    @property
    @pulumi.getter
    def klv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "klv")

    @klv.setter
    def klv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "klv", value)

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "klv_data_pids")

    @klv_data_pids.setter
    def klv_data_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "klv_data_pids", value)

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @nielsen_id3_behavior.setter
    def nielsen_id3_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_id3_behavior", value)

    @property
    @pulumi.getter(name="nullPacketBitrate")
    def null_packet_bitrate(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "null_packet_bitrate")

    @null_packet_bitrate.setter
    def null_packet_bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "null_packet_bitrate", value)

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pat_interval")

    @pat_interval.setter
    def pat_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pat_interval", value)

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_control")

    @pcr_control.setter
    def pcr_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_control", value)

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pcr_period")

    @pcr_period.setter
    def pcr_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pcr_period", value)

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_pid")

    @pcr_pid.setter
    def pcr_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_pid", value)

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pmt_interval")

    @pmt_interval.setter
    def pmt_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pmt_interval", value)

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pmt_pid")

    @pmt_pid.setter
    def pmt_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pmt_pid", value)

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "program_num")

    @program_num.setter
    def program_num(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "program_num", value)

    @property
    @pulumi.getter(name="rateMode")
    def rate_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rate_mode")

    @rate_mode.setter
    def rate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_mode", value)

    @property
    @pulumi.getter(name="scte27Pids")
    def scte27_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte27_pids")

    @scte27_pids.setter
    def scte27_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte27_pids", value)

    @property
    @pulumi.getter(name="scte35Control")
    def scte35_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte35_control")

    @scte35_control.setter
    def scte35_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_control", value)

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[pulumi.Input[str]]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @scte35_pid.setter
    def scte35_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_pid", value)

    @property
    @pulumi.getter(name="segmentationMarkers")
    def segmentation_markers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segmentation_markers")

    @segmentation_markers.setter
    def segmentation_markers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segmentation_markers", value)

    @property
    @pulumi.getter(name="segmentationStyle")
    def segmentation_style(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segmentation_style")

    @segmentation_style.setter
    def segmentation_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segmentation_style", value)

    @property
    @pulumi.getter(name="segmentationTime")
    def segmentation_time(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "segmentation_time")

    @segmentation_time.setter
    def segmentation_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "segmentation_time", value)

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_behavior")

    @timed_metadata_behavior.setter
    def timed_metadata_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_behavior", value)

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_pid")

    @timed_metadata_pid.setter
    def timed_metadata_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_pid", value)

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "transport_stream_id")

    @transport_stream_id.setter
    def transport_stream_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transport_stream_id", value)

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "video_pid")

    @video_pid.setter
    def video_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_pid", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[int],
                 network_name: pulumi.Input[str],
                 rep_interval: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            network_name=network_name,
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[pulumi.Input[int]] = None,
             network_name: Optional[pulumi.Input[str]] = None,
             rep_interval: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if network_name is None and 'networkName' in kwargs:
            network_name = kwargs['networkName']
        if network_name is None:
            raise TypeError("Missing 'network_name' argument")
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        _setter("network_id", network_id)
        _setter("network_name", network_name)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs:
    def __init__(__self__, *,
                 output_sdt: Optional[pulumi.Input[str]] = None,
                 rep_interval: Optional[pulumi.Input[int]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 service_provider_name: Optional[pulumi.Input[str]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_sdt=output_sdt,
            rep_interval=rep_interval,
            service_name=service_name,
            service_provider_name=service_provider_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_sdt: Optional[pulumi.Input[str]] = None,
             rep_interval: Optional[pulumi.Input[int]] = None,
             service_name: Optional[pulumi.Input[str]] = None,
             service_provider_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_sdt is None and 'outputSdt' in kwargs:
            output_sdt = kwargs['outputSdt']
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_provider_name is None and 'serviceProviderName' in kwargs:
            service_provider_name = kwargs['serviceProviderName']

        if output_sdt is not None:
            _setter("output_sdt", output_sdt)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)
        if service_name is not None:
            _setter("service_name", service_name)
        if service_provider_name is not None:
            _setter("service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="outputSdt")
    def output_sdt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "output_sdt")

    @output_sdt.setter
    def output_sdt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_sdt", value)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_provider_name")

    @service_provider_name.setter
    def service_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_provider_name", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs:
    def __init__(__self__, *,
                 rep_interval: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rep_interval: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs:
    def __init__(__self__, *,
                 name_modifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name_modifier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[pulumi.Input[str]]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")

    @name_modifier.setter
    def name_modifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_modifier", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs:
    def __init__(__self__, *,
                 hls_settings: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs'],
                 h265_packaging_type: Optional[pulumi.Input[str]] = None,
                 name_modifier: Optional[pulumi.Input[str]] = None,
                 segment_modifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_settings=hls_settings,
            h265_packaging_type=h265_packaging_type,
            name_modifier=name_modifier,
            segment_modifier=segment_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs']] = None,
             h265_packaging_type: Optional[pulumi.Input[str]] = None,
             name_modifier: Optional[pulumi.Input[str]] = None,
             segment_modifier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_settings is None and 'hlsSettings' in kwargs:
            hls_settings = kwargs['hlsSettings']
        if hls_settings is None:
            raise TypeError("Missing 'hls_settings' argument")
        if h265_packaging_type is None and 'h265PackagingType' in kwargs:
            h265_packaging_type = kwargs['h265PackagingType']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']
        if segment_modifier is None and 'segmentModifier' in kwargs:
            segment_modifier = kwargs['segmentModifier']

        _setter("hls_settings", hls_settings)
        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)
        if segment_modifier is not None:
            _setter("segment_modifier", segment_modifier)

    @property
    @pulumi.getter(name="hlsSettings")
    def hls_settings(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs']:
        return pulumi.get(self, "hls_settings")

    @hls_settings.setter
    def hls_settings(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs']):
        pulumi.set(self, "hls_settings", value)

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h265_packaging_type")

    @h265_packaging_type.setter
    def h265_packaging_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h265_packaging_type", value)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[pulumi.Input[str]]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")

    @name_modifier.setter
    def name_modifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_modifier", value)

    @property
    @pulumi.getter(name="segmentModifier")
    def segment_modifier(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segment_modifier")

    @segment_modifier.setter
    def segment_modifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_modifier", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs:
    def __init__(__self__, *,
                 audio_only_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs']] = None,
                 fmp4_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs']] = None,
                 frame_capture_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs']] = None,
                 standard_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs']] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_only_hls_settings=audio_only_hls_settings,
            fmp4_hls_settings=fmp4_hls_settings,
            frame_capture_hls_settings=frame_capture_hls_settings,
            standard_hls_settings=standard_hls_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_only_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs']] = None,
             fmp4_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs']] = None,
             frame_capture_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs']] = None,
             standard_hls_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_only_hls_settings is None and 'audioOnlyHlsSettings' in kwargs:
            audio_only_hls_settings = kwargs['audioOnlyHlsSettings']
        if fmp4_hls_settings is None and 'fmp4HlsSettings' in kwargs:
            fmp4_hls_settings = kwargs['fmp4HlsSettings']
        if frame_capture_hls_settings is None and 'frameCaptureHlsSettings' in kwargs:
            frame_capture_hls_settings = kwargs['frameCaptureHlsSettings']
        if standard_hls_settings is None and 'standardHlsSettings' in kwargs:
            standard_hls_settings = kwargs['standardHlsSettings']

        if audio_only_hls_settings is not None:
            _setter("audio_only_hls_settings", audio_only_hls_settings)
        if fmp4_hls_settings is not None:
            _setter("fmp4_hls_settings", fmp4_hls_settings)
        if frame_capture_hls_settings is not None:
            _setter("frame_capture_hls_settings", frame_capture_hls_settings)
        if standard_hls_settings is not None:
            _setter("standard_hls_settings", standard_hls_settings)

    @property
    @pulumi.getter(name="audioOnlyHlsSettings")
    def audio_only_hls_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs']]:
        return pulumi.get(self, "audio_only_hls_settings")

    @audio_only_hls_settings.setter
    def audio_only_hls_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs']]):
        pulumi.set(self, "audio_only_hls_settings", value)

    @property
    @pulumi.getter(name="fmp4HlsSettings")
    def fmp4_hls_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs']]:
        return pulumi.get(self, "fmp4_hls_settings")

    @fmp4_hls_settings.setter
    def fmp4_hls_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs']]):
        pulumi.set(self, "fmp4_hls_settings", value)

    @property
    @pulumi.getter(name="frameCaptureHlsSettings")
    def frame_capture_hls_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs']]:
        return pulumi.get(self, "frame_capture_hls_settings")

    @frame_capture_hls_settings.setter
    def frame_capture_hls_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs']]):
        pulumi.set(self, "frame_capture_hls_settings", value)

    @property
    @pulumi.getter(name="standardHlsSettings")
    def standard_hls_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs']]:
        return pulumi.get(self, "standard_hls_settings")

    @standard_hls_settings.setter
    def standard_hls_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs']]):
        pulumi.set(self, "standard_hls_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs:
    def __init__(__self__, *,
                 audio_group_id: Optional[pulumi.Input[str]] = None,
                 audio_only_image: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs']] = None,
                 audio_track_type: Optional[pulumi.Input[str]] = None,
                 segment_type: Optional[pulumi.Input[str]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_group_id=audio_group_id,
            audio_only_image=audio_only_image,
            audio_track_type=audio_track_type,
            segment_type=segment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_group_id: Optional[pulumi.Input[str]] = None,
             audio_only_image: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs']] = None,
             audio_track_type: Optional[pulumi.Input[str]] = None,
             segment_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_group_id is None and 'audioGroupId' in kwargs:
            audio_group_id = kwargs['audioGroupId']
        if audio_only_image is None and 'audioOnlyImage' in kwargs:
            audio_only_image = kwargs['audioOnlyImage']
        if audio_track_type is None and 'audioTrackType' in kwargs:
            audio_track_type = kwargs['audioTrackType']
        if segment_type is None and 'segmentType' in kwargs:
            segment_type = kwargs['segmentType']

        if audio_group_id is not None:
            _setter("audio_group_id", audio_group_id)
        if audio_only_image is not None:
            _setter("audio_only_image", audio_only_image)
        if audio_track_type is not None:
            _setter("audio_track_type", audio_track_type)
        if segment_type is not None:
            _setter("segment_type", segment_type)

    @property
    @pulumi.getter(name="audioGroupId")
    def audio_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_group_id")

    @audio_group_id.setter
    def audio_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_group_id", value)

    @property
    @pulumi.getter(name="audioOnlyImage")
    def audio_only_image(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs']]:
        return pulumi.get(self, "audio_only_image")

    @audio_only_image.setter
    def audio_only_image(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs']]):
        pulumi.set(self, "audio_only_image", value)

    @property
    @pulumi.getter(name="audioTrackType")
    def audio_track_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_track_type")

    @audio_track_type.setter
    def audio_track_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_track_type", value)

    @property
    @pulumi.getter(name="segmentType")
    def segment_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segment_type")

    @segment_type.setter
    def segment_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_type", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 password_param: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Path to a file accessible to the live stream.
        :param pulumi.Input[str] password_param: Key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] username: . Username to be used.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             password_param: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[pulumi.Input[str]]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs:
    def __init__(__self__, *,
                 audio_rendition_sets: Optional[pulumi.Input[str]] = None,
                 nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
                 timed_metadata_behavior: Optional[pulumi.Input[str]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_rendition_sets=audio_rendition_sets,
            nielsen_id3_behavior=nielsen_id3_behavior,
            timed_metadata_behavior=timed_metadata_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_rendition_sets: Optional[pulumi.Input[str]] = None,
             nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
             timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_rendition_sets is None and 'audioRenditionSets' in kwargs:
            audio_rendition_sets = kwargs['audioRenditionSets']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']

        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_rendition_sets")

    @audio_rendition_sets.setter
    def audio_rendition_sets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_rendition_sets", value)

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @nielsen_id3_behavior.setter
    def nielsen_id3_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_id3_behavior", value)

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_behavior")

    @timed_metadata_behavior.setter
    def timed_metadata_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_behavior", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs:
    def __init__(__self__, *,
                 m3u8_settings: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs'],
                 audio_rendition_sets: Optional[pulumi.Input[str]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m3u8_settings=m3u8_settings,
            audio_rendition_sets=audio_rendition_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m3u8_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs']] = None,
             audio_rendition_sets: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m3u8_settings is None and 'm3u8Settings' in kwargs:
            m3u8_settings = kwargs['m3u8Settings']
        if m3u8_settings is None:
            raise TypeError("Missing 'm3u8_settings' argument")
        if audio_rendition_sets is None and 'audioRenditionSets' in kwargs:
            audio_rendition_sets = kwargs['audioRenditionSets']

        _setter("m3u8_settings", m3u8_settings)
        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)

    @property
    @pulumi.getter(name="m3u8Settings")
    def m3u8_settings(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs']:
        return pulumi.get(self, "m3u8_settings")

    @m3u8_settings.setter
    def m3u8_settings(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs']):
        pulumi.set(self, "m3u8_settings", value)

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_rendition_sets")

    @audio_rendition_sets.setter
    def audio_rendition_sets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_rendition_sets", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs:
    def __init__(__self__, *,
                 audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
                 audio_pids: Optional[pulumi.Input[str]] = None,
                 ecm_pid: Optional[pulumi.Input[str]] = None,
                 nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
                 pat_interval: Optional[pulumi.Input[int]] = None,
                 pcr_control: Optional[pulumi.Input[str]] = None,
                 pcr_period: Optional[pulumi.Input[int]] = None,
                 pcr_pid: Optional[pulumi.Input[str]] = None,
                 pmt_interval: Optional[pulumi.Input[int]] = None,
                 pmt_pid: Optional[pulumi.Input[str]] = None,
                 program_num: Optional[pulumi.Input[int]] = None,
                 scte35_behavior: Optional[pulumi.Input[str]] = None,
                 scte35_pid: Optional[pulumi.Input[str]] = None,
                 timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
                 timed_metadata_pid: Optional[pulumi.Input[str]] = None,
                 transport_stream_id: Optional[pulumi.Input[int]] = None,
                 video_pid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            ecm_pid=ecm_pid,
            nielsen_id3_behavior=nielsen_id3_behavior,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            scte35_behavior=scte35_behavior,
            scte35_pid=scte35_pid,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
             audio_pids: Optional[pulumi.Input[str]] = None,
             ecm_pid: Optional[pulumi.Input[str]] = None,
             nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
             pat_interval: Optional[pulumi.Input[int]] = None,
             pcr_control: Optional[pulumi.Input[str]] = None,
             pcr_period: Optional[pulumi.Input[int]] = None,
             pcr_pid: Optional[pulumi.Input[str]] = None,
             pmt_interval: Optional[pulumi.Input[int]] = None,
             pmt_pid: Optional[pulumi.Input[str]] = None,
             program_num: Optional[pulumi.Input[int]] = None,
             scte35_behavior: Optional[pulumi.Input[str]] = None,
             scte35_pid: Optional[pulumi.Input[str]] = None,
             timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
             timed_metadata_pid: Optional[pulumi.Input[str]] = None,
             transport_stream_id: Optional[pulumi.Input[int]] = None,
             video_pid: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if scte35_behavior is None and 'scte35Behavior' in kwargs:
            scte35_behavior = kwargs['scte35Behavior']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if scte35_behavior is not None:
            _setter("scte35_behavior", scte35_behavior)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "audio_frames_per_pes")

    @audio_frames_per_pes.setter
    def audio_frames_per_pes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_frames_per_pes", value)

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_pids")

    @audio_pids.setter
    def audio_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_pids", value)

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ecm_pid")

    @ecm_pid.setter
    def ecm_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ecm_pid", value)

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @nielsen_id3_behavior.setter
    def nielsen_id3_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_id3_behavior", value)

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pat_interval")

    @pat_interval.setter
    def pat_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pat_interval", value)

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_control")

    @pcr_control.setter
    def pcr_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_control", value)

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pcr_period")

    @pcr_period.setter
    def pcr_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pcr_period", value)

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_pid")

    @pcr_pid.setter
    def pcr_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_pid", value)

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pmt_interval")

    @pmt_interval.setter
    def pmt_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pmt_interval", value)

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pmt_pid")

    @pmt_pid.setter
    def pmt_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pmt_pid", value)

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "program_num")

    @program_num.setter
    def program_num(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "program_num", value)

    @property
    @pulumi.getter(name="scte35Behavior")
    def scte35_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte35_behavior")

    @scte35_behavior.setter
    def scte35_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_behavior", value)

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[pulumi.Input[str]]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @scte35_pid.setter
    def scte35_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_pid", value)

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_behavior")

    @timed_metadata_behavior.setter
    def timed_metadata_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_behavior", value)

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_pid")

    @timed_metadata_pid.setter
    def timed_metadata_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_pid", value)

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "transport_stream_id")

    @transport_stream_id.setter
    def transport_stream_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transport_stream_id", value)

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "video_pid")

    @video_pid.setter
    def video_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_pid", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs:
    def __init__(__self__, *,
                 h265_packaging_type: Optional[pulumi.Input[str]] = None,
                 name_modifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            h265_packaging_type=h265_packaging_type,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             h265_packaging_type: Optional[pulumi.Input[str]] = None,
             name_modifier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if h265_packaging_type is None and 'h265PackagingType' in kwargs:
            h265_packaging_type = kwargs['h265PackagingType']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "h265_packaging_type")

    @h265_packaging_type.setter
    def h265_packaging_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h265_packaging_type", value)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[pulumi.Input[str]]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")

    @name_modifier.setter
    def name_modifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_modifier", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs']):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs'] destination: Destination is a multiplex. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs']:
        """
        Destination is a multiplex. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs'],
                 certificate_mode: Optional[pulumi.Input[str]] = None,
                 connection_retry_interval: Optional[pulumi.Input[int]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs'] destination: The RTMP endpoint excluding the stream name. See Destination for more details.
        :param pulumi.Input[str] certificate_mode: Setting to allow self signed or verified RTMP certificates.
        :param pulumi.Input[int] connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param pulumi.Input[int] num_retries: Number of retry attempts.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            num_retries=num_retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs']] = None,
             certificate_mode: Optional[pulumi.Input[str]] = None,
             connection_retry_interval: Optional[pulumi.Input[int]] = None,
             num_retries: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if certificate_mode is None and 'certificateMode' in kwargs:
            certificate_mode = kwargs['certificateMode']
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']

        _setter("destination", destination)
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if num_retries is not None:
            _setter("num_retries", num_retries)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs']:
        """
        The RTMP endpoint excluding the stream name. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Setting to allow self signed or verified RTMP certificates.
        """
        return pulumi.get(self, "certificate_mode")

    @certificate_mode.setter
    def certificate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_mode", value)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @connection_retry_interval.setter
    def connection_retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_retry_interval", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs:
    def __init__(__self__, *,
                 container_settings: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs'],
                 destination: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs'],
                 buffer_msec: Optional[pulumi.Input[int]] = None,
                 fec_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs'] container_settings: UDP container settings. See Container Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs'] destination: Destination address and port number for RTP or UDP packets. See Destination for more details.
        :param pulumi.Input[int] buffer_msec: UDP output buffering in milliseconds.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_settings=container_settings,
            destination=destination,
            buffer_msec=buffer_msec,
            fec_output_settings=fec_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs']] = None,
             destination: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs']] = None,
             buffer_msec: Optional[pulumi.Input[int]] = None,
             fec_output_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_settings is None and 'containerSettings' in kwargs:
            container_settings = kwargs['containerSettings']
        if container_settings is None:
            raise TypeError("Missing 'container_settings' argument")
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if buffer_msec is None and 'bufferMsec' in kwargs:
            buffer_msec = kwargs['bufferMsec']
        if fec_output_settings is None and 'fecOutputSettings' in kwargs:
            fec_output_settings = kwargs['fecOutputSettings']

        _setter("container_settings", container_settings)
        _setter("destination", destination)
        if buffer_msec is not None:
            _setter("buffer_msec", buffer_msec)
        if fec_output_settings is not None:
            _setter("fec_output_settings", fec_output_settings)

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs']:
        """
        UDP container settings. See Container Settings for more details.
        """
        return pulumi.get(self, "container_settings")

    @container_settings.setter
    def container_settings(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs']):
        pulumi.set(self, "container_settings", value)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs']:
        """
        Destination address and port number for RTP or UDP packets. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="bufferMsec")
    def buffer_msec(self) -> Optional[pulumi.Input[int]]:
        """
        UDP output buffering in milliseconds.
        """
        return pulumi.get(self, "buffer_msec")

    @buffer_msec.setter
    def buffer_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_msec", value)

    @property
    @pulumi.getter(name="fecOutputSettings")
    def fec_output_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs']]:
        return pulumi.get(self, "fec_output_settings")

    @fec_output_settings.setter
    def fec_output_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs']]):
        pulumi.set(self, "fec_output_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs:
    def __init__(__self__, *,
                 m2ts_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs'] m2ts_settings: M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m2ts_settings is None and 'm2tsSettings' in kwargs:
            m2ts_settings = kwargs['m2tsSettings']

        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs']]:
        """
        M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        return pulumi.get(self, "m2ts_settings")

    @m2ts_settings.setter
    def m2ts_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs']]):
        pulumi.set(self, "m2ts_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs:
    def __init__(__self__, *,
                 absent_input_audio_behavior: Optional[pulumi.Input[str]] = None,
                 arib: Optional[pulumi.Input[str]] = None,
                 arib_captions_pid: Optional[pulumi.Input[str]] = None,
                 arib_captions_pid_control: Optional[pulumi.Input[str]] = None,
                 audio_buffer_model: Optional[pulumi.Input[str]] = None,
                 audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
                 audio_pids: Optional[pulumi.Input[str]] = None,
                 audio_stream_type: Optional[pulumi.Input[str]] = None,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 buffer_model: Optional[pulumi.Input[str]] = None,
                 cc_descriptor: Optional[pulumi.Input[str]] = None,
                 dvb_nit_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']] = None,
                 dvb_sdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']] = None,
                 dvb_sub_pids: Optional[pulumi.Input[str]] = None,
                 dvb_tdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']] = None,
                 dvb_teletext_pid: Optional[pulumi.Input[str]] = None,
                 ebif: Optional[pulumi.Input[str]] = None,
                 ebp_audio_interval: Optional[pulumi.Input[str]] = None,
                 ebp_lookahead_ms: Optional[pulumi.Input[int]] = None,
                 ebp_placement: Optional[pulumi.Input[str]] = None,
                 ecm_pid: Optional[pulumi.Input[str]] = None,
                 es_rate_in_pes: Optional[pulumi.Input[str]] = None,
                 etv_platform_pid: Optional[pulumi.Input[str]] = None,
                 etv_signal_pid: Optional[pulumi.Input[str]] = None,
                 fragment_time: Optional[pulumi.Input[float]] = None,
                 klv: Optional[pulumi.Input[str]] = None,
                 klv_data_pids: Optional[pulumi.Input[str]] = None,
                 nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
                 null_packet_bitrate: Optional[pulumi.Input[float]] = None,
                 pat_interval: Optional[pulumi.Input[int]] = None,
                 pcr_control: Optional[pulumi.Input[str]] = None,
                 pcr_period: Optional[pulumi.Input[int]] = None,
                 pcr_pid: Optional[pulumi.Input[str]] = None,
                 pmt_interval: Optional[pulumi.Input[int]] = None,
                 pmt_pid: Optional[pulumi.Input[str]] = None,
                 program_num: Optional[pulumi.Input[int]] = None,
                 rate_mode: Optional[pulumi.Input[str]] = None,
                 scte27_pids: Optional[pulumi.Input[str]] = None,
                 scte35_control: Optional[pulumi.Input[str]] = None,
                 scte35_pid: Optional[pulumi.Input[str]] = None,
                 segmentation_markers: Optional[pulumi.Input[str]] = None,
                 segmentation_style: Optional[pulumi.Input[str]] = None,
                 segmentation_time: Optional[pulumi.Input[float]] = None,
                 timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
                 timed_metadata_pid: Optional[pulumi.Input[str]] = None,
                 transport_stream_id: Optional[pulumi.Input[int]] = None,
                 video_pid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[str] scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            absent_input_audio_behavior=absent_input_audio_behavior,
            arib=arib,
            arib_captions_pid=arib_captions_pid,
            arib_captions_pid_control=arib_captions_pid_control,
            audio_buffer_model=audio_buffer_model,
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            audio_stream_type=audio_stream_type,
            bitrate=bitrate,
            buffer_model=buffer_model,
            cc_descriptor=cc_descriptor,
            dvb_nit_settings=dvb_nit_settings,
            dvb_sdt_settings=dvb_sdt_settings,
            dvb_sub_pids=dvb_sub_pids,
            dvb_tdt_settings=dvb_tdt_settings,
            dvb_teletext_pid=dvb_teletext_pid,
            ebif=ebif,
            ebp_audio_interval=ebp_audio_interval,
            ebp_lookahead_ms=ebp_lookahead_ms,
            ebp_placement=ebp_placement,
            ecm_pid=ecm_pid,
            es_rate_in_pes=es_rate_in_pes,
            etv_platform_pid=etv_platform_pid,
            etv_signal_pid=etv_signal_pid,
            fragment_time=fragment_time,
            klv=klv,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            null_packet_bitrate=null_packet_bitrate,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            rate_mode=rate_mode,
            scte27_pids=scte27_pids,
            scte35_control=scte35_control,
            scte35_pid=scte35_pid,
            segmentation_markers=segmentation_markers,
            segmentation_style=segmentation_style,
            segmentation_time=segmentation_time,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             absent_input_audio_behavior: Optional[pulumi.Input[str]] = None,
             arib: Optional[pulumi.Input[str]] = None,
             arib_captions_pid: Optional[pulumi.Input[str]] = None,
             arib_captions_pid_control: Optional[pulumi.Input[str]] = None,
             audio_buffer_model: Optional[pulumi.Input[str]] = None,
             audio_frames_per_pes: Optional[pulumi.Input[int]] = None,
             audio_pids: Optional[pulumi.Input[str]] = None,
             audio_stream_type: Optional[pulumi.Input[str]] = None,
             bitrate: Optional[pulumi.Input[int]] = None,
             buffer_model: Optional[pulumi.Input[str]] = None,
             cc_descriptor: Optional[pulumi.Input[str]] = None,
             dvb_nit_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']] = None,
             dvb_sdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']] = None,
             dvb_sub_pids: Optional[pulumi.Input[str]] = None,
             dvb_tdt_settings: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']] = None,
             dvb_teletext_pid: Optional[pulumi.Input[str]] = None,
             ebif: Optional[pulumi.Input[str]] = None,
             ebp_audio_interval: Optional[pulumi.Input[str]] = None,
             ebp_lookahead_ms: Optional[pulumi.Input[int]] = None,
             ebp_placement: Optional[pulumi.Input[str]] = None,
             ecm_pid: Optional[pulumi.Input[str]] = None,
             es_rate_in_pes: Optional[pulumi.Input[str]] = None,
             etv_platform_pid: Optional[pulumi.Input[str]] = None,
             etv_signal_pid: Optional[pulumi.Input[str]] = None,
             fragment_time: Optional[pulumi.Input[float]] = None,
             klv: Optional[pulumi.Input[str]] = None,
             klv_data_pids: Optional[pulumi.Input[str]] = None,
             nielsen_id3_behavior: Optional[pulumi.Input[str]] = None,
             null_packet_bitrate: Optional[pulumi.Input[float]] = None,
             pat_interval: Optional[pulumi.Input[int]] = None,
             pcr_control: Optional[pulumi.Input[str]] = None,
             pcr_period: Optional[pulumi.Input[int]] = None,
             pcr_pid: Optional[pulumi.Input[str]] = None,
             pmt_interval: Optional[pulumi.Input[int]] = None,
             pmt_pid: Optional[pulumi.Input[str]] = None,
             program_num: Optional[pulumi.Input[int]] = None,
             rate_mode: Optional[pulumi.Input[str]] = None,
             scte27_pids: Optional[pulumi.Input[str]] = None,
             scte35_control: Optional[pulumi.Input[str]] = None,
             scte35_pid: Optional[pulumi.Input[str]] = None,
             segmentation_markers: Optional[pulumi.Input[str]] = None,
             segmentation_style: Optional[pulumi.Input[str]] = None,
             segmentation_time: Optional[pulumi.Input[float]] = None,
             timed_metadata_behavior: Optional[pulumi.Input[str]] = None,
             timed_metadata_pid: Optional[pulumi.Input[str]] = None,
             transport_stream_id: Optional[pulumi.Input[int]] = None,
             video_pid: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if absent_input_audio_behavior is None and 'absentInputAudioBehavior' in kwargs:
            absent_input_audio_behavior = kwargs['absentInputAudioBehavior']
        if arib_captions_pid is None and 'aribCaptionsPid' in kwargs:
            arib_captions_pid = kwargs['aribCaptionsPid']
        if arib_captions_pid_control is None and 'aribCaptionsPidControl' in kwargs:
            arib_captions_pid_control = kwargs['aribCaptionsPidControl']
        if audio_buffer_model is None and 'audioBufferModel' in kwargs:
            audio_buffer_model = kwargs['audioBufferModel']
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if audio_stream_type is None and 'audioStreamType' in kwargs:
            audio_stream_type = kwargs['audioStreamType']
        if buffer_model is None and 'bufferModel' in kwargs:
            buffer_model = kwargs['bufferModel']
        if cc_descriptor is None and 'ccDescriptor' in kwargs:
            cc_descriptor = kwargs['ccDescriptor']
        if dvb_nit_settings is None and 'dvbNitSettings' in kwargs:
            dvb_nit_settings = kwargs['dvbNitSettings']
        if dvb_sdt_settings is None and 'dvbSdtSettings' in kwargs:
            dvb_sdt_settings = kwargs['dvbSdtSettings']
        if dvb_sub_pids is None and 'dvbSubPids' in kwargs:
            dvb_sub_pids = kwargs['dvbSubPids']
        if dvb_tdt_settings is None and 'dvbTdtSettings' in kwargs:
            dvb_tdt_settings = kwargs['dvbTdtSettings']
        if dvb_teletext_pid is None and 'dvbTeletextPid' in kwargs:
            dvb_teletext_pid = kwargs['dvbTeletextPid']
        if ebp_audio_interval is None and 'ebpAudioInterval' in kwargs:
            ebp_audio_interval = kwargs['ebpAudioInterval']
        if ebp_lookahead_ms is None and 'ebpLookaheadMs' in kwargs:
            ebp_lookahead_ms = kwargs['ebpLookaheadMs']
        if ebp_placement is None and 'ebpPlacement' in kwargs:
            ebp_placement = kwargs['ebpPlacement']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if es_rate_in_pes is None and 'esRateInPes' in kwargs:
            es_rate_in_pes = kwargs['esRateInPes']
        if etv_platform_pid is None and 'etvPlatformPid' in kwargs:
            etv_platform_pid = kwargs['etvPlatformPid']
        if etv_signal_pid is None and 'etvSignalPid' in kwargs:
            etv_signal_pid = kwargs['etvSignalPid']
        if fragment_time is None and 'fragmentTime' in kwargs:
            fragment_time = kwargs['fragmentTime']
        if klv_data_pids is None and 'klvDataPids' in kwargs:
            klv_data_pids = kwargs['klvDataPids']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if null_packet_bitrate is None and 'nullPacketBitrate' in kwargs:
            null_packet_bitrate = kwargs['nullPacketBitrate']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if rate_mode is None and 'rateMode' in kwargs:
            rate_mode = kwargs['rateMode']
        if scte27_pids is None and 'scte27Pids' in kwargs:
            scte27_pids = kwargs['scte27Pids']
        if scte35_control is None and 'scte35Control' in kwargs:
            scte35_control = kwargs['scte35Control']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if segmentation_markers is None and 'segmentationMarkers' in kwargs:
            segmentation_markers = kwargs['segmentationMarkers']
        if segmentation_style is None and 'segmentationStyle' in kwargs:
            segmentation_style = kwargs['segmentationStyle']
        if segmentation_time is None and 'segmentationTime' in kwargs:
            segmentation_time = kwargs['segmentationTime']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if absent_input_audio_behavior is not None:
            _setter("absent_input_audio_behavior", absent_input_audio_behavior)
        if arib is not None:
            _setter("arib", arib)
        if arib_captions_pid is not None:
            _setter("arib_captions_pid", arib_captions_pid)
        if arib_captions_pid_control is not None:
            _setter("arib_captions_pid_control", arib_captions_pid_control)
        if audio_buffer_model is not None:
            _setter("audio_buffer_model", audio_buffer_model)
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if audio_stream_type is not None:
            _setter("audio_stream_type", audio_stream_type)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buffer_model is not None:
            _setter("buffer_model", buffer_model)
        if cc_descriptor is not None:
            _setter("cc_descriptor", cc_descriptor)
        if dvb_nit_settings is not None:
            _setter("dvb_nit_settings", dvb_nit_settings)
        if dvb_sdt_settings is not None:
            _setter("dvb_sdt_settings", dvb_sdt_settings)
        if dvb_sub_pids is not None:
            _setter("dvb_sub_pids", dvb_sub_pids)
        if dvb_tdt_settings is not None:
            _setter("dvb_tdt_settings", dvb_tdt_settings)
        if dvb_teletext_pid is not None:
            _setter("dvb_teletext_pid", dvb_teletext_pid)
        if ebif is not None:
            _setter("ebif", ebif)
        if ebp_audio_interval is not None:
            _setter("ebp_audio_interval", ebp_audio_interval)
        if ebp_lookahead_ms is not None:
            _setter("ebp_lookahead_ms", ebp_lookahead_ms)
        if ebp_placement is not None:
            _setter("ebp_placement", ebp_placement)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if es_rate_in_pes is not None:
            _setter("es_rate_in_pes", es_rate_in_pes)
        if etv_platform_pid is not None:
            _setter("etv_platform_pid", etv_platform_pid)
        if etv_signal_pid is not None:
            _setter("etv_signal_pid", etv_signal_pid)
        if fragment_time is not None:
            _setter("fragment_time", fragment_time)
        if klv is not None:
            _setter("klv", klv)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if null_packet_bitrate is not None:
            _setter("null_packet_bitrate", null_packet_bitrate)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if rate_mode is not None:
            _setter("rate_mode", rate_mode)
        if scte27_pids is not None:
            _setter("scte27_pids", scte27_pids)
        if scte35_control is not None:
            _setter("scte35_control", scte35_control)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if segmentation_markers is not None:
            _setter("segmentation_markers", segmentation_markers)
        if segmentation_style is not None:
            _setter("segmentation_style", segmentation_style)
        if segmentation_time is not None:
            _setter("segmentation_time", segmentation_time)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="absentInputAudioBehavior")
    def absent_input_audio_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "absent_input_audio_behavior")

    @absent_input_audio_behavior.setter
    def absent_input_audio_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "absent_input_audio_behavior", value)

    @property
    @pulumi.getter
    def arib(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib")

    @arib.setter
    def arib(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib", value)

    @property
    @pulumi.getter(name="aribCaptionsPid")
    def arib_captions_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib_captions_pid")

    @arib_captions_pid.setter
    def arib_captions_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib_captions_pid", value)

    @property
    @pulumi.getter(name="aribCaptionsPidControl")
    def arib_captions_pid_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arib_captions_pid_control")

    @arib_captions_pid_control.setter
    def arib_captions_pid_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arib_captions_pid_control", value)

    @property
    @pulumi.getter(name="audioBufferModel")
    def audio_buffer_model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_buffer_model")

    @audio_buffer_model.setter
    def audio_buffer_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_buffer_model", value)

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "audio_frames_per_pes")

    @audio_frames_per_pes.setter
    def audio_frames_per_pes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_frames_per_pes", value)

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_pids")

    @audio_pids.setter
    def audio_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_pids", value)

    @property
    @pulumi.getter(name="audioStreamType")
    def audio_stream_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "audio_stream_type")

    @audio_stream_type.setter
    def audio_stream_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_stream_type", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="bufferModel")
    def buffer_model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "buffer_model")

    @buffer_model.setter
    def buffer_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buffer_model", value)

    @property
    @pulumi.getter(name="ccDescriptor")
    def cc_descriptor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cc_descriptor")

    @cc_descriptor.setter
    def cc_descriptor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cc_descriptor", value)

    @property
    @pulumi.getter(name="dvbNitSettings")
    def dvb_nit_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']]:
        return pulumi.get(self, "dvb_nit_settings")

    @dvb_nit_settings.setter
    def dvb_nit_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs']]):
        pulumi.set(self, "dvb_nit_settings", value)

    @property
    @pulumi.getter(name="dvbSdtSettings")
    def dvb_sdt_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']]:
        return pulumi.get(self, "dvb_sdt_settings")

    @dvb_sdt_settings.setter
    def dvb_sdt_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs']]):
        pulumi.set(self, "dvb_sdt_settings", value)

    @property
    @pulumi.getter(name="dvbSubPids")
    def dvb_sub_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dvb_sub_pids")

    @dvb_sub_pids.setter
    def dvb_sub_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dvb_sub_pids", value)

    @property
    @pulumi.getter(name="dvbTdtSettings")
    def dvb_tdt_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']]:
        return pulumi.get(self, "dvb_tdt_settings")

    @dvb_tdt_settings.setter
    def dvb_tdt_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs']]):
        pulumi.set(self, "dvb_tdt_settings", value)

    @property
    @pulumi.getter(name="dvbTeletextPid")
    def dvb_teletext_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dvb_teletext_pid")

    @dvb_teletext_pid.setter
    def dvb_teletext_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dvb_teletext_pid", value)

    @property
    @pulumi.getter
    def ebif(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebif")

    @ebif.setter
    def ebif(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebif", value)

    @property
    @pulumi.getter(name="ebpAudioInterval")
    def ebp_audio_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebp_audio_interval")

    @ebp_audio_interval.setter
    def ebp_audio_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebp_audio_interval", value)

    @property
    @pulumi.getter(name="ebpLookaheadMs")
    def ebp_lookahead_ms(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebp_lookahead_ms")

    @ebp_lookahead_ms.setter
    def ebp_lookahead_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebp_lookahead_ms", value)

    @property
    @pulumi.getter(name="ebpPlacement")
    def ebp_placement(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebp_placement")

    @ebp_placement.setter
    def ebp_placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebp_placement", value)

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ecm_pid")

    @ecm_pid.setter
    def ecm_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ecm_pid", value)

    @property
    @pulumi.getter(name="esRateInPes")
    def es_rate_in_pes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "es_rate_in_pes")

    @es_rate_in_pes.setter
    def es_rate_in_pes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "es_rate_in_pes", value)

    @property
    @pulumi.getter(name="etvPlatformPid")
    def etv_platform_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "etv_platform_pid")

    @etv_platform_pid.setter
    def etv_platform_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "etv_platform_pid", value)

    @property
    @pulumi.getter(name="etvSignalPid")
    def etv_signal_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "etv_signal_pid")

    @etv_signal_pid.setter
    def etv_signal_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "etv_signal_pid", value)

    @property
    @pulumi.getter(name="fragmentTime")
    def fragment_time(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "fragment_time")

    @fragment_time.setter
    def fragment_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "fragment_time", value)

    @property
    @pulumi.getter
    def klv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "klv")

    @klv.setter
    def klv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "klv", value)

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "klv_data_pids")

    @klv_data_pids.setter
    def klv_data_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "klv_data_pids", value)

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @nielsen_id3_behavior.setter
    def nielsen_id3_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nielsen_id3_behavior", value)

    @property
    @pulumi.getter(name="nullPacketBitrate")
    def null_packet_bitrate(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "null_packet_bitrate")

    @null_packet_bitrate.setter
    def null_packet_bitrate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "null_packet_bitrate", value)

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pat_interval")

    @pat_interval.setter
    def pat_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pat_interval", value)

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_control")

    @pcr_control.setter
    def pcr_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_control", value)

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pcr_period")

    @pcr_period.setter
    def pcr_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pcr_period", value)

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pcr_pid")

    @pcr_pid.setter
    def pcr_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pcr_pid", value)

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pmt_interval")

    @pmt_interval.setter
    def pmt_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pmt_interval", value)

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pmt_pid")

    @pmt_pid.setter
    def pmt_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pmt_pid", value)

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "program_num")

    @program_num.setter
    def program_num(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "program_num", value)

    @property
    @pulumi.getter(name="rateMode")
    def rate_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rate_mode")

    @rate_mode.setter
    def rate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_mode", value)

    @property
    @pulumi.getter(name="scte27Pids")
    def scte27_pids(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte27_pids")

    @scte27_pids.setter
    def scte27_pids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte27_pids", value)

    @property
    @pulumi.getter(name="scte35Control")
    def scte35_control(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte35_control")

    @scte35_control.setter
    def scte35_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_control", value)

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[pulumi.Input[str]]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @scte35_pid.setter
    def scte35_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_pid", value)

    @property
    @pulumi.getter(name="segmentationMarkers")
    def segmentation_markers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segmentation_markers")

    @segmentation_markers.setter
    def segmentation_markers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segmentation_markers", value)

    @property
    @pulumi.getter(name="segmentationStyle")
    def segmentation_style(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segmentation_style")

    @segmentation_style.setter
    def segmentation_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segmentation_style", value)

    @property
    @pulumi.getter(name="segmentationTime")
    def segmentation_time(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "segmentation_time")

    @segmentation_time.setter
    def segmentation_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "segmentation_time", value)

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_behavior")

    @timed_metadata_behavior.setter
    def timed_metadata_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_behavior", value)

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timed_metadata_pid")

    @timed_metadata_pid.setter
    def timed_metadata_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timed_metadata_pid", value)

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "transport_stream_id")

    @transport_stream_id.setter
    def transport_stream_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transport_stream_id", value)

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "video_pid")

    @video_pid.setter
    def video_pid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "video_pid", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[int],
                 network_name: pulumi.Input[str],
                 rep_interval: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            network_name=network_name,
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[pulumi.Input[int]] = None,
             network_name: Optional[pulumi.Input[str]] = None,
             rep_interval: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if network_name is None and 'networkName' in kwargs:
            network_name = kwargs['networkName']
        if network_name is None:
            raise TypeError("Missing 'network_name' argument")
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        _setter("network_id", network_id)
        _setter("network_name", network_name)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs:
    def __init__(__self__, *,
                 output_sdt: Optional[pulumi.Input[str]] = None,
                 rep_interval: Optional[pulumi.Input[int]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 service_provider_name: Optional[pulumi.Input[str]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_sdt=output_sdt,
            rep_interval=rep_interval,
            service_name=service_name,
            service_provider_name=service_provider_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_sdt: Optional[pulumi.Input[str]] = None,
             rep_interval: Optional[pulumi.Input[int]] = None,
             service_name: Optional[pulumi.Input[str]] = None,
             service_provider_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_sdt is None and 'outputSdt' in kwargs:
            output_sdt = kwargs['outputSdt']
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_provider_name is None and 'serviceProviderName' in kwargs:
            service_provider_name = kwargs['serviceProviderName']

        if output_sdt is not None:
            _setter("output_sdt", output_sdt)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)
        if service_name is not None:
            _setter("service_name", service_name)
        if service_provider_name is not None:
            _setter("service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="outputSdt")
    def output_sdt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "output_sdt")

    @output_sdt.setter
    def output_sdt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_sdt", value)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_provider_name")

    @service_provider_name.setter
    def service_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_provider_name", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs:
    def __init__(__self__, *,
                 rep_interval: Optional[pulumi.Input[int]] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rep_interval: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rep_interval")

    @rep_interval.setter
    def rep_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rep_interval", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs:
    def __init__(__self__, *,
                 destination_ref_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> pulumi.Input[str]:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")

    @destination_ref_id.setter
    def destination_ref_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_ref_id", value)


@pulumi.input_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs:
    def __init__(__self__, *,
                 column_depth: Optional[pulumi.Input[int]] = None,
                 include_fec: Optional[pulumi.Input[str]] = None,
                 row_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] column_depth: The height of the FEC protection matrix.
        :param pulumi.Input[str] include_fec: Enables column only or column and row based FEC.
        :param pulumi.Input[int] row_length: The width of the FEC protection matrix.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_depth=column_depth,
            include_fec=include_fec,
            row_length=row_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_depth: Optional[pulumi.Input[int]] = None,
             include_fec: Optional[pulumi.Input[str]] = None,
             row_length: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_depth is None and 'columnDepth' in kwargs:
            column_depth = kwargs['columnDepth']
        if include_fec is None and 'includeFec' in kwargs:
            include_fec = kwargs['includeFec']
        if row_length is None and 'rowLength' in kwargs:
            row_length = kwargs['rowLength']

        if column_depth is not None:
            _setter("column_depth", column_depth)
        if include_fec is not None:
            _setter("include_fec", include_fec)
        if row_length is not None:
            _setter("row_length", row_length)

    @property
    @pulumi.getter(name="columnDepth")
    def column_depth(self) -> Optional[pulumi.Input[int]]:
        """
        The height of the FEC protection matrix.
        """
        return pulumi.get(self, "column_depth")

    @column_depth.setter
    def column_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "column_depth", value)

    @property
    @pulumi.getter(name="includeFec")
    def include_fec(self) -> Optional[pulumi.Input[str]]:
        """
        Enables column only or column and row based FEC.
        """
        return pulumi.get(self, "include_fec")

    @include_fec.setter
    def include_fec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_fec", value)

    @property
    @pulumi.getter(name="rowLength")
    def row_length(self) -> Optional[pulumi.Input[int]]:
        """
        The width of the FEC protection matrix.
        """
        return pulumi.get(self, "row_length")

    @row_length.setter
    def row_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "row_length", value)


@pulumi.input_type
class ChannelEncoderSettingsTimecodeConfigArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 sync_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] source: The source for the timecode that will be associated with the events outputs.
        :param pulumi.Input[int] sync_threshold: Threshold in frames beyond which output timecode is resynchronized to the input timecode.
        """
        ChannelEncoderSettingsTimecodeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            sync_threshold=sync_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: Optional[pulumi.Input[str]] = None,
             sync_threshold: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source is None:
            raise TypeError("Missing 'source' argument")
        if sync_threshold is None and 'syncThreshold' in kwargs:
            sync_threshold = kwargs['syncThreshold']

        _setter("source", source)
        if sync_threshold is not None:
            _setter("sync_threshold", sync_threshold)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source for the timecode that will be associated with the events outputs.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="syncThreshold")
    def sync_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Threshold in frames beyond which output timecode is resynchronized to the input timecode.
        """
        return pulumi.get(self, "sync_threshold")

    @sync_threshold.setter
    def sync_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_threshold", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 codec_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs']] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 respond_to_afd: Optional[pulumi.Input[str]] = None,
                 scaling_behavior: Optional[pulumi.Input[str]] = None,
                 sharpness: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of the video description.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs'] codec_settings: The video codec settings. See Video Codec Settings for more details.
        :param pulumi.Input[int] height: Output video height in pixels.
        :param pulumi.Input[str] respond_to_afd: Indicate how to respond to the AFD values that might be in the input video.
        :param pulumi.Input[str] scaling_behavior: Behavior on how to scale.
        :param pulumi.Input[int] sharpness: Changes the strength of the anti-alias filter used for scaling.
        :param pulumi.Input[int] width: Output video width in pixels.
        """
        ChannelEncoderSettingsVideoDescriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            codec_settings=codec_settings,
            height=height,
            respond_to_afd=respond_to_afd,
            scaling_behavior=scaling_behavior,
            sharpness=sharpness,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             codec_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs']] = None,
             height: Optional[pulumi.Input[int]] = None,
             respond_to_afd: Optional[pulumi.Input[str]] = None,
             scaling_behavior: Optional[pulumi.Input[str]] = None,
             sharpness: Optional[pulumi.Input[int]] = None,
             width: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if codec_settings is None and 'codecSettings' in kwargs:
            codec_settings = kwargs['codecSettings']
        if respond_to_afd is None and 'respondToAfd' in kwargs:
            respond_to_afd = kwargs['respondToAfd']
        if scaling_behavior is None and 'scalingBehavior' in kwargs:
            scaling_behavior = kwargs['scalingBehavior']

        _setter("name", name)
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if height is not None:
            _setter("height", height)
        if respond_to_afd is not None:
            _setter("respond_to_afd", respond_to_afd)
        if scaling_behavior is not None:
            _setter("scaling_behavior", scaling_behavior)
        if sharpness is not None:
            _setter("sharpness", sharpness)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the video description.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs']]:
        """
        The video codec settings. See Video Codec Settings for more details.
        """
        return pulumi.get(self, "codec_settings")

    @codec_settings.setter
    def codec_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs']]):
        pulumi.set(self, "codec_settings", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        Output video height in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="respondToAfd")
    def respond_to_afd(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate how to respond to the AFD values that might be in the input video.
        """
        return pulumi.get(self, "respond_to_afd")

    @respond_to_afd.setter
    def respond_to_afd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "respond_to_afd", value)

    @property
    @pulumi.getter(name="scalingBehavior")
    def scaling_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Behavior on how to scale.
        """
        return pulumi.get(self, "scaling_behavior")

    @scaling_behavior.setter
    def scaling_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scaling_behavior", value)

    @property
    @pulumi.getter
    def sharpness(self) -> Optional[pulumi.Input[int]]:
        """
        Changes the strength of the anti-alias filter used for scaling.
        """
        return pulumi.get(self, "sharpness")

    @sharpness.setter
    def sharpness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sharpness", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Output video width in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs:
    def __init__(__self__, *,
                 frame_capture_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs']] = None,
                 h264_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs']] = None,
                 h265_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs'] frame_capture_settings: Frame capture settings. See Frame Capture Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs'] h264_settings: H264 settings. See H264 Settings for more details.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_settings=frame_capture_settings,
            h264_settings=h264_settings,
            h265_settings=h265_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs']] = None,
             h264_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs']] = None,
             h265_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if frame_capture_settings is None and 'frameCaptureSettings' in kwargs:
            frame_capture_settings = kwargs['frameCaptureSettings']
        if h264_settings is None and 'h264Settings' in kwargs:
            h264_settings = kwargs['h264Settings']
        if h265_settings is None and 'h265Settings' in kwargs:
            h265_settings = kwargs['h265Settings']

        if frame_capture_settings is not None:
            _setter("frame_capture_settings", frame_capture_settings)
        if h264_settings is not None:
            _setter("h264_settings", h264_settings)
        if h265_settings is not None:
            _setter("h265_settings", h265_settings)

    @property
    @pulumi.getter(name="frameCaptureSettings")
    def frame_capture_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs']]:
        """
        Frame capture settings. See Frame Capture Settings for more details.
        """
        return pulumi.get(self, "frame_capture_settings")

    @frame_capture_settings.setter
    def frame_capture_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs']]):
        pulumi.set(self, "frame_capture_settings", value)

    @property
    @pulumi.getter(name="h264Settings")
    def h264_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs']]:
        """
        H264 settings. See H264 Settings for more details.
        """
        return pulumi.get(self, "h264_settings")

    @h264_settings.setter
    def h264_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs']]):
        pulumi.set(self, "h264_settings", value)

    @property
    @pulumi.getter(name="h265Settings")
    def h265_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs']]:
        return pulumi.get(self, "h265_settings")

    @h265_settings.setter
    def h265_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs']]):
        pulumi.set(self, "h265_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs:
    def __init__(__self__, *,
                 capture_interval: Optional[pulumi.Input[int]] = None,
                 capture_interval_units: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] capture_interval: The frequency at which to capture frames for inclusion in the output.
        :param pulumi.Input[str] capture_interval_units: Unit for the frame capture interval.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capture_interval=capture_interval,
            capture_interval_units=capture_interval_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capture_interval: Optional[pulumi.Input[int]] = None,
             capture_interval_units: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capture_interval is None and 'captureInterval' in kwargs:
            capture_interval = kwargs['captureInterval']
        if capture_interval_units is None and 'captureIntervalUnits' in kwargs:
            capture_interval_units = kwargs['captureIntervalUnits']

        if capture_interval is not None:
            _setter("capture_interval", capture_interval)
        if capture_interval_units is not None:
            _setter("capture_interval_units", capture_interval_units)

    @property
    @pulumi.getter(name="captureInterval")
    def capture_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The frequency at which to capture frames for inclusion in the output.
        """
        return pulumi.get(self, "capture_interval")

    @capture_interval.setter
    def capture_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capture_interval", value)

    @property
    @pulumi.getter(name="captureIntervalUnits")
    def capture_interval_units(self) -> Optional[pulumi.Input[str]]:
        """
        Unit for the frame capture interval.
        """
        return pulumi.get(self, "capture_interval_units")

    @capture_interval_units.setter
    def capture_interval_units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capture_interval_units", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs:
    def __init__(__self__, *,
                 adaptive_quantization: Optional[pulumi.Input[str]] = None,
                 afd_signaling: Optional[pulumi.Input[str]] = None,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 buf_fill_pct: Optional[pulumi.Input[int]] = None,
                 buf_size: Optional[pulumi.Input[int]] = None,
                 color_metadata: Optional[pulumi.Input[str]] = None,
                 entropy_encoding: Optional[pulumi.Input[str]] = None,
                 filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs']] = None,
                 fixed_afd: Optional[pulumi.Input[str]] = None,
                 flicker_aq: Optional[pulumi.Input[str]] = None,
                 force_field_pictures: Optional[pulumi.Input[str]] = None,
                 framerate_control: Optional[pulumi.Input[str]] = None,
                 framerate_denominator: Optional[pulumi.Input[int]] = None,
                 framerate_numerator: Optional[pulumi.Input[int]] = None,
                 gop_b_reference: Optional[pulumi.Input[str]] = None,
                 gop_closed_cadence: Optional[pulumi.Input[int]] = None,
                 gop_num_b_frames: Optional[pulumi.Input[int]] = None,
                 gop_size: Optional[pulumi.Input[float]] = None,
                 gop_size_units: Optional[pulumi.Input[str]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 look_ahead_rate_control: Optional[pulumi.Input[str]] = None,
                 max_bitrate: Optional[pulumi.Input[int]] = None,
                 min_i_interval: Optional[pulumi.Input[int]] = None,
                 num_ref_frames: Optional[pulumi.Input[int]] = None,
                 par_control: Optional[pulumi.Input[str]] = None,
                 par_denominator: Optional[pulumi.Input[int]] = None,
                 par_numerator: Optional[pulumi.Input[int]] = None,
                 profile: Optional[pulumi.Input[str]] = None,
                 quality_level: Optional[pulumi.Input[str]] = None,
                 qvbr_quality_level: Optional[pulumi.Input[int]] = None,
                 rate_control_mode: Optional[pulumi.Input[str]] = None,
                 scan_type: Optional[pulumi.Input[str]] = None,
                 scene_change_detect: Optional[pulumi.Input[str]] = None,
                 slices: Optional[pulumi.Input[int]] = None,
                 softness: Optional[pulumi.Input[int]] = None,
                 spatial_aq: Optional[pulumi.Input[str]] = None,
                 subgop_length: Optional[pulumi.Input[str]] = None,
                 syntax: Optional[pulumi.Input[str]] = None,
                 temporal_aq: Optional[pulumi.Input[str]] = None,
                 timecode_insertion: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] adaptive_quantization: Enables or disables adaptive quantization.
        :param pulumi.Input[str] afd_signaling: Indicates that AFD values will be written into the output stream.
        :param pulumi.Input[int] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[int] buf_size: Size of buffer in bits.
        :param pulumi.Input[str] color_metadata: Includes color space metadata in the output.
        :param pulumi.Input[str] entropy_encoding: Entropy encoding mode.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs'] filter_settings: Filters to apply to an encode. See H265 Filter Settings for more details.
        :param pulumi.Input[str] fixed_afd: Four bit AFD value to write on all frames of video in the output stream.
        :param pulumi.Input[str] force_field_pictures: Controls whether coding is performed on a field basis or on a frame basis.
        :param pulumi.Input[str] framerate_control: Indicates how the output video frame rate is specified.
        :param pulumi.Input[int] framerate_denominator: Framerate denominator.
        :param pulumi.Input[int] framerate_numerator: Framerate numerator.
        :param pulumi.Input[str] gop_b_reference: GOP-B reference.
        :param pulumi.Input[int] gop_closed_cadence: Frequency of closed GOPs.
        :param pulumi.Input[int] gop_num_b_frames: Number of B-frames between reference frames.
        :param pulumi.Input[float] gop_size: GOP size in units of either frames of seconds per `gop_size_units`.
        :param pulumi.Input[str] gop_size_units: Indicates if the `gop_size` is specified in frames or seconds.
        :param pulumi.Input[str] level: H265 level.
        :param pulumi.Input[str] look_ahead_rate_control: Amount of lookahead.
        :param pulumi.Input[int] max_bitrate: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        :param pulumi.Input[int] num_ref_frames: Number of reference frames to use.
        :param pulumi.Input[str] par_control: Indicates how the output pixel aspect ratio is specified.
        :param pulumi.Input[int] par_denominator: Pixel Aspect Ratio denominator.
        :param pulumi.Input[int] par_numerator: Pixel Aspect Ratio numerator.
        :param pulumi.Input[str] profile: AAC profile.
        :param pulumi.Input[str] quality_level: Quality level.
        :param pulumi.Input[int] qvbr_quality_level: Controls the target quality for the video encode.
        :param pulumi.Input[str] rate_control_mode: The rate control mode.
        :param pulumi.Input[str] scan_type: Sets the scan type of the output.
        :param pulumi.Input[str] scene_change_detect: Scene change detection.
        :param pulumi.Input[int] slices: Number of slices per picture.
        :param pulumi.Input[int] softness: Softness.
        :param pulumi.Input[str] spatial_aq: Makes adjustments within each frame based on spatial variation of content complexity.
        :param pulumi.Input[str] subgop_length: Subgop length.
        :param pulumi.Input[str] syntax: Produces a bitstream compliant with SMPTE RP-2027.
        :param pulumi.Input[str] temporal_aq: Makes adjustments within each frame based on temporal variation of content complexity.
        :param pulumi.Input[str] timecode_insertion: Determines how timecodes should be inserted into the video elementary stream.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            bitrate=bitrate,
            buf_fill_pct=buf_fill_pct,
            buf_size=buf_size,
            color_metadata=color_metadata,
            entropy_encoding=entropy_encoding,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            force_field_pictures=force_field_pictures,
            framerate_control=framerate_control,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            gop_b_reference=gop_b_reference,
            gop_closed_cadence=gop_closed_cadence,
            gop_num_b_frames=gop_num_b_frames,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            num_ref_frames=num_ref_frames,
            par_control=par_control,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            quality_level=quality_level,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            softness=softness,
            spatial_aq=spatial_aq,
            subgop_length=subgop_length,
            syntax=syntax,
            temporal_aq=temporal_aq,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_quantization: Optional[pulumi.Input[str]] = None,
             afd_signaling: Optional[pulumi.Input[str]] = None,
             bitrate: Optional[pulumi.Input[int]] = None,
             buf_fill_pct: Optional[pulumi.Input[int]] = None,
             buf_size: Optional[pulumi.Input[int]] = None,
             color_metadata: Optional[pulumi.Input[str]] = None,
             entropy_encoding: Optional[pulumi.Input[str]] = None,
             filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs']] = None,
             fixed_afd: Optional[pulumi.Input[str]] = None,
             flicker_aq: Optional[pulumi.Input[str]] = None,
             force_field_pictures: Optional[pulumi.Input[str]] = None,
             framerate_control: Optional[pulumi.Input[str]] = None,
             framerate_denominator: Optional[pulumi.Input[int]] = None,
             framerate_numerator: Optional[pulumi.Input[int]] = None,
             gop_b_reference: Optional[pulumi.Input[str]] = None,
             gop_closed_cadence: Optional[pulumi.Input[int]] = None,
             gop_num_b_frames: Optional[pulumi.Input[int]] = None,
             gop_size: Optional[pulumi.Input[float]] = None,
             gop_size_units: Optional[pulumi.Input[str]] = None,
             level: Optional[pulumi.Input[str]] = None,
             look_ahead_rate_control: Optional[pulumi.Input[str]] = None,
             max_bitrate: Optional[pulumi.Input[int]] = None,
             min_i_interval: Optional[pulumi.Input[int]] = None,
             num_ref_frames: Optional[pulumi.Input[int]] = None,
             par_control: Optional[pulumi.Input[str]] = None,
             par_denominator: Optional[pulumi.Input[int]] = None,
             par_numerator: Optional[pulumi.Input[int]] = None,
             profile: Optional[pulumi.Input[str]] = None,
             quality_level: Optional[pulumi.Input[str]] = None,
             qvbr_quality_level: Optional[pulumi.Input[int]] = None,
             rate_control_mode: Optional[pulumi.Input[str]] = None,
             scan_type: Optional[pulumi.Input[str]] = None,
             scene_change_detect: Optional[pulumi.Input[str]] = None,
             slices: Optional[pulumi.Input[int]] = None,
             softness: Optional[pulumi.Input[int]] = None,
             spatial_aq: Optional[pulumi.Input[str]] = None,
             subgop_length: Optional[pulumi.Input[str]] = None,
             syntax: Optional[pulumi.Input[str]] = None,
             temporal_aq: Optional[pulumi.Input[str]] = None,
             timecode_insertion: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if adaptive_quantization is None and 'adaptiveQuantization' in kwargs:
            adaptive_quantization = kwargs['adaptiveQuantization']
        if afd_signaling is None and 'afdSignaling' in kwargs:
            afd_signaling = kwargs['afdSignaling']
        if buf_fill_pct is None and 'bufFillPct' in kwargs:
            buf_fill_pct = kwargs['bufFillPct']
        if buf_size is None and 'bufSize' in kwargs:
            buf_size = kwargs['bufSize']
        if color_metadata is None and 'colorMetadata' in kwargs:
            color_metadata = kwargs['colorMetadata']
        if entropy_encoding is None and 'entropyEncoding' in kwargs:
            entropy_encoding = kwargs['entropyEncoding']
        if filter_settings is None and 'filterSettings' in kwargs:
            filter_settings = kwargs['filterSettings']
        if fixed_afd is None and 'fixedAfd' in kwargs:
            fixed_afd = kwargs['fixedAfd']
        if flicker_aq is None and 'flickerAq' in kwargs:
            flicker_aq = kwargs['flickerAq']
        if force_field_pictures is None and 'forceFieldPictures' in kwargs:
            force_field_pictures = kwargs['forceFieldPictures']
        if framerate_control is None and 'framerateControl' in kwargs:
            framerate_control = kwargs['framerateControl']
        if framerate_denominator is None and 'framerateDenominator' in kwargs:
            framerate_denominator = kwargs['framerateDenominator']
        if framerate_numerator is None and 'framerateNumerator' in kwargs:
            framerate_numerator = kwargs['framerateNumerator']
        if gop_b_reference is None and 'gopBReference' in kwargs:
            gop_b_reference = kwargs['gopBReference']
        if gop_closed_cadence is None and 'gopClosedCadence' in kwargs:
            gop_closed_cadence = kwargs['gopClosedCadence']
        if gop_num_b_frames is None and 'gopNumBFrames' in kwargs:
            gop_num_b_frames = kwargs['gopNumBFrames']
        if gop_size is None and 'gopSize' in kwargs:
            gop_size = kwargs['gopSize']
        if gop_size_units is None and 'gopSizeUnits' in kwargs:
            gop_size_units = kwargs['gopSizeUnits']
        if look_ahead_rate_control is None and 'lookAheadRateControl' in kwargs:
            look_ahead_rate_control = kwargs['lookAheadRateControl']
        if max_bitrate is None and 'maxBitrate' in kwargs:
            max_bitrate = kwargs['maxBitrate']
        if min_i_interval is None and 'minIInterval' in kwargs:
            min_i_interval = kwargs['minIInterval']
        if num_ref_frames is None and 'numRefFrames' in kwargs:
            num_ref_frames = kwargs['numRefFrames']
        if par_control is None and 'parControl' in kwargs:
            par_control = kwargs['parControl']
        if par_denominator is None and 'parDenominator' in kwargs:
            par_denominator = kwargs['parDenominator']
        if par_numerator is None and 'parNumerator' in kwargs:
            par_numerator = kwargs['parNumerator']
        if quality_level is None and 'qualityLevel' in kwargs:
            quality_level = kwargs['qualityLevel']
        if qvbr_quality_level is None and 'qvbrQualityLevel' in kwargs:
            qvbr_quality_level = kwargs['qvbrQualityLevel']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if scan_type is None and 'scanType' in kwargs:
            scan_type = kwargs['scanType']
        if scene_change_detect is None and 'sceneChangeDetect' in kwargs:
            scene_change_detect = kwargs['sceneChangeDetect']
        if spatial_aq is None and 'spatialAq' in kwargs:
            spatial_aq = kwargs['spatialAq']
        if subgop_length is None and 'subgopLength' in kwargs:
            subgop_length = kwargs['subgopLength']
        if temporal_aq is None and 'temporalAq' in kwargs:
            temporal_aq = kwargs['temporalAq']
        if timecode_insertion is None and 'timecodeInsertion' in kwargs:
            timecode_insertion = kwargs['timecodeInsertion']

        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buf_fill_pct is not None:
            _setter("buf_fill_pct", buf_fill_pct)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if entropy_encoding is not None:
            _setter("entropy_encoding", entropy_encoding)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if force_field_pictures is not None:
            _setter("force_field_pictures", force_field_pictures)
        if framerate_control is not None:
            _setter("framerate_control", framerate_control)
        if framerate_denominator is not None:
            _setter("framerate_denominator", framerate_denominator)
        if framerate_numerator is not None:
            _setter("framerate_numerator", framerate_numerator)
        if gop_b_reference is not None:
            _setter("gop_b_reference", gop_b_reference)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_num_b_frames is not None:
            _setter("gop_num_b_frames", gop_num_b_frames)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if num_ref_frames is not None:
            _setter("num_ref_frames", num_ref_frames)
        if par_control is not None:
            _setter("par_control", par_control)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if quality_level is not None:
            _setter("quality_level", quality_level)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if softness is not None:
            _setter("softness", softness)
        if spatial_aq is not None:
            _setter("spatial_aq", spatial_aq)
        if subgop_length is not None:
            _setter("subgop_length", subgop_length)
        if syntax is not None:
            _setter("syntax", syntax)
        if temporal_aq is not None:
            _setter("temporal_aq", temporal_aq)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[pulumi.Input[str]]:
        """
        Enables or disables adaptive quantization.
        """
        return pulumi.get(self, "adaptive_quantization")

    @adaptive_quantization.setter
    def adaptive_quantization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adaptive_quantization", value)

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that AFD values will be written into the output stream.
        """
        return pulumi.get(self, "afd_signaling")

    @afd_signaling.setter
    def afd_signaling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "afd_signaling", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="bufFillPct")
    def buf_fill_pct(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buf_fill_pct")

    @buf_fill_pct.setter
    def buf_fill_pct(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buf_fill_pct", value)

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of buffer in bits.
        """
        return pulumi.get(self, "buf_size")

    @buf_size.setter
    def buf_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buf_size", value)

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Includes color space metadata in the output.
        """
        return pulumi.get(self, "color_metadata")

    @color_metadata.setter
    def color_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_metadata", value)

    @property
    @pulumi.getter(name="entropyEncoding")
    def entropy_encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Entropy encoding mode.
        """
        return pulumi.get(self, "entropy_encoding")

    @entropy_encoding.setter
    def entropy_encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entropy_encoding", value)

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs']]:
        """
        Filters to apply to an encode. See H265 Filter Settings for more details.
        """
        return pulumi.get(self, "filter_settings")

    @filter_settings.setter
    def filter_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs']]):
        pulumi.set(self, "filter_settings", value)

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[pulumi.Input[str]]:
        """
        Four bit AFD value to write on all frames of video in the output stream.
        """
        return pulumi.get(self, "fixed_afd")

    @fixed_afd.setter
    def fixed_afd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fixed_afd", value)

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flicker_aq")

    @flicker_aq.setter
    def flicker_aq(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flicker_aq", value)

    @property
    @pulumi.getter(name="forceFieldPictures")
    def force_field_pictures(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether coding is performed on a field basis or on a frame basis.
        """
        return pulumi.get(self, "force_field_pictures")

    @force_field_pictures.setter
    def force_field_pictures(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "force_field_pictures", value)

    @property
    @pulumi.getter(name="framerateControl")
    def framerate_control(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how the output video frame rate is specified.
        """
        return pulumi.get(self, "framerate_control")

    @framerate_control.setter
    def framerate_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "framerate_control", value)

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> Optional[pulumi.Input[int]]:
        """
        Framerate denominator.
        """
        return pulumi.get(self, "framerate_denominator")

    @framerate_denominator.setter
    def framerate_denominator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "framerate_denominator", value)

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> Optional[pulumi.Input[int]]:
        """
        Framerate numerator.
        """
        return pulumi.get(self, "framerate_numerator")

    @framerate_numerator.setter
    def framerate_numerator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "framerate_numerator", value)

    @property
    @pulumi.getter(name="gopBReference")
    def gop_b_reference(self) -> Optional[pulumi.Input[str]]:
        """
        GOP-B reference.
        """
        return pulumi.get(self, "gop_b_reference")

    @gop_b_reference.setter
    def gop_b_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gop_b_reference", value)

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency of closed GOPs.
        """
        return pulumi.get(self, "gop_closed_cadence")

    @gop_closed_cadence.setter
    def gop_closed_cadence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop_closed_cadence", value)

    @property
    @pulumi.getter(name="gopNumBFrames")
    def gop_num_b_frames(self) -> Optional[pulumi.Input[int]]:
        """
        Number of B-frames between reference frames.
        """
        return pulumi.get(self, "gop_num_b_frames")

    @gop_num_b_frames.setter
    def gop_num_b_frames(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop_num_b_frames", value)

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[pulumi.Input[float]]:
        """
        GOP size in units of either frames of seconds per `gop_size_units`.
        """
        return pulumi.get(self, "gop_size")

    @gop_size.setter
    def gop_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gop_size", value)

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates if the `gop_size` is specified in frames or seconds.
        """
        return pulumi.get(self, "gop_size_units")

    @gop_size_units.setter
    def gop_size_units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gop_size_units", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        H265 level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of lookahead.
        """
        return pulumi.get(self, "look_ahead_rate_control")

    @look_ahead_rate_control.setter
    def look_ahead_rate_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "look_ahead_rate_control", value)

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        """
        return pulumi.get(self, "max_bitrate")

    @max_bitrate.setter
    def max_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bitrate", value)

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_i_interval")

    @min_i_interval.setter
    def min_i_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_i_interval", value)

    @property
    @pulumi.getter(name="numRefFrames")
    def num_ref_frames(self) -> Optional[pulumi.Input[int]]:
        """
        Number of reference frames to use.
        """
        return pulumi.get(self, "num_ref_frames")

    @num_ref_frames.setter
    def num_ref_frames(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_ref_frames", value)

    @property
    @pulumi.getter(name="parControl")
    def par_control(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how the output pixel aspect ratio is specified.
        """
        return pulumi.get(self, "par_control")

    @par_control.setter
    def par_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "par_control", value)

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[pulumi.Input[int]]:
        """
        Pixel Aspect Ratio denominator.
        """
        return pulumi.get(self, "par_denominator")

    @par_denominator.setter
    def par_denominator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "par_denominator", value)

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[pulumi.Input[int]]:
        """
        Pixel Aspect Ratio numerator.
        """
        return pulumi.get(self, "par_numerator")

    @par_numerator.setter
    def par_numerator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "par_numerator", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter(name="qualityLevel")
    def quality_level(self) -> Optional[pulumi.Input[str]]:
        """
        Quality level.
        """
        return pulumi.get(self, "quality_level")

    @quality_level.setter
    def quality_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quality_level", value)

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[pulumi.Input[int]]:
        """
        Controls the target quality for the video encode.
        """
        return pulumi.get(self, "qvbr_quality_level")

    @qvbr_quality_level.setter
    def qvbr_quality_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qvbr_quality_level", value)

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @rate_control_mode.setter
    def rate_control_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_control_mode", value)

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the scan type of the output.
        """
        return pulumi.get(self, "scan_type")

    @scan_type.setter
    def scan_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_type", value)

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[pulumi.Input[str]]:
        """
        Scene change detection.
        """
        return pulumi.get(self, "scene_change_detect")

    @scene_change_detect.setter
    def scene_change_detect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scene_change_detect", value)

    @property
    @pulumi.getter
    def slices(self) -> Optional[pulumi.Input[int]]:
        """
        Number of slices per picture.
        """
        return pulumi.get(self, "slices")

    @slices.setter
    def slices(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slices", value)

    @property
    @pulumi.getter
    def softness(self) -> Optional[pulumi.Input[int]]:
        """
        Softness.
        """
        return pulumi.get(self, "softness")

    @softness.setter
    def softness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "softness", value)

    @property
    @pulumi.getter(name="spatialAq")
    def spatial_aq(self) -> Optional[pulumi.Input[str]]:
        """
        Makes adjustments within each frame based on spatial variation of content complexity.
        """
        return pulumi.get(self, "spatial_aq")

    @spatial_aq.setter
    def spatial_aq(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spatial_aq", value)

    @property
    @pulumi.getter(name="subgopLength")
    def subgop_length(self) -> Optional[pulumi.Input[str]]:
        """
        Subgop length.
        """
        return pulumi.get(self, "subgop_length")

    @subgop_length.setter
    def subgop_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subgop_length", value)

    @property
    @pulumi.getter
    def syntax(self) -> Optional[pulumi.Input[str]]:
        """
        Produces a bitstream compliant with SMPTE RP-2027.
        """
        return pulumi.get(self, "syntax")

    @syntax.setter
    def syntax(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syntax", value)

    @property
    @pulumi.getter(name="temporalAq")
    def temporal_aq(self) -> Optional[pulumi.Input[str]]:
        """
        Makes adjustments within each frame based on temporal variation of content complexity.
        """
        return pulumi.get(self, "temporal_aq")

    @temporal_aq.setter
    def temporal_aq(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "temporal_aq", value)

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[pulumi.Input[str]]:
        """
        Determines how timecodes should be inserted into the video elementary stream.
        """
        return pulumi.get(self, "timecode_insertion")

    @timecode_insertion.setter
    def timecode_insertion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timecode_insertion", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs:
    def __init__(__self__, *,
                 temporal_filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs'] temporal_filter_settings: Temporal filter settings. See Temporal Filter Settings
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if temporal_filter_settings is None and 'temporalFilterSettings' in kwargs:
            temporal_filter_settings = kwargs['temporalFilterSettings']

        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs']]:
        """
        Temporal filter settings. See Temporal Filter Settings
        """
        return pulumi.get(self, "temporal_filter_settings")

    @temporal_filter_settings.setter
    def temporal_filter_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs']]):
        pulumi.set(self, "temporal_filter_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs:
    def __init__(__self__, *,
                 post_filter_sharpening: Optional[pulumi.Input[str]] = None,
                 strength: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] post_filter_sharpening: Post filter sharpening.
        :param pulumi.Input[str] strength: Filter strength.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_filter_sharpening=post_filter_sharpening,
            strength=strength,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_filter_sharpening: Optional[pulumi.Input[str]] = None,
             strength: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if post_filter_sharpening is None and 'postFilterSharpening' in kwargs:
            post_filter_sharpening = kwargs['postFilterSharpening']

        if post_filter_sharpening is not None:
            _setter("post_filter_sharpening", post_filter_sharpening)
        if strength is not None:
            _setter("strength", strength)

    @property
    @pulumi.getter(name="postFilterSharpening")
    def post_filter_sharpening(self) -> Optional[pulumi.Input[str]]:
        """
        Post filter sharpening.
        """
        return pulumi.get(self, "post_filter_sharpening")

    @post_filter_sharpening.setter
    def post_filter_sharpening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_filter_sharpening", value)

    @property
    @pulumi.getter
    def strength(self) -> Optional[pulumi.Input[str]]:
        """
        Filter strength.
        """
        return pulumi.get(self, "strength")

    @strength.setter
    def strength(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strength", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 framerate_denominator: pulumi.Input[int],
                 framerate_numerator: pulumi.Input[int],
                 adaptive_quantization: Optional[pulumi.Input[str]] = None,
                 afd_signaling: Optional[pulumi.Input[str]] = None,
                 alternative_transfer_function: Optional[pulumi.Input[str]] = None,
                 buf_size: Optional[pulumi.Input[int]] = None,
                 color_metadata: Optional[pulumi.Input[str]] = None,
                 color_space_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs']] = None,
                 filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs']] = None,
                 fixed_afd: Optional[pulumi.Input[str]] = None,
                 flicker_aq: Optional[pulumi.Input[str]] = None,
                 gop_closed_cadence: Optional[pulumi.Input[int]] = None,
                 gop_size: Optional[pulumi.Input[float]] = None,
                 gop_size_units: Optional[pulumi.Input[str]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 look_ahead_rate_control: Optional[pulumi.Input[str]] = None,
                 max_bitrate: Optional[pulumi.Input[int]] = None,
                 min_i_interval: Optional[pulumi.Input[int]] = None,
                 par_denominator: Optional[pulumi.Input[int]] = None,
                 par_numerator: Optional[pulumi.Input[int]] = None,
                 profile: Optional[pulumi.Input[str]] = None,
                 qvbr_quality_level: Optional[pulumi.Input[int]] = None,
                 rate_control_mode: Optional[pulumi.Input[str]] = None,
                 scan_type: Optional[pulumi.Input[str]] = None,
                 scene_change_detect: Optional[pulumi.Input[str]] = None,
                 slices: Optional[pulumi.Input[int]] = None,
                 tier: Optional[pulumi.Input[str]] = None,
                 timecode_burnin_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs']] = None,
                 timecode_insertion: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bitrate: Average bitrate in bits/second.
        :param pulumi.Input[int] framerate_denominator: Framerate denominator.
        :param pulumi.Input[int] framerate_numerator: Framerate numerator.
        :param pulumi.Input[str] adaptive_quantization: Enables or disables adaptive quantization.
        :param pulumi.Input[str] afd_signaling: Indicates that AFD values will be written into the output stream.
        :param pulumi.Input[str] alternative_transfer_function: Whether or not EML should insert an Alternative Transfer Function SEI message.
        :param pulumi.Input[int] buf_size: Size of buffer in bits.
        :param pulumi.Input[str] color_metadata: Includes color space metadata in the output.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs'] color_space_settings: Define the color metadata for the output. H265 Color Space Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs'] filter_settings: Filters to apply to an encode. See H265 Filter Settings for more details.
        :param pulumi.Input[str] fixed_afd: Four bit AFD value to write on all frames of video in the output stream.
        :param pulumi.Input[int] gop_closed_cadence: Frequency of closed GOPs.
        :param pulumi.Input[float] gop_size: GOP size in units of either frames of seconds per `gop_size_units`.
        :param pulumi.Input[str] gop_size_units: Indicates if the `gop_size` is specified in frames or seconds.
        :param pulumi.Input[str] level: H265 level.
        :param pulumi.Input[str] look_ahead_rate_control: Amount of lookahead.
        :param pulumi.Input[int] max_bitrate: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        :param pulumi.Input[int] par_denominator: Pixel Aspect Ratio denominator.
        :param pulumi.Input[int] par_numerator: Pixel Aspect Ratio numerator.
        :param pulumi.Input[str] profile: AAC profile.
        :param pulumi.Input[int] qvbr_quality_level: Controls the target quality for the video encode.
        :param pulumi.Input[str] rate_control_mode: The rate control mode.
        :param pulumi.Input[str] scan_type: Sets the scan type of the output.
        :param pulumi.Input[str] scene_change_detect: Scene change detection.
        :param pulumi.Input[int] slices: Number of slices per picture.
        :param pulumi.Input[str] tier: Set the H265 tier in the output.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs'] timecode_burnin_settings: Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
        :param pulumi.Input[str] timecode_insertion: Determines how timecodes should be inserted into the video elementary stream.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            alternative_transfer_function=alternative_transfer_function,
            buf_size=buf_size,
            color_metadata=color_metadata,
            color_space_settings=color_space_settings,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            gop_closed_cadence=gop_closed_cadence,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            tier=tier,
            timecode_burnin_settings=timecode_burnin_settings,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[pulumi.Input[int]] = None,
             framerate_denominator: Optional[pulumi.Input[int]] = None,
             framerate_numerator: Optional[pulumi.Input[int]] = None,
             adaptive_quantization: Optional[pulumi.Input[str]] = None,
             afd_signaling: Optional[pulumi.Input[str]] = None,
             alternative_transfer_function: Optional[pulumi.Input[str]] = None,
             buf_size: Optional[pulumi.Input[int]] = None,
             color_metadata: Optional[pulumi.Input[str]] = None,
             color_space_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs']] = None,
             filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs']] = None,
             fixed_afd: Optional[pulumi.Input[str]] = None,
             flicker_aq: Optional[pulumi.Input[str]] = None,
             gop_closed_cadence: Optional[pulumi.Input[int]] = None,
             gop_size: Optional[pulumi.Input[float]] = None,
             gop_size_units: Optional[pulumi.Input[str]] = None,
             level: Optional[pulumi.Input[str]] = None,
             look_ahead_rate_control: Optional[pulumi.Input[str]] = None,
             max_bitrate: Optional[pulumi.Input[int]] = None,
             min_i_interval: Optional[pulumi.Input[int]] = None,
             par_denominator: Optional[pulumi.Input[int]] = None,
             par_numerator: Optional[pulumi.Input[int]] = None,
             profile: Optional[pulumi.Input[str]] = None,
             qvbr_quality_level: Optional[pulumi.Input[int]] = None,
             rate_control_mode: Optional[pulumi.Input[str]] = None,
             scan_type: Optional[pulumi.Input[str]] = None,
             scene_change_detect: Optional[pulumi.Input[str]] = None,
             slices: Optional[pulumi.Input[int]] = None,
             tier: Optional[pulumi.Input[str]] = None,
             timecode_burnin_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs']] = None,
             timecode_insertion: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bitrate is None:
            raise TypeError("Missing 'bitrate' argument")
        if framerate_denominator is None and 'framerateDenominator' in kwargs:
            framerate_denominator = kwargs['framerateDenominator']
        if framerate_denominator is None:
            raise TypeError("Missing 'framerate_denominator' argument")
        if framerate_numerator is None and 'framerateNumerator' in kwargs:
            framerate_numerator = kwargs['framerateNumerator']
        if framerate_numerator is None:
            raise TypeError("Missing 'framerate_numerator' argument")
        if adaptive_quantization is None and 'adaptiveQuantization' in kwargs:
            adaptive_quantization = kwargs['adaptiveQuantization']
        if afd_signaling is None and 'afdSignaling' in kwargs:
            afd_signaling = kwargs['afdSignaling']
        if alternative_transfer_function is None and 'alternativeTransferFunction' in kwargs:
            alternative_transfer_function = kwargs['alternativeTransferFunction']
        if buf_size is None and 'bufSize' in kwargs:
            buf_size = kwargs['bufSize']
        if color_metadata is None and 'colorMetadata' in kwargs:
            color_metadata = kwargs['colorMetadata']
        if color_space_settings is None and 'colorSpaceSettings' in kwargs:
            color_space_settings = kwargs['colorSpaceSettings']
        if filter_settings is None and 'filterSettings' in kwargs:
            filter_settings = kwargs['filterSettings']
        if fixed_afd is None and 'fixedAfd' in kwargs:
            fixed_afd = kwargs['fixedAfd']
        if flicker_aq is None and 'flickerAq' in kwargs:
            flicker_aq = kwargs['flickerAq']
        if gop_closed_cadence is None and 'gopClosedCadence' in kwargs:
            gop_closed_cadence = kwargs['gopClosedCadence']
        if gop_size is None and 'gopSize' in kwargs:
            gop_size = kwargs['gopSize']
        if gop_size_units is None and 'gopSizeUnits' in kwargs:
            gop_size_units = kwargs['gopSizeUnits']
        if look_ahead_rate_control is None and 'lookAheadRateControl' in kwargs:
            look_ahead_rate_control = kwargs['lookAheadRateControl']
        if max_bitrate is None and 'maxBitrate' in kwargs:
            max_bitrate = kwargs['maxBitrate']
        if min_i_interval is None and 'minIInterval' in kwargs:
            min_i_interval = kwargs['minIInterval']
        if par_denominator is None and 'parDenominator' in kwargs:
            par_denominator = kwargs['parDenominator']
        if par_numerator is None and 'parNumerator' in kwargs:
            par_numerator = kwargs['parNumerator']
        if qvbr_quality_level is None and 'qvbrQualityLevel' in kwargs:
            qvbr_quality_level = kwargs['qvbrQualityLevel']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if scan_type is None and 'scanType' in kwargs:
            scan_type = kwargs['scanType']
        if scene_change_detect is None and 'sceneChangeDetect' in kwargs:
            scene_change_detect = kwargs['sceneChangeDetect']
        if timecode_burnin_settings is None and 'timecodeBurninSettings' in kwargs:
            timecode_burnin_settings = kwargs['timecodeBurninSettings']
        if timecode_insertion is None and 'timecodeInsertion' in kwargs:
            timecode_insertion = kwargs['timecodeInsertion']

        _setter("bitrate", bitrate)
        _setter("framerate_denominator", framerate_denominator)
        _setter("framerate_numerator", framerate_numerator)
        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if alternative_transfer_function is not None:
            _setter("alternative_transfer_function", alternative_transfer_function)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if color_space_settings is not None:
            _setter("color_space_settings", color_space_settings)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if tier is not None:
            _setter("tier", tier)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> pulumi.Input[int]:
        """
        Framerate denominator.
        """
        return pulumi.get(self, "framerate_denominator")

    @framerate_denominator.setter
    def framerate_denominator(self, value: pulumi.Input[int]):
        pulumi.set(self, "framerate_denominator", value)

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> pulumi.Input[int]:
        """
        Framerate numerator.
        """
        return pulumi.get(self, "framerate_numerator")

    @framerate_numerator.setter
    def framerate_numerator(self, value: pulumi.Input[int]):
        pulumi.set(self, "framerate_numerator", value)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[pulumi.Input[str]]:
        """
        Enables or disables adaptive quantization.
        """
        return pulumi.get(self, "adaptive_quantization")

    @adaptive_quantization.setter
    def adaptive_quantization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adaptive_quantization", value)

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that AFD values will be written into the output stream.
        """
        return pulumi.get(self, "afd_signaling")

    @afd_signaling.setter
    def afd_signaling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "afd_signaling", value)

    @property
    @pulumi.getter(name="alternativeTransferFunction")
    def alternative_transfer_function(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not EML should insert an Alternative Transfer Function SEI message.
        """
        return pulumi.get(self, "alternative_transfer_function")

    @alternative_transfer_function.setter
    def alternative_transfer_function(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alternative_transfer_function", value)

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of buffer in bits.
        """
        return pulumi.get(self, "buf_size")

    @buf_size.setter
    def buf_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buf_size", value)

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Includes color space metadata in the output.
        """
        return pulumi.get(self, "color_metadata")

    @color_metadata.setter
    def color_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_metadata", value)

    @property
    @pulumi.getter(name="colorSpaceSettings")
    def color_space_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs']]:
        """
        Define the color metadata for the output. H265 Color Space Settings for more details.
        """
        return pulumi.get(self, "color_space_settings")

    @color_space_settings.setter
    def color_space_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs']]):
        pulumi.set(self, "color_space_settings", value)

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs']]:
        """
        Filters to apply to an encode. See H265 Filter Settings for more details.
        """
        return pulumi.get(self, "filter_settings")

    @filter_settings.setter
    def filter_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs']]):
        pulumi.set(self, "filter_settings", value)

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[pulumi.Input[str]]:
        """
        Four bit AFD value to write on all frames of video in the output stream.
        """
        return pulumi.get(self, "fixed_afd")

    @fixed_afd.setter
    def fixed_afd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fixed_afd", value)

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flicker_aq")

    @flicker_aq.setter
    def flicker_aq(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flicker_aq", value)

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency of closed GOPs.
        """
        return pulumi.get(self, "gop_closed_cadence")

    @gop_closed_cadence.setter
    def gop_closed_cadence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop_closed_cadence", value)

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[pulumi.Input[float]]:
        """
        GOP size in units of either frames of seconds per `gop_size_units`.
        """
        return pulumi.get(self, "gop_size")

    @gop_size.setter
    def gop_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gop_size", value)

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates if the `gop_size` is specified in frames or seconds.
        """
        return pulumi.get(self, "gop_size_units")

    @gop_size_units.setter
    def gop_size_units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gop_size_units", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        H265 level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of lookahead.
        """
        return pulumi.get(self, "look_ahead_rate_control")

    @look_ahead_rate_control.setter
    def look_ahead_rate_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "look_ahead_rate_control", value)

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        """
        return pulumi.get(self, "max_bitrate")

    @max_bitrate.setter
    def max_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bitrate", value)

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_i_interval")

    @min_i_interval.setter
    def min_i_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_i_interval", value)

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[pulumi.Input[int]]:
        """
        Pixel Aspect Ratio denominator.
        """
        return pulumi.get(self, "par_denominator")

    @par_denominator.setter
    def par_denominator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "par_denominator", value)

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[pulumi.Input[int]]:
        """
        Pixel Aspect Ratio numerator.
        """
        return pulumi.get(self, "par_numerator")

    @par_numerator.setter
    def par_numerator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "par_numerator", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[pulumi.Input[int]]:
        """
        Controls the target quality for the video encode.
        """
        return pulumi.get(self, "qvbr_quality_level")

    @qvbr_quality_level.setter
    def qvbr_quality_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qvbr_quality_level", value)

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @rate_control_mode.setter
    def rate_control_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_control_mode", value)

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the scan type of the output.
        """
        return pulumi.get(self, "scan_type")

    @scan_type.setter
    def scan_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_type", value)

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[pulumi.Input[str]]:
        """
        Scene change detection.
        """
        return pulumi.get(self, "scene_change_detect")

    @scene_change_detect.setter
    def scene_change_detect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scene_change_detect", value)

    @property
    @pulumi.getter
    def slices(self) -> Optional[pulumi.Input[int]]:
        """
        Number of slices per picture.
        """
        return pulumi.get(self, "slices")

    @slices.setter
    def slices(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slices", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Set the H265 tier in the output.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs']]:
        """
        Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
        """
        return pulumi.get(self, "timecode_burnin_settings")

    @timecode_burnin_settings.setter
    def timecode_burnin_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs']]):
        pulumi.set(self, "timecode_burnin_settings", value)

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[pulumi.Input[str]]:
        """
        Determines how timecodes should be inserted into the video elementary stream.
        """
        return pulumi.get(self, "timecode_insertion")

    @timecode_insertion.setter
    def timecode_insertion(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timecode_insertion", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs:
    def __init__(__self__, *,
                 color_space_passthrough_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs']] = None,
                 dolby_vision81_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs']] = None,
                 hdr10_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs']] = None,
                 rec601_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs']] = None,
                 rec709_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs'] color_space_passthrough_settings: Sets the colorspace metadata to be passed through.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs'] dolby_vision81_settings: Set the colorspace to Dolby Vision81.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs'] hdr10_settings: Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs'] rec601_settings: Set the colorspace to Rec. 601.
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs'] rec709_settings: Set the colorspace to Rec. 709.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space_passthrough_settings=color_space_passthrough_settings,
            dolby_vision81_settings=dolby_vision81_settings,
            hdr10_settings=hdr10_settings,
            rec601_settings=rec601_settings,
            rec709_settings=rec709_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space_passthrough_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs']] = None,
             dolby_vision81_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs']] = None,
             hdr10_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs']] = None,
             rec601_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs']] = None,
             rec709_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if color_space_passthrough_settings is None and 'colorSpacePassthroughSettings' in kwargs:
            color_space_passthrough_settings = kwargs['colorSpacePassthroughSettings']
        if dolby_vision81_settings is None and 'dolbyVision81Settings' in kwargs:
            dolby_vision81_settings = kwargs['dolbyVision81Settings']
        if hdr10_settings is None and 'hdr10Settings' in kwargs:
            hdr10_settings = kwargs['hdr10Settings']
        if rec601_settings is None and 'rec601Settings' in kwargs:
            rec601_settings = kwargs['rec601Settings']
        if rec709_settings is None and 'rec709Settings' in kwargs:
            rec709_settings = kwargs['rec709Settings']

        if color_space_passthrough_settings is not None:
            _setter("color_space_passthrough_settings", color_space_passthrough_settings)
        if dolby_vision81_settings is not None:
            _setter("dolby_vision81_settings", dolby_vision81_settings)
        if hdr10_settings is not None:
            _setter("hdr10_settings", hdr10_settings)
        if rec601_settings is not None:
            _setter("rec601_settings", rec601_settings)
        if rec709_settings is not None:
            _setter("rec709_settings", rec709_settings)

    @property
    @pulumi.getter(name="colorSpacePassthroughSettings")
    def color_space_passthrough_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs']]:
        """
        Sets the colorspace metadata to be passed through.
        """
        return pulumi.get(self, "color_space_passthrough_settings")

    @color_space_passthrough_settings.setter
    def color_space_passthrough_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs']]):
        pulumi.set(self, "color_space_passthrough_settings", value)

    @property
    @pulumi.getter(name="dolbyVision81Settings")
    def dolby_vision81_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs']]:
        """
        Set the colorspace to Dolby Vision81.
        """
        return pulumi.get(self, "dolby_vision81_settings")

    @dolby_vision81_settings.setter
    def dolby_vision81_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs']]):
        pulumi.set(self, "dolby_vision81_settings", value)

    @property
    @pulumi.getter(name="hdr10Settings")
    def hdr10_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs']]:
        """
        Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
        """
        return pulumi.get(self, "hdr10_settings")

    @hdr10_settings.setter
    def hdr10_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs']]):
        pulumi.set(self, "hdr10_settings", value)

    @property
    @pulumi.getter(name="rec601Settings")
    def rec601_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs']]:
        """
        Set the colorspace to Rec. 601.
        """
        return pulumi.get(self, "rec601_settings")

    @rec601_settings.setter
    def rec601_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs']]):
        pulumi.set(self, "rec601_settings", value)

    @property
    @pulumi.getter(name="rec709Settings")
    def rec709_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs']]:
        """
        Set the colorspace to Rec. 709.
        """
        return pulumi.get(self, "rec709_settings")

    @rec709_settings.setter
    def rec709_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs']]):
        pulumi.set(self, "rec709_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs:
    def __init__(__self__, *,
                 max_cll: Optional[pulumi.Input[int]] = None,
                 max_fall: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_cll: Sets the MaxCLL value for HDR10.
        :param pulumi.Input[int] max_fall: Sets the MaxFALL value for HDR10.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_cll=max_cll,
            max_fall=max_fall,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_cll: Optional[pulumi.Input[int]] = None,
             max_fall: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_cll is None and 'maxCll' in kwargs:
            max_cll = kwargs['maxCll']
        if max_fall is None and 'maxFall' in kwargs:
            max_fall = kwargs['maxFall']

        if max_cll is not None:
            _setter("max_cll", max_cll)
        if max_fall is not None:
            _setter("max_fall", max_fall)

    @property
    @pulumi.getter(name="maxCll")
    def max_cll(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the MaxCLL value for HDR10.
        """
        return pulumi.get(self, "max_cll")

    @max_cll.setter
    def max_cll(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_cll", value)

    @property
    @pulumi.getter(name="maxFall")
    def max_fall(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the MaxFALL value for HDR10.
        """
        return pulumi.get(self, "max_fall")

    @max_fall.setter
    def max_fall(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_fall", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs:
    def __init__(__self__, *,
                 temporal_filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs'] temporal_filter_settings: Temporal filter settings. See Temporal Filter Settings
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if temporal_filter_settings is None and 'temporalFilterSettings' in kwargs:
            temporal_filter_settings = kwargs['temporalFilterSettings']

        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs']]:
        """
        Temporal filter settings. See Temporal Filter Settings
        """
        return pulumi.get(self, "temporal_filter_settings")

    @temporal_filter_settings.setter
    def temporal_filter_settings(self, value: Optional[pulumi.Input['ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs']]):
        pulumi.set(self, "temporal_filter_settings", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs:
    def __init__(__self__, *,
                 post_filter_sharpening: Optional[pulumi.Input[str]] = None,
                 strength: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] post_filter_sharpening: Post filter sharpening.
        :param pulumi.Input[str] strength: Filter strength.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_filter_sharpening=post_filter_sharpening,
            strength=strength,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_filter_sharpening: Optional[pulumi.Input[str]] = None,
             strength: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if post_filter_sharpening is None and 'postFilterSharpening' in kwargs:
            post_filter_sharpening = kwargs['postFilterSharpening']

        if post_filter_sharpening is not None:
            _setter("post_filter_sharpening", post_filter_sharpening)
        if strength is not None:
            _setter("strength", strength)

    @property
    @pulumi.getter(name="postFilterSharpening")
    def post_filter_sharpening(self) -> Optional[pulumi.Input[str]]:
        """
        Post filter sharpening.
        """
        return pulumi.get(self, "post_filter_sharpening")

    @post_filter_sharpening.setter
    def post_filter_sharpening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_filter_sharpening", value)

    @property
    @pulumi.getter
    def strength(self) -> Optional[pulumi.Input[str]]:
        """
        Filter strength.
        """
        return pulumi.get(self, "strength")

    @strength.setter
    def strength(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strength", value)


@pulumi.input_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None,
                 timecode_burnin_font_size: Optional[pulumi.Input[str]] = None,
                 timecode_burnin_position: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] prefix: Set a prefix on the burned in timecode.
        :param pulumi.Input[str] timecode_burnin_font_size: Sets the size of the burned in timecode.
        :param pulumi.Input[str] timecode_burnin_position: Sets the position of the burned in timecode.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            timecode_burnin_font_size=timecode_burnin_font_size,
            timecode_burnin_position=timecode_burnin_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[pulumi.Input[str]] = None,
             timecode_burnin_font_size: Optional[pulumi.Input[str]] = None,
             timecode_burnin_position: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if timecode_burnin_font_size is None and 'timecodeBurninFontSize' in kwargs:
            timecode_burnin_font_size = kwargs['timecodeBurninFontSize']
        if timecode_burnin_position is None and 'timecodeBurninPosition' in kwargs:
            timecode_burnin_position = kwargs['timecodeBurninPosition']

        if prefix is not None:
            _setter("prefix", prefix)
        if timecode_burnin_font_size is not None:
            _setter("timecode_burnin_font_size", timecode_burnin_font_size)
        if timecode_burnin_position is not None:
            _setter("timecode_burnin_position", timecode_burnin_position)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Set a prefix on the burned in timecode.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="timecodeBurninFontSize")
    def timecode_burnin_font_size(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the size of the burned in timecode.
        """
        return pulumi.get(self, "timecode_burnin_font_size")

    @timecode_burnin_font_size.setter
    def timecode_burnin_font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timecode_burnin_font_size", value)

    @property
    @pulumi.getter(name="timecodeBurninPosition")
    def timecode_burnin_position(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the position of the burned in timecode.
        """
        return pulumi.get(self, "timecode_burnin_position")

    @timecode_burnin_position.setter
    def timecode_burnin_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timecode_burnin_position", value)


@pulumi.input_type
class ChannelInputAttachmentArgs:
    def __init__(__self__, *,
                 input_attachment_name: pulumi.Input[str],
                 input_id: pulumi.Input[str],
                 automatic_input_failover_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsArgs']] = None,
                 input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsArgs']] = None):
        """
        :param pulumi.Input[str] input_attachment_name: User-specified name for the attachment.
        :param pulumi.Input[str] input_id: The ID of the input.
        :param pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsArgs'] automatic_input_failover_settings: User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsArgs'] input_settings: Settings of an input. See Input Settings for more details.
        """
        ChannelInputAttachmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_attachment_name=input_attachment_name,
            input_id=input_id,
            automatic_input_failover_settings=automatic_input_failover_settings,
            input_settings=input_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_attachment_name: Optional[pulumi.Input[str]] = None,
             input_id: Optional[pulumi.Input[str]] = None,
             automatic_input_failover_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsArgs']] = None,
             input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_attachment_name is None and 'inputAttachmentName' in kwargs:
            input_attachment_name = kwargs['inputAttachmentName']
        if input_attachment_name is None:
            raise TypeError("Missing 'input_attachment_name' argument")
        if input_id is None and 'inputId' in kwargs:
            input_id = kwargs['inputId']
        if input_id is None:
            raise TypeError("Missing 'input_id' argument")
        if automatic_input_failover_settings is None and 'automaticInputFailoverSettings' in kwargs:
            automatic_input_failover_settings = kwargs['automaticInputFailoverSettings']
        if input_settings is None and 'inputSettings' in kwargs:
            input_settings = kwargs['inputSettings']

        _setter("input_attachment_name", input_attachment_name)
        _setter("input_id", input_id)
        if automatic_input_failover_settings is not None:
            _setter("automatic_input_failover_settings", automatic_input_failover_settings)
        if input_settings is not None:
            _setter("input_settings", input_settings)

    @property
    @pulumi.getter(name="inputAttachmentName")
    def input_attachment_name(self) -> pulumi.Input[str]:
        """
        User-specified name for the attachment.
        """
        return pulumi.get(self, "input_attachment_name")

    @input_attachment_name.setter
    def input_attachment_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_attachment_name", value)

    @property
    @pulumi.getter(name="inputId")
    def input_id(self) -> pulumi.Input[str]:
        """
        The ID of the input.
        """
        return pulumi.get(self, "input_id")

    @input_id.setter
    def input_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_id", value)

    @property
    @pulumi.getter(name="automaticInputFailoverSettings")
    def automatic_input_failover_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsArgs']]:
        """
        User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
        """
        return pulumi.get(self, "automatic_input_failover_settings")

    @automatic_input_failover_settings.setter
    def automatic_input_failover_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsArgs']]):
        pulumi.set(self, "automatic_input_failover_settings", value)

    @property
    @pulumi.getter(name="inputSettings")
    def input_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsArgs']]:
        """
        Settings of an input. See Input Settings for more details.
        """
        return pulumi.get(self, "input_settings")

    @input_settings.setter
    def input_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsArgs']]):
        pulumi.set(self, "input_settings", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsArgs:
    def __init__(__self__, *,
                 secondary_input_id: pulumi.Input[str],
                 error_clear_time_msec: Optional[pulumi.Input[int]] = None,
                 failover_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs']]]] = None,
                 input_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] secondary_input_id: The input ID of the secondary input in the automatic input failover pair.
        :param pulumi.Input[int] error_clear_time_msec: This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\\_preference for the failover pair is set to PRIMARY\\_INPUT\\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
        :param pulumi.Input[str] input_preference: Input preference when deciding which input to make active when a previously failed input has recovered.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secondary_input_id=secondary_input_id,
            error_clear_time_msec=error_clear_time_msec,
            failover_conditions=failover_conditions,
            input_preference=input_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secondary_input_id: Optional[pulumi.Input[str]] = None,
             error_clear_time_msec: Optional[pulumi.Input[int]] = None,
             failover_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs']]]] = None,
             input_preference: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secondary_input_id is None and 'secondaryInputId' in kwargs:
            secondary_input_id = kwargs['secondaryInputId']
        if secondary_input_id is None:
            raise TypeError("Missing 'secondary_input_id' argument")
        if error_clear_time_msec is None and 'errorClearTimeMsec' in kwargs:
            error_clear_time_msec = kwargs['errorClearTimeMsec']
        if failover_conditions is None and 'failoverConditions' in kwargs:
            failover_conditions = kwargs['failoverConditions']
        if input_preference is None and 'inputPreference' in kwargs:
            input_preference = kwargs['inputPreference']

        _setter("secondary_input_id", secondary_input_id)
        if error_clear_time_msec is not None:
            _setter("error_clear_time_msec", error_clear_time_msec)
        if failover_conditions is not None:
            _setter("failover_conditions", failover_conditions)
        if input_preference is not None:
            _setter("input_preference", input_preference)

    @property
    @pulumi.getter(name="secondaryInputId")
    def secondary_input_id(self) -> pulumi.Input[str]:
        """
        The input ID of the secondary input in the automatic input failover pair.
        """
        return pulumi.get(self, "secondary_input_id")

    @secondary_input_id.setter
    def secondary_input_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secondary_input_id", value)

    @property
    @pulumi.getter(name="errorClearTimeMsec")
    def error_clear_time_msec(self) -> Optional[pulumi.Input[int]]:
        """
        This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\\_preference for the failover pair is set to PRIMARY\\_INPUT\\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
        """
        return pulumi.get(self, "error_clear_time_msec")

    @error_clear_time_msec.setter
    def error_clear_time_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "error_clear_time_msec", value)

    @property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs']]]]:
        return pulumi.get(self, "failover_conditions")

    @failover_conditions.setter
    def failover_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs']]]]):
        pulumi.set(self, "failover_conditions", value)

    @property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Input preference when deciding which input to make active when a previously failed input has recovered.
        """
        return pulumi.get(self, "input_preference")

    @input_preference.setter
    def input_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_preference", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs:
    def __init__(__self__, *,
                 failover_condition_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs'] failover_condition_settings: Failover condition type-specific settings. See Failover Condition Settings for more details.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_condition_settings=failover_condition_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_condition_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failover_condition_settings is None and 'failoverConditionSettings' in kwargs:
            failover_condition_settings = kwargs['failoverConditionSettings']

        if failover_condition_settings is not None:
            _setter("failover_condition_settings", failover_condition_settings)

    @property
    @pulumi.getter(name="failoverConditionSettings")
    def failover_condition_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs']]:
        """
        Failover condition type-specific settings. See Failover Condition Settings for more details.
        """
        return pulumi.get(self, "failover_condition_settings")

    @failover_condition_settings.setter
    def failover_condition_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs']]):
        pulumi.set(self, "failover_condition_settings", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs:
    def __init__(__self__, *,
                 audio_silence_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs']] = None,
                 input_loss_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs']] = None,
                 video_black_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs'] audio_silence_settings: MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs'] input_loss_settings: MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs'] video_black_settings: MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_silence_settings=audio_silence_settings,
            input_loss_settings=input_loss_settings,
            video_black_settings=video_black_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_silence_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs']] = None,
             input_loss_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs']] = None,
             video_black_settings: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_silence_settings is None and 'audioSilenceSettings' in kwargs:
            audio_silence_settings = kwargs['audioSilenceSettings']
        if input_loss_settings is None and 'inputLossSettings' in kwargs:
            input_loss_settings = kwargs['inputLossSettings']
        if video_black_settings is None and 'videoBlackSettings' in kwargs:
            video_black_settings = kwargs['videoBlackSettings']

        if audio_silence_settings is not None:
            _setter("audio_silence_settings", audio_silence_settings)
        if input_loss_settings is not None:
            _setter("input_loss_settings", input_loss_settings)
        if video_black_settings is not None:
            _setter("video_black_settings", video_black_settings)

    @property
    @pulumi.getter(name="audioSilenceSettings")
    def audio_silence_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs']]:
        """
        MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
        """
        return pulumi.get(self, "audio_silence_settings")

    @audio_silence_settings.setter
    def audio_silence_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs']]):
        pulumi.set(self, "audio_silence_settings", value)

    @property
    @pulumi.getter(name="inputLossSettings")
    def input_loss_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs']]:
        """
        MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
        """
        return pulumi.get(self, "input_loss_settings")

    @input_loss_settings.setter
    def input_loss_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs']]):
        pulumi.set(self, "input_loss_settings", value)

    @property
    @pulumi.getter(name="videoBlackSettings")
    def video_black_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs']]:
        """
        MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
        """
        return pulumi.get(self, "video_black_settings")

    @video_black_settings.setter
    def video_black_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs']]):
        pulumi.set(self, "video_black_settings", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs:
    def __init__(__self__, *,
                 audio_selector_name: pulumi.Input[str],
                 audio_silence_threshold_msec: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] audio_selector_name: The name of the audio selector used as the source for this AudioDescription.
        :param pulumi.Input[int] audio_silence_threshold_msec: The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selector_name=audio_selector_name,
            audio_silence_threshold_msec=audio_silence_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selector_name: Optional[pulumi.Input[str]] = None,
             audio_silence_threshold_msec: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selector_name is None and 'audioSelectorName' in kwargs:
            audio_selector_name = kwargs['audioSelectorName']
        if audio_selector_name is None:
            raise TypeError("Missing 'audio_selector_name' argument")
        if audio_silence_threshold_msec is None and 'audioSilenceThresholdMsec' in kwargs:
            audio_silence_threshold_msec = kwargs['audioSilenceThresholdMsec']

        _setter("audio_selector_name", audio_selector_name)
        if audio_silence_threshold_msec is not None:
            _setter("audio_silence_threshold_msec", audio_silence_threshold_msec)

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> pulumi.Input[str]:
        """
        The name of the audio selector used as the source for this AudioDescription.
        """
        return pulumi.get(self, "audio_selector_name")

    @audio_selector_name.setter
    def audio_selector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "audio_selector_name", value)

    @property
    @pulumi.getter(name="audioSilenceThresholdMsec")
    def audio_silence_threshold_msec(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS.
        """
        return pulumi.get(self, "audio_silence_threshold_msec")

    @audio_silence_threshold_msec.setter
    def audio_silence_threshold_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_silence_threshold_msec", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs:
    def __init__(__self__, *,
                 input_loss_threshold_msec: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] input_loss_threshold_msec: The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_threshold_msec=input_loss_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_threshold_msec: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_loss_threshold_msec is None and 'inputLossThresholdMsec' in kwargs:
            input_loss_threshold_msec = kwargs['inputLossThresholdMsec']

        if input_loss_threshold_msec is not None:
            _setter("input_loss_threshold_msec", input_loss_threshold_msec)

    @property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur.
        """
        return pulumi.get(self, "input_loss_threshold_msec")

    @input_loss_threshold_msec.setter
    def input_loss_threshold_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "input_loss_threshold_msec", value)


@pulumi.input_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs:
    def __init__(__self__, *,
                 black_detect_threshold: Optional[pulumi.Input[float]] = None,
                 video_black_threshold_msec: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[float] black_detect_threshold: A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
        :param pulumi.Input[int] video_black_threshold_msec: The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_detect_threshold=black_detect_threshold,
            video_black_threshold_msec=video_black_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_detect_threshold: Optional[pulumi.Input[float]] = None,
             video_black_threshold_msec: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if black_detect_threshold is None and 'blackDetectThreshold' in kwargs:
            black_detect_threshold = kwargs['blackDetectThreshold']
        if video_black_threshold_msec is None and 'videoBlackThresholdMsec' in kwargs:
            video_black_threshold_msec = kwargs['videoBlackThresholdMsec']

        if black_detect_threshold is not None:
            _setter("black_detect_threshold", black_detect_threshold)
        if video_black_threshold_msec is not None:
            _setter("video_black_threshold_msec", video_black_threshold_msec)

    @property
    @pulumi.getter(name="blackDetectThreshold")
    def black_detect_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
        """
        return pulumi.get(self, "black_detect_threshold")

    @black_detect_threshold.setter
    def black_detect_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "black_detect_threshold", value)

    @property
    @pulumi.getter(name="videoBlackThresholdMsec")
    def video_black_threshold_msec(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
        """
        return pulumi.get(self, "video_black_threshold_msec")

    @video_black_threshold_msec.setter
    def video_black_threshold_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "video_black_threshold_msec", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsArgs:
    def __init__(__self__, *,
                 audio_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorArgs']]]] = None,
                 caption_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorArgs']]]] = None,
                 deblock_filter: Optional[pulumi.Input[str]] = None,
                 denoise_filter: Optional[pulumi.Input[str]] = None,
                 filter_strength: Optional[pulumi.Input[int]] = None,
                 input_filter: Optional[pulumi.Input[str]] = None,
                 network_input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs']] = None,
                 scte35_pid: Optional[pulumi.Input[int]] = None,
                 smpte2038_data_preference: Optional[pulumi.Input[str]] = None,
                 source_end_behavior: Optional[pulumi.Input[str]] = None,
                 video_selector: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsVideoSelectorArgs']] = None):
        """
        :param pulumi.Input[str] deblock_filter: Enable or disable the deblock filter when filtering.
        :param pulumi.Input[str] denoise_filter: Enable or disable the denoise filter when filtering.
        :param pulumi.Input[int] filter_strength: Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
        :param pulumi.Input[str] input_filter: Turns on the filter for the input.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs'] network_input_settings: Input settings. See Network Input Settings for more details.
        :param pulumi.Input[int] scte35_pid: PID from which to read SCTE-35 messages.
        :param pulumi.Input[str] smpte2038_data_preference: Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
        :param pulumi.Input[str] source_end_behavior: Loop input if it is a file.
        """
        ChannelInputAttachmentInputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selectors=audio_selectors,
            caption_selectors=caption_selectors,
            deblock_filter=deblock_filter,
            denoise_filter=denoise_filter,
            filter_strength=filter_strength,
            input_filter=input_filter,
            network_input_settings=network_input_settings,
            scte35_pid=scte35_pid,
            smpte2038_data_preference=smpte2038_data_preference,
            source_end_behavior=source_end_behavior,
            video_selector=video_selector,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorArgs']]]] = None,
             caption_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorArgs']]]] = None,
             deblock_filter: Optional[pulumi.Input[str]] = None,
             denoise_filter: Optional[pulumi.Input[str]] = None,
             filter_strength: Optional[pulumi.Input[int]] = None,
             input_filter: Optional[pulumi.Input[str]] = None,
             network_input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs']] = None,
             scte35_pid: Optional[pulumi.Input[int]] = None,
             smpte2038_data_preference: Optional[pulumi.Input[str]] = None,
             source_end_behavior: Optional[pulumi.Input[str]] = None,
             video_selector: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsVideoSelectorArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selectors is None and 'audioSelectors' in kwargs:
            audio_selectors = kwargs['audioSelectors']
        if caption_selectors is None and 'captionSelectors' in kwargs:
            caption_selectors = kwargs['captionSelectors']
        if deblock_filter is None and 'deblockFilter' in kwargs:
            deblock_filter = kwargs['deblockFilter']
        if denoise_filter is None and 'denoiseFilter' in kwargs:
            denoise_filter = kwargs['denoiseFilter']
        if filter_strength is None and 'filterStrength' in kwargs:
            filter_strength = kwargs['filterStrength']
        if input_filter is None and 'inputFilter' in kwargs:
            input_filter = kwargs['inputFilter']
        if network_input_settings is None and 'networkInputSettings' in kwargs:
            network_input_settings = kwargs['networkInputSettings']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if smpte2038_data_preference is None and 'smpte2038DataPreference' in kwargs:
            smpte2038_data_preference = kwargs['smpte2038DataPreference']
        if source_end_behavior is None and 'sourceEndBehavior' in kwargs:
            source_end_behavior = kwargs['sourceEndBehavior']
        if video_selector is None and 'videoSelector' in kwargs:
            video_selector = kwargs['videoSelector']

        if audio_selectors is not None:
            _setter("audio_selectors", audio_selectors)
        if caption_selectors is not None:
            _setter("caption_selectors", caption_selectors)
        if deblock_filter is not None:
            _setter("deblock_filter", deblock_filter)
        if denoise_filter is not None:
            _setter("denoise_filter", denoise_filter)
        if filter_strength is not None:
            _setter("filter_strength", filter_strength)
        if input_filter is not None:
            _setter("input_filter", input_filter)
        if network_input_settings is not None:
            _setter("network_input_settings", network_input_settings)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if smpte2038_data_preference is not None:
            _setter("smpte2038_data_preference", smpte2038_data_preference)
        if source_end_behavior is not None:
            _setter("source_end_behavior", source_end_behavior)
        if video_selector is not None:
            _setter("video_selector", video_selector)

    @property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorArgs']]]]:
        return pulumi.get(self, "audio_selectors")

    @audio_selectors.setter
    def audio_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorArgs']]]]):
        pulumi.set(self, "audio_selectors", value)

    @property
    @pulumi.getter(name="captionSelectors")
    def caption_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorArgs']]]]:
        return pulumi.get(self, "caption_selectors")

    @caption_selectors.setter
    def caption_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorArgs']]]]):
        pulumi.set(self, "caption_selectors", value)

    @property
    @pulumi.getter(name="deblockFilter")
    def deblock_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Enable or disable the deblock filter when filtering.
        """
        return pulumi.get(self, "deblock_filter")

    @deblock_filter.setter
    def deblock_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deblock_filter", value)

    @property
    @pulumi.getter(name="denoiseFilter")
    def denoise_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Enable or disable the denoise filter when filtering.
        """
        return pulumi.get(self, "denoise_filter")

    @denoise_filter.setter
    def denoise_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "denoise_filter", value)

    @property
    @pulumi.getter(name="filterStrength")
    def filter_strength(self) -> Optional[pulumi.Input[int]]:
        """
        Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
        """
        return pulumi.get(self, "filter_strength")

    @filter_strength.setter
    def filter_strength(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filter_strength", value)

    @property
    @pulumi.getter(name="inputFilter")
    def input_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Turns on the filter for the input.
        """
        return pulumi.get(self, "input_filter")

    @input_filter.setter
    def input_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_filter", value)

    @property
    @pulumi.getter(name="networkInputSettings")
    def network_input_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs']]:
        """
        Input settings. See Network Input Settings for more details.
        """
        return pulumi.get(self, "network_input_settings")

    @network_input_settings.setter
    def network_input_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs']]):
        pulumi.set(self, "network_input_settings", value)

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[pulumi.Input[int]]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @scte35_pid.setter
    def scte35_pid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scte35_pid", value)

    @property
    @pulumi.getter(name="smpte2038DataPreference")
    def smpte2038_data_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
        """
        return pulumi.get(self, "smpte2038_data_preference")

    @smpte2038_data_preference.setter
    def smpte2038_data_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "smpte2038_data_preference", value)

    @property
    @pulumi.getter(name="sourceEndBehavior")
    def source_end_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Loop input if it is a file.
        """
        return pulumi.get(self, "source_end_behavior")

    @source_end_behavior.setter
    def source_end_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_end_behavior", value)

    @property
    @pulumi.getter(name="videoSelector")
    def video_selector(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsVideoSelectorArgs']]:
        return pulumi.get(self, "video_selector")

    @video_selector.setter
    def video_selector(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsVideoSelectorArgs']]):
        pulumi.set(self, "video_selector", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 selector_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the Channel.
               
               The following arguments are optional:
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs'] selector_settings: The audio selector settings. See Audio Selector Settings for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             selector_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if selector_settings is None and 'selectorSettings' in kwargs:
            selector_settings = kwargs['selectorSettings']

        _setter("name", name)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Channel.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs']]:
        """
        The audio selector settings. See Audio Selector Settings for more details.
        """
        return pulumi.get(self, "selector_settings")

    @selector_settings.setter
    def selector_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs']]):
        pulumi.set(self, "selector_settings", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs:
    def __init__(__self__, *,
                 audio_hls_rendition_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs']] = None,
                 audio_language_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']] = None,
                 audio_pid_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs']] = None,
                 audio_track_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs']] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs'] audio_hls_rendition_selection: Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs'] audio_language_selection: Audio Language Selection. See Audio Language Selection for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs'] audio_pid_selection: Audio Pid Selection. See Audio PID Selection for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs'] audio_track_selection: Audio Track Selection. See Audio Track Selection for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_hls_rendition_selection=audio_hls_rendition_selection,
            audio_language_selection=audio_language_selection,
            audio_pid_selection=audio_pid_selection,
            audio_track_selection=audio_track_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_hls_rendition_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs']] = None,
             audio_language_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']] = None,
             audio_pid_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs']] = None,
             audio_track_selection: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_hls_rendition_selection is None and 'audioHlsRenditionSelection' in kwargs:
            audio_hls_rendition_selection = kwargs['audioHlsRenditionSelection']
        if audio_language_selection is None and 'audioLanguageSelection' in kwargs:
            audio_language_selection = kwargs['audioLanguageSelection']
        if audio_pid_selection is None and 'audioPidSelection' in kwargs:
            audio_pid_selection = kwargs['audioPidSelection']
        if audio_track_selection is None and 'audioTrackSelection' in kwargs:
            audio_track_selection = kwargs['audioTrackSelection']

        if audio_hls_rendition_selection is not None:
            _setter("audio_hls_rendition_selection", audio_hls_rendition_selection)
        if audio_language_selection is not None:
            _setter("audio_language_selection", audio_language_selection)
        if audio_pid_selection is not None:
            _setter("audio_pid_selection", audio_pid_selection)
        if audio_track_selection is not None:
            _setter("audio_track_selection", audio_track_selection)

    @property
    @pulumi.getter(name="audioHlsRenditionSelection")
    def audio_hls_rendition_selection(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs']]:
        """
        Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details.
        """
        return pulumi.get(self, "audio_hls_rendition_selection")

    @audio_hls_rendition_selection.setter
    def audio_hls_rendition_selection(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs']]):
        pulumi.set(self, "audio_hls_rendition_selection", value)

    @property
    @pulumi.getter(name="audioLanguageSelection")
    def audio_language_selection(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']]:
        """
        Audio Language Selection. See Audio Language Selection for more details.
        """
        return pulumi.get(self, "audio_language_selection")

    @audio_language_selection.setter
    def audio_language_selection(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']]):
        pulumi.set(self, "audio_language_selection", value)

    @property
    @pulumi.getter(name="audioPidSelection")
    def audio_pid_selection(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs']]:
        """
        Audio Pid Selection. See Audio PID Selection for more details.
        """
        return pulumi.get(self, "audio_pid_selection")

    @audio_pid_selection.setter
    def audio_pid_selection(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs']]):
        pulumi.set(self, "audio_pid_selection", value)

    @property
    @pulumi.getter(name="audioTrackSelection")
    def audio_track_selection(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs']]:
        """
        Audio Track Selection. See Audio Track Selection for more details.
        """
        return pulumi.get(self, "audio_track_selection")

    @audio_track_selection.setter
    def audio_track_selection(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs']]):
        pulumi.set(self, "audio_track_selection", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_id: Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        :param pulumi.Input[str] name: Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("group_id", group_id)
        _setter("name", name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[str]:
        """
        Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[str],
                 language_selection_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] language_code: Selects a specific three-letter language code from within an audio source.
        :param pulumi.Input[str] language_selection_policy: When set to strict, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If loose, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it cant find one with the same language.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            language_selection_policy=language_selection_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[pulumi.Input[str]] = None,
             language_selection_policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if language_selection_policy is None and 'languageSelectionPolicy' in kwargs:
            language_selection_policy = kwargs['languageSelectionPolicy']

        _setter("language_code", language_code)
        if language_selection_policy is not None:
            _setter("language_selection_policy", language_selection_policy)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> Optional[pulumi.Input[str]]:
        """
        When set to strict, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If loose, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it cant find one with the same language.
        """
        return pulumi.get(self, "language_selection_policy")

    @language_selection_policy.setter
    def language_selection_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_selection_policy", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs:
    def __init__(__self__, *,
                 pid: pulumi.Input[int]):
        """
        :param pulumi.Input[int] pid: Selects a specific PID from within a source.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pid: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if pid is None:
            raise TypeError("Missing 'pid' argument")

        _setter("pid", pid)

    @property
    @pulumi.getter
    def pid(self) -> pulumi.Input[int]:
        """
        Selects a specific PID from within a source.
        """
        return pulumi.get(self, "pid")

    @pid.setter
    def pid(self, value: pulumi.Input[int]):
        pulumi.set(self, "pid", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs:
    def __init__(__self__, *,
                 tracks: pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs']]],
                 dolby_e_decode: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs']]] tracks: Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs'] dolby_e_decode: Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tracks=tracks,
            dolby_e_decode=dolby_e_decode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tracks: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs']]]] = None,
             dolby_e_decode: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tracks is None:
            raise TypeError("Missing 'tracks' argument")
        if dolby_e_decode is None and 'dolbyEDecode' in kwargs:
            dolby_e_decode = kwargs['dolbyEDecode']

        _setter("tracks", tracks)
        if dolby_e_decode is not None:
            _setter("dolby_e_decode", dolby_e_decode)

    @property
    @pulumi.getter
    def tracks(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs']]]:
        """
        Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
        """
        return pulumi.get(self, "tracks")

    @tracks.setter
    def tracks(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs']]]):
        pulumi.set(self, "tracks", value)

    @property
    @pulumi.getter(name="dolbyEDecode")
    def dolby_e_decode(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs']]:
        """
        Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
        """
        return pulumi.get(self, "dolby_e_decode")

    @dolby_e_decode.setter
    def dolby_e_decode(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs']]):
        pulumi.set(self, "dolby_e_decode", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs:
    def __init__(__self__, *,
                 program_selection: pulumi.Input[str]):
        """
        :param pulumi.Input[str] program_selection: Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. All channels means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            program_selection=program_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             program_selection: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if program_selection is None and 'programSelection' in kwargs:
            program_selection = kwargs['programSelection']
        if program_selection is None:
            raise TypeError("Missing 'program_selection' argument")

        _setter("program_selection", program_selection)

    @property
    @pulumi.getter(name="programSelection")
    def program_selection(self) -> pulumi.Input[str]:
        """
        Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. All channels means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
        """
        return pulumi.get(self, "program_selection")

    @program_selection.setter
    def program_selection(self, value: pulumi.Input[str]):
        pulumi.set(self, "program_selection", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs:
    def __init__(__self__, *,
                 track: pulumi.Input[int]):
        """
        :param pulumi.Input[int] track: 1-based integer value that maps to a specific audio track.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            track=track,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             track: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if track is None:
            raise TypeError("Missing 'track' argument")

        _setter("track", track)

    @property
    @pulumi.getter
    def track(self) -> pulumi.Input[int]:
        """
        1-based integer value that maps to a specific audio track.
        """
        return pulumi.get(self, "track")

    @track.setter
    def track(self, value: pulumi.Input[int]):
        pulumi.set(self, "track", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 language_code: Optional[pulumi.Input[str]] = None,
                 selector_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the Channel.
               
               The following arguments are optional:
        :param pulumi.Input[str] language_code: Selects a specific three-letter language code from within an audio source.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs'] selector_settings: The audio selector settings. See Audio Selector Settings for more details.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            language_code=language_code,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             language_code: Optional[pulumi.Input[str]] = None,
             selector_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if selector_settings is None and 'selectorSettings' in kwargs:
            selector_settings = kwargs['selectorSettings']

        _setter("name", name)
        if language_code is not None:
            _setter("language_code", language_code)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Channel.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[str]]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs']]:
        """
        The audio selector settings. See Audio Selector Settings for more details.
        """
        return pulumi.get(self, "selector_settings")

    @selector_settings.setter
    def selector_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs']]):
        pulumi.set(self, "selector_settings", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs:
    def __init__(__self__, *,
                 ancillary_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs']] = None,
                 arib_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs']] = None,
                 dvb_sub_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs']] = None,
                 embedded_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs']] = None,
                 scte20_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs']] = None,
                 scte27_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs']] = None,
                 teletext_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs']] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs'] ancillary_source_settings: Ancillary Source Settings. See Ancillary Source Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs'] arib_source_settings: ARIB Source Settings.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs'] dvb_sub_source_settings: DVB Sub Source Settings. See DVB Sub Source Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs'] embedded_source_settings: Embedded Source Settings. See Embedded Source Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs'] scte20_source_settings: SCTE20 Source Settings. See SCTE 20 Source Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs'] scte27_source_settings: SCTE27 Source Settings. See SCTE 27 Source Settings for more details.
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs'] teletext_source_settings: Teletext Source Settings. See Teletext Source Settings for more details.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ancillary_source_settings=ancillary_source_settings,
            arib_source_settings=arib_source_settings,
            dvb_sub_source_settings=dvb_sub_source_settings,
            embedded_source_settings=embedded_source_settings,
            scte20_source_settings=scte20_source_settings,
            scte27_source_settings=scte27_source_settings,
            teletext_source_settings=teletext_source_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ancillary_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs']] = None,
             arib_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs']] = None,
             dvb_sub_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs']] = None,
             embedded_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs']] = None,
             scte20_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs']] = None,
             scte27_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs']] = None,
             teletext_source_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ancillary_source_settings is None and 'ancillarySourceSettings' in kwargs:
            ancillary_source_settings = kwargs['ancillarySourceSettings']
        if arib_source_settings is None and 'aribSourceSettings' in kwargs:
            arib_source_settings = kwargs['aribSourceSettings']
        if dvb_sub_source_settings is None and 'dvbSubSourceSettings' in kwargs:
            dvb_sub_source_settings = kwargs['dvbSubSourceSettings']
        if embedded_source_settings is None and 'embeddedSourceSettings' in kwargs:
            embedded_source_settings = kwargs['embeddedSourceSettings']
        if scte20_source_settings is None and 'scte20SourceSettings' in kwargs:
            scte20_source_settings = kwargs['scte20SourceSettings']
        if scte27_source_settings is None and 'scte27SourceSettings' in kwargs:
            scte27_source_settings = kwargs['scte27SourceSettings']
        if teletext_source_settings is None and 'teletextSourceSettings' in kwargs:
            teletext_source_settings = kwargs['teletextSourceSettings']

        if ancillary_source_settings is not None:
            _setter("ancillary_source_settings", ancillary_source_settings)
        if arib_source_settings is not None:
            _setter("arib_source_settings", arib_source_settings)
        if dvb_sub_source_settings is not None:
            _setter("dvb_sub_source_settings", dvb_sub_source_settings)
        if embedded_source_settings is not None:
            _setter("embedded_source_settings", embedded_source_settings)
        if scte20_source_settings is not None:
            _setter("scte20_source_settings", scte20_source_settings)
        if scte27_source_settings is not None:
            _setter("scte27_source_settings", scte27_source_settings)
        if teletext_source_settings is not None:
            _setter("teletext_source_settings", teletext_source_settings)

    @property
    @pulumi.getter(name="ancillarySourceSettings")
    def ancillary_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs']]:
        """
        Ancillary Source Settings. See Ancillary Source Settings for more details.
        """
        return pulumi.get(self, "ancillary_source_settings")

    @ancillary_source_settings.setter
    def ancillary_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs']]):
        pulumi.set(self, "ancillary_source_settings", value)

    @property
    @pulumi.getter(name="aribSourceSettings")
    def arib_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs']]:
        """
        ARIB Source Settings.
        """
        return pulumi.get(self, "arib_source_settings")

    @arib_source_settings.setter
    def arib_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs']]):
        pulumi.set(self, "arib_source_settings", value)

    @property
    @pulumi.getter(name="dvbSubSourceSettings")
    def dvb_sub_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs']]:
        """
        DVB Sub Source Settings. See DVB Sub Source Settings for more details.
        """
        return pulumi.get(self, "dvb_sub_source_settings")

    @dvb_sub_source_settings.setter
    def dvb_sub_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs']]):
        pulumi.set(self, "dvb_sub_source_settings", value)

    @property
    @pulumi.getter(name="embeddedSourceSettings")
    def embedded_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs']]:
        """
        Embedded Source Settings. See Embedded Source Settings for more details.
        """
        return pulumi.get(self, "embedded_source_settings")

    @embedded_source_settings.setter
    def embedded_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs']]):
        pulumi.set(self, "embedded_source_settings", value)

    @property
    @pulumi.getter(name="scte20SourceSettings")
    def scte20_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs']]:
        """
        SCTE20 Source Settings. See SCTE 20 Source Settings for more details.
        """
        return pulumi.get(self, "scte20_source_settings")

    @scte20_source_settings.setter
    def scte20_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs']]):
        pulumi.set(self, "scte20_source_settings", value)

    @property
    @pulumi.getter(name="scte27SourceSettings")
    def scte27_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs']]:
        """
        SCTE27 Source Settings. See SCTE 27 Source Settings for more details.
        """
        return pulumi.get(self, "scte27_source_settings")

    @scte27_source_settings.setter
    def scte27_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs']]):
        pulumi.set(self, "scte27_source_settings", value)

    @property
    @pulumi.getter(name="teletextSourceSettings")
    def teletext_source_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs']]:
        """
        Teletext Source Settings. See Teletext Source Settings for more details.
        """
        return pulumi.get(self, "teletext_source_settings")

    @teletext_source_settings.setter
    def teletext_source_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs']]):
        pulumi.set(self, "teletext_source_settings", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs:
    def __init__(__self__, *,
                 source_ancillary_channel_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] source_ancillary_channel_number: Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_ancillary_channel_number=source_ancillary_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_ancillary_channel_number: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_ancillary_channel_number is None and 'sourceAncillaryChannelNumber' in kwargs:
            source_ancillary_channel_number = kwargs['sourceAncillaryChannelNumber']

        if source_ancillary_channel_number is not None:
            _setter("source_ancillary_channel_number", source_ancillary_channel_number)

    @property
    @pulumi.getter(name="sourceAncillaryChannelNumber")
    def source_ancillary_channel_number(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
        """
        return pulumi.get(self, "source_ancillary_channel_number")

    @source_ancillary_channel_number.setter
    def source_ancillary_channel_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "source_ancillary_channel_number", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs:
    def __init__(__self__, *,
                 ocr_language: Optional[pulumi.Input[str]] = None,
                 pid: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ocr_language: If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        :param pulumi.Input[int] pid: When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[pulumi.Input[str]] = None,
             pid: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ocr_language is None and 'ocrLanguage' in kwargs:
            ocr_language = kwargs['ocrLanguage']

        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[pulumi.Input[str]]:
        """
        If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        """
        return pulumi.get(self, "ocr_language")

    @ocr_language.setter
    def ocr_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ocr_language", value)

    @property
    @pulumi.getter
    def pid(self) -> Optional[pulumi.Input[int]]:
        """
        When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        """
        return pulumi.get(self, "pid")

    @pid.setter
    def pid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pid", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs:
    def __init__(__self__, *,
                 convert608_to708: Optional[pulumi.Input[str]] = None,
                 scte20_detection: Optional[pulumi.Input[str]] = None,
                 source608_channel_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] convert608_to708: If upconvert, 608 data is both passed through via the 608 compatibility bytes fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        :param pulumi.Input[str] scte20_detection: Set to auto to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
        :param pulumi.Input[int] source608_channel_number: Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            scte20_detection=scte20_detection,
            source608_channel_number=source608_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[pulumi.Input[str]] = None,
             scte20_detection: Optional[pulumi.Input[str]] = None,
             source608_channel_number: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if convert608_to708 is None and 'convert608To708' in kwargs:
            convert608_to708 = kwargs['convert608To708']
        if scte20_detection is None and 'scte20Detection' in kwargs:
            scte20_detection = kwargs['scte20Detection']
        if source608_channel_number is None and 'source608ChannelNumber' in kwargs:
            source608_channel_number = kwargs['source608ChannelNumber']

        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if scte20_detection is not None:
            _setter("scte20_detection", scte20_detection)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[pulumi.Input[str]]:
        """
        If upconvert, 608 data is both passed through via the 608 compatibility bytes fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        """
        return pulumi.get(self, "convert608_to708")

    @convert608_to708.setter
    def convert608_to708(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "convert608_to708", value)

    @property
    @pulumi.getter(name="scte20Detection")
    def scte20_detection(self) -> Optional[pulumi.Input[str]]:
        """
        Set to auto to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
        """
        return pulumi.get(self, "scte20_detection")

    @scte20_detection.setter
    def scte20_detection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte20_detection", value)

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        return pulumi.get(self, "source608_channel_number")

    @source608_channel_number.setter
    def source608_channel_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "source608_channel_number", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs:
    def __init__(__self__, *,
                 convert608_to708: Optional[pulumi.Input[str]] = None,
                 source608_channel_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] convert608_to708: If upconvert, 608 data is both passed through via the 608 compatibility bytes fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        :param pulumi.Input[int] source608_channel_number: Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            source608_channel_number=source608_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[pulumi.Input[str]] = None,
             source608_channel_number: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if convert608_to708 is None and 'convert608To708' in kwargs:
            convert608_to708 = kwargs['convert608To708']
        if source608_channel_number is None and 'source608ChannelNumber' in kwargs:
            source608_channel_number = kwargs['source608ChannelNumber']

        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[pulumi.Input[str]]:
        """
        If upconvert, 608 data is both passed through via the 608 compatibility bytes fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        """
        return pulumi.get(self, "convert608_to708")

    @convert608_to708.setter
    def convert608_to708(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "convert608_to708", value)

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        return pulumi.get(self, "source608_channel_number")

    @source608_channel_number.setter
    def source608_channel_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "source608_channel_number", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs:
    def __init__(__self__, *,
                 ocr_language: Optional[pulumi.Input[str]] = None,
                 pid: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ocr_language: If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        :param pulumi.Input[int] pid: Selects a specific PID from within a source.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[pulumi.Input[str]] = None,
             pid: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ocr_language is None and 'ocrLanguage' in kwargs:
            ocr_language = kwargs['ocrLanguage']

        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[pulumi.Input[str]]:
        """
        If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        """
        return pulumi.get(self, "ocr_language")

    @ocr_language.setter
    def ocr_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ocr_language", value)

    @property
    @pulumi.getter
    def pid(self) -> Optional[pulumi.Input[int]]:
        """
        Selects a specific PID from within a source.
        """
        return pulumi.get(self, "pid")

    @pid.setter
    def pid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pid", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs:
    def __init__(__self__, *,
                 output_rectangle: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs']] = None,
                 page_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs'] output_rectangle: Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
        :param pulumi.Input[str] page_number: Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no 0x prefix.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_rectangle=output_rectangle,
            page_number=page_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_rectangle: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs']] = None,
             page_number: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_rectangle is None and 'outputRectangle' in kwargs:
            output_rectangle = kwargs['outputRectangle']
        if page_number is None and 'pageNumber' in kwargs:
            page_number = kwargs['pageNumber']

        if output_rectangle is not None:
            _setter("output_rectangle", output_rectangle)
        if page_number is not None:
            _setter("page_number", page_number)

    @property
    @pulumi.getter(name="outputRectangle")
    def output_rectangle(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs']]:
        """
        Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
        """
        return pulumi.get(self, "output_rectangle")

    @output_rectangle.setter
    def output_rectangle(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs']]):
        pulumi.set(self, "output_rectangle", value)

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no 0x prefix.
        """
        return pulumi.get(self, "page_number")

    @page_number.setter
    def page_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_number", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[float],
                 left_offset: pulumi.Input[float],
                 top_offset: pulumi.Input[float],
                 width: pulumi.Input[float]):
        """
        :param pulumi.Input[float] height: See the description in left\\_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, "80" means the rectangle height is 80% of the underlying frame height. The top\\_offset and rectangle\\_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard.
        :param pulumi.Input[float] left_offset: Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you dont have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, "10" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard.
        :param pulumi.Input[float] top_offset: See the description in left\\_offset. For top\\_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, "10" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard.
        :param pulumi.Input[float] width: See the description in left\\_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, "80" means the rectangle width is 80% of the underlying frame width. The left\\_offset and rectangle\\_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            left_offset=left_offset,
            top_offset=top_offset,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[pulumi.Input[float]] = None,
             left_offset: Optional[pulumi.Input[float]] = None,
             top_offset: Optional[pulumi.Input[float]] = None,
             width: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if height is None:
            raise TypeError("Missing 'height' argument")
        if left_offset is None and 'leftOffset' in kwargs:
            left_offset = kwargs['leftOffset']
        if left_offset is None:
            raise TypeError("Missing 'left_offset' argument")
        if top_offset is None and 'topOffset' in kwargs:
            top_offset = kwargs['topOffset']
        if top_offset is None:
            raise TypeError("Missing 'top_offset' argument")
        if width is None:
            raise TypeError("Missing 'width' argument")

        _setter("height", height)
        _setter("left_offset", left_offset)
        _setter("top_offset", top_offset)
        _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[float]:
        """
        See the description in left\\_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, "80" means the rectangle height is 80% of the underlying frame height. The top\\_offset and rectangle\\_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[float]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="leftOffset")
    def left_offset(self) -> pulumi.Input[float]:
        """
        Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you dont have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, "10" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard.
        """
        return pulumi.get(self, "left_offset")

    @left_offset.setter
    def left_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "left_offset", value)

    @property
    @pulumi.getter(name="topOffset")
    def top_offset(self) -> pulumi.Input[float]:
        """
        See the description in left\\_offset. For top\\_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, "10" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard.
        """
        return pulumi.get(self, "top_offset")

    @top_offset.setter
    def top_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "top_offset", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[float]:
        """
        See the description in left\\_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, "80" means the rectangle width is 80% of the underlying frame width. The left\\_offset and rectangle\\_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[float]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs:
    def __init__(__self__, *,
                 hls_input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs']] = None,
                 server_validation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs'] hls_input_settings: Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
        :param pulumi.Input[str] server_validation: Check HTTPS server certificates.
        """
        ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_input_settings=hls_input_settings,
            server_validation=server_validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_input_settings: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs']] = None,
             server_validation: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_input_settings is None and 'hlsInputSettings' in kwargs:
            hls_input_settings = kwargs['hlsInputSettings']
        if server_validation is None and 'serverValidation' in kwargs:
            server_validation = kwargs['serverValidation']

        if hls_input_settings is not None:
            _setter("hls_input_settings", hls_input_settings)
        if server_validation is not None:
            _setter("server_validation", server_validation)

    @property
    @pulumi.getter(name="hlsInputSettings")
    def hls_input_settings(self) -> Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs']]:
        """
        Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
        """
        return pulumi.get(self, "hls_input_settings")

    @hls_input_settings.setter
    def hls_input_settings(self, value: Optional[pulumi.Input['ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs']]):
        pulumi.set(self, "hls_input_settings", value)

    @property
    @pulumi.getter(name="serverValidation")
    def server_validation(self) -> Optional[pulumi.Input[str]]:
        """
        Check HTTPS server certificates.
        """
        return pulumi.get(self, "server_validation")

    @server_validation.setter
    def server_validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_validation", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs:
    def __init__(__self__, *,
                 bandwidth: Optional[pulumi.Input[int]] = None,
                 buffer_segments: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 retry_interval: Optional[pulumi.Input[int]] = None,
                 scte35_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bandwidth: The bitrate is specified in bits per second, as in an HLS manifest.
        :param pulumi.Input[int] buffer_segments: Buffer segments.
        :param pulumi.Input[int] retries: The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
        :param pulumi.Input[int] retry_interval: The number of seconds between retries when an attempt to read a manifest or segment fails.
        """
        ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bandwidth=bandwidth,
            buffer_segments=buffer_segments,
            retries=retries,
            retry_interval=retry_interval,
            scte35_source=scte35_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bandwidth: Optional[pulumi.Input[int]] = None,
             buffer_segments: Optional[pulumi.Input[int]] = None,
             retries: Optional[pulumi.Input[int]] = None,
             retry_interval: Optional[pulumi.Input[int]] = None,
             scte35_source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if buffer_segments is None and 'bufferSegments' in kwargs:
            buffer_segments = kwargs['bufferSegments']
        if retry_interval is None and 'retryInterval' in kwargs:
            retry_interval = kwargs['retryInterval']
        if scte35_source is None and 'scte35Source' in kwargs:
            scte35_source = kwargs['scte35Source']

        if bandwidth is not None:
            _setter("bandwidth", bandwidth)
        if buffer_segments is not None:
            _setter("buffer_segments", buffer_segments)
        if retries is not None:
            _setter("retries", retries)
        if retry_interval is not None:
            _setter("retry_interval", retry_interval)
        if scte35_source is not None:
            _setter("scte35_source", scte35_source)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        The bitrate is specified in bits per second, as in an HLS manifest.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter(name="bufferSegments")
    def buffer_segments(self) -> Optional[pulumi.Input[int]]:
        """
        Buffer segments.
        """
        return pulumi.get(self, "buffer_segments")

    @buffer_segments.setter
    def buffer_segments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_segments", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between retries when an attempt to read a manifest or segment fails.
        """
        return pulumi.get(self, "retry_interval")

    @retry_interval.setter
    def retry_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_interval", value)

    @property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scte35_source")

    @scte35_source.setter
    def scte35_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scte35_source", value)


@pulumi.input_type
class ChannelInputAttachmentInputSettingsVideoSelectorArgs:
    def __init__(__self__, *,
                 color_space: Optional[pulumi.Input[str]] = None,
                 color_space_usage: Optional[pulumi.Input[str]] = None):
        ChannelInputAttachmentInputSettingsVideoSelectorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space=color_space,
            color_space_usage=color_space_usage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space: Optional[pulumi.Input[str]] = None,
             color_space_usage: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if color_space is None and 'colorSpace' in kwargs:
            color_space = kwargs['colorSpace']
        if color_space_usage is None and 'colorSpaceUsage' in kwargs:
            color_space_usage = kwargs['colorSpaceUsage']

        if color_space is not None:
            _setter("color_space", color_space)
        if color_space_usage is not None:
            _setter("color_space_usage", color_space_usage)

    @property
    @pulumi.getter(name="colorSpace")
    def color_space(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "color_space")

    @color_space.setter
    def color_space(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_space", value)

    @property
    @pulumi.getter(name="colorSpaceUsage")
    def color_space_usage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "color_space_usage")

    @color_space_usage.setter
    def color_space_usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_space_usage", value)


@pulumi.input_type
class ChannelInputSpecificationArgs:
    def __init__(__self__, *,
                 codec: pulumi.Input[str],
                 input_resolution: pulumi.Input[str],
                 maximum_bitrate: pulumi.Input[str]):
        ChannelInputSpecificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            codec=codec,
            input_resolution=input_resolution,
            maximum_bitrate=maximum_bitrate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             codec: Optional[pulumi.Input[str]] = None,
             input_resolution: Optional[pulumi.Input[str]] = None,
             maximum_bitrate: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if codec is None:
            raise TypeError("Missing 'codec' argument")
        if input_resolution is None and 'inputResolution' in kwargs:
            input_resolution = kwargs['inputResolution']
        if input_resolution is None:
            raise TypeError("Missing 'input_resolution' argument")
        if maximum_bitrate is None and 'maximumBitrate' in kwargs:
            maximum_bitrate = kwargs['maximumBitrate']
        if maximum_bitrate is None:
            raise TypeError("Missing 'maximum_bitrate' argument")

        _setter("codec", codec)
        _setter("input_resolution", input_resolution)
        _setter("maximum_bitrate", maximum_bitrate)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="inputResolution")
    def input_resolution(self) -> pulumi.Input[str]:
        return pulumi.get(self, "input_resolution")

    @input_resolution.setter
    def input_resolution(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_resolution", value)

    @property
    @pulumi.getter(name="maximumBitrate")
    def maximum_bitrate(self) -> pulumi.Input[str]:
        return pulumi.get(self, "maximum_bitrate")

    @maximum_bitrate.setter
    def maximum_bitrate(self, value: pulumi.Input[str]):
        pulumi.set(self, "maximum_bitrate", value)


@pulumi.input_type
class ChannelMaintenanceArgs:
    def __init__(__self__, *,
                 maintenance_day: pulumi.Input[str],
                 maintenance_start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] maintenance_day: The day of the week to use for maintenance.
        :param pulumi.Input[str] maintenance_start_time: The hour maintenance will start.
        """
        ChannelMaintenanceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maintenance_day=maintenance_day,
            maintenance_start_time=maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maintenance_day: Optional[pulumi.Input[str]] = None,
             maintenance_start_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maintenance_day is None and 'maintenanceDay' in kwargs:
            maintenance_day = kwargs['maintenanceDay']
        if maintenance_day is None:
            raise TypeError("Missing 'maintenance_day' argument")
        if maintenance_start_time is None and 'maintenanceStartTime' in kwargs:
            maintenance_start_time = kwargs['maintenanceStartTime']
        if maintenance_start_time is None:
            raise TypeError("Missing 'maintenance_start_time' argument")

        _setter("maintenance_day", maintenance_day)
        _setter("maintenance_start_time", maintenance_start_time)

    @property
    @pulumi.getter(name="maintenanceDay")
    def maintenance_day(self) -> pulumi.Input[str]:
        """
        The day of the week to use for maintenance.
        """
        return pulumi.get(self, "maintenance_day")

    @maintenance_day.setter
    def maintenance_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_day", value)

    @property
    @pulumi.getter(name="maintenanceStartTime")
    def maintenance_start_time(self) -> pulumi.Input[str]:
        """
        The hour maintenance will start.
        """
        return pulumi.get(self, "maintenance_start_time")

    @maintenance_start_time.setter
    def maintenance_start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_start_time", value)


@pulumi.input_type
class ChannelVpcArgs:
    def __init__(__self__, *,
                 public_address_allocation_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network_interface_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_address_allocation_ids: List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
        """
        ChannelVpcArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_address_allocation_ids=public_address_allocation_ids,
            subnet_ids=subnet_ids,
            availability_zones=availability_zones,
            network_interface_ids=network_interface_ids,
            security_group_ids=security_group_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_address_allocation_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             network_interface_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_address_allocation_ids is None and 'publicAddressAllocationIds' in kwargs:
            public_address_allocation_ids = kwargs['publicAddressAllocationIds']
        if public_address_allocation_ids is None:
            raise TypeError("Missing 'public_address_allocation_ids' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if network_interface_ids is None and 'networkInterfaceIds' in kwargs:
            network_interface_ids = kwargs['networkInterfaceIds']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']

        _setter("public_address_allocation_ids", public_address_allocation_ids)
        _setter("subnet_ids", subnet_ids)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if network_interface_ids is not None:
            _setter("network_interface_ids", network_interface_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="publicAddressAllocationIds")
    def public_address_allocation_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
        """
        return pulumi.get(self, "public_address_allocation_ids")

    @public_address_allocation_ids.setter
    def public_address_allocation_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "public_address_allocation_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="networkInterfaceIds")
    def network_interface_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "network_interface_ids")

    @network_interface_ids.setter
    def network_interface_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_interface_ids", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


@pulumi.input_type
class InputDestinationArgs:
    def __init__(__self__, *,
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] stream_name: A unique name for the location the RTMP stream is being pushed to.
        """
        InputDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stream_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")

        _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        A unique name for the location the RTMP stream is being pushed to.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


@pulumi.input_type
class InputInputDeviceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The unique ID for the device.
        """
        InputInputDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique ID for the device.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class InputMediaConnectFlowArgs:
    def __init__(__self__, *,
                 flow_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] flow_arn: The ARN of the MediaConnect Flow
        """
        InputMediaConnectFlowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flow_arn=flow_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flow_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if flow_arn is None and 'flowArn' in kwargs:
            flow_arn = kwargs['flowArn']
        if flow_arn is None:
            raise TypeError("Missing 'flow_arn' argument")

        _setter("flow_arn", flow_arn)

    @property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the MediaConnect Flow
        """
        return pulumi.get(self, "flow_arn")

    @flow_arn.setter
    def flow_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "flow_arn", value)


@pulumi.input_type
class InputSecurityGroupWhitelistRuleArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr: The IPv4 CIDR that's whitelisted.
        """
        InputSecurityGroupWhitelistRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")

        _setter("cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[str]:
        """
        The IPv4 CIDR that's whitelisted.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)


@pulumi.input_type
class InputSourceArgs:
    def __init__(__self__, *,
                 password_param: pulumi.Input[str],
                 url: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_param: The key used to extract the password from EC2 Parameter store.
        :param pulumi.Input[str] url: The URL where the stream is pulled from.
        :param pulumi.Input[str] username: The username for the input source.
        """
        InputSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[pulumi.Input[str]] = None,
             url: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']
        if password_param is None:
            raise TypeError("Missing 'password_param' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password_param", password_param)
        _setter("url", url)
        _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> pulumi.Input[str]:
        """
        The key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @password_param.setter
    def password_param(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_param", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL where the stream is pulled from.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username for the input source.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class InputVpcArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of 2 VPC subnet IDs from the same VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: A list of up to 5 EC2 VPC security group IDs to attach to the Input.
        """
        InputVpcArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            security_group_ids=security_group_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']

        _setter("subnet_ids", subnet_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of 2 VPC subnet IDs from the same VPC.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of up to 5 EC2 VPC security group IDs to attach to the Input.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


@pulumi.input_type
class MultiplexMultiplexSettingsArgs:
    def __init__(__self__, *,
                 transport_stream_bitrate: pulumi.Input[int],
                 transport_stream_id: pulumi.Input[int],
                 maximum_video_buffer_delay_milliseconds: Optional[pulumi.Input[int]] = None,
                 transport_stream_reserved_bitrate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] transport_stream_bitrate: Transport stream bit rate.
        :param pulumi.Input[int] transport_stream_id: Unique ID for each multiplex.
        :param pulumi.Input[int] maximum_video_buffer_delay_milliseconds: Maximum video buffer delay.
        :param pulumi.Input[int] transport_stream_reserved_bitrate: Transport stream reserved bit rate.
        """
        MultiplexMultiplexSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            transport_stream_bitrate=transport_stream_bitrate,
            transport_stream_id=transport_stream_id,
            maximum_video_buffer_delay_milliseconds=maximum_video_buffer_delay_milliseconds,
            transport_stream_reserved_bitrate=transport_stream_reserved_bitrate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             transport_stream_bitrate: Optional[pulumi.Input[int]] = None,
             transport_stream_id: Optional[pulumi.Input[int]] = None,
             maximum_video_buffer_delay_milliseconds: Optional[pulumi.Input[int]] = None,
             transport_stream_reserved_bitrate: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if transport_stream_bitrate is None and 'transportStreamBitrate' in kwargs:
            transport_stream_bitrate = kwargs['transportStreamBitrate']
        if transport_stream_bitrate is None:
            raise TypeError("Missing 'transport_stream_bitrate' argument")
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if transport_stream_id is None:
            raise TypeError("Missing 'transport_stream_id' argument")
        if maximum_video_buffer_delay_milliseconds is None and 'maximumVideoBufferDelayMilliseconds' in kwargs:
            maximum_video_buffer_delay_milliseconds = kwargs['maximumVideoBufferDelayMilliseconds']
        if transport_stream_reserved_bitrate is None and 'transportStreamReservedBitrate' in kwargs:
            transport_stream_reserved_bitrate = kwargs['transportStreamReservedBitrate']

        _setter("transport_stream_bitrate", transport_stream_bitrate)
        _setter("transport_stream_id", transport_stream_id)
        if maximum_video_buffer_delay_milliseconds is not None:
            _setter("maximum_video_buffer_delay_milliseconds", maximum_video_buffer_delay_milliseconds)
        if transport_stream_reserved_bitrate is not None:
            _setter("transport_stream_reserved_bitrate", transport_stream_reserved_bitrate)

    @property
    @pulumi.getter(name="transportStreamBitrate")
    def transport_stream_bitrate(self) -> pulumi.Input[int]:
        """
        Transport stream bit rate.
        """
        return pulumi.get(self, "transport_stream_bitrate")

    @transport_stream_bitrate.setter
    def transport_stream_bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "transport_stream_bitrate", value)

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> pulumi.Input[int]:
        """
        Unique ID for each multiplex.
        """
        return pulumi.get(self, "transport_stream_id")

    @transport_stream_id.setter
    def transport_stream_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "transport_stream_id", value)

    @property
    @pulumi.getter(name="maximumVideoBufferDelayMilliseconds")
    def maximum_video_buffer_delay_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum video buffer delay.
        """
        return pulumi.get(self, "maximum_video_buffer_delay_milliseconds")

    @maximum_video_buffer_delay_milliseconds.setter
    def maximum_video_buffer_delay_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_video_buffer_delay_milliseconds", value)

    @property
    @pulumi.getter(name="transportStreamReservedBitrate")
    def transport_stream_reserved_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Transport stream reserved bit rate.
        """
        return pulumi.get(self, "transport_stream_reserved_bitrate")

    @transport_stream_reserved_bitrate.setter
    def transport_stream_reserved_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transport_stream_reserved_bitrate", value)


@pulumi.input_type
class MultiplexProgramMultiplexProgramSettingsArgs:
    def __init__(__self__, *,
                 preferred_channel_pipeline: pulumi.Input[str],
                 program_number: pulumi.Input[int],
                 service_descriptor: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs']] = None,
                 video_settings: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs']] = None):
        """
        :param pulumi.Input[str] preferred_channel_pipeline: Enum for preferred channel pipeline. Options are `CURRENTLY_ACTIVE`, `PIPELINE_0`, or `PIPELINE_1`.
        :param pulumi.Input[int] program_number: Unique program number.
        :param pulumi.Input['MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs'] service_descriptor: Service Descriptor. See Service Descriptor for more details.
        :param pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs'] video_settings: Video settings. See Video Settings for more details.
        """
        MultiplexProgramMultiplexProgramSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preferred_channel_pipeline=preferred_channel_pipeline,
            program_number=program_number,
            service_descriptor=service_descriptor,
            video_settings=video_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preferred_channel_pipeline: Optional[pulumi.Input[str]] = None,
             program_number: Optional[pulumi.Input[int]] = None,
             service_descriptor: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs']] = None,
             video_settings: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if preferred_channel_pipeline is None and 'preferredChannelPipeline' in kwargs:
            preferred_channel_pipeline = kwargs['preferredChannelPipeline']
        if preferred_channel_pipeline is None:
            raise TypeError("Missing 'preferred_channel_pipeline' argument")
        if program_number is None and 'programNumber' in kwargs:
            program_number = kwargs['programNumber']
        if program_number is None:
            raise TypeError("Missing 'program_number' argument")
        if service_descriptor is None and 'serviceDescriptor' in kwargs:
            service_descriptor = kwargs['serviceDescriptor']
        if video_settings is None and 'videoSettings' in kwargs:
            video_settings = kwargs['videoSettings']

        _setter("preferred_channel_pipeline", preferred_channel_pipeline)
        _setter("program_number", program_number)
        if service_descriptor is not None:
            _setter("service_descriptor", service_descriptor)
        if video_settings is not None:
            _setter("video_settings", video_settings)

    @property
    @pulumi.getter(name="preferredChannelPipeline")
    def preferred_channel_pipeline(self) -> pulumi.Input[str]:
        """
        Enum for preferred channel pipeline. Options are `CURRENTLY_ACTIVE`, `PIPELINE_0`, or `PIPELINE_1`.
        """
        return pulumi.get(self, "preferred_channel_pipeline")

    @preferred_channel_pipeline.setter
    def preferred_channel_pipeline(self, value: pulumi.Input[str]):
        pulumi.set(self, "preferred_channel_pipeline", value)

    @property
    @pulumi.getter(name="programNumber")
    def program_number(self) -> pulumi.Input[int]:
        """
        Unique program number.
        """
        return pulumi.get(self, "program_number")

    @program_number.setter
    def program_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "program_number", value)

    @property
    @pulumi.getter(name="serviceDescriptor")
    def service_descriptor(self) -> Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs']]:
        """
        Service Descriptor. See Service Descriptor for more details.
        """
        return pulumi.get(self, "service_descriptor")

    @service_descriptor.setter
    def service_descriptor(self, value: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs']]):
        pulumi.set(self, "service_descriptor", value)

    @property
    @pulumi.getter(name="videoSettings")
    def video_settings(self) -> Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs']]:
        """
        Video settings. See Video Settings for more details.
        """
        return pulumi.get(self, "video_settings")

    @video_settings.setter
    def video_settings(self, value: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs']]):
        pulumi.set(self, "video_settings", value)


@pulumi.input_type
class MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs:
    def __init__(__self__, *,
                 provider_name: pulumi.Input[str],
                 service_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] provider_name: Unique provider name.
        :param pulumi.Input[str] service_name: Unique service name.
        """
        MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provider_name=provider_name,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provider_name: Optional[pulumi.Input[str]] = None,
             service_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provider_name is None and 'providerName' in kwargs:
            provider_name = kwargs['providerName']
        if provider_name is None:
            raise TypeError("Missing 'provider_name' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("provider_name", provider_name)
        _setter("service_name", service_name)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> pulumi.Input[str]:
        """
        Unique provider name.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Unique service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs:
    def __init__(__self__, *,
                 constant_bitrate: Optional[pulumi.Input[int]] = None,
                 statmux_settings: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs']] = None):
        """
        :param pulumi.Input[int] constant_bitrate: Constant bitrate value.
        :param pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs'] statmux_settings: Statmux settings. See Statmux Settings for more details.
        """
        MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant_bitrate=constant_bitrate,
            statmux_settings=statmux_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant_bitrate: Optional[pulumi.Input[int]] = None,
             statmux_settings: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if constant_bitrate is None and 'constantBitrate' in kwargs:
            constant_bitrate = kwargs['constantBitrate']
        if statmux_settings is None and 'statmuxSettings' in kwargs:
            statmux_settings = kwargs['statmuxSettings']

        if constant_bitrate is not None:
            _setter("constant_bitrate", constant_bitrate)
        if statmux_settings is not None:
            _setter("statmux_settings", statmux_settings)

    @property
    @pulumi.getter(name="constantBitrate")
    def constant_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Constant bitrate value.
        """
        return pulumi.get(self, "constant_bitrate")

    @constant_bitrate.setter
    def constant_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "constant_bitrate", value)

    @property
    @pulumi.getter(name="statmuxSettings")
    def statmux_settings(self) -> Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs']]:
        """
        Statmux settings. See Statmux Settings for more details.
        """
        return pulumi.get(self, "statmux_settings")

    @statmux_settings.setter
    def statmux_settings(self, value: Optional[pulumi.Input['MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs']]):
        pulumi.set(self, "statmux_settings", value)


@pulumi.input_type
class MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs:
    def __init__(__self__, *,
                 maximum_bitrate: Optional[pulumi.Input[int]] = None,
                 minimum_bitrate: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] maximum_bitrate: Maximum bitrate.
        :param pulumi.Input[int] minimum_bitrate: Minimum bitrate.
        :param pulumi.Input[int] priority: Priority value.
        """
        MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_bitrate=maximum_bitrate,
            minimum_bitrate=minimum_bitrate,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_bitrate: Optional[pulumi.Input[int]] = None,
             minimum_bitrate: Optional[pulumi.Input[int]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_bitrate is None and 'maximumBitrate' in kwargs:
            maximum_bitrate = kwargs['maximumBitrate']
        if minimum_bitrate is None and 'minimumBitrate' in kwargs:
            minimum_bitrate = kwargs['minimumBitrate']

        if maximum_bitrate is not None:
            _setter("maximum_bitrate", maximum_bitrate)
        if minimum_bitrate is not None:
            _setter("minimum_bitrate", minimum_bitrate)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="maximumBitrate")
    def maximum_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum bitrate.
        """
        return pulumi.get(self, "maximum_bitrate")

    @maximum_bitrate.setter
    def maximum_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_bitrate", value)

    @property
    @pulumi.getter(name="minimumBitrate")
    def minimum_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum bitrate.
        """
        return pulumi.get(self, "minimum_bitrate")

    @minimum_bitrate.setter
    def minimum_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_bitrate", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority value.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


