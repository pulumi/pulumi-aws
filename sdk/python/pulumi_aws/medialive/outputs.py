# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ChannelCdiInputSpecification',
    'ChannelDestination',
    'ChannelDestinationMediaPackageSetting',
    'ChannelDestinationMultiplexSettings',
    'ChannelDestinationSetting',
    'ChannelEncoderSettings',
    'ChannelEncoderSettingsAudioDescription',
    'ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings',
    'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting',
    'ChannelEncoderSettingsAudioDescriptionCodecSettings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings',
    'ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings',
    'ChannelEncoderSettingsAudioDescriptionRemixSettings',
    'ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping',
    'ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel',
    'ChannelEncoderSettingsAvailBlanking',
    'ChannelEncoderSettingsAvailBlankingAvailBlankingImage',
    'ChannelEncoderSettingsCaptionDescription',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings',
    'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings',
    'ChannelEncoderSettingsGlobalConfiguration',
    'ChannelEncoderSettingsGlobalConfigurationInputLossBehavior',
    'ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate',
    'ChannelEncoderSettingsMotionGraphicsConfiguration',
    'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings',
    'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings',
    'ChannelEncoderSettingsNielsenConfiguration',
    'ChannelEncoderSettingsOutputGroup',
    'ChannelEncoderSettingsOutputGroupOutput',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination',
    'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings',
    'ChannelEncoderSettingsTimecodeConfig',
    'ChannelEncoderSettingsVideoDescription',
    'ChannelEncoderSettingsVideoDescriptionCodecSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings',
    'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings',
    'ChannelInputAttachment',
    'ChannelInputAttachmentAutomaticInputFailoverSettings',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings',
    'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings',
    'ChannelInputAttachmentInputSettings',
    'ChannelInputAttachmentInputSettingsAudioSelector',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode',
    'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack',
    'ChannelInputAttachmentInputSettingsCaptionSelector',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings',
    'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle',
    'ChannelInputAttachmentInputSettingsNetworkInputSettings',
    'ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings',
    'ChannelInputAttachmentInputSettingsVideoSelector',
    'ChannelInputSpecification',
    'ChannelMaintenance',
    'ChannelVpc',
    'InputDestination',
    'InputInputDevice',
    'InputMediaConnectFlow',
    'InputSecurityGroupWhitelistRule',
    'InputSource',
    'InputVpc',
    'MultiplexMultiplexSettings',
    'MultiplexProgramMultiplexProgramSettings',
    'MultiplexProgramMultiplexProgramSettingsServiceDescriptor',
    'MultiplexProgramMultiplexProgramSettingsVideoSettings',
    'MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings',
]

@pulumi.output_type
class ChannelCdiInputSpecification(dict):
    def __init__(__self__, *,
                 resolution: str):
        """
        :param str resolution: Maximum CDI input resolution.
        """
        ChannelCdiInputSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resolution is None:
            raise TypeError("Missing 'resolution' argument")

        _setter("resolution", resolution)

    @property
    @pulumi.getter
    def resolution(self) -> str:
        """
        Maximum CDI input resolution.
        """
        return pulumi.get(self, "resolution")


@pulumi.output_type
class ChannelDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaPackageSettings":
            suggest = "media_package_settings"
        elif key == "multiplexSettings":
            suggest = "multiplex_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 media_package_settings: Optional[Sequence['outputs.ChannelDestinationMediaPackageSetting']] = None,
                 multiplex_settings: Optional['outputs.ChannelDestinationMultiplexSettings'] = None,
                 settings: Optional[Sequence['outputs.ChannelDestinationSetting']] = None):
        """
        :param str id: User-specified id. Ths is used in an output group or an output.
        :param Sequence['ChannelDestinationMediaPackageSettingArgs'] media_package_settings: Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
        :param 'ChannelDestinationMultiplexSettingsArgs' multiplex_settings: Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
        :param Sequence['ChannelDestinationSettingArgs'] settings: Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
        """
        ChannelDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            media_package_settings=media_package_settings,
            multiplex_settings=multiplex_settings,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             media_package_settings: Optional[Sequence['outputs.ChannelDestinationMediaPackageSetting']] = None,
             multiplex_settings: Optional['outputs.ChannelDestinationMultiplexSettings'] = None,
             settings: Optional[Sequence['outputs.ChannelDestinationSetting']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if media_package_settings is None and 'mediaPackageSettings' in kwargs:
            media_package_settings = kwargs['mediaPackageSettings']
        if multiplex_settings is None and 'multiplexSettings' in kwargs:
            multiplex_settings = kwargs['multiplexSettings']

        _setter("id", id)
        if media_package_settings is not None:
            _setter("media_package_settings", media_package_settings)
        if multiplex_settings is not None:
            _setter("multiplex_settings", multiplex_settings)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        User-specified id. Ths is used in an output group or an output.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mediaPackageSettings")
    def media_package_settings(self) -> Optional[Sequence['outputs.ChannelDestinationMediaPackageSetting']]:
        """
        Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
        """
        return pulumi.get(self, "media_package_settings")

    @property
    @pulumi.getter(name="multiplexSettings")
    def multiplex_settings(self) -> Optional['outputs.ChannelDestinationMultiplexSettings']:
        """
        Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
        """
        return pulumi.get(self, "multiplex_settings")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.ChannelDestinationSetting']]:
        """
        Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ChannelDestinationMediaPackageSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDestinationMediaPackageSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDestinationMediaPackageSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDestinationMediaPackageSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: str):
        """
        :param str channel_id: ID of the channel in MediaPackage that is the destination for this output group.
        """
        ChannelDestinationMediaPackageSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_id=channel_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_id is None and 'channelId' in kwargs:
            channel_id = kwargs['channelId']
        if channel_id is None:
            raise TypeError("Missing 'channel_id' argument")

        _setter("channel_id", channel_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> str:
        """
        ID of the channel in MediaPackage that is the destination for this output group.
        """
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class ChannelDestinationMultiplexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiplexId":
            suggest = "multiplex_id"
        elif key == "programName":
            suggest = "program_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDestinationMultiplexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDestinationMultiplexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDestinationMultiplexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiplex_id: str,
                 program_name: str):
        """
        :param str multiplex_id: The ID of the Multiplex that the encoder is providing output to.
        :param str program_name: The program name of the Multiplex program that the encoder is providing output to.
        """
        ChannelDestinationMultiplexSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            multiplex_id=multiplex_id,
            program_name=program_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             multiplex_id: Optional[str] = None,
             program_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if multiplex_id is None and 'multiplexId' in kwargs:
            multiplex_id = kwargs['multiplexId']
        if multiplex_id is None:
            raise TypeError("Missing 'multiplex_id' argument")
        if program_name is None and 'programName' in kwargs:
            program_name = kwargs['programName']
        if program_name is None:
            raise TypeError("Missing 'program_name' argument")

        _setter("multiplex_id", multiplex_id)
        _setter("program_name", program_name)

    @property
    @pulumi.getter(name="multiplexId")
    def multiplex_id(self) -> str:
        """
        The ID of the Multiplex that the encoder is providing output to.
        """
        return pulumi.get(self, "multiplex_id")

    @property
    @pulumi.getter(name="programName")
    def program_name(self) -> str:
        """
        The program name of the Multiplex program that the encoder is providing output to.
        """
        return pulumi.get(self, "program_name")


@pulumi.output_type
class ChannelDestinationSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDestinationSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDestinationSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDestinationSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_param: Optional[str] = None,
                 stream_name: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str stream_name: Stream name RTMP destinations (URLs of type rtmp://)
        :param str url: A URL specifying a destination.
        :param str username: Username for destination.
        """
        ChannelDestinationSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            stream_name=stream_name,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[str] = None,
             stream_name: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']

        if password_param is not None:
            _setter("password_param", password_param)
        if stream_name is not None:
            _setter("stream_name", stream_name)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        """
        Stream name RTMP destinations (URLs of type rtmp://)
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A URL specifying a destination.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for destination.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputGroups":
            suggest = "output_groups"
        elif key == "timecodeConfig":
            suggest = "timecode_config"
        elif key == "audioDescriptions":
            suggest = "audio_descriptions"
        elif key == "availBlanking":
            suggest = "avail_blanking"
        elif key == "captionDescriptions":
            suggest = "caption_descriptions"
        elif key == "globalConfiguration":
            suggest = "global_configuration"
        elif key == "motionGraphicsConfiguration":
            suggest = "motion_graphics_configuration"
        elif key == "nielsenConfiguration":
            suggest = "nielsen_configuration"
        elif key == "videoDescriptions":
            suggest = "video_descriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_groups: Sequence['outputs.ChannelEncoderSettingsOutputGroup'],
                 timecode_config: 'outputs.ChannelEncoderSettingsTimecodeConfig',
                 audio_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescription']] = None,
                 avail_blanking: Optional['outputs.ChannelEncoderSettingsAvailBlanking'] = None,
                 caption_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsCaptionDescription']] = None,
                 global_configuration: Optional['outputs.ChannelEncoderSettingsGlobalConfiguration'] = None,
                 motion_graphics_configuration: Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfiguration'] = None,
                 nielsen_configuration: Optional['outputs.ChannelEncoderSettingsNielsenConfiguration'] = None,
                 video_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsVideoDescription']] = None):
        """
        :param Sequence['ChannelEncoderSettingsOutputGroupArgs'] output_groups: Output groups for the channel. See Output Groups for more details.
        :param 'ChannelEncoderSettingsTimecodeConfigArgs' timecode_config: Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
        :param Sequence['ChannelEncoderSettingsAudioDescriptionArgs'] audio_descriptions: Audio descriptions for the channel. See Audio Descriptions for more details.
        :param 'ChannelEncoderSettingsAvailBlankingArgs' avail_blanking: Settings for ad avail blanking. See Avail Blanking for more details.
        :param Sequence['ChannelEncoderSettingsCaptionDescriptionArgs'] caption_descriptions: Caption Descriptions. See Caption Descriptions for more details.
        :param 'ChannelEncoderSettingsGlobalConfigurationArgs' global_configuration: Configuration settings that apply to the event as a whole. See Global Configuration for more details.
        :param 'ChannelEncoderSettingsMotionGraphicsConfigurationArgs' motion_graphics_configuration: Settings for motion graphics. See Motion Graphics Configuration for more details.
        :param 'ChannelEncoderSettingsNielsenConfigurationArgs' nielsen_configuration: Nielsen configuration settings. See Nielsen Configuration for more details.
        :param Sequence['ChannelEncoderSettingsVideoDescriptionArgs'] video_descriptions: Video Descriptions. See Video Descriptions for more details.
        """
        ChannelEncoderSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_groups=output_groups,
            timecode_config=timecode_config,
            audio_descriptions=audio_descriptions,
            avail_blanking=avail_blanking,
            caption_descriptions=caption_descriptions,
            global_configuration=global_configuration,
            motion_graphics_configuration=motion_graphics_configuration,
            nielsen_configuration=nielsen_configuration,
            video_descriptions=video_descriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_groups: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroup']] = None,
             timecode_config: Optional['outputs.ChannelEncoderSettingsTimecodeConfig'] = None,
             audio_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescription']] = None,
             avail_blanking: Optional['outputs.ChannelEncoderSettingsAvailBlanking'] = None,
             caption_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsCaptionDescription']] = None,
             global_configuration: Optional['outputs.ChannelEncoderSettingsGlobalConfiguration'] = None,
             motion_graphics_configuration: Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfiguration'] = None,
             nielsen_configuration: Optional['outputs.ChannelEncoderSettingsNielsenConfiguration'] = None,
             video_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsVideoDescription']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_groups is None and 'outputGroups' in kwargs:
            output_groups = kwargs['outputGroups']
        if output_groups is None:
            raise TypeError("Missing 'output_groups' argument")
        if timecode_config is None and 'timecodeConfig' in kwargs:
            timecode_config = kwargs['timecodeConfig']
        if timecode_config is None:
            raise TypeError("Missing 'timecode_config' argument")
        if audio_descriptions is None and 'audioDescriptions' in kwargs:
            audio_descriptions = kwargs['audioDescriptions']
        if avail_blanking is None and 'availBlanking' in kwargs:
            avail_blanking = kwargs['availBlanking']
        if caption_descriptions is None and 'captionDescriptions' in kwargs:
            caption_descriptions = kwargs['captionDescriptions']
        if global_configuration is None and 'globalConfiguration' in kwargs:
            global_configuration = kwargs['globalConfiguration']
        if motion_graphics_configuration is None and 'motionGraphicsConfiguration' in kwargs:
            motion_graphics_configuration = kwargs['motionGraphicsConfiguration']
        if nielsen_configuration is None and 'nielsenConfiguration' in kwargs:
            nielsen_configuration = kwargs['nielsenConfiguration']
        if video_descriptions is None and 'videoDescriptions' in kwargs:
            video_descriptions = kwargs['videoDescriptions']

        _setter("output_groups", output_groups)
        _setter("timecode_config", timecode_config)
        if audio_descriptions is not None:
            _setter("audio_descriptions", audio_descriptions)
        if avail_blanking is not None:
            _setter("avail_blanking", avail_blanking)
        if caption_descriptions is not None:
            _setter("caption_descriptions", caption_descriptions)
        if global_configuration is not None:
            _setter("global_configuration", global_configuration)
        if motion_graphics_configuration is not None:
            _setter("motion_graphics_configuration", motion_graphics_configuration)
        if nielsen_configuration is not None:
            _setter("nielsen_configuration", nielsen_configuration)
        if video_descriptions is not None:
            _setter("video_descriptions", video_descriptions)

    @property
    @pulumi.getter(name="outputGroups")
    def output_groups(self) -> Sequence['outputs.ChannelEncoderSettingsOutputGroup']:
        """
        Output groups for the channel. See Output Groups for more details.
        """
        return pulumi.get(self, "output_groups")

    @property
    @pulumi.getter(name="timecodeConfig")
    def timecode_config(self) -> 'outputs.ChannelEncoderSettingsTimecodeConfig':
        """
        Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
        """
        return pulumi.get(self, "timecode_config")

    @property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescription']]:
        """
        Audio descriptions for the channel. See Audio Descriptions for more details.
        """
        return pulumi.get(self, "audio_descriptions")

    @property
    @pulumi.getter(name="availBlanking")
    def avail_blanking(self) -> Optional['outputs.ChannelEncoderSettingsAvailBlanking']:
        """
        Settings for ad avail blanking. See Avail Blanking for more details.
        """
        return pulumi.get(self, "avail_blanking")

    @property
    @pulumi.getter(name="captionDescriptions")
    def caption_descriptions(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsCaptionDescription']]:
        """
        Caption Descriptions. See Caption Descriptions for more details.
        """
        return pulumi.get(self, "caption_descriptions")

    @property
    @pulumi.getter(name="globalConfiguration")
    def global_configuration(self) -> Optional['outputs.ChannelEncoderSettingsGlobalConfiguration']:
        """
        Configuration settings that apply to the event as a whole. See Global Configuration for more details.
        """
        return pulumi.get(self, "global_configuration")

    @property
    @pulumi.getter(name="motionGraphicsConfiguration")
    def motion_graphics_configuration(self) -> Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfiguration']:
        """
        Settings for motion graphics. See Motion Graphics Configuration for more details.
        """
        return pulumi.get(self, "motion_graphics_configuration")

    @property
    @pulumi.getter(name="nielsenConfiguration")
    def nielsen_configuration(self) -> Optional['outputs.ChannelEncoderSettingsNielsenConfiguration']:
        """
        Nielsen configuration settings. See Nielsen Configuration for more details.
        """
        return pulumi.get(self, "nielsen_configuration")

    @property
    @pulumi.getter(name="videoDescriptions")
    def video_descriptions(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsVideoDescription']]:
        """
        Video Descriptions. See Video Descriptions for more details.
        """
        return pulumi.get(self, "video_descriptions")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectorName":
            suggest = "audio_selector_name"
        elif key == "audioNormalizationSettings":
            suggest = "audio_normalization_settings"
        elif key == "audioType":
            suggest = "audio_type"
        elif key == "audioTypeControl":
            suggest = "audio_type_control"
        elif key == "audioWatermarkSettings":
            suggest = "audio_watermark_settings"
        elif key == "codecSettings":
            suggest = "codec_settings"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageCodeControl":
            suggest = "language_code_control"
        elif key == "remixSettings":
            suggest = "remix_settings"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selector_name: str,
                 name: str,
                 audio_normalization_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings'] = None,
                 audio_type: Optional[str] = None,
                 audio_type_control: Optional[str] = None,
                 audio_watermark_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings'] = None,
                 codec_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettings'] = None,
                 language_code: Optional[str] = None,
                 language_code_control: Optional[str] = None,
                 remix_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettings'] = None,
                 stream_name: Optional[str] = None):
        """
        :param str audio_selector_name: The name of the audio selector used as the source for this AudioDescription.
        :param str name: The name of this audio description.
        :param 'ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettingsArgs' audio_normalization_settings: Advanced audio normalization settings. See Audio Normalization Settings for more details.
        :param str audio_type: Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
        :param str audio_type_control: Determined how audio type is determined.
        :param 'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsArgs' audio_watermark_settings: Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
        :param 'ChannelEncoderSettingsAudioDescriptionCodecSettingsArgs' codec_settings: Audio codec settings. See Audio Codec Settings for more details.
        :param str language_code: Selects a specific three-letter language code from within an audio source.
        :param str stream_name: Stream name RTMP destinations (URLs of type rtmp://)
        """
        ChannelEncoderSettingsAudioDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selector_name=audio_selector_name,
            name=name,
            audio_normalization_settings=audio_normalization_settings,
            audio_type=audio_type,
            audio_type_control=audio_type_control,
            audio_watermark_settings=audio_watermark_settings,
            codec_settings=codec_settings,
            language_code=language_code,
            language_code_control=language_code_control,
            remix_settings=remix_settings,
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selector_name: Optional[str] = None,
             name: Optional[str] = None,
             audio_normalization_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings'] = None,
             audio_type: Optional[str] = None,
             audio_type_control: Optional[str] = None,
             audio_watermark_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings'] = None,
             codec_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettings'] = None,
             language_code: Optional[str] = None,
             language_code_control: Optional[str] = None,
             remix_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettings'] = None,
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selector_name is None and 'audioSelectorName' in kwargs:
            audio_selector_name = kwargs['audioSelectorName']
        if audio_selector_name is None:
            raise TypeError("Missing 'audio_selector_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if audio_normalization_settings is None and 'audioNormalizationSettings' in kwargs:
            audio_normalization_settings = kwargs['audioNormalizationSettings']
        if audio_type is None and 'audioType' in kwargs:
            audio_type = kwargs['audioType']
        if audio_type_control is None and 'audioTypeControl' in kwargs:
            audio_type_control = kwargs['audioTypeControl']
        if audio_watermark_settings is None and 'audioWatermarkSettings' in kwargs:
            audio_watermark_settings = kwargs['audioWatermarkSettings']
        if codec_settings is None and 'codecSettings' in kwargs:
            codec_settings = kwargs['codecSettings']
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code_control is None and 'languageCodeControl' in kwargs:
            language_code_control = kwargs['languageCodeControl']
        if remix_settings is None and 'remixSettings' in kwargs:
            remix_settings = kwargs['remixSettings']
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']

        _setter("audio_selector_name", audio_selector_name)
        _setter("name", name)
        if audio_normalization_settings is not None:
            _setter("audio_normalization_settings", audio_normalization_settings)
        if audio_type is not None:
            _setter("audio_type", audio_type)
        if audio_type_control is not None:
            _setter("audio_type_control", audio_type_control)
        if audio_watermark_settings is not None:
            _setter("audio_watermark_settings", audio_watermark_settings)
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_code_control is not None:
            _setter("language_code_control", language_code_control)
        if remix_settings is not None:
            _setter("remix_settings", remix_settings)
        if stream_name is not None:
            _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> str:
        """
        The name of the audio selector used as the source for this AudioDescription.
        """
        return pulumi.get(self, "audio_selector_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this audio description.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="audioNormalizationSettings")
    def audio_normalization_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings']:
        """
        Advanced audio normalization settings. See Audio Normalization Settings for more details.
        """
        return pulumi.get(self, "audio_normalization_settings")

    @property
    @pulumi.getter(name="audioType")
    def audio_type(self) -> Optional[str]:
        """
        Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
        """
        return pulumi.get(self, "audio_type")

    @property
    @pulumi.getter(name="audioTypeControl")
    def audio_type_control(self) -> Optional[str]:
        """
        Determined how audio type is determined.
        """
        return pulumi.get(self, "audio_type_control")

    @property
    @pulumi.getter(name="audioWatermarkSettings")
    def audio_watermark_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings']:
        """
        Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
        """
        return pulumi.get(self, "audio_watermark_settings")

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettings']:
        """
        Audio codec settings. See Audio Codec Settings for more details.
        """
        return pulumi.get(self, "codec_settings")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> Optional[str]:
        return pulumi.get(self, "language_code_control")

    @property
    @pulumi.getter(name="remixSettings")
    def remix_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettings']:
        return pulumi.get(self, "remix_settings")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        """
        Stream name RTMP destinations (URLs of type rtmp://)
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "algorithmControl":
            suggest = "algorithm_control"
        elif key == "targetLkfs":
            suggest = "target_lkfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 algorithm_control: Optional[str] = None,
                 target_lkfs: Optional[float] = None):
        """
        :param str algorithm: Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
        :param str algorithm_control: Algorithm control for the audio description.
        :param float target_lkfs: Target LKFS (loudness) to adjust volume to.
        """
        ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            algorithm_control=algorithm_control,
            target_lkfs=target_lkfs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[str] = None,
             algorithm_control: Optional[str] = None,
             target_lkfs: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if algorithm_control is None and 'algorithmControl' in kwargs:
            algorithm_control = kwargs['algorithmControl']
        if target_lkfs is None and 'targetLkfs' in kwargs:
            target_lkfs = kwargs['targetLkfs']

        if algorithm is not None:
            _setter("algorithm", algorithm)
        if algorithm_control is not None:
            _setter("algorithm_control", algorithm_control)
        if target_lkfs is not None:
            _setter("target_lkfs", target_lkfs)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        """
        Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="algorithmControl")
    def algorithm_control(self) -> Optional[str]:
        """
        Algorithm control for the audio description.
        """
        return pulumi.get(self, "algorithm_control")

    @property
    @pulumi.getter(name="targetLkfs")
    def target_lkfs(self) -> Optional[float]:
        """
        Target LKFS (loudness) to adjust volume to.
        """
        return pulumi.get(self, "target_lkfs")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nielsenWatermarksSettings":
            suggest = "nielsen_watermarks_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nielsen_watermarks_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings'] = None):
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_watermarks_settings=nielsen_watermarks_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_watermarks_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if nielsen_watermarks_settings is None and 'nielsenWatermarksSettings' in kwargs:
            nielsen_watermarks_settings = kwargs['nielsenWatermarksSettings']

        if nielsen_watermarks_settings is not None:
            _setter("nielsen_watermarks_settings", nielsen_watermarks_settings)

    @property
    @pulumi.getter(name="nielsenWatermarksSettings")
    def nielsen_watermarks_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings']:
        return pulumi.get(self, "nielsen_watermarks_settings")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nielsenCbetSettings":
            suggest = "nielsen_cbet_settings"
        elif key == "nielsenDistributionType":
            suggest = "nielsen_distribution_type"
        elif key == "nielsenNaesIiNwSettings":
            suggest = "nielsen_naes_ii_nw_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nielsen_cbet_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings'] = None,
                 nielsen_distribution_type: Optional[str] = None,
                 nielsen_naes_ii_nw_settings: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting']] = None):
        """
        :param 'ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettingsArgs' nielsen_cbet_settings: Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
        :param str nielsen_distribution_type: Distribution types to assign to the watermarks. Options are `PROGRAM_CONTENT` and `FINAL_DISTRIBUTOR`.
        :param Sequence['ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettingArgs'] nielsen_naes_ii_nw_settings: Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_cbet_settings=nielsen_cbet_settings,
            nielsen_distribution_type=nielsen_distribution_type,
            nielsen_naes_ii_nw_settings=nielsen_naes_ii_nw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_cbet_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings'] = None,
             nielsen_distribution_type: Optional[str] = None,
             nielsen_naes_ii_nw_settings: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if nielsen_cbet_settings is None and 'nielsenCbetSettings' in kwargs:
            nielsen_cbet_settings = kwargs['nielsenCbetSettings']
        if nielsen_distribution_type is None and 'nielsenDistributionType' in kwargs:
            nielsen_distribution_type = kwargs['nielsenDistributionType']
        if nielsen_naes_ii_nw_settings is None and 'nielsenNaesIiNwSettings' in kwargs:
            nielsen_naes_ii_nw_settings = kwargs['nielsenNaesIiNwSettings']

        if nielsen_cbet_settings is not None:
            _setter("nielsen_cbet_settings", nielsen_cbet_settings)
        if nielsen_distribution_type is not None:
            _setter("nielsen_distribution_type", nielsen_distribution_type)
        if nielsen_naes_ii_nw_settings is not None:
            _setter("nielsen_naes_ii_nw_settings", nielsen_naes_ii_nw_settings)

    @property
    @pulumi.getter(name="nielsenCbetSettings")
    def nielsen_cbet_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings']:
        """
        Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
        """
        return pulumi.get(self, "nielsen_cbet_settings")

    @property
    @pulumi.getter(name="nielsenDistributionType")
    def nielsen_distribution_type(self) -> Optional[str]:
        """
        Distribution types to assign to the watermarks. Options are `PROGRAM_CONTENT` and `FINAL_DISTRIBUTOR`.
        """
        return pulumi.get(self, "nielsen_distribution_type")

    @property
    @pulumi.getter(name="nielsenNaesIiNwSettings")
    def nielsen_naes_ii_nw_settings(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting']]:
        """
        Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
        """
        return pulumi.get(self, "nielsen_naes_ii_nw_settings")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cbetCheckDigitString":
            suggest = "cbet_check_digit_string"
        elif key == "cbetStepaside":
            suggest = "cbet_stepaside"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cbet_check_digit_string: str,
                 cbet_stepaside: str,
                 csid: str):
        """
        :param str cbet_stepaside: Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
        :param str csid: CBET source ID to use in the watermark.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cbet_check_digit_string=cbet_check_digit_string,
            cbet_stepaside=cbet_stepaside,
            csid=csid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cbet_check_digit_string: Optional[str] = None,
             cbet_stepaside: Optional[str] = None,
             csid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cbet_check_digit_string is None and 'cbetCheckDigitString' in kwargs:
            cbet_check_digit_string = kwargs['cbetCheckDigitString']
        if cbet_check_digit_string is None:
            raise TypeError("Missing 'cbet_check_digit_string' argument")
        if cbet_stepaside is None and 'cbetStepaside' in kwargs:
            cbet_stepaside = kwargs['cbetStepaside']
        if cbet_stepaside is None:
            raise TypeError("Missing 'cbet_stepaside' argument")
        if csid is None:
            raise TypeError("Missing 'csid' argument")

        _setter("cbet_check_digit_string", cbet_check_digit_string)
        _setter("cbet_stepaside", cbet_stepaside)
        _setter("csid", csid)

    @property
    @pulumi.getter(name="cbetCheckDigitString")
    def cbet_check_digit_string(self) -> str:
        return pulumi.get(self, "cbet_check_digit_string")

    @property
    @pulumi.getter(name="cbetStepaside")
    def cbet_stepaside(self) -> str:
        """
        Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
        """
        return pulumi.get(self, "cbet_stepaside")

    @property
    @pulumi.getter
    def csid(self) -> str:
        """
        CBET source ID to use in the watermark.
        """
        return pulumi.get(self, "csid")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkDigitString":
            suggest = "check_digit_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_digit_string: str,
                 sid: float):
        """
        :param float sid: The Nielsen Source ID to include in the watermark.
        """
        ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_digit_string=check_digit_string,
            sid=sid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_digit_string: Optional[str] = None,
             sid: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if check_digit_string is None and 'checkDigitString' in kwargs:
            check_digit_string = kwargs['checkDigitString']
        if check_digit_string is None:
            raise TypeError("Missing 'check_digit_string' argument")
        if sid is None:
            raise TypeError("Missing 'sid' argument")

        _setter("check_digit_string", check_digit_string)
        _setter("sid", sid)

    @property
    @pulumi.getter(name="checkDigitString")
    def check_digit_string(self) -> str:
        return pulumi.get(self, "check_digit_string")

    @property
    @pulumi.getter
    def sid(self) -> float:
        """
        The Nielsen Source ID to include in the watermark.
        """
        return pulumi.get(self, "sid")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aacSettings":
            suggest = "aac_settings"
        elif key == "ac3Settings":
            suggest = "ac3_settings"
        elif key == "eac3AtmosSettings":
            suggest = "eac3_atmos_settings"
        elif key == "eac3Settings":
            suggest = "eac3_settings"
        elif key == "mp2Settings":
            suggest = "mp2_settings"
        elif key == "passThroughSettings":
            suggest = "pass_through_settings"
        elif key == "wavSettings":
            suggest = "wav_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aac_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings'] = None,
                 ac3_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings'] = None,
                 eac3_atmos_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings'] = None,
                 eac3_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings'] = None,
                 mp2_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings'] = None,
                 pass_through_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings'] = None,
                 wav_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings'] = None):
        """
        :param 'ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettingsArgs' aac_settings: Aac Settings. See AAC Settings for more details.
        :param 'ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3SettingsArgs' ac3_settings: Ac3 Settings. See AC3 Settings for more details.
        :param 'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettingsArgs' eac3_atmos_settings: Eac3 Atmos Settings. See EAC3 Atmos Settings
        :param 'ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3SettingsArgs' eac3_settings: Eac3 Settings. See EAC3 Settings
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aac_settings=aac_settings,
            ac3_settings=ac3_settings,
            eac3_atmos_settings=eac3_atmos_settings,
            eac3_settings=eac3_settings,
            mp2_settings=mp2_settings,
            pass_through_settings=pass_through_settings,
            wav_settings=wav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aac_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings'] = None,
             ac3_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings'] = None,
             eac3_atmos_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings'] = None,
             eac3_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings'] = None,
             mp2_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings'] = None,
             pass_through_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings'] = None,
             wav_settings: Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aac_settings is None and 'aacSettings' in kwargs:
            aac_settings = kwargs['aacSettings']
        if ac3_settings is None and 'ac3Settings' in kwargs:
            ac3_settings = kwargs['ac3Settings']
        if eac3_atmos_settings is None and 'eac3AtmosSettings' in kwargs:
            eac3_atmos_settings = kwargs['eac3AtmosSettings']
        if eac3_settings is None and 'eac3Settings' in kwargs:
            eac3_settings = kwargs['eac3Settings']
        if mp2_settings is None and 'mp2Settings' in kwargs:
            mp2_settings = kwargs['mp2Settings']
        if pass_through_settings is None and 'passThroughSettings' in kwargs:
            pass_through_settings = kwargs['passThroughSettings']
        if wav_settings is None and 'wavSettings' in kwargs:
            wav_settings = kwargs['wavSettings']

        if aac_settings is not None:
            _setter("aac_settings", aac_settings)
        if ac3_settings is not None:
            _setter("ac3_settings", ac3_settings)
        if eac3_atmos_settings is not None:
            _setter("eac3_atmos_settings", eac3_atmos_settings)
        if eac3_settings is not None:
            _setter("eac3_settings", eac3_settings)
        if mp2_settings is not None:
            _setter("mp2_settings", mp2_settings)
        if pass_through_settings is not None:
            _setter("pass_through_settings", pass_through_settings)
        if wav_settings is not None:
            _setter("wav_settings", wav_settings)

    @property
    @pulumi.getter(name="aacSettings")
    def aac_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings']:
        """
        Aac Settings. See AAC Settings for more details.
        """
        return pulumi.get(self, "aac_settings")

    @property
    @pulumi.getter(name="ac3Settings")
    def ac3_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings']:
        """
        Ac3 Settings. See AC3 Settings for more details.
        """
        return pulumi.get(self, "ac3_settings")

    @property
    @pulumi.getter(name="eac3AtmosSettings")
    def eac3_atmos_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings']:
        """
        Eac3 Atmos Settings. See EAC3 Atmos Settings
        """
        return pulumi.get(self, "eac3_atmos_settings")

    @property
    @pulumi.getter(name="eac3Settings")
    def eac3_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings']:
        """
        Eac3 Settings. See EAC3 Settings
        """
        return pulumi.get(self, "eac3_settings")

    @property
    @pulumi.getter(name="mp2Settings")
    def mp2_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings']:
        return pulumi.get(self, "mp2_settings")

    @property
    @pulumi.getter(name="passThroughSettings")
    def pass_through_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings']:
        return pulumi.get(self, "pass_through_settings")

    @property
    @pulumi.getter(name="wavSettings")
    def wav_settings(self) -> Optional['outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings']:
        return pulumi.get(self, "wav_settings")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "inputType":
            suggest = "input_type"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "rawFormat":
            suggest = "raw_format"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "vbrQuality":
            suggest = "vbr_quality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 input_type: Optional[str] = None,
                 profile: Optional[str] = None,
                 rate_control_mode: Optional[str] = None,
                 raw_format: Optional[str] = None,
                 sample_rate: Optional[float] = None,
                 spec: Optional[str] = None,
                 vbr_quality: Optional[str] = None):
        """
        :param float bitrate: Average bitrate in bits/second.
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param str input_type: Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
        :param str profile: AAC profile.
        :param str rate_control_mode: The rate control mode.
        :param str raw_format: Sets LATM/LOAS AAC output for raw containers.
        :param float sample_rate: Sample rate in Hz.
        :param str spec: Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
        :param str vbr_quality: VBR Quality Level - Only used if rateControlMode is VBR.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            input_type=input_type,
            profile=profile,
            rate_control_mode=rate_control_mode,
            raw_format=raw_format,
            sample_rate=sample_rate,
            spec=spec,
            vbr_quality=vbr_quality,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             input_type: Optional[str] = None,
             profile: Optional[str] = None,
             rate_control_mode: Optional[str] = None,
             raw_format: Optional[str] = None,
             sample_rate: Optional[float] = None,
             spec: Optional[str] = None,
             vbr_quality: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if input_type is None and 'inputType' in kwargs:
            input_type = kwargs['inputType']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if raw_format is None and 'rawFormat' in kwargs:
            raw_format = kwargs['rawFormat']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']
        if vbr_quality is None and 'vbrQuality' in kwargs:
            vbr_quality = kwargs['vbrQuality']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if input_type is not None:
            _setter("input_type", input_type)
        if profile is not None:
            _setter("profile", profile)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if raw_format is not None:
            _setter("raw_format", raw_format)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)
        if spec is not None:
            _setter("spec", spec)
        if vbr_quality is not None:
            _setter("vbr_quality", vbr_quality)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="inputType")
    def input_type(self) -> Optional[str]:
        """
        Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
        """
        return pulumi.get(self, "input_type")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="rawFormat")
    def raw_format(self) -> Optional[str]:
        """
        Sets LATM/LOAS AAC output for raw containers.
        """
        return pulumi.get(self, "raw_format")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter
    def spec(self) -> Optional[str]:
        """
        Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter(name="vbrQuality")
    def vbr_quality(self) -> Optional[str]:
        """
        VBR Quality Level - Only used if rateControlMode is VBR.
        """
        return pulumi.get(self, "vbr_quality")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bitstreamMode":
            suggest = "bitstream_mode"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "drcProfile":
            suggest = "drc_profile"
        elif key == "lfeFilter":
            suggest = "lfe_filter"
        elif key == "metadataControl":
            suggest = "metadata_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 bitstream_mode: Optional[str] = None,
                 coding_mode: Optional[str] = None,
                 dialnorm: Optional[int] = None,
                 drc_profile: Optional[str] = None,
                 lfe_filter: Optional[str] = None,
                 metadata_control: Optional[str] = None):
        """
        :param float bitrate: Average bitrate in bits/second.
        :param str bitstream_mode: Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param int dialnorm: Sets the dialnorm of the output.
        :param str drc_profile: If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
        :param str lfe_filter: When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        :param str metadata_control: Metadata control.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_profile=drc_profile,
            lfe_filter=lfe_filter,
            metadata_control=metadata_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             bitstream_mode: Optional[str] = None,
             coding_mode: Optional[str] = None,
             dialnorm: Optional[int] = None,
             drc_profile: Optional[str] = None,
             lfe_filter: Optional[str] = None,
             metadata_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bitstream_mode is None and 'bitstreamMode' in kwargs:
            bitstream_mode = kwargs['bitstreamMode']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if drc_profile is None and 'drcProfile' in kwargs:
            drc_profile = kwargs['drcProfile']
        if lfe_filter is None and 'lfeFilter' in kwargs:
            lfe_filter = kwargs['lfeFilter']
        if metadata_control is None and 'metadataControl' in kwargs:
            metadata_control = kwargs['metadataControl']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_profile is not None:
            _setter("drc_profile", drc_profile)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[str]:
        """
        Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        """
        return pulumi.get(self, "bitstream_mode")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[int]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcProfile")
    def drc_profile(self) -> Optional[str]:
        """
        If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
        """
        return pulumi.get(self, "drc_profile")

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[str]:
        """
        When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        """
        return pulumi.get(self, "lfe_filter")

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[str]:
        """
        Metadata control.
        """
        return pulumi.get(self, "metadata_control")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "drcLine":
            suggest = "drc_line"
        elif key == "drcRf":
            suggest = "drc_rf"
        elif key == "heightTrim":
            suggest = "height_trim"
        elif key == "surroundTrim":
            suggest = "surround_trim"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 dialnorm: Optional[float] = None,
                 drc_line: Optional[str] = None,
                 drc_rf: Optional[str] = None,
                 height_trim: Optional[float] = None,
                 surround_trim: Optional[float] = None):
        """
        :param float bitrate: Average bitrate in bits/second.
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param float dialnorm: Sets the dialnorm of the output.
        :param str drc_line: Sets the Dolby dynamic range compression profile.
        :param str drc_rf: Sets the profile for heavy Dolby dynamic range compression.
        :param float height_trim: Height dimensional trim.
        :param float surround_trim: Surround dimensional trim.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            height_trim=height_trim,
            surround_trim=surround_trim,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             dialnorm: Optional[float] = None,
             drc_line: Optional[str] = None,
             drc_rf: Optional[str] = None,
             height_trim: Optional[float] = None,
             surround_trim: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if drc_line is None and 'drcLine' in kwargs:
            drc_line = kwargs['drcLine']
        if drc_rf is None and 'drcRf' in kwargs:
            drc_rf = kwargs['drcRf']
        if height_trim is None and 'heightTrim' in kwargs:
            height_trim = kwargs['heightTrim']
        if surround_trim is None and 'surroundTrim' in kwargs:
            surround_trim = kwargs['surroundTrim']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if height_trim is not None:
            _setter("height_trim", height_trim)
        if surround_trim is not None:
            _setter("surround_trim", surround_trim)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[float]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[str]:
        """
        Sets the Dolby dynamic range compression profile.
        """
        return pulumi.get(self, "drc_line")

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[str]:
        """
        Sets the profile for heavy Dolby dynamic range compression.
        """
        return pulumi.get(self, "drc_rf")

    @property
    @pulumi.getter(name="heightTrim")
    def height_trim(self) -> Optional[float]:
        """
        Height dimensional trim.
        """
        return pulumi.get(self, "height_trim")

    @property
    @pulumi.getter(name="surroundTrim")
    def surround_trim(self) -> Optional[float]:
        """
        Surround dimensional trim.
        """
        return pulumi.get(self, "surround_trim")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attenuationControl":
            suggest = "attenuation_control"
        elif key == "bitstreamMode":
            suggest = "bitstream_mode"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "dcFilter":
            suggest = "dc_filter"
        elif key == "drcLine":
            suggest = "drc_line"
        elif key == "drcRf":
            suggest = "drc_rf"
        elif key == "lfeControl":
            suggest = "lfe_control"
        elif key == "lfeFilter":
            suggest = "lfe_filter"
        elif key == "loRoCenterMixLevel":
            suggest = "lo_ro_center_mix_level"
        elif key == "loRoSurroundMixLevel":
            suggest = "lo_ro_surround_mix_level"
        elif key == "ltRtCenterMixLevel":
            suggest = "lt_rt_center_mix_level"
        elif key == "ltRtSurroundMixLevel":
            suggest = "lt_rt_surround_mix_level"
        elif key == "metadataControl":
            suggest = "metadata_control"
        elif key == "passthroughControl":
            suggest = "passthrough_control"
        elif key == "phaseControl":
            suggest = "phase_control"
        elif key == "stereoDownmix":
            suggest = "stereo_downmix"
        elif key == "surroundExMode":
            suggest = "surround_ex_mode"
        elif key == "surroundMode":
            suggest = "surround_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attenuation_control: Optional[str] = None,
                 bitrate: Optional[float] = None,
                 bitstream_mode: Optional[str] = None,
                 coding_mode: Optional[str] = None,
                 dc_filter: Optional[str] = None,
                 dialnorm: Optional[int] = None,
                 drc_line: Optional[str] = None,
                 drc_rf: Optional[str] = None,
                 lfe_control: Optional[str] = None,
                 lfe_filter: Optional[str] = None,
                 lo_ro_center_mix_level: Optional[float] = None,
                 lo_ro_surround_mix_level: Optional[float] = None,
                 lt_rt_center_mix_level: Optional[float] = None,
                 lt_rt_surround_mix_level: Optional[float] = None,
                 metadata_control: Optional[str] = None,
                 passthrough_control: Optional[str] = None,
                 phase_control: Optional[str] = None,
                 stereo_downmix: Optional[str] = None,
                 surround_ex_mode: Optional[str] = None,
                 surround_mode: Optional[str] = None):
        """
        :param str attenuation_control: Sets the attenuation control.
        :param float bitrate: Average bitrate in bits/second.
        :param str bitstream_mode: Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param int dialnorm: Sets the dialnorm of the output.
        :param str drc_line: Sets the Dolby dynamic range compression profile.
        :param str drc_rf: Sets the profile for heavy Dolby dynamic range compression.
        :param str lfe_filter: When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        :param str metadata_control: Metadata control.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attenuation_control=attenuation_control,
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dc_filter=dc_filter,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            lfe_control=lfe_control,
            lfe_filter=lfe_filter,
            lo_ro_center_mix_level=lo_ro_center_mix_level,
            lo_ro_surround_mix_level=lo_ro_surround_mix_level,
            lt_rt_center_mix_level=lt_rt_center_mix_level,
            lt_rt_surround_mix_level=lt_rt_surround_mix_level,
            metadata_control=metadata_control,
            passthrough_control=passthrough_control,
            phase_control=phase_control,
            stereo_downmix=stereo_downmix,
            surround_ex_mode=surround_ex_mode,
            surround_mode=surround_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attenuation_control: Optional[str] = None,
             bitrate: Optional[float] = None,
             bitstream_mode: Optional[str] = None,
             coding_mode: Optional[str] = None,
             dc_filter: Optional[str] = None,
             dialnorm: Optional[int] = None,
             drc_line: Optional[str] = None,
             drc_rf: Optional[str] = None,
             lfe_control: Optional[str] = None,
             lfe_filter: Optional[str] = None,
             lo_ro_center_mix_level: Optional[float] = None,
             lo_ro_surround_mix_level: Optional[float] = None,
             lt_rt_center_mix_level: Optional[float] = None,
             lt_rt_surround_mix_level: Optional[float] = None,
             metadata_control: Optional[str] = None,
             passthrough_control: Optional[str] = None,
             phase_control: Optional[str] = None,
             stereo_downmix: Optional[str] = None,
             surround_ex_mode: Optional[str] = None,
             surround_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attenuation_control is None and 'attenuationControl' in kwargs:
            attenuation_control = kwargs['attenuationControl']
        if bitstream_mode is None and 'bitstreamMode' in kwargs:
            bitstream_mode = kwargs['bitstreamMode']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if dc_filter is None and 'dcFilter' in kwargs:
            dc_filter = kwargs['dcFilter']
        if drc_line is None and 'drcLine' in kwargs:
            drc_line = kwargs['drcLine']
        if drc_rf is None and 'drcRf' in kwargs:
            drc_rf = kwargs['drcRf']
        if lfe_control is None and 'lfeControl' in kwargs:
            lfe_control = kwargs['lfeControl']
        if lfe_filter is None and 'lfeFilter' in kwargs:
            lfe_filter = kwargs['lfeFilter']
        if lo_ro_center_mix_level is None and 'loRoCenterMixLevel' in kwargs:
            lo_ro_center_mix_level = kwargs['loRoCenterMixLevel']
        if lo_ro_surround_mix_level is None and 'loRoSurroundMixLevel' in kwargs:
            lo_ro_surround_mix_level = kwargs['loRoSurroundMixLevel']
        if lt_rt_center_mix_level is None and 'ltRtCenterMixLevel' in kwargs:
            lt_rt_center_mix_level = kwargs['ltRtCenterMixLevel']
        if lt_rt_surround_mix_level is None and 'ltRtSurroundMixLevel' in kwargs:
            lt_rt_surround_mix_level = kwargs['ltRtSurroundMixLevel']
        if metadata_control is None and 'metadataControl' in kwargs:
            metadata_control = kwargs['metadataControl']
        if passthrough_control is None and 'passthroughControl' in kwargs:
            passthrough_control = kwargs['passthroughControl']
        if phase_control is None and 'phaseControl' in kwargs:
            phase_control = kwargs['phaseControl']
        if stereo_downmix is None and 'stereoDownmix' in kwargs:
            stereo_downmix = kwargs['stereoDownmix']
        if surround_ex_mode is None and 'surroundExMode' in kwargs:
            surround_ex_mode = kwargs['surroundExMode']
        if surround_mode is None and 'surroundMode' in kwargs:
            surround_mode = kwargs['surroundMode']

        if attenuation_control is not None:
            _setter("attenuation_control", attenuation_control)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dc_filter is not None:
            _setter("dc_filter", dc_filter)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if lfe_control is not None:
            _setter("lfe_control", lfe_control)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if lo_ro_center_mix_level is not None:
            _setter("lo_ro_center_mix_level", lo_ro_center_mix_level)
        if lo_ro_surround_mix_level is not None:
            _setter("lo_ro_surround_mix_level", lo_ro_surround_mix_level)
        if lt_rt_center_mix_level is not None:
            _setter("lt_rt_center_mix_level", lt_rt_center_mix_level)
        if lt_rt_surround_mix_level is not None:
            _setter("lt_rt_surround_mix_level", lt_rt_surround_mix_level)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)
        if passthrough_control is not None:
            _setter("passthrough_control", passthrough_control)
        if phase_control is not None:
            _setter("phase_control", phase_control)
        if stereo_downmix is not None:
            _setter("stereo_downmix", stereo_downmix)
        if surround_ex_mode is not None:
            _setter("surround_ex_mode", surround_ex_mode)
        if surround_mode is not None:
            _setter("surround_mode", surround_mode)

    @property
    @pulumi.getter(name="attenuationControl")
    def attenuation_control(self) -> Optional[str]:
        """
        Sets the attenuation control.
        """
        return pulumi.get(self, "attenuation_control")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[str]:
        """
        Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
        """
        return pulumi.get(self, "bitstream_mode")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="dcFilter")
    def dc_filter(self) -> Optional[str]:
        return pulumi.get(self, "dc_filter")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[int]:
        """
        Sets the dialnorm of the output.
        """
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[str]:
        """
        Sets the Dolby dynamic range compression profile.
        """
        return pulumi.get(self, "drc_line")

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[str]:
        """
        Sets the profile for heavy Dolby dynamic range compression.
        """
        return pulumi.get(self, "drc_rf")

    @property
    @pulumi.getter(name="lfeControl")
    def lfe_control(self) -> Optional[str]:
        return pulumi.get(self, "lfe_control")

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[str]:
        """
        When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
        """
        return pulumi.get(self, "lfe_filter")

    @property
    @pulumi.getter(name="loRoCenterMixLevel")
    def lo_ro_center_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lo_ro_center_mix_level")

    @property
    @pulumi.getter(name="loRoSurroundMixLevel")
    def lo_ro_surround_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lo_ro_surround_mix_level")

    @property
    @pulumi.getter(name="ltRtCenterMixLevel")
    def lt_rt_center_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lt_rt_center_mix_level")

    @property
    @pulumi.getter(name="ltRtSurroundMixLevel")
    def lt_rt_surround_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lt_rt_surround_mix_level")

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[str]:
        """
        Metadata control.
        """
        return pulumi.get(self, "metadata_control")

    @property
    @pulumi.getter(name="passthroughControl")
    def passthrough_control(self) -> Optional[str]:
        return pulumi.get(self, "passthrough_control")

    @property
    @pulumi.getter(name="phaseControl")
    def phase_control(self) -> Optional[str]:
        return pulumi.get(self, "phase_control")

    @property
    @pulumi.getter(name="stereoDownmix")
    def stereo_downmix(self) -> Optional[str]:
        return pulumi.get(self, "stereo_downmix")

    @property
    @pulumi.getter(name="surroundExMode")
    def surround_ex_mode(self) -> Optional[str]:
        return pulumi.get(self, "surround_ex_mode")

    @property
    @pulumi.getter(name="surroundMode")
    def surround_mode(self) -> Optional[str]:
        return pulumi.get(self, "surround_mode")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param float bitrate: Average bitrate in bits/second.
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param float sample_rate: Sample rate in Hz.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             sample_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']

        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bitDepth":
            suggest = "bit_depth"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bit_depth: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param str coding_mode: Mono, Stereo, or 5.1 channel layout.
        :param float sample_rate: Sample rate in Hz.
        """
        ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bit_depth=bit_depth,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bit_depth: Optional[float] = None,
             coding_mode: Optional[str] = None,
             sample_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bit_depth is None and 'bitDepth' in kwargs:
            bit_depth = kwargs['bitDepth']
        if coding_mode is None and 'codingMode' in kwargs:
            coding_mode = kwargs['codingMode']
        if sample_rate is None and 'sampleRate' in kwargs:
            sample_rate = kwargs['sampleRate']

        if bit_depth is not None:
            _setter("bit_depth", bit_depth)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter(name="bitDepth")
    def bit_depth(self) -> Optional[float]:
        return pulumi.get(self, "bit_depth")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        """
        Mono, Stereo, or 5.1 channel layout.
        """
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        Sample rate in Hz.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionRemixSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelMappings":
            suggest = "channel_mappings"
        elif key == "channelsIn":
            suggest = "channels_in"
        elif key == "channelsOut":
            suggest = "channels_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionRemixSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_mappings: Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping'],
                 channels_in: Optional[int] = None,
                 channels_out: Optional[int] = None):
        ChannelEncoderSettingsAudioDescriptionRemixSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_mappings=channel_mappings,
            channels_in=channels_in,
            channels_out=channels_out,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_mappings: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping']] = None,
             channels_in: Optional[int] = None,
             channels_out: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_mappings is None and 'channelMappings' in kwargs:
            channel_mappings = kwargs['channelMappings']
        if channel_mappings is None:
            raise TypeError("Missing 'channel_mappings' argument")
        if channels_in is None and 'channelsIn' in kwargs:
            channels_in = kwargs['channelsIn']
        if channels_out is None and 'channelsOut' in kwargs:
            channels_out = kwargs['channelsOut']

        _setter("channel_mappings", channel_mappings)
        if channels_in is not None:
            _setter("channels_in", channels_in)
        if channels_out is not None:
            _setter("channels_out", channels_out)

    @property
    @pulumi.getter(name="channelMappings")
    def channel_mappings(self) -> Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping']:
        return pulumi.get(self, "channel_mappings")

    @property
    @pulumi.getter(name="channelsIn")
    def channels_in(self) -> Optional[int]:
        return pulumi.get(self, "channels_in")

    @property
    @pulumi.getter(name="channelsOut")
    def channels_out(self) -> Optional[int]:
        return pulumi.get(self, "channels_out")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputChannelLevels":
            suggest = "input_channel_levels"
        elif key == "outputChannel":
            suggest = "output_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_channel_levels: Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel'],
                 output_channel: int):
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_channel_levels=input_channel_levels,
            output_channel=output_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_channel_levels: Optional[Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel']] = None,
             output_channel: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_channel_levels is None and 'inputChannelLevels' in kwargs:
            input_channel_levels = kwargs['inputChannelLevels']
        if input_channel_levels is None:
            raise TypeError("Missing 'input_channel_levels' argument")
        if output_channel is None and 'outputChannel' in kwargs:
            output_channel = kwargs['outputChannel']
        if output_channel is None:
            raise TypeError("Missing 'output_channel' argument")

        _setter("input_channel_levels", input_channel_levels)
        _setter("output_channel", output_channel)

    @property
    @pulumi.getter(name="inputChannelLevels")
    def input_channel_levels(self) -> Sequence['outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel']:
        return pulumi.get(self, "input_channel_levels")

    @property
    @pulumi.getter(name="outputChannel")
    def output_channel(self) -> int:
        return pulumi.get(self, "output_channel")


@pulumi.output_type
class ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputChannel":
            suggest = "input_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gain: int,
                 input_channel: int):
        ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gain=gain,
            input_channel=input_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gain: Optional[int] = None,
             input_channel: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if gain is None:
            raise TypeError("Missing 'gain' argument")
        if input_channel is None and 'inputChannel' in kwargs:
            input_channel = kwargs['inputChannel']
        if input_channel is None:
            raise TypeError("Missing 'input_channel' argument")

        _setter("gain", gain)
        _setter("input_channel", input_channel)

    @property
    @pulumi.getter
    def gain(self) -> int:
        return pulumi.get(self, "gain")

    @property
    @pulumi.getter(name="inputChannel")
    def input_channel(self) -> int:
        return pulumi.get(self, "input_channel")


@pulumi.output_type
class ChannelEncoderSettingsAvailBlanking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availBlankingImage":
            suggest = "avail_blanking_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAvailBlanking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAvailBlanking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAvailBlanking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avail_blanking_image: Optional['outputs.ChannelEncoderSettingsAvailBlankingAvailBlankingImage'] = None,
                 state: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsAvailBlankingAvailBlankingImageArgs' avail_blanking_image: Blanking image to be used. See Avail Blanking Image for more details.
        :param str state: When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
        """
        ChannelEncoderSettingsAvailBlanking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            avail_blanking_image=avail_blanking_image,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             avail_blanking_image: Optional['outputs.ChannelEncoderSettingsAvailBlankingAvailBlankingImage'] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if avail_blanking_image is None and 'availBlankingImage' in kwargs:
            avail_blanking_image = kwargs['availBlankingImage']

        if avail_blanking_image is not None:
            _setter("avail_blanking_image", avail_blanking_image)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="availBlankingImage")
    def avail_blanking_image(self) -> Optional['outputs.ChannelEncoderSettingsAvailBlankingAvailBlankingImage']:
        """
        Blanking image to be used. See Avail Blanking Image for more details.
        """
        return pulumi.get(self, "avail_blanking_image")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ChannelEncoderSettingsAvailBlankingAvailBlankingImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsAvailBlankingAvailBlankingImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsAvailBlankingAvailBlankingImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsAvailBlankingAvailBlankingImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: . Username to be used.
        """
        ChannelEncoderSettingsAvailBlankingAvailBlankingImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captionSelectorName":
            suggest = "caption_selector_name"
        elif key == "destinationSettings":
            suggest = "destination_settings"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageDescription":
            suggest = "language_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caption_selector_name: str,
                 name: str,
                 accessibility: Optional[str] = None,
                 destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettings'] = None,
                 language_code: Optional[str] = None,
                 language_description: Optional[str] = None):
        """
        :param str caption_selector_name: Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
        :param str name: Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
        :param str accessibility: Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsArgs' destination_settings: Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
        :param str language_code: ISO 639-2 three-digit code.
        :param str language_description: Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        ChannelEncoderSettingsCaptionDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caption_selector_name=caption_selector_name,
            name=name,
            accessibility=accessibility,
            destination_settings=destination_settings,
            language_code=language_code,
            language_description=language_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caption_selector_name: Optional[str] = None,
             name: Optional[str] = None,
             accessibility: Optional[str] = None,
             destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettings'] = None,
             language_code: Optional[str] = None,
             language_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if caption_selector_name is None and 'captionSelectorName' in kwargs:
            caption_selector_name = kwargs['captionSelectorName']
        if caption_selector_name is None:
            raise TypeError("Missing 'caption_selector_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if destination_settings is None and 'destinationSettings' in kwargs:
            destination_settings = kwargs['destinationSettings']
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_description is None and 'languageDescription' in kwargs:
            language_description = kwargs['languageDescription']

        _setter("caption_selector_name", caption_selector_name)
        _setter("name", name)
        if accessibility is not None:
            _setter("accessibility", accessibility)
        if destination_settings is not None:
            _setter("destination_settings", destination_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_description is not None:
            _setter("language_description", language_description)

    @property
    @pulumi.getter(name="captionSelectorName")
    def caption_selector_name(self) -> str:
        """
        Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
        """
        return pulumi.get(self, "caption_selector_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def accessibility(self) -> Optional[str]:
        """
        Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
        """
        return pulumi.get(self, "accessibility")

    @property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettings']:
        """
        Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
        """
        return pulumi.get(self, "destination_settings")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        """
        ISO 639-2 three-digit code.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> Optional[str]:
        """
        Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        return pulumi.get(self, "language_description")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aribDestinationSettings":
            suggest = "arib_destination_settings"
        elif key == "burnInDestinationSettings":
            suggest = "burn_in_destination_settings"
        elif key == "dvbSubDestinationSettings":
            suggest = "dvb_sub_destination_settings"
        elif key == "ebuTtDDestinationSettings":
            suggest = "ebu_tt_d_destination_settings"
        elif key == "embeddedDestinationSettings":
            suggest = "embedded_destination_settings"
        elif key == "embeddedPlusScte20DestinationSettings":
            suggest = "embedded_plus_scte20_destination_settings"
        elif key == "rtmpCaptionInfoDestinationSettings":
            suggest = "rtmp_caption_info_destination_settings"
        elif key == "scte20PlusEmbeddedDestinationSettings":
            suggest = "scte20_plus_embedded_destination_settings"
        elif key == "scte27DestinationSettings":
            suggest = "scte27_destination_settings"
        elif key == "smpteTtDestinationSettings":
            suggest = "smpte_tt_destination_settings"
        elif key == "teletextDestinationSettings":
            suggest = "teletext_destination_settings"
        elif key == "ttmlDestinationSettings":
            suggest = "ttml_destination_settings"
        elif key == "webvttDestinationSettings":
            suggest = "webvtt_destination_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arib_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings'] = None,
                 burn_in_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings'] = None,
                 dvb_sub_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings'] = None,
                 ebu_tt_d_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings'] = None,
                 embedded_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings'] = None,
                 embedded_plus_scte20_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings'] = None,
                 rtmp_caption_info_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings'] = None,
                 scte20_plus_embedded_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings'] = None,
                 scte27_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings'] = None,
                 smpte_tt_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings'] = None,
                 teletext_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings'] = None,
                 ttml_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings'] = None,
                 webvtt_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings'] = None):
        """
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettingsArgs' arib_destination_settings: ARIB Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsArgs' burn_in_destination_settings: Burn In Destination Settings. See Burn In Destination Settings for more details.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsArgs' dvb_sub_destination_settings: DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettingsArgs' ebu_tt_d_destination_settings: EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettingsArgs' embedded_destination_settings: Embedded Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettingsArgs' embedded_plus_scte20_destination_settings: Embedded Plus SCTE20 Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettingsArgs' rtmp_caption_info_destination_settings: RTMP Caption Info Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettingsArgs' scte20_plus_embedded_destination_settings: SCTE20 Plus Embedded Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettingsArgs' scte27_destination_settings: SCTE27 Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettingsArgs' smpte_tt_destination_settings: SMPTE TT Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettingsArgs' teletext_destination_settings: Teletext Destination Settings.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettingsArgs' ttml_destination_settings: TTML Destination Settings. See TTML Destination Settings for more details.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettingsArgs' webvtt_destination_settings: WebVTT Destination Settings. See WebVTT Destination Settings for more details.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arib_destination_settings=arib_destination_settings,
            burn_in_destination_settings=burn_in_destination_settings,
            dvb_sub_destination_settings=dvb_sub_destination_settings,
            ebu_tt_d_destination_settings=ebu_tt_d_destination_settings,
            embedded_destination_settings=embedded_destination_settings,
            embedded_plus_scte20_destination_settings=embedded_plus_scte20_destination_settings,
            rtmp_caption_info_destination_settings=rtmp_caption_info_destination_settings,
            scte20_plus_embedded_destination_settings=scte20_plus_embedded_destination_settings,
            scte27_destination_settings=scte27_destination_settings,
            smpte_tt_destination_settings=smpte_tt_destination_settings,
            teletext_destination_settings=teletext_destination_settings,
            ttml_destination_settings=ttml_destination_settings,
            webvtt_destination_settings=webvtt_destination_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arib_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings'] = None,
             burn_in_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings'] = None,
             dvb_sub_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings'] = None,
             ebu_tt_d_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings'] = None,
             embedded_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings'] = None,
             embedded_plus_scte20_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings'] = None,
             rtmp_caption_info_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings'] = None,
             scte20_plus_embedded_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings'] = None,
             scte27_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings'] = None,
             smpte_tt_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings'] = None,
             teletext_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings'] = None,
             ttml_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings'] = None,
             webvtt_destination_settings: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arib_destination_settings is None and 'aribDestinationSettings' in kwargs:
            arib_destination_settings = kwargs['aribDestinationSettings']
        if burn_in_destination_settings is None and 'burnInDestinationSettings' in kwargs:
            burn_in_destination_settings = kwargs['burnInDestinationSettings']
        if dvb_sub_destination_settings is None and 'dvbSubDestinationSettings' in kwargs:
            dvb_sub_destination_settings = kwargs['dvbSubDestinationSettings']
        if ebu_tt_d_destination_settings is None and 'ebuTtDDestinationSettings' in kwargs:
            ebu_tt_d_destination_settings = kwargs['ebuTtDDestinationSettings']
        if embedded_destination_settings is None and 'embeddedDestinationSettings' in kwargs:
            embedded_destination_settings = kwargs['embeddedDestinationSettings']
        if embedded_plus_scte20_destination_settings is None and 'embeddedPlusScte20DestinationSettings' in kwargs:
            embedded_plus_scte20_destination_settings = kwargs['embeddedPlusScte20DestinationSettings']
        if rtmp_caption_info_destination_settings is None and 'rtmpCaptionInfoDestinationSettings' in kwargs:
            rtmp_caption_info_destination_settings = kwargs['rtmpCaptionInfoDestinationSettings']
        if scte20_plus_embedded_destination_settings is None and 'scte20PlusEmbeddedDestinationSettings' in kwargs:
            scte20_plus_embedded_destination_settings = kwargs['scte20PlusEmbeddedDestinationSettings']
        if scte27_destination_settings is None and 'scte27DestinationSettings' in kwargs:
            scte27_destination_settings = kwargs['scte27DestinationSettings']
        if smpte_tt_destination_settings is None and 'smpteTtDestinationSettings' in kwargs:
            smpte_tt_destination_settings = kwargs['smpteTtDestinationSettings']
        if teletext_destination_settings is None and 'teletextDestinationSettings' in kwargs:
            teletext_destination_settings = kwargs['teletextDestinationSettings']
        if ttml_destination_settings is None and 'ttmlDestinationSettings' in kwargs:
            ttml_destination_settings = kwargs['ttmlDestinationSettings']
        if webvtt_destination_settings is None and 'webvttDestinationSettings' in kwargs:
            webvtt_destination_settings = kwargs['webvttDestinationSettings']

        if arib_destination_settings is not None:
            _setter("arib_destination_settings", arib_destination_settings)
        if burn_in_destination_settings is not None:
            _setter("burn_in_destination_settings", burn_in_destination_settings)
        if dvb_sub_destination_settings is not None:
            _setter("dvb_sub_destination_settings", dvb_sub_destination_settings)
        if ebu_tt_d_destination_settings is not None:
            _setter("ebu_tt_d_destination_settings", ebu_tt_d_destination_settings)
        if embedded_destination_settings is not None:
            _setter("embedded_destination_settings", embedded_destination_settings)
        if embedded_plus_scte20_destination_settings is not None:
            _setter("embedded_plus_scte20_destination_settings", embedded_plus_scte20_destination_settings)
        if rtmp_caption_info_destination_settings is not None:
            _setter("rtmp_caption_info_destination_settings", rtmp_caption_info_destination_settings)
        if scte20_plus_embedded_destination_settings is not None:
            _setter("scte20_plus_embedded_destination_settings", scte20_plus_embedded_destination_settings)
        if scte27_destination_settings is not None:
            _setter("scte27_destination_settings", scte27_destination_settings)
        if smpte_tt_destination_settings is not None:
            _setter("smpte_tt_destination_settings", smpte_tt_destination_settings)
        if teletext_destination_settings is not None:
            _setter("teletext_destination_settings", teletext_destination_settings)
        if ttml_destination_settings is not None:
            _setter("ttml_destination_settings", ttml_destination_settings)
        if webvtt_destination_settings is not None:
            _setter("webvtt_destination_settings", webvtt_destination_settings)

    @property
    @pulumi.getter(name="aribDestinationSettings")
    def arib_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings']:
        """
        ARIB Destination Settings.
        """
        return pulumi.get(self, "arib_destination_settings")

    @property
    @pulumi.getter(name="burnInDestinationSettings")
    def burn_in_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings']:
        """
        Burn In Destination Settings. See Burn In Destination Settings for more details.
        """
        return pulumi.get(self, "burn_in_destination_settings")

    @property
    @pulumi.getter(name="dvbSubDestinationSettings")
    def dvb_sub_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings']:
        """
        DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
        """
        return pulumi.get(self, "dvb_sub_destination_settings")

    @property
    @pulumi.getter(name="ebuTtDDestinationSettings")
    def ebu_tt_d_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings']:
        """
        EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
        """
        return pulumi.get(self, "ebu_tt_d_destination_settings")

    @property
    @pulumi.getter(name="embeddedDestinationSettings")
    def embedded_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings']:
        """
        Embedded Destination Settings.
        """
        return pulumi.get(self, "embedded_destination_settings")

    @property
    @pulumi.getter(name="embeddedPlusScte20DestinationSettings")
    def embedded_plus_scte20_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings']:
        """
        Embedded Plus SCTE20 Destination Settings.
        """
        return pulumi.get(self, "embedded_plus_scte20_destination_settings")

    @property
    @pulumi.getter(name="rtmpCaptionInfoDestinationSettings")
    def rtmp_caption_info_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings']:
        """
        RTMP Caption Info Destination Settings.
        """
        return pulumi.get(self, "rtmp_caption_info_destination_settings")

    @property
    @pulumi.getter(name="scte20PlusEmbeddedDestinationSettings")
    def scte20_plus_embedded_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings']:
        """
        SCTE20 Plus Embedded Destination Settings.
        """
        return pulumi.get(self, "scte20_plus_embedded_destination_settings")

    @property
    @pulumi.getter(name="scte27DestinationSettings")
    def scte27_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings']:
        """
        SCTE27 Destination Settings.
        """
        return pulumi.get(self, "scte27_destination_settings")

    @property
    @pulumi.getter(name="smpteTtDestinationSettings")
    def smpte_tt_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings']:
        """
        SMPTE TT Destination Settings.
        """
        return pulumi.get(self, "smpte_tt_destination_settings")

    @property
    @pulumi.getter(name="teletextDestinationSettings")
    def teletext_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings']:
        """
        Teletext Destination Settings.
        """
        return pulumi.get(self, "teletext_destination_settings")

    @property
    @pulumi.getter(name="ttmlDestinationSettings")
    def ttml_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings']:
        """
        TTML Destination Settings. See TTML Destination Settings for more details.
        """
        return pulumi.get(self, "ttml_destination_settings")

    @property
    @pulumi.getter(name="webvttDestinationSettings")
    def webvtt_destination_settings(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings']:
        """
        WebVTT Destination Settings. See WebVTT Destination Settings for more details.
        """
        return pulumi.get(self, "webvtt_destination_settings")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outlineColor":
            suggest = "outline_color"
        elif key == "teletextGridControl":
            suggest = "teletext_grid_control"
        elif key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundOpacity":
            suggest = "background_opacity"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontOpacity":
            suggest = "font_opacity"
        elif key == "fontResolution":
            suggest = "font_resolution"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "outlineSize":
            suggest = "outline_size"
        elif key == "shadowColor":
            suggest = "shadow_color"
        elif key == "shadowOpacity":
            suggest = "shadow_opacity"
        elif key == "shadowXOffset":
            suggest = "shadow_x_offset"
        elif key == "shadowYOffset":
            suggest = "shadow_y_offset"
        elif key == "xPosition":
            suggest = "x_position"
        elif key == "yPosition":
            suggest = "y_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outline_color: str,
                 teletext_grid_control: str,
                 alignment: Optional[str] = None,
                 background_color: Optional[str] = None,
                 background_opacity: Optional[int] = None,
                 font: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont'] = None,
                 font_color: Optional[str] = None,
                 font_opacity: Optional[int] = None,
                 font_resolution: Optional[int] = None,
                 font_size: Optional[str] = None,
                 outline_size: Optional[int] = None,
                 shadow_color: Optional[str] = None,
                 shadow_opacity: Optional[int] = None,
                 shadow_x_offset: Optional[int] = None,
                 shadow_y_offset: Optional[int] = None,
                 x_position: Optional[int] = None,
                 y_position: Optional[int] = None):
        """
        :param str outline_color: Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param str teletext_grid_control: Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        :param str alignment: If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
        :param str background_color: Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        :param int background_opacity: Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFontArgs' font: External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        :param str font_color: Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param int font_opacity: Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        :param int font_resolution: Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        :param str font_size: When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        :param int outline_size: Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param str shadow_color: Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        :param int shadow_opacity: Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param int shadow_x_offset: Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        :param int shadow_y_offset: Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        :param int x_position: Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
        :param int y_position: Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            outline_color=outline_color,
            teletext_grid_control=teletext_grid_control,
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             outline_color: Optional[str] = None,
             teletext_grid_control: Optional[str] = None,
             alignment: Optional[str] = None,
             background_color: Optional[str] = None,
             background_opacity: Optional[int] = None,
             font: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont'] = None,
             font_color: Optional[str] = None,
             font_opacity: Optional[int] = None,
             font_resolution: Optional[int] = None,
             font_size: Optional[str] = None,
             outline_size: Optional[int] = None,
             shadow_color: Optional[str] = None,
             shadow_opacity: Optional[int] = None,
             shadow_x_offset: Optional[int] = None,
             shadow_y_offset: Optional[int] = None,
             x_position: Optional[int] = None,
             y_position: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if outline_color is None and 'outlineColor' in kwargs:
            outline_color = kwargs['outlineColor']
        if outline_color is None:
            raise TypeError("Missing 'outline_color' argument")
        if teletext_grid_control is None and 'teletextGridControl' in kwargs:
            teletext_grid_control = kwargs['teletextGridControl']
        if teletext_grid_control is None:
            raise TypeError("Missing 'teletext_grid_control' argument")
        if background_color is None and 'backgroundColor' in kwargs:
            background_color = kwargs['backgroundColor']
        if background_opacity is None and 'backgroundOpacity' in kwargs:
            background_opacity = kwargs['backgroundOpacity']
        if font_color is None and 'fontColor' in kwargs:
            font_color = kwargs['fontColor']
        if font_opacity is None and 'fontOpacity' in kwargs:
            font_opacity = kwargs['fontOpacity']
        if font_resolution is None and 'fontResolution' in kwargs:
            font_resolution = kwargs['fontResolution']
        if font_size is None and 'fontSize' in kwargs:
            font_size = kwargs['fontSize']
        if outline_size is None and 'outlineSize' in kwargs:
            outline_size = kwargs['outlineSize']
        if shadow_color is None and 'shadowColor' in kwargs:
            shadow_color = kwargs['shadowColor']
        if shadow_opacity is None and 'shadowOpacity' in kwargs:
            shadow_opacity = kwargs['shadowOpacity']
        if shadow_x_offset is None and 'shadowXOffset' in kwargs:
            shadow_x_offset = kwargs['shadowXOffset']
        if shadow_y_offset is None and 'shadowYOffset' in kwargs:
            shadow_y_offset = kwargs['shadowYOffset']
        if x_position is None and 'xPosition' in kwargs:
            x_position = kwargs['xPosition']
        if y_position is None and 'yPosition' in kwargs:
            y_position = kwargs['yPosition']

        _setter("outline_color", outline_color)
        _setter("teletext_grid_control", teletext_grid_control)
        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> str:
        """
        Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_color")

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> str:
        """
        Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        """
        return pulumi.get(self, "teletext_grid_control")

    @property
    @pulumi.getter
    def alignment(self) -> Optional[str]:
        """
        If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "alignment")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_opacity")

    @property
    @pulumi.getter
    def font(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont']:
        """
        External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        """
        return pulumi.get(self, "font")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        """
        Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_opacity")

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[int]:
        """
        Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_resolution")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[int]:
        """
        Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_size")

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[str]:
        """
        Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_color")

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_opacity")

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[int]:
        """
        Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_x_offset")

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[int]:
        """
        Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_y_offset")

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[int]:
        """
        Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "x_position")

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[int]:
        """
        Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "y_position")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: Username to be used.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundOpacity":
            suggest = "background_opacity"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontOpacity":
            suggest = "font_opacity"
        elif key == "fontResolution":
            suggest = "font_resolution"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "outlineColor":
            suggest = "outline_color"
        elif key == "outlineSize":
            suggest = "outline_size"
        elif key == "shadowColor":
            suggest = "shadow_color"
        elif key == "shadowOpacity":
            suggest = "shadow_opacity"
        elif key == "shadowXOffset":
            suggest = "shadow_x_offset"
        elif key == "shadowYOffset":
            suggest = "shadow_y_offset"
        elif key == "teletextGridControl":
            suggest = "teletext_grid_control"
        elif key == "xPosition":
            suggest = "x_position"
        elif key == "yPosition":
            suggest = "y_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alignment: Optional[str] = None,
                 background_color: Optional[str] = None,
                 background_opacity: Optional[int] = None,
                 font: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont'] = None,
                 font_color: Optional[str] = None,
                 font_opacity: Optional[int] = None,
                 font_resolution: Optional[int] = None,
                 font_size: Optional[str] = None,
                 outline_color: Optional[str] = None,
                 outline_size: Optional[int] = None,
                 shadow_color: Optional[str] = None,
                 shadow_opacity: Optional[int] = None,
                 shadow_x_offset: Optional[int] = None,
                 shadow_y_offset: Optional[int] = None,
                 teletext_grid_control: Optional[str] = None,
                 x_position: Optional[int] = None,
                 y_position: Optional[int] = None):
        """
        :param str alignment: If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param str background_color: Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        :param int background_opacity: Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param 'ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFontArgs' font: External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        :param str font_color: Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param int font_opacity: Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        :param int font_resolution: Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        :param str font_size: When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        :param str outline_color: Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param int outline_size: Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param str shadow_color: Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        :param int shadow_opacity: Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        :param int shadow_x_offset: Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        :param int shadow_y_offset: Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        :param str teletext_grid_control: Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        :param int x_position: Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        :param int y_position: Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_color=outline_color,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            teletext_grid_control=teletext_grid_control,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alignment: Optional[str] = None,
             background_color: Optional[str] = None,
             background_opacity: Optional[int] = None,
             font: Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont'] = None,
             font_color: Optional[str] = None,
             font_opacity: Optional[int] = None,
             font_resolution: Optional[int] = None,
             font_size: Optional[str] = None,
             outline_color: Optional[str] = None,
             outline_size: Optional[int] = None,
             shadow_color: Optional[str] = None,
             shadow_opacity: Optional[int] = None,
             shadow_x_offset: Optional[int] = None,
             shadow_y_offset: Optional[int] = None,
             teletext_grid_control: Optional[str] = None,
             x_position: Optional[int] = None,
             y_position: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if background_color is None and 'backgroundColor' in kwargs:
            background_color = kwargs['backgroundColor']
        if background_opacity is None and 'backgroundOpacity' in kwargs:
            background_opacity = kwargs['backgroundOpacity']
        if font_color is None and 'fontColor' in kwargs:
            font_color = kwargs['fontColor']
        if font_opacity is None and 'fontOpacity' in kwargs:
            font_opacity = kwargs['fontOpacity']
        if font_resolution is None and 'fontResolution' in kwargs:
            font_resolution = kwargs['fontResolution']
        if font_size is None and 'fontSize' in kwargs:
            font_size = kwargs['fontSize']
        if outline_color is None and 'outlineColor' in kwargs:
            outline_color = kwargs['outlineColor']
        if outline_size is None and 'outlineSize' in kwargs:
            outline_size = kwargs['outlineSize']
        if shadow_color is None and 'shadowColor' in kwargs:
            shadow_color = kwargs['shadowColor']
        if shadow_opacity is None and 'shadowOpacity' in kwargs:
            shadow_opacity = kwargs['shadowOpacity']
        if shadow_x_offset is None and 'shadowXOffset' in kwargs:
            shadow_x_offset = kwargs['shadowXOffset']
        if shadow_y_offset is None and 'shadowYOffset' in kwargs:
            shadow_y_offset = kwargs['shadowYOffset']
        if teletext_grid_control is None and 'teletextGridControl' in kwargs:
            teletext_grid_control = kwargs['teletextGridControl']
        if x_position is None and 'xPosition' in kwargs:
            x_position = kwargs['xPosition']
        if y_position is None and 'yPosition' in kwargs:
            y_position = kwargs['yPosition']

        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_color is not None:
            _setter("outline_color", outline_color)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if teletext_grid_control is not None:
            _setter("teletext_grid_control", teletext_grid_control)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[str]:
        """
        If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "alignment")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "background_opacity")

    @property
    @pulumi.getter
    def font(self) -> Optional['outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont']:
        """
        External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
        """
        return pulumi.get(self, "font")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        """
        Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_opacity")

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[int]:
        """
        Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_resolution")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> Optional[str]:
        """
        Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_color")

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[int]:
        """
        Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "outline_size")

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[str]:
        """
        Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_color")

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[int]:
        """
        Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_opacity")

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[int]:
        """
        Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_x_offset")

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[int]:
        """
        Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "shadow_y_offset")

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> Optional[str]:
        """
        Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
        """
        return pulumi.get(self, "teletext_grid_control")

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[int]:
        """
        Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "x_position")

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[int]:
        """
        Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        """
        return pulumi.get(self, "y_position")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: Username to be used.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyrightHolder":
            suggest = "copyright_holder"
        elif key == "fillLineGap":
            suggest = "fill_line_gap"
        elif key == "fontFamily":
            suggest = "font_family"
        elif key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copyright_holder: Optional[str] = None,
                 fill_line_gap: Optional[str] = None,
                 font_family: Optional[str] = None,
                 style_control: Optional[str] = None):
        """
        :param str copyright_holder: Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
        :param str fill_line_gap: Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
        :param str font_family: Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”.
        :param str style_control: Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copyright_holder=copyright_holder,
            fill_line_gap=fill_line_gap,
            font_family=font_family,
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copyright_holder: Optional[str] = None,
             fill_line_gap: Optional[str] = None,
             font_family: Optional[str] = None,
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if copyright_holder is None and 'copyrightHolder' in kwargs:
            copyright_holder = kwargs['copyrightHolder']
        if fill_line_gap is None and 'fillLineGap' in kwargs:
            fill_line_gap = kwargs['fillLineGap']
        if font_family is None and 'fontFamily' in kwargs:
            font_family = kwargs['fontFamily']
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']

        if copyright_holder is not None:
            _setter("copyright_holder", copyright_holder)
        if fill_line_gap is not None:
            _setter("fill_line_gap", fill_line_gap)
        if font_family is not None:
            _setter("font_family", font_family)
        if style_control is not None:
            _setter("style_control", style_control)

    @property
    @pulumi.getter(name="copyrightHolder")
    def copyright_holder(self) -> Optional[str]:
        """
        Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
        """
        return pulumi.get(self, "copyright_holder")

    @property
    @pulumi.getter(name="fillLineGap")
    def fill_line_gap(self) -> Optional[str]:
        """
        Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
        """
        return pulumi.get(self, "fill_line_gap")

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[str]:
        """
        Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”.
        """
        return pulumi.get(self, "font_family")

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> Optional[str]:
        """
        Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information.
        """
        return pulumi.get(self, "style_control")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 style_control: str):
        """
        :param str style_control: This field is not currently supported and will not affect the output styling. Leave the default value.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']
        if style_control is None:
            raise TypeError("Missing 'style_control' argument")

        _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> str:
        """
        This field is not currently supported and will not affect the output styling. Leave the default value.
        """
        return pulumi.get(self, "style_control")


@pulumi.output_type
class ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 style_control: str):
        """
        :param str style_control: Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\\_STYLE\\_DATA - Don’t pass through the style. The output captions will not contain any font styling information.
        """
        ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if style_control is None and 'styleControl' in kwargs:
            style_control = kwargs['styleControl']
        if style_control is None:
            raise TypeError("Missing 'style_control' argument")

        _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> str:
        """
        Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\\_STYLE\\_DATA - Don’t pass through the style. The output captions will not contain any font styling information.
        """
        return pulumi.get(self, "style_control")


@pulumi.output_type
class ChannelEncoderSettingsGlobalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialAudioGain":
            suggest = "initial_audio_gain"
        elif key == "inputEndAction":
            suggest = "input_end_action"
        elif key == "inputLossBehavior":
            suggest = "input_loss_behavior"
        elif key == "outputLockingMode":
            suggest = "output_locking_mode"
        elif key == "outputTimingSource":
            suggest = "output_timing_source"
        elif key == "supportLowFramerateInputs":
            suggest = "support_low_framerate_inputs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsGlobalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsGlobalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsGlobalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_audio_gain: Optional[int] = None,
                 input_end_action: Optional[str] = None,
                 input_loss_behavior: Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehavior'] = None,
                 output_locking_mode: Optional[str] = None,
                 output_timing_source: Optional[str] = None,
                 support_low_framerate_inputs: Optional[str] = None):
        """
        :param int initial_audio_gain: Value to set the initial audio gain for the Live Event.
        :param str input_end_action: Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
        :param 'ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorArgs' input_loss_behavior: Settings for system actions when input is lost. See Input Loss Behavior for more details.
        :param str output_locking_mode: Indicates how MediaLive pipelines are synchronized. PIPELINE\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
        :param str output_timing_source: Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
        :param str support_low_framerate_inputs: Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
        """
        ChannelEncoderSettingsGlobalConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            initial_audio_gain=initial_audio_gain,
            input_end_action=input_end_action,
            input_loss_behavior=input_loss_behavior,
            output_locking_mode=output_locking_mode,
            output_timing_source=output_timing_source,
            support_low_framerate_inputs=support_low_framerate_inputs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             initial_audio_gain: Optional[int] = None,
             input_end_action: Optional[str] = None,
             input_loss_behavior: Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehavior'] = None,
             output_locking_mode: Optional[str] = None,
             output_timing_source: Optional[str] = None,
             support_low_framerate_inputs: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if initial_audio_gain is None and 'initialAudioGain' in kwargs:
            initial_audio_gain = kwargs['initialAudioGain']
        if input_end_action is None and 'inputEndAction' in kwargs:
            input_end_action = kwargs['inputEndAction']
        if input_loss_behavior is None and 'inputLossBehavior' in kwargs:
            input_loss_behavior = kwargs['inputLossBehavior']
        if output_locking_mode is None and 'outputLockingMode' in kwargs:
            output_locking_mode = kwargs['outputLockingMode']
        if output_timing_source is None and 'outputTimingSource' in kwargs:
            output_timing_source = kwargs['outputTimingSource']
        if support_low_framerate_inputs is None and 'supportLowFramerateInputs' in kwargs:
            support_low_framerate_inputs = kwargs['supportLowFramerateInputs']

        if initial_audio_gain is not None:
            _setter("initial_audio_gain", initial_audio_gain)
        if input_end_action is not None:
            _setter("input_end_action", input_end_action)
        if input_loss_behavior is not None:
            _setter("input_loss_behavior", input_loss_behavior)
        if output_locking_mode is not None:
            _setter("output_locking_mode", output_locking_mode)
        if output_timing_source is not None:
            _setter("output_timing_source", output_timing_source)
        if support_low_framerate_inputs is not None:
            _setter("support_low_framerate_inputs", support_low_framerate_inputs)

    @property
    @pulumi.getter(name="initialAudioGain")
    def initial_audio_gain(self) -> Optional[int]:
        """
        Value to set the initial audio gain for the Live Event.
        """
        return pulumi.get(self, "initial_audio_gain")

    @property
    @pulumi.getter(name="inputEndAction")
    def input_end_action(self) -> Optional[str]:
        """
        Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
        """
        return pulumi.get(self, "input_end_action")

    @property
    @pulumi.getter(name="inputLossBehavior")
    def input_loss_behavior(self) -> Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehavior']:
        """
        Settings for system actions when input is lost. See Input Loss Behavior for more details.
        """
        return pulumi.get(self, "input_loss_behavior")

    @property
    @pulumi.getter(name="outputLockingMode")
    def output_locking_mode(self) -> Optional[str]:
        """
        Indicates how MediaLive pipelines are synchronized. PIPELINE\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
        """
        return pulumi.get(self, "output_locking_mode")

    @property
    @pulumi.getter(name="outputTimingSource")
    def output_timing_source(self) -> Optional[str]:
        """
        Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
        """
        return pulumi.get(self, "output_timing_source")

    @property
    @pulumi.getter(name="supportLowFramerateInputs")
    def support_low_framerate_inputs(self) -> Optional[str]:
        """
        Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
        """
        return pulumi.get(self, "support_low_framerate_inputs")


@pulumi.output_type
class ChannelEncoderSettingsGlobalConfigurationInputLossBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackFrameMsec":
            suggest = "black_frame_msec"
        elif key == "inputLossImageColor":
            suggest = "input_loss_image_color"
        elif key == "inputLossImageSlate":
            suggest = "input_loss_image_slate"
        elif key == "inputLossImageType":
            suggest = "input_loss_image_type"
        elif key == "repeatFrameMsec":
            suggest = "repeat_frame_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsGlobalConfigurationInputLossBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsGlobalConfigurationInputLossBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsGlobalConfigurationInputLossBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 black_frame_msec: Optional[int] = None,
                 input_loss_image_color: Optional[str] = None,
                 input_loss_image_slate: Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate'] = None,
                 input_loss_image_type: Optional[str] = None,
                 repeat_frame_msec: Optional[int] = None):
        ChannelEncoderSettingsGlobalConfigurationInputLossBehavior._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_frame_msec=black_frame_msec,
            input_loss_image_color=input_loss_image_color,
            input_loss_image_slate=input_loss_image_slate,
            input_loss_image_type=input_loss_image_type,
            repeat_frame_msec=repeat_frame_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_frame_msec: Optional[int] = None,
             input_loss_image_color: Optional[str] = None,
             input_loss_image_slate: Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate'] = None,
             input_loss_image_type: Optional[str] = None,
             repeat_frame_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if black_frame_msec is None and 'blackFrameMsec' in kwargs:
            black_frame_msec = kwargs['blackFrameMsec']
        if input_loss_image_color is None and 'inputLossImageColor' in kwargs:
            input_loss_image_color = kwargs['inputLossImageColor']
        if input_loss_image_slate is None and 'inputLossImageSlate' in kwargs:
            input_loss_image_slate = kwargs['inputLossImageSlate']
        if input_loss_image_type is None and 'inputLossImageType' in kwargs:
            input_loss_image_type = kwargs['inputLossImageType']
        if repeat_frame_msec is None and 'repeatFrameMsec' in kwargs:
            repeat_frame_msec = kwargs['repeatFrameMsec']

        if black_frame_msec is not None:
            _setter("black_frame_msec", black_frame_msec)
        if input_loss_image_color is not None:
            _setter("input_loss_image_color", input_loss_image_color)
        if input_loss_image_slate is not None:
            _setter("input_loss_image_slate", input_loss_image_slate)
        if input_loss_image_type is not None:
            _setter("input_loss_image_type", input_loss_image_type)
        if repeat_frame_msec is not None:
            _setter("repeat_frame_msec", repeat_frame_msec)

    @property
    @pulumi.getter(name="blackFrameMsec")
    def black_frame_msec(self) -> Optional[int]:
        return pulumi.get(self, "black_frame_msec")

    @property
    @pulumi.getter(name="inputLossImageColor")
    def input_loss_image_color(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_image_color")

    @property
    @pulumi.getter(name="inputLossImageSlate")
    def input_loss_image_slate(self) -> Optional['outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate']:
        return pulumi.get(self, "input_loss_image_slate")

    @property
    @pulumi.getter(name="inputLossImageType")
    def input_loss_image_type(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_image_type")

    @property
    @pulumi.getter(name="repeatFrameMsec")
    def repeat_frame_msec(self) -> Optional[int]:
        return pulumi.get(self, "repeat_frame_msec")


@pulumi.output_type
class ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: . Username to be used.
        """
        ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsMotionGraphicsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "motionGraphicsSettings":
            suggest = "motion_graphics_settings"
        elif key == "motionGraphicsInsertion":
            suggest = "motion_graphics_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsMotionGraphicsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsMotionGraphicsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsMotionGraphicsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 motion_graphics_settings: 'outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings',
                 motion_graphics_insertion: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsArgs' motion_graphics_settings: Motion Graphics Settings. See Motion Graphics Settings for more details.
        :param str motion_graphics_insertion: Motion Graphics Insertion.
        """
        ChannelEncoderSettingsMotionGraphicsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            motion_graphics_settings=motion_graphics_settings,
            motion_graphics_insertion=motion_graphics_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             motion_graphics_settings: Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings'] = None,
             motion_graphics_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if motion_graphics_settings is None and 'motionGraphicsSettings' in kwargs:
            motion_graphics_settings = kwargs['motionGraphicsSettings']
        if motion_graphics_settings is None:
            raise TypeError("Missing 'motion_graphics_settings' argument")
        if motion_graphics_insertion is None and 'motionGraphicsInsertion' in kwargs:
            motion_graphics_insertion = kwargs['motionGraphicsInsertion']

        _setter("motion_graphics_settings", motion_graphics_settings)
        if motion_graphics_insertion is not None:
            _setter("motion_graphics_insertion", motion_graphics_insertion)

    @property
    @pulumi.getter(name="motionGraphicsSettings")
    def motion_graphics_settings(self) -> 'outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings':
        """
        Motion Graphics Settings. See Motion Graphics Settings for more details.
        """
        return pulumi.get(self, "motion_graphics_settings")

    @property
    @pulumi.getter(name="motionGraphicsInsertion")
    def motion_graphics_insertion(self) -> Optional[str]:
        """
        Motion Graphics Insertion.
        """
        return pulumi.get(self, "motion_graphics_insertion")


@pulumi.output_type
class ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlMotionGraphicsSettings":
            suggest = "html_motion_graphics_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_motion_graphics_settings: Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings'] = None):
        """
        :param 'ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettingsArgs' html_motion_graphics_settings: Html Motion Graphics Settings.
        """
        ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            html_motion_graphics_settings=html_motion_graphics_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             html_motion_graphics_settings: Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if html_motion_graphics_settings is None and 'htmlMotionGraphicsSettings' in kwargs:
            html_motion_graphics_settings = kwargs['htmlMotionGraphicsSettings']

        if html_motion_graphics_settings is not None:
            _setter("html_motion_graphics_settings", html_motion_graphics_settings)

    @property
    @pulumi.getter(name="htmlMotionGraphicsSettings")
    def html_motion_graphics_settings(self) -> Optional['outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings']:
        """
        Html Motion Graphics Settings.
        """
        return pulumi.get(self, "html_motion_graphics_settings")


@pulumi.output_type
class ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsNielsenConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributorId":
            suggest = "distributor_id"
        elif key == "nielsenPcmToId3Tagging":
            suggest = "nielsen_pcm_to_id3_tagging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsNielsenConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsNielsenConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsNielsenConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distributor_id: Optional[str] = None,
                 nielsen_pcm_to_id3_tagging: Optional[str] = None):
        """
        :param str distributor_id: Enter the Distributor ID assigned to your organization by Nielsen.
        :param str nielsen_pcm_to_id3_tagging: Enables Nielsen PCM to ID3 tagging.
        """
        ChannelEncoderSettingsNielsenConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distributor_id=distributor_id,
            nielsen_pcm_to_id3_tagging=nielsen_pcm_to_id3_tagging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distributor_id: Optional[str] = None,
             nielsen_pcm_to_id3_tagging: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distributor_id is None and 'distributorId' in kwargs:
            distributor_id = kwargs['distributorId']
        if nielsen_pcm_to_id3_tagging is None and 'nielsenPcmToId3Tagging' in kwargs:
            nielsen_pcm_to_id3_tagging = kwargs['nielsenPcmToId3Tagging']

        if distributor_id is not None:
            _setter("distributor_id", distributor_id)
        if nielsen_pcm_to_id3_tagging is not None:
            _setter("nielsen_pcm_to_id3_tagging", nielsen_pcm_to_id3_tagging)

    @property
    @pulumi.getter(name="distributorId")
    def distributor_id(self) -> Optional[str]:
        """
        Enter the Distributor ID assigned to your organization by Nielsen.
        """
        return pulumi.get(self, "distributor_id")

    @property
    @pulumi.getter(name="nielsenPcmToId3Tagging")
    def nielsen_pcm_to_id3_tagging(self) -> Optional[str]:
        """
        Enables Nielsen PCM to ID3 tagging.
        """
        return pulumi.get(self, "nielsen_pcm_to_id3_tagging")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputGroupSettings":
            suggest = "output_group_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_group_settings: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettings',
                 outputs: Sequence['outputs.ChannelEncoderSettingsOutputGroupOutput'],
                 name: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArgs' output_group_settings: Settings associated with the output group. See Output Group Settings for more details.
        :param Sequence['ChannelEncoderSettingsOutputGroupOutputArgs'] outputs: List of outputs. See Outputs for more details.
        :param str name: Custom output group name defined by the user.
        """
        ChannelEncoderSettingsOutputGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_group_settings=output_group_settings,
            outputs=outputs,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettings'] = None,
             outputs: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutput']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_group_settings is None and 'outputGroupSettings' in kwargs:
            output_group_settings = kwargs['outputGroupSettings']
        if output_group_settings is None:
            raise TypeError("Missing 'output_group_settings' argument")
        if outputs is None:
            raise TypeError("Missing 'outputs' argument")

        _setter("output_group_settings", output_group_settings)
        _setter("outputs", outputs)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="outputGroupSettings")
    def output_group_settings(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettings':
        """
        Settings associated with the output group. See Output Group Settings for more details.
        """
        return pulumi.get(self, "output_group_settings")

    @property
    @pulumi.getter
    def outputs(self) -> Sequence['outputs.ChannelEncoderSettingsOutputGroupOutput']:
        """
        List of outputs. See Outputs for more details.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom output group name defined by the user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSettings":
            suggest = "output_settings"
        elif key == "audioDescriptionNames":
            suggest = "audio_description_names"
        elif key == "captionDescriptionNames":
            suggest = "caption_description_names"
        elif key == "outputName":
            suggest = "output_name"
        elif key == "videoDescriptionName":
            suggest = "video_description_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_settings: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettings',
                 audio_description_names: Optional[Sequence[str]] = None,
                 caption_description_names: Optional[Sequence[str]] = None,
                 output_name: Optional[str] = None,
                 video_description_name: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArgs' output_settings: Settings for output. See Output Settings for more details.
        :param Sequence[str] audio_description_names: The names of the audio descriptions used as audio sources for the output.
        :param Sequence[str] caption_description_names: The names of the caption descriptions used as caption sources for the output.
        :param str output_name: The name used to identify an output.
        :param str video_description_name: The name of the video description used as video source for the output.
        """
        ChannelEncoderSettingsOutputGroupOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_settings=output_settings,
            audio_description_names=audio_description_names,
            caption_description_names=caption_description_names,
            output_name=output_name,
            video_description_name=video_description_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettings'] = None,
             audio_description_names: Optional[Sequence[str]] = None,
             caption_description_names: Optional[Sequence[str]] = None,
             output_name: Optional[str] = None,
             video_description_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_settings is None and 'outputSettings' in kwargs:
            output_settings = kwargs['outputSettings']
        if output_settings is None:
            raise TypeError("Missing 'output_settings' argument")
        if audio_description_names is None and 'audioDescriptionNames' in kwargs:
            audio_description_names = kwargs['audioDescriptionNames']
        if caption_description_names is None and 'captionDescriptionNames' in kwargs:
            caption_description_names = kwargs['captionDescriptionNames']
        if output_name is None and 'outputName' in kwargs:
            output_name = kwargs['outputName']
        if video_description_name is None and 'videoDescriptionName' in kwargs:
            video_description_name = kwargs['videoDescriptionName']

        _setter("output_settings", output_settings)
        if audio_description_names is not None:
            _setter("audio_description_names", audio_description_names)
        if caption_description_names is not None:
            _setter("caption_description_names", caption_description_names)
        if output_name is not None:
            _setter("output_name", output_name)
        if video_description_name is not None:
            _setter("video_description_name", video_description_name)

    @property
    @pulumi.getter(name="outputSettings")
    def output_settings(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettings':
        """
        Settings for output. See Output Settings for more details.
        """
        return pulumi.get(self, "output_settings")

    @property
    @pulumi.getter(name="audioDescriptionNames")
    def audio_description_names(self) -> Optional[Sequence[str]]:
        """
        The names of the audio descriptions used as audio sources for the output.
        """
        return pulumi.get(self, "audio_description_names")

    @property
    @pulumi.getter(name="captionDescriptionNames")
    def caption_description_names(self) -> Optional[Sequence[str]]:
        """
        The names of the caption descriptions used as caption sources for the output.
        """
        return pulumi.get(self, "caption_description_names")

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> Optional[str]:
        """
        The name used to identify an output.
        """
        return pulumi.get(self, "output_name")

    @property
    @pulumi.getter(name="videoDescriptionName")
    def video_description_name(self) -> Optional[str]:
        """
        The name of the video description used as video source for the output.
        """
        return pulumi.get(self, "video_description_name")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveGroupSettings":
            suggest = "archive_group_settings"
        elif key == "frameCaptureGroupSettings":
            suggest = "frame_capture_group_settings"
        elif key == "hlsGroupSettings":
            suggest = "hls_group_settings"
        elif key == "mediaPackageGroupSettings":
            suggest = "media_package_group_settings"
        elif key == "msSmoothGroupSettings":
            suggest = "ms_smooth_group_settings"
        elif key == "multiplexGroupSettings":
            suggest = "multiplex_group_settings"
        elif key == "rtmpGroupSettings":
            suggest = "rtmp_group_settings"
        elif key == "udpGroupSettings":
            suggest = "udp_group_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_group_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting']] = None,
                 frame_capture_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings'] = None,
                 hls_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings'] = None,
                 media_package_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings'] = None,
                 ms_smooth_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings'] = None,
                 multiplex_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings'] = None,
                 rtmp_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings'] = None,
                 udp_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings'] = None):
        """
        :param Sequence['ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArgs'] archive_group_settings: Archive group settings. See Archive Group Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsArgs' media_package_group_settings: Media package group settings. See Media Package Group Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettingsArgs' rtmp_group_settings: RTMP group settings. See RTMP Group Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_group_settings=archive_group_settings,
            frame_capture_group_settings=frame_capture_group_settings,
            hls_group_settings=hls_group_settings,
            media_package_group_settings=media_package_group_settings,
            ms_smooth_group_settings=ms_smooth_group_settings,
            multiplex_group_settings=multiplex_group_settings,
            rtmp_group_settings=rtmp_group_settings,
            udp_group_settings=udp_group_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_group_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting']] = None,
             frame_capture_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings'] = None,
             hls_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings'] = None,
             media_package_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings'] = None,
             ms_smooth_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings'] = None,
             multiplex_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings'] = None,
             rtmp_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings'] = None,
             udp_group_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_group_settings is None and 'archiveGroupSettings' in kwargs:
            archive_group_settings = kwargs['archiveGroupSettings']
        if frame_capture_group_settings is None and 'frameCaptureGroupSettings' in kwargs:
            frame_capture_group_settings = kwargs['frameCaptureGroupSettings']
        if hls_group_settings is None and 'hlsGroupSettings' in kwargs:
            hls_group_settings = kwargs['hlsGroupSettings']
        if media_package_group_settings is None and 'mediaPackageGroupSettings' in kwargs:
            media_package_group_settings = kwargs['mediaPackageGroupSettings']
        if ms_smooth_group_settings is None and 'msSmoothGroupSettings' in kwargs:
            ms_smooth_group_settings = kwargs['msSmoothGroupSettings']
        if multiplex_group_settings is None and 'multiplexGroupSettings' in kwargs:
            multiplex_group_settings = kwargs['multiplexGroupSettings']
        if rtmp_group_settings is None and 'rtmpGroupSettings' in kwargs:
            rtmp_group_settings = kwargs['rtmpGroupSettings']
        if udp_group_settings is None and 'udpGroupSettings' in kwargs:
            udp_group_settings = kwargs['udpGroupSettings']

        if archive_group_settings is not None:
            _setter("archive_group_settings", archive_group_settings)
        if frame_capture_group_settings is not None:
            _setter("frame_capture_group_settings", frame_capture_group_settings)
        if hls_group_settings is not None:
            _setter("hls_group_settings", hls_group_settings)
        if media_package_group_settings is not None:
            _setter("media_package_group_settings", media_package_group_settings)
        if ms_smooth_group_settings is not None:
            _setter("ms_smooth_group_settings", ms_smooth_group_settings)
        if multiplex_group_settings is not None:
            _setter("multiplex_group_settings", multiplex_group_settings)
        if rtmp_group_settings is not None:
            _setter("rtmp_group_settings", rtmp_group_settings)
        if udp_group_settings is not None:
            _setter("udp_group_settings", udp_group_settings)

    @property
    @pulumi.getter(name="archiveGroupSettings")
    def archive_group_settings(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting']]:
        """
        Archive group settings. See Archive Group Settings for more details.
        """
        return pulumi.get(self, "archive_group_settings")

    @property
    @pulumi.getter(name="frameCaptureGroupSettings")
    def frame_capture_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings']:
        return pulumi.get(self, "frame_capture_group_settings")

    @property
    @pulumi.getter(name="hlsGroupSettings")
    def hls_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings']:
        return pulumi.get(self, "hls_group_settings")

    @property
    @pulumi.getter(name="mediaPackageGroupSettings")
    def media_package_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings']:
        """
        Media package group settings. See Media Package Group Settings for more details.
        """
        return pulumi.get(self, "media_package_group_settings")

    @property
    @pulumi.getter(name="msSmoothGroupSettings")
    def ms_smooth_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings']:
        return pulumi.get(self, "ms_smooth_group_settings")

    @property
    @pulumi.getter(name="multiplexGroupSettings")
    def multiplex_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings']:
        return pulumi.get(self, "multiplex_group_settings")

    @property
    @pulumi.getter(name="rtmpGroupSettings")
    def rtmp_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings']:
        """
        RTMP group settings. See RTMP Group Settings for more details.
        """
        return pulumi.get(self, "rtmp_group_settings")

    @property
    @pulumi.getter(name="udpGroupSettings")
    def udp_group_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings']:
        return pulumi.get(self, "udp_group_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveCdnSettings":
            suggest = "archive_cdn_settings"
        elif key == "rolloverInterval":
            suggest = "rollover_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination',
                 archive_cdn_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings'] = None,
                 rollover_interval: Optional[int] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestinationArgs' destination: A director and base filename where archive files should be written. See Destination for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArgs' archive_cdn_settings: Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
        :param int rollover_interval: Number of seconds to write to archive file before closing and starting a new one.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            archive_cdn_settings=archive_cdn_settings,
            rollover_interval=rollover_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination'] = None,
             archive_cdn_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings'] = None,
             rollover_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if archive_cdn_settings is None and 'archiveCdnSettings' in kwargs:
            archive_cdn_settings = kwargs['archiveCdnSettings']
        if rollover_interval is None and 'rolloverInterval' in kwargs:
            rollover_interval = kwargs['rolloverInterval']

        _setter("destination", destination)
        if archive_cdn_settings is not None:
            _setter("archive_cdn_settings", archive_cdn_settings)
        if rollover_interval is not None:
            _setter("rollover_interval", rollover_interval)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination':
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="archiveCdnSettings")
    def archive_cdn_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings']:
        """
        Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
        """
        return pulumi.get(self, "archive_cdn_settings")

    @property
    @pulumi.getter(name="rolloverInterval")
    def rollover_interval(self) -> Optional[int]:
        """
        Number of seconds to write to archive file before closing and starting a new one.
        """
        return pulumi.get(self, "rollover_interval")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveS3Settings":
            suggest = "archive_s3_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3SettingsArgs' archive_s3_settings: Archive S3 Settings. See Archive S3 Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_s3_settings=archive_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_s3_settings is None and 'archiveS3Settings' in kwargs:
            archive_s3_settings = kwargs['archiveS3Settings']

        if archive_s3_settings is not None:
            _setter("archive_s3_settings", archive_s3_settings)

    @property
    @pulumi.getter(name="archiveS3Settings")
    def archive_s3_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings']:
        """
        Archive S3 Settings. See Archive S3 Settings for more details.
        """
        return pulumi.get(self, "archive_s3_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        """
        :param str canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureCdnSettings":
            suggest = "frame_capture_cdn_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination',
                 frame_capture_cdn_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestinationArgs' destination: A director and base filename where archive files should be written. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            frame_capture_cdn_settings=frame_capture_cdn_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination'] = None,
             frame_capture_cdn_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if frame_capture_cdn_settings is None and 'frameCaptureCdnSettings' in kwargs:
            frame_capture_cdn_settings = kwargs['frameCaptureCdnSettings']

        _setter("destination", destination)
        if frame_capture_cdn_settings is not None:
            _setter("frame_capture_cdn_settings", frame_capture_cdn_settings)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination':
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="frameCaptureCdnSettings")
    def frame_capture_cdn_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings']:
        return pulumi.get(self, "frame_capture_cdn_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureS3Settings":
            suggest = "frame_capture_s3_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frame_capture_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings'] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_s3_settings=frame_capture_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if frame_capture_s3_settings is None and 'frameCaptureS3Settings' in kwargs:
            frame_capture_s3_settings = kwargs['frameCaptureS3Settings']

        if frame_capture_s3_settings is not None:
            _setter("frame_capture_s3_settings", frame_capture_s3_settings)

    @property
    @pulumi.getter(name="frameCaptureS3Settings")
    def frame_capture_s3_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings']:
        return pulumi.get(self, "frame_capture_s3_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        """
        :param str canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adMarkers":
            suggest = "ad_markers"
        elif key == "baseUrlContent":
            suggest = "base_url_content"
        elif key == "baseUrlContent1":
            suggest = "base_url_content1"
        elif key == "baseUrlManifest":
            suggest = "base_url_manifest"
        elif key == "baseUrlManifest1":
            suggest = "base_url_manifest1"
        elif key == "captionLanguageMappings":
            suggest = "caption_language_mappings"
        elif key == "captionLanguageSetting":
            suggest = "caption_language_setting"
        elif key == "clientCache":
            suggest = "client_cache"
        elif key == "codecSpecification":
            suggest = "codec_specification"
        elif key == "constantIv":
            suggest = "constant_iv"
        elif key == "directoryStructure":
            suggest = "directory_structure"
        elif key == "discontinuityTags":
            suggest = "discontinuity_tags"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "hlsCdnSettings":
            suggest = "hls_cdn_settings"
        elif key == "hlsId3SegmentTagging":
            suggest = "hls_id3_segment_tagging"
        elif key == "iframeOnlyPlaylists":
            suggest = "iframe_only_playlists"
        elif key == "incompleteSegmentBehavior":
            suggest = "incomplete_segment_behavior"
        elif key == "indexNSegments":
            suggest = "index_n_segments"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "ivInManifest":
            suggest = "iv_in_manifest"
        elif key == "ivSource":
            suggest = "iv_source"
        elif key == "keepSegments":
            suggest = "keep_segments"
        elif key == "keyFormat":
            suggest = "key_format"
        elif key == "keyFormatVersions":
            suggest = "key_format_versions"
        elif key == "keyProviderSettings":
            suggest = "key_provider_settings"
        elif key == "manifestCompression":
            suggest = "manifest_compression"
        elif key == "manifestDurationFormat":
            suggest = "manifest_duration_format"
        elif key == "minSegmentLength":
            suggest = "min_segment_length"
        elif key == "outputSelection":
            suggest = "output_selection"
        elif key == "programDateTime":
            suggest = "program_date_time"
        elif key == "programDateTimeClock":
            suggest = "program_date_time_clock"
        elif key == "programDateTimePeriod":
            suggest = "program_date_time_period"
        elif key == "redundantManifest":
            suggest = "redundant_manifest"
        elif key == "segmentLength":
            suggest = "segment_length"
        elif key == "segmentsPerSubdirectory":
            suggest = "segments_per_subdirectory"
        elif key == "streamInfResolution":
            suggest = "stream_inf_resolution"
        elif key == "timedMetadataId3Frame":
            suggest = "timed_metadata_id3_frame"
        elif key == "timedMetadataId3Period":
            suggest = "timed_metadata_id3_period"
        elif key == "timestampDeltaMilliseconds":
            suggest = "timestamp_delta_milliseconds"
        elif key == "tsFileMode":
            suggest = "ts_file_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination',
                 ad_markers: Optional[Sequence[str]] = None,
                 base_url_content: Optional[str] = None,
                 base_url_content1: Optional[str] = None,
                 base_url_manifest: Optional[str] = None,
                 base_url_manifest1: Optional[str] = None,
                 caption_language_mappings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping']] = None,
                 caption_language_setting: Optional[str] = None,
                 client_cache: Optional[str] = None,
                 codec_specification: Optional[str] = None,
                 constant_iv: Optional[str] = None,
                 directory_structure: Optional[str] = None,
                 discontinuity_tags: Optional[str] = None,
                 encryption_type: Optional[str] = None,
                 hls_cdn_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting']] = None,
                 hls_id3_segment_tagging: Optional[str] = None,
                 iframe_only_playlists: Optional[str] = None,
                 incomplete_segment_behavior: Optional[str] = None,
                 index_n_segments: Optional[int] = None,
                 input_loss_action: Optional[str] = None,
                 iv_in_manifest: Optional[str] = None,
                 iv_source: Optional[str] = None,
                 keep_segments: Optional[int] = None,
                 key_format: Optional[str] = None,
                 key_format_versions: Optional[str] = None,
                 key_provider_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings'] = None,
                 manifest_compression: Optional[str] = None,
                 manifest_duration_format: Optional[str] = None,
                 min_segment_length: Optional[int] = None,
                 mode: Optional[str] = None,
                 output_selection: Optional[str] = None,
                 program_date_time: Optional[str] = None,
                 program_date_time_clock: Optional[str] = None,
                 program_date_time_period: Optional[int] = None,
                 redundant_manifest: Optional[str] = None,
                 segment_length: Optional[int] = None,
                 segments_per_subdirectory: Optional[int] = None,
                 stream_inf_resolution: Optional[str] = None,
                 timed_metadata_id3_frame: Optional[str] = None,
                 timed_metadata_id3_period: Optional[int] = None,
                 timestamp_delta_milliseconds: Optional[int] = None,
                 ts_file_mode: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestinationArgs' destination: A director and base filename where archive files should be written. See Destination for more details.
        :param Sequence[str] ad_markers: The ad marker type for this output group.
        :param str input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param str timed_metadata_id3_frame: Indicates ID3 frame that has the timecode.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            ad_markers=ad_markers,
            base_url_content=base_url_content,
            base_url_content1=base_url_content1,
            base_url_manifest=base_url_manifest,
            base_url_manifest1=base_url_manifest1,
            caption_language_mappings=caption_language_mappings,
            caption_language_setting=caption_language_setting,
            client_cache=client_cache,
            codec_specification=codec_specification,
            constant_iv=constant_iv,
            directory_structure=directory_structure,
            discontinuity_tags=discontinuity_tags,
            encryption_type=encryption_type,
            hls_cdn_settings=hls_cdn_settings,
            hls_id3_segment_tagging=hls_id3_segment_tagging,
            iframe_only_playlists=iframe_only_playlists,
            incomplete_segment_behavior=incomplete_segment_behavior,
            index_n_segments=index_n_segments,
            input_loss_action=input_loss_action,
            iv_in_manifest=iv_in_manifest,
            iv_source=iv_source,
            keep_segments=keep_segments,
            key_format=key_format,
            key_format_versions=key_format_versions,
            key_provider_settings=key_provider_settings,
            manifest_compression=manifest_compression,
            manifest_duration_format=manifest_duration_format,
            min_segment_length=min_segment_length,
            mode=mode,
            output_selection=output_selection,
            program_date_time=program_date_time,
            program_date_time_clock=program_date_time_clock,
            program_date_time_period=program_date_time_period,
            redundant_manifest=redundant_manifest,
            segment_length=segment_length,
            segments_per_subdirectory=segments_per_subdirectory,
            stream_inf_resolution=stream_inf_resolution,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
            timestamp_delta_milliseconds=timestamp_delta_milliseconds,
            ts_file_mode=ts_file_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination'] = None,
             ad_markers: Optional[Sequence[str]] = None,
             base_url_content: Optional[str] = None,
             base_url_content1: Optional[str] = None,
             base_url_manifest: Optional[str] = None,
             base_url_manifest1: Optional[str] = None,
             caption_language_mappings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping']] = None,
             caption_language_setting: Optional[str] = None,
             client_cache: Optional[str] = None,
             codec_specification: Optional[str] = None,
             constant_iv: Optional[str] = None,
             directory_structure: Optional[str] = None,
             discontinuity_tags: Optional[str] = None,
             encryption_type: Optional[str] = None,
             hls_cdn_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting']] = None,
             hls_id3_segment_tagging: Optional[str] = None,
             iframe_only_playlists: Optional[str] = None,
             incomplete_segment_behavior: Optional[str] = None,
             index_n_segments: Optional[int] = None,
             input_loss_action: Optional[str] = None,
             iv_in_manifest: Optional[str] = None,
             iv_source: Optional[str] = None,
             keep_segments: Optional[int] = None,
             key_format: Optional[str] = None,
             key_format_versions: Optional[str] = None,
             key_provider_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings'] = None,
             manifest_compression: Optional[str] = None,
             manifest_duration_format: Optional[str] = None,
             min_segment_length: Optional[int] = None,
             mode: Optional[str] = None,
             output_selection: Optional[str] = None,
             program_date_time: Optional[str] = None,
             program_date_time_clock: Optional[str] = None,
             program_date_time_period: Optional[int] = None,
             redundant_manifest: Optional[str] = None,
             segment_length: Optional[int] = None,
             segments_per_subdirectory: Optional[int] = None,
             stream_inf_resolution: Optional[str] = None,
             timed_metadata_id3_frame: Optional[str] = None,
             timed_metadata_id3_period: Optional[int] = None,
             timestamp_delta_milliseconds: Optional[int] = None,
             ts_file_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if ad_markers is None and 'adMarkers' in kwargs:
            ad_markers = kwargs['adMarkers']
        if base_url_content is None and 'baseUrlContent' in kwargs:
            base_url_content = kwargs['baseUrlContent']
        if base_url_content1 is None and 'baseUrlContent1' in kwargs:
            base_url_content1 = kwargs['baseUrlContent1']
        if base_url_manifest is None and 'baseUrlManifest' in kwargs:
            base_url_manifest = kwargs['baseUrlManifest']
        if base_url_manifest1 is None and 'baseUrlManifest1' in kwargs:
            base_url_manifest1 = kwargs['baseUrlManifest1']
        if caption_language_mappings is None and 'captionLanguageMappings' in kwargs:
            caption_language_mappings = kwargs['captionLanguageMappings']
        if caption_language_setting is None and 'captionLanguageSetting' in kwargs:
            caption_language_setting = kwargs['captionLanguageSetting']
        if client_cache is None and 'clientCache' in kwargs:
            client_cache = kwargs['clientCache']
        if codec_specification is None and 'codecSpecification' in kwargs:
            codec_specification = kwargs['codecSpecification']
        if constant_iv is None and 'constantIv' in kwargs:
            constant_iv = kwargs['constantIv']
        if directory_structure is None and 'directoryStructure' in kwargs:
            directory_structure = kwargs['directoryStructure']
        if discontinuity_tags is None and 'discontinuityTags' in kwargs:
            discontinuity_tags = kwargs['discontinuityTags']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if hls_cdn_settings is None and 'hlsCdnSettings' in kwargs:
            hls_cdn_settings = kwargs['hlsCdnSettings']
        if hls_id3_segment_tagging is None and 'hlsId3SegmentTagging' in kwargs:
            hls_id3_segment_tagging = kwargs['hlsId3SegmentTagging']
        if iframe_only_playlists is None and 'iframeOnlyPlaylists' in kwargs:
            iframe_only_playlists = kwargs['iframeOnlyPlaylists']
        if incomplete_segment_behavior is None and 'incompleteSegmentBehavior' in kwargs:
            incomplete_segment_behavior = kwargs['incompleteSegmentBehavior']
        if index_n_segments is None and 'indexNSegments' in kwargs:
            index_n_segments = kwargs['indexNSegments']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if iv_in_manifest is None and 'ivInManifest' in kwargs:
            iv_in_manifest = kwargs['ivInManifest']
        if iv_source is None and 'ivSource' in kwargs:
            iv_source = kwargs['ivSource']
        if keep_segments is None and 'keepSegments' in kwargs:
            keep_segments = kwargs['keepSegments']
        if key_format is None and 'keyFormat' in kwargs:
            key_format = kwargs['keyFormat']
        if key_format_versions is None and 'keyFormatVersions' in kwargs:
            key_format_versions = kwargs['keyFormatVersions']
        if key_provider_settings is None and 'keyProviderSettings' in kwargs:
            key_provider_settings = kwargs['keyProviderSettings']
        if manifest_compression is None and 'manifestCompression' in kwargs:
            manifest_compression = kwargs['manifestCompression']
        if manifest_duration_format is None and 'manifestDurationFormat' in kwargs:
            manifest_duration_format = kwargs['manifestDurationFormat']
        if min_segment_length is None and 'minSegmentLength' in kwargs:
            min_segment_length = kwargs['minSegmentLength']
        if output_selection is None and 'outputSelection' in kwargs:
            output_selection = kwargs['outputSelection']
        if program_date_time is None and 'programDateTime' in kwargs:
            program_date_time = kwargs['programDateTime']
        if program_date_time_clock is None and 'programDateTimeClock' in kwargs:
            program_date_time_clock = kwargs['programDateTimeClock']
        if program_date_time_period is None and 'programDateTimePeriod' in kwargs:
            program_date_time_period = kwargs['programDateTimePeriod']
        if redundant_manifest is None and 'redundantManifest' in kwargs:
            redundant_manifest = kwargs['redundantManifest']
        if segment_length is None and 'segmentLength' in kwargs:
            segment_length = kwargs['segmentLength']
        if segments_per_subdirectory is None and 'segmentsPerSubdirectory' in kwargs:
            segments_per_subdirectory = kwargs['segmentsPerSubdirectory']
        if stream_inf_resolution is None and 'streamInfResolution' in kwargs:
            stream_inf_resolution = kwargs['streamInfResolution']
        if timed_metadata_id3_frame is None and 'timedMetadataId3Frame' in kwargs:
            timed_metadata_id3_frame = kwargs['timedMetadataId3Frame']
        if timed_metadata_id3_period is None and 'timedMetadataId3Period' in kwargs:
            timed_metadata_id3_period = kwargs['timedMetadataId3Period']
        if timestamp_delta_milliseconds is None and 'timestampDeltaMilliseconds' in kwargs:
            timestamp_delta_milliseconds = kwargs['timestampDeltaMilliseconds']
        if ts_file_mode is None and 'tsFileMode' in kwargs:
            ts_file_mode = kwargs['tsFileMode']

        _setter("destination", destination)
        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if base_url_content is not None:
            _setter("base_url_content", base_url_content)
        if base_url_content1 is not None:
            _setter("base_url_content1", base_url_content1)
        if base_url_manifest is not None:
            _setter("base_url_manifest", base_url_manifest)
        if base_url_manifest1 is not None:
            _setter("base_url_manifest1", base_url_manifest1)
        if caption_language_mappings is not None:
            _setter("caption_language_mappings", caption_language_mappings)
        if caption_language_setting is not None:
            _setter("caption_language_setting", caption_language_setting)
        if client_cache is not None:
            _setter("client_cache", client_cache)
        if codec_specification is not None:
            _setter("codec_specification", codec_specification)
        if constant_iv is not None:
            _setter("constant_iv", constant_iv)
        if directory_structure is not None:
            _setter("directory_structure", directory_structure)
        if discontinuity_tags is not None:
            _setter("discontinuity_tags", discontinuity_tags)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if hls_cdn_settings is not None:
            _setter("hls_cdn_settings", hls_cdn_settings)
        if hls_id3_segment_tagging is not None:
            _setter("hls_id3_segment_tagging", hls_id3_segment_tagging)
        if iframe_only_playlists is not None:
            _setter("iframe_only_playlists", iframe_only_playlists)
        if incomplete_segment_behavior is not None:
            _setter("incomplete_segment_behavior", incomplete_segment_behavior)
        if index_n_segments is not None:
            _setter("index_n_segments", index_n_segments)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if iv_in_manifest is not None:
            _setter("iv_in_manifest", iv_in_manifest)
        if iv_source is not None:
            _setter("iv_source", iv_source)
        if keep_segments is not None:
            _setter("keep_segments", keep_segments)
        if key_format is not None:
            _setter("key_format", key_format)
        if key_format_versions is not None:
            _setter("key_format_versions", key_format_versions)
        if key_provider_settings is not None:
            _setter("key_provider_settings", key_provider_settings)
        if manifest_compression is not None:
            _setter("manifest_compression", manifest_compression)
        if manifest_duration_format is not None:
            _setter("manifest_duration_format", manifest_duration_format)
        if min_segment_length is not None:
            _setter("min_segment_length", min_segment_length)
        if mode is not None:
            _setter("mode", mode)
        if output_selection is not None:
            _setter("output_selection", output_selection)
        if program_date_time is not None:
            _setter("program_date_time", program_date_time)
        if program_date_time_clock is not None:
            _setter("program_date_time_clock", program_date_time_clock)
        if program_date_time_period is not None:
            _setter("program_date_time_period", program_date_time_period)
        if redundant_manifest is not None:
            _setter("redundant_manifest", redundant_manifest)
        if segment_length is not None:
            _setter("segment_length", segment_length)
        if segments_per_subdirectory is not None:
            _setter("segments_per_subdirectory", segments_per_subdirectory)
        if stream_inf_resolution is not None:
            _setter("stream_inf_resolution", stream_inf_resolution)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)
        if timestamp_delta_milliseconds is not None:
            _setter("timestamp_delta_milliseconds", timestamp_delta_milliseconds)
        if ts_file_mode is not None:
            _setter("ts_file_mode", ts_file_mode)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination':
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[Sequence[str]]:
        """
        The ad marker type for this output group.
        """
        return pulumi.get(self, "ad_markers")

    @property
    @pulumi.getter(name="baseUrlContent")
    def base_url_content(self) -> Optional[str]:
        return pulumi.get(self, "base_url_content")

    @property
    @pulumi.getter(name="baseUrlContent1")
    def base_url_content1(self) -> Optional[str]:
        return pulumi.get(self, "base_url_content1")

    @property
    @pulumi.getter(name="baseUrlManifest")
    def base_url_manifest(self) -> Optional[str]:
        return pulumi.get(self, "base_url_manifest")

    @property
    @pulumi.getter(name="baseUrlManifest1")
    def base_url_manifest1(self) -> Optional[str]:
        return pulumi.get(self, "base_url_manifest1")

    @property
    @pulumi.getter(name="captionLanguageMappings")
    def caption_language_mappings(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping']]:
        return pulumi.get(self, "caption_language_mappings")

    @property
    @pulumi.getter(name="captionLanguageSetting")
    def caption_language_setting(self) -> Optional[str]:
        return pulumi.get(self, "caption_language_setting")

    @property
    @pulumi.getter(name="clientCache")
    def client_cache(self) -> Optional[str]:
        return pulumi.get(self, "client_cache")

    @property
    @pulumi.getter(name="codecSpecification")
    def codec_specification(self) -> Optional[str]:
        return pulumi.get(self, "codec_specification")

    @property
    @pulumi.getter(name="constantIv")
    def constant_iv(self) -> Optional[str]:
        return pulumi.get(self, "constant_iv")

    @property
    @pulumi.getter(name="directoryStructure")
    def directory_structure(self) -> Optional[str]:
        return pulumi.get(self, "directory_structure")

    @property
    @pulumi.getter(name="discontinuityTags")
    def discontinuity_tags(self) -> Optional[str]:
        return pulumi.get(self, "discontinuity_tags")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="hlsCdnSettings")
    def hls_cdn_settings(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting']]:
        return pulumi.get(self, "hls_cdn_settings")

    @property
    @pulumi.getter(name="hlsId3SegmentTagging")
    def hls_id3_segment_tagging(self) -> Optional[str]:
        return pulumi.get(self, "hls_id3_segment_tagging")

    @property
    @pulumi.getter(name="iframeOnlyPlaylists")
    def iframe_only_playlists(self) -> Optional[str]:
        return pulumi.get(self, "iframe_only_playlists")

    @property
    @pulumi.getter(name="incompleteSegmentBehavior")
    def incomplete_segment_behavior(self) -> Optional[str]:
        return pulumi.get(self, "incomplete_segment_behavior")

    @property
    @pulumi.getter(name="indexNSegments")
    def index_n_segments(self) -> Optional[int]:
        return pulumi.get(self, "index_n_segments")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="ivInManifest")
    def iv_in_manifest(self) -> Optional[str]:
        return pulumi.get(self, "iv_in_manifest")

    @property
    @pulumi.getter(name="ivSource")
    def iv_source(self) -> Optional[str]:
        return pulumi.get(self, "iv_source")

    @property
    @pulumi.getter(name="keepSegments")
    def keep_segments(self) -> Optional[int]:
        return pulumi.get(self, "keep_segments")

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[str]:
        return pulumi.get(self, "key_format")

    @property
    @pulumi.getter(name="keyFormatVersions")
    def key_format_versions(self) -> Optional[str]:
        return pulumi.get(self, "key_format_versions")

    @property
    @pulumi.getter(name="keyProviderSettings")
    def key_provider_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings']:
        return pulumi.get(self, "key_provider_settings")

    @property
    @pulumi.getter(name="manifestCompression")
    def manifest_compression(self) -> Optional[str]:
        return pulumi.get(self, "manifest_compression")

    @property
    @pulumi.getter(name="manifestDurationFormat")
    def manifest_duration_format(self) -> Optional[str]:
        return pulumi.get(self, "manifest_duration_format")

    @property
    @pulumi.getter(name="minSegmentLength")
    def min_segment_length(self) -> Optional[int]:
        return pulumi.get(self, "min_segment_length")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="outputSelection")
    def output_selection(self) -> Optional[str]:
        return pulumi.get(self, "output_selection")

    @property
    @pulumi.getter(name="programDateTime")
    def program_date_time(self) -> Optional[str]:
        return pulumi.get(self, "program_date_time")

    @property
    @pulumi.getter(name="programDateTimeClock")
    def program_date_time_clock(self) -> Optional[str]:
        return pulumi.get(self, "program_date_time_clock")

    @property
    @pulumi.getter(name="programDateTimePeriod")
    def program_date_time_period(self) -> Optional[int]:
        return pulumi.get(self, "program_date_time_period")

    @property
    @pulumi.getter(name="redundantManifest")
    def redundant_manifest(self) -> Optional[str]:
        return pulumi.get(self, "redundant_manifest")

    @property
    @pulumi.getter(name="segmentLength")
    def segment_length(self) -> Optional[int]:
        return pulumi.get(self, "segment_length")

    @property
    @pulumi.getter(name="segmentsPerSubdirectory")
    def segments_per_subdirectory(self) -> Optional[int]:
        return pulumi.get(self, "segments_per_subdirectory")

    @property
    @pulumi.getter(name="streamInfResolution")
    def stream_inf_resolution(self) -> Optional[str]:
        return pulumi.get(self, "stream_inf_resolution")

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[str]:
        """
        Indicates ID3 frame that has the timecode.
        """
        return pulumi.get(self, "timed_metadata_id3_frame")

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[int]:
        return pulumi.get(self, "timed_metadata_id3_period")

    @property
    @pulumi.getter(name="timestampDeltaMilliseconds")
    def timestamp_delta_milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "timestamp_delta_milliseconds")

    @property
    @pulumi.getter(name="tsFileMode")
    def ts_file_mode(self) -> Optional[str]:
        return pulumi.get(self, "ts_file_mode")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captionChannel":
            suggest = "caption_channel"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageDescription":
            suggest = "language_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caption_channel: int,
                 language_code: str,
                 language_description: str):
        """
        :param str language_code: Selects a specific three-letter language code from within an audio source.
        :param str language_description: Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caption_channel=caption_channel,
            language_code=language_code,
            language_description=language_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caption_channel: Optional[int] = None,
             language_code: Optional[str] = None,
             language_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if caption_channel is None and 'captionChannel' in kwargs:
            caption_channel = kwargs['captionChannel']
        if caption_channel is None:
            raise TypeError("Missing 'caption_channel' argument")
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if language_description is None and 'languageDescription' in kwargs:
            language_description = kwargs['languageDescription']
        if language_description is None:
            raise TypeError("Missing 'language_description' argument")

        _setter("caption_channel", caption_channel)
        _setter("language_code", language_code)
        _setter("language_description", language_description)

    @property
    @pulumi.getter(name="captionChannel")
    def caption_channel(self) -> int:
        return pulumi.get(self, "caption_channel")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> str:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> str:
        """
        Human readable information to indicate captions available for players (eg. English, or Spanish).
        """
        return pulumi.get(self, "language_description")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsAkamaiSettings":
            suggest = "hls_akamai_settings"
        elif key == "hlsBasicPutSettings":
            suggest = "hls_basic_put_settings"
        elif key == "hlsMediaStoreSettings":
            suggest = "hls_media_store_settings"
        elif key == "hlsS3Settings":
            suggest = "hls_s3_settings"
        elif key == "hlsWebdavSettings":
            suggest = "hls_webdav_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_akamai_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings'] = None,
                 hls_basic_put_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings'] = None,
                 hls_media_store_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings'] = None,
                 hls_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings'] = None,
                 hls_webdav_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings'] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_akamai_settings=hls_akamai_settings,
            hls_basic_put_settings=hls_basic_put_settings,
            hls_media_store_settings=hls_media_store_settings,
            hls_s3_settings=hls_s3_settings,
            hls_webdav_settings=hls_webdav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_akamai_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings'] = None,
             hls_basic_put_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings'] = None,
             hls_media_store_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings'] = None,
             hls_s3_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings'] = None,
             hls_webdav_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_akamai_settings is None and 'hlsAkamaiSettings' in kwargs:
            hls_akamai_settings = kwargs['hlsAkamaiSettings']
        if hls_basic_put_settings is None and 'hlsBasicPutSettings' in kwargs:
            hls_basic_put_settings = kwargs['hlsBasicPutSettings']
        if hls_media_store_settings is None and 'hlsMediaStoreSettings' in kwargs:
            hls_media_store_settings = kwargs['hlsMediaStoreSettings']
        if hls_s3_settings is None and 'hlsS3Settings' in kwargs:
            hls_s3_settings = kwargs['hlsS3Settings']
        if hls_webdav_settings is None and 'hlsWebdavSettings' in kwargs:
            hls_webdav_settings = kwargs['hlsWebdavSettings']

        if hls_akamai_settings is not None:
            _setter("hls_akamai_settings", hls_akamai_settings)
        if hls_basic_put_settings is not None:
            _setter("hls_basic_put_settings", hls_basic_put_settings)
        if hls_media_store_settings is not None:
            _setter("hls_media_store_settings", hls_media_store_settings)
        if hls_s3_settings is not None:
            _setter("hls_s3_settings", hls_s3_settings)
        if hls_webdav_settings is not None:
            _setter("hls_webdav_settings", hls_webdav_settings)

    @property
    @pulumi.getter(name="hlsAkamaiSettings")
    def hls_akamai_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings']:
        return pulumi.get(self, "hls_akamai_settings")

    @property
    @pulumi.getter(name="hlsBasicPutSettings")
    def hls_basic_put_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings']:
        return pulumi.get(self, "hls_basic_put_settings")

    @property
    @pulumi.getter(name="hlsMediaStoreSettings")
    def hls_media_store_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings']:
        return pulumi.get(self, "hls_media_store_settings")

    @property
    @pulumi.getter(name="hlsS3Settings")
    def hls_s3_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings']:
        return pulumi.get(self, "hls_s3_settings")

    @property
    @pulumi.getter(name="hlsWebdavSettings")
    def hls_webdav_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings']:
        return pulumi.get(self, "hls_webdav_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "httpTransferMode":
            suggest = "http_transfer_mode"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 http_transfer_mode: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None,
                 salt: Optional[str] = None,
                 token: Optional[str] = None):
        """
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param int num_retries: Number of retry attempts.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
            salt=salt,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             http_transfer_mode: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             salt: Optional[str] = None,
             token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if http_transfer_mode is None and 'httpTransferMode' in kwargs:
            http_transfer_mode = kwargs['httpTransferMode']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if salt is not None:
            _setter("salt", salt)
        if token is not None:
            _setter("token", token)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[str]:
        return pulumi.get(self, "http_transfer_mode")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @property
    @pulumi.getter
    def salt(self) -> Optional[str]:
        return pulumi.get(self, "salt")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        """
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param int num_retries: Number of retry attempts.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "mediaStoreStorageClass":
            suggest = "media_store_storage_class"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 media_store_storage_class: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        """
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param int num_retries: Number of retry attempts.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            media_store_storage_class=media_store_storage_class,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             media_store_storage_class: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if media_store_storage_class is None and 'mediaStoreStorageClass' in kwargs:
            media_store_storage_class = kwargs['mediaStoreStorageClass']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if media_store_storage_class is not None:
            _setter("media_store_storage_class", media_store_storage_class)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="mediaStoreStorageClass")
    def media_store_storage_class(self) -> Optional[str]:
        return pulumi.get(self, "media_store_storage_class")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        """
        :param str canned_acl: Specify the canned ACL to apply to each S3 request.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        """
        Specify the canned ACL to apply to each S3 request.
        """
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "httpTransferMode":
            suggest = "http_transfer_mode"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 http_transfer_mode: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        """
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param int num_retries: Number of retry attempts.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             http_transfer_mode: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if http_transfer_mode is None and 'httpTransferMode' in kwargs:
            http_transfer_mode = kwargs['httpTransferMode']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[str]:
        return pulumi.get(self, "http_transfer_mode")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticKeySettings":
            suggest = "static_key_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_key_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting']] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_key_settings=static_key_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_key_settings: Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if static_key_settings is None and 'staticKeySettings' in kwargs:
            static_key_settings = kwargs['staticKeySettings']

        if static_key_settings is not None:
            _setter("static_key_settings", static_key_settings)

    @property
    @pulumi.getter(name="staticKeySettings")
    def static_key_settings(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting']]:
        return pulumi.get(self, "static_key_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticKeyValue":
            suggest = "static_key_value"
        elif key == "keyProviderServer":
            suggest = "key_provider_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_key_value: str,
                 key_provider_server: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer'] = None):
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_key_value=static_key_value,
            key_provider_server=key_provider_server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_key_value: Optional[str] = None,
             key_provider_server: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if static_key_value is None and 'staticKeyValue' in kwargs:
            static_key_value = kwargs['staticKeyValue']
        if static_key_value is None:
            raise TypeError("Missing 'static_key_value' argument")
        if key_provider_server is None and 'keyProviderServer' in kwargs:
            key_provider_server = kwargs['keyProviderServer']

        _setter("static_key_value", static_key_value)
        if key_provider_server is not None:
            _setter("key_provider_server", key_provider_server)

    @property
    @pulumi.getter(name="staticKeyValue")
    def static_key_value(self) -> str:
        return pulumi.get(self, "static_key_value")

    @property
    @pulumi.getter(name="keyProviderServer")
    def key_provider_server(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer']:
        return pulumi.get(self, "key_provider_server")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: . Username to be used.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings(dict):
    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination'):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestinationArgs' destination: A director and base filename where archive files should be written. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination':
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acquisitionPointId":
            suggest = "acquisition_point_id"
        elif key == "audioOnlyTimecodeControl":
            suggest = "audio_only_timecode_control"
        elif key == "certificateMode":
            suggest = "certificate_mode"
        elif key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "eventId":
            suggest = "event_id"
        elif key == "eventIdMode":
            suggest = "event_id_mode"
        elif key == "eventStopBehavior":
            suggest = "event_stop_behavior"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "fragmentLength":
            suggest = "fragment_length"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"
        elif key == "segmentationMode":
            suggest = "segmentation_mode"
        elif key == "sendDelayMs":
            suggest = "send_delay_ms"
        elif key == "sparseTrackType":
            suggest = "sparse_track_type"
        elif key == "streamManifestBehavior":
            suggest = "stream_manifest_behavior"
        elif key == "timestampOffset":
            suggest = "timestamp_offset"
        elif key == "timestampOffsetMode":
            suggest = "timestamp_offset_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination',
                 acquisition_point_id: Optional[str] = None,
                 audio_only_timecode_control: Optional[str] = None,
                 certificate_mode: Optional[str] = None,
                 connection_retry_interval: Optional[int] = None,
                 event_id: Optional[str] = None,
                 event_id_mode: Optional[str] = None,
                 event_stop_behavior: Optional[str] = None,
                 filecache_duration: Optional[int] = None,
                 fragment_length: Optional[int] = None,
                 input_loss_action: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None,
                 segmentation_mode: Optional[str] = None,
                 send_delay_ms: Optional[int] = None,
                 sparse_track_type: Optional[str] = None,
                 stream_manifest_behavior: Optional[str] = None,
                 timestamp_offset: Optional[str] = None,
                 timestamp_offset_mode: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestinationArgs' destination: A director and base filename where archive files should be written. See Destination for more details.
        :param str certificate_mode: Setting to allow self signed or verified RTMP certificates.
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param str input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param int num_retries: Number of retry attempts.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            acquisition_point_id=acquisition_point_id,
            audio_only_timecode_control=audio_only_timecode_control,
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            event_id=event_id,
            event_id_mode=event_id_mode,
            event_stop_behavior=event_stop_behavior,
            filecache_duration=filecache_duration,
            fragment_length=fragment_length,
            input_loss_action=input_loss_action,
            num_retries=num_retries,
            restart_delay=restart_delay,
            segmentation_mode=segmentation_mode,
            send_delay_ms=send_delay_ms,
            sparse_track_type=sparse_track_type,
            stream_manifest_behavior=stream_manifest_behavior,
            timestamp_offset=timestamp_offset,
            timestamp_offset_mode=timestamp_offset_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination'] = None,
             acquisition_point_id: Optional[str] = None,
             audio_only_timecode_control: Optional[str] = None,
             certificate_mode: Optional[str] = None,
             connection_retry_interval: Optional[int] = None,
             event_id: Optional[str] = None,
             event_id_mode: Optional[str] = None,
             event_stop_behavior: Optional[str] = None,
             filecache_duration: Optional[int] = None,
             fragment_length: Optional[int] = None,
             input_loss_action: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             segmentation_mode: Optional[str] = None,
             send_delay_ms: Optional[int] = None,
             sparse_track_type: Optional[str] = None,
             stream_manifest_behavior: Optional[str] = None,
             timestamp_offset: Optional[str] = None,
             timestamp_offset_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if acquisition_point_id is None and 'acquisitionPointId' in kwargs:
            acquisition_point_id = kwargs['acquisitionPointId']
        if audio_only_timecode_control is None and 'audioOnlyTimecodeControl' in kwargs:
            audio_only_timecode_control = kwargs['audioOnlyTimecodeControl']
        if certificate_mode is None and 'certificateMode' in kwargs:
            certificate_mode = kwargs['certificateMode']
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if event_id is None and 'eventId' in kwargs:
            event_id = kwargs['eventId']
        if event_id_mode is None and 'eventIdMode' in kwargs:
            event_id_mode = kwargs['eventIdMode']
        if event_stop_behavior is None and 'eventStopBehavior' in kwargs:
            event_stop_behavior = kwargs['eventStopBehavior']
        if filecache_duration is None and 'filecacheDuration' in kwargs:
            filecache_duration = kwargs['filecacheDuration']
        if fragment_length is None and 'fragmentLength' in kwargs:
            fragment_length = kwargs['fragmentLength']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']
        if segmentation_mode is None and 'segmentationMode' in kwargs:
            segmentation_mode = kwargs['segmentationMode']
        if send_delay_ms is None and 'sendDelayMs' in kwargs:
            send_delay_ms = kwargs['sendDelayMs']
        if sparse_track_type is None and 'sparseTrackType' in kwargs:
            sparse_track_type = kwargs['sparseTrackType']
        if stream_manifest_behavior is None and 'streamManifestBehavior' in kwargs:
            stream_manifest_behavior = kwargs['streamManifestBehavior']
        if timestamp_offset is None and 'timestampOffset' in kwargs:
            timestamp_offset = kwargs['timestampOffset']
        if timestamp_offset_mode is None and 'timestampOffsetMode' in kwargs:
            timestamp_offset_mode = kwargs['timestampOffsetMode']

        _setter("destination", destination)
        if acquisition_point_id is not None:
            _setter("acquisition_point_id", acquisition_point_id)
        if audio_only_timecode_control is not None:
            _setter("audio_only_timecode_control", audio_only_timecode_control)
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if event_id is not None:
            _setter("event_id", event_id)
        if event_id_mode is not None:
            _setter("event_id_mode", event_id_mode)
        if event_stop_behavior is not None:
            _setter("event_stop_behavior", event_stop_behavior)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if fragment_length is not None:
            _setter("fragment_length", fragment_length)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if segmentation_mode is not None:
            _setter("segmentation_mode", segmentation_mode)
        if send_delay_ms is not None:
            _setter("send_delay_ms", send_delay_ms)
        if sparse_track_type is not None:
            _setter("sparse_track_type", sparse_track_type)
        if stream_manifest_behavior is not None:
            _setter("stream_manifest_behavior", stream_manifest_behavior)
        if timestamp_offset is not None:
            _setter("timestamp_offset", timestamp_offset)
        if timestamp_offset_mode is not None:
            _setter("timestamp_offset_mode", timestamp_offset_mode)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination':
        """
        A director and base filename where archive files should be written. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="acquisitionPointId")
    def acquisition_point_id(self) -> Optional[str]:
        return pulumi.get(self, "acquisition_point_id")

    @property
    @pulumi.getter(name="audioOnlyTimecodeControl")
    def audio_only_timecode_control(self) -> Optional[str]:
        return pulumi.get(self, "audio_only_timecode_control")

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[str]:
        """
        Setting to allow self signed or verified RTMP certificates.
        """
        return pulumi.get(self, "certificate_mode")

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="eventId")
    def event_id(self) -> Optional[str]:
        return pulumi.get(self, "event_id")

    @property
    @pulumi.getter(name="eventIdMode")
    def event_id_mode(self) -> Optional[str]:
        return pulumi.get(self, "event_id_mode")

    @property
    @pulumi.getter(name="eventStopBehavior")
    def event_stop_behavior(self) -> Optional[str]:
        return pulumi.get(self, "event_stop_behavior")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="fragmentLength")
    def fragment_length(self) -> Optional[int]:
        return pulumi.get(self, "fragment_length")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")

    @property
    @pulumi.getter(name="segmentationMode")
    def segmentation_mode(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_mode")

    @property
    @pulumi.getter(name="sendDelayMs")
    def send_delay_ms(self) -> Optional[int]:
        return pulumi.get(self, "send_delay_ms")

    @property
    @pulumi.getter(name="sparseTrackType")
    def sparse_track_type(self) -> Optional[str]:
        return pulumi.get(self, "sparse_track_type")

    @property
    @pulumi.getter(name="streamManifestBehavior")
    def stream_manifest_behavior(self) -> Optional[str]:
        return pulumi.get(self, "stream_manifest_behavior")

    @property
    @pulumi.getter(name="timestampOffset")
    def timestamp_offset(self) -> Optional[str]:
        return pulumi.get(self, "timestamp_offset")

    @property
    @pulumi.getter(name="timestampOffsetMode")
    def timestamp_offset_mode(self) -> Optional[str]:
        return pulumi.get(self, "timestamp_offset_mode")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adMarkers":
            suggest = "ad_markers"
        elif key == "authenticationScheme":
            suggest = "authentication_scheme"
        elif key == "cacheFullBehavior":
            suggest = "cache_full_behavior"
        elif key == "cacheLength":
            suggest = "cache_length"
        elif key == "captionData":
            suggest = "caption_data"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_markers: Optional[Sequence[str]] = None,
                 authentication_scheme: Optional[str] = None,
                 cache_full_behavior: Optional[str] = None,
                 cache_length: Optional[int] = None,
                 caption_data: Optional[str] = None,
                 input_loss_action: Optional[str] = None,
                 restart_delay: Optional[int] = None):
        """
        :param Sequence[str] ad_markers: The ad marker type for this output group.
        :param str authentication_scheme: Authentication scheme to use when connecting with CDN.
        :param str cache_full_behavior: Controls behavior when content cache fills up.
        :param int cache_length: Cache length in seconds, is used to calculate buffer size.
        :param str caption_data: Controls the types of data that passes to onCaptionInfo outputs.
        :param str input_loss_action: Controls the behavior of the RTMP group if input becomes unavailable.
        :param int restart_delay: Number of seconds to wait until a restart is initiated.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_markers=ad_markers,
            authentication_scheme=authentication_scheme,
            cache_full_behavior=cache_full_behavior,
            cache_length=cache_length,
            caption_data=caption_data,
            input_loss_action=input_loss_action,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_markers: Optional[Sequence[str]] = None,
             authentication_scheme: Optional[str] = None,
             cache_full_behavior: Optional[str] = None,
             cache_length: Optional[int] = None,
             caption_data: Optional[str] = None,
             input_loss_action: Optional[str] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ad_markers is None and 'adMarkers' in kwargs:
            ad_markers = kwargs['adMarkers']
        if authentication_scheme is None and 'authenticationScheme' in kwargs:
            authentication_scheme = kwargs['authenticationScheme']
        if cache_full_behavior is None and 'cacheFullBehavior' in kwargs:
            cache_full_behavior = kwargs['cacheFullBehavior']
        if cache_length is None and 'cacheLength' in kwargs:
            cache_length = kwargs['cacheLength']
        if caption_data is None and 'captionData' in kwargs:
            caption_data = kwargs['captionData']
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if restart_delay is None and 'restartDelay' in kwargs:
            restart_delay = kwargs['restartDelay']

        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if authentication_scheme is not None:
            _setter("authentication_scheme", authentication_scheme)
        if cache_full_behavior is not None:
            _setter("cache_full_behavior", cache_full_behavior)
        if cache_length is not None:
            _setter("cache_length", cache_length)
        if caption_data is not None:
            _setter("caption_data", caption_data)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[Sequence[str]]:
        """
        The ad marker type for this output group.
        """
        return pulumi.get(self, "ad_markers")

    @property
    @pulumi.getter(name="authenticationScheme")
    def authentication_scheme(self) -> Optional[str]:
        """
        Authentication scheme to use when connecting with CDN.
        """
        return pulumi.get(self, "authentication_scheme")

    @property
    @pulumi.getter(name="cacheFullBehavior")
    def cache_full_behavior(self) -> Optional[str]:
        """
        Controls behavior when content cache fills up.
        """
        return pulumi.get(self, "cache_full_behavior")

    @property
    @pulumi.getter(name="cacheLength")
    def cache_length(self) -> Optional[int]:
        """
        Cache length in seconds, is used to calculate buffer size.
        """
        return pulumi.get(self, "cache_length")

    @property
    @pulumi.getter(name="captionData")
    def caption_data(self) -> Optional[str]:
        """
        Controls the types of data that passes to onCaptionInfo outputs.
        """
        return pulumi.get(self, "caption_data")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        """
        Controls the behavior of the RTMP group if input becomes unavailable.
        """
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        """
        Number of seconds to wait until a restart is initiated.
        """
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "timedMetadataId3Frame":
            suggest = "timed_metadata_id3_frame"
        elif key == "timedMetadataId3Period":
            suggest = "timed_metadata_id3_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_loss_action: Optional[str] = None,
                 timed_metadata_id3_frame: Optional[str] = None,
                 timed_metadata_id3_period: Optional[int] = None):
        """
        :param str input_loss_action: Specifies behavior of last resort when input video os lost.
        :param str timed_metadata_id3_frame: Indicates ID3 frame that has the timecode.
        """
        ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_action=input_loss_action,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_action: Optional[str] = None,
             timed_metadata_id3_frame: Optional[str] = None,
             timed_metadata_id3_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_loss_action is None and 'inputLossAction' in kwargs:
            input_loss_action = kwargs['inputLossAction']
        if timed_metadata_id3_frame is None and 'timedMetadataId3Frame' in kwargs:
            timed_metadata_id3_frame = kwargs['timedMetadataId3Frame']
        if timed_metadata_id3_period is None and 'timedMetadataId3Period' in kwargs:
            timed_metadata_id3_period = kwargs['timedMetadataId3Period']

        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        """
        Specifies behavior of last resort when input video os lost.
        """
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[str]:
        """
        Indicates ID3 frame that has the timecode.
        """
        return pulumi.get(self, "timed_metadata_id3_frame")

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[int]:
        return pulumi.get(self, "timed_metadata_id3_period")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveOutputSettings":
            suggest = "archive_output_settings"
        elif key == "frameCaptureOutputSettings":
            suggest = "frame_capture_output_settings"
        elif key == "hlsOutputSettings":
            suggest = "hls_output_settings"
        elif key == "mediaPackageOutputSettings":
            suggest = "media_package_output_settings"
        elif key == "msSmoothOutputSettings":
            suggest = "ms_smooth_output_settings"
        elif key == "multiplexOutputSettings":
            suggest = "multiplex_output_settings"
        elif key == "rtmpOutputSettings":
            suggest = "rtmp_output_settings"
        elif key == "udpOutputSettings":
            suggest = "udp_output_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings'] = None,
                 frame_capture_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings'] = None,
                 hls_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings'] = None,
                 media_package_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings'] = None,
                 ms_smooth_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings'] = None,
                 multiplex_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings'] = None,
                 rtmp_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings'] = None,
                 udp_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsArgs' archive_output_settings: Archive output settings. See Archive Output Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettingsArgs' media_package_output_settings: Media package output settings. This can be set as an empty block.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsArgs' multiplex_output_settings: Multiplex output settings. See Multiplex Output Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsArgs' rtmp_output_settings: RTMP output settings. See RTMP Output Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsArgs' udp_output_settings: UDP output settings. See UDP Output Settings for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_output_settings=archive_output_settings,
            frame_capture_output_settings=frame_capture_output_settings,
            hls_output_settings=hls_output_settings,
            media_package_output_settings=media_package_output_settings,
            ms_smooth_output_settings=ms_smooth_output_settings,
            multiplex_output_settings=multiplex_output_settings,
            rtmp_output_settings=rtmp_output_settings,
            udp_output_settings=udp_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings'] = None,
             frame_capture_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings'] = None,
             hls_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings'] = None,
             media_package_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings'] = None,
             ms_smooth_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings'] = None,
             multiplex_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings'] = None,
             rtmp_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings'] = None,
             udp_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_output_settings is None and 'archiveOutputSettings' in kwargs:
            archive_output_settings = kwargs['archiveOutputSettings']
        if frame_capture_output_settings is None and 'frameCaptureOutputSettings' in kwargs:
            frame_capture_output_settings = kwargs['frameCaptureOutputSettings']
        if hls_output_settings is None and 'hlsOutputSettings' in kwargs:
            hls_output_settings = kwargs['hlsOutputSettings']
        if media_package_output_settings is None and 'mediaPackageOutputSettings' in kwargs:
            media_package_output_settings = kwargs['mediaPackageOutputSettings']
        if ms_smooth_output_settings is None and 'msSmoothOutputSettings' in kwargs:
            ms_smooth_output_settings = kwargs['msSmoothOutputSettings']
        if multiplex_output_settings is None and 'multiplexOutputSettings' in kwargs:
            multiplex_output_settings = kwargs['multiplexOutputSettings']
        if rtmp_output_settings is None and 'rtmpOutputSettings' in kwargs:
            rtmp_output_settings = kwargs['rtmpOutputSettings']
        if udp_output_settings is None and 'udpOutputSettings' in kwargs:
            udp_output_settings = kwargs['udpOutputSettings']

        if archive_output_settings is not None:
            _setter("archive_output_settings", archive_output_settings)
        if frame_capture_output_settings is not None:
            _setter("frame_capture_output_settings", frame_capture_output_settings)
        if hls_output_settings is not None:
            _setter("hls_output_settings", hls_output_settings)
        if media_package_output_settings is not None:
            _setter("media_package_output_settings", media_package_output_settings)
        if ms_smooth_output_settings is not None:
            _setter("ms_smooth_output_settings", ms_smooth_output_settings)
        if multiplex_output_settings is not None:
            _setter("multiplex_output_settings", multiplex_output_settings)
        if rtmp_output_settings is not None:
            _setter("rtmp_output_settings", rtmp_output_settings)
        if udp_output_settings is not None:
            _setter("udp_output_settings", udp_output_settings)

    @property
    @pulumi.getter(name="archiveOutputSettings")
    def archive_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings']:
        """
        Archive output settings. See Archive Output Settings for more details.
        """
        return pulumi.get(self, "archive_output_settings")

    @property
    @pulumi.getter(name="frameCaptureOutputSettings")
    def frame_capture_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings']:
        return pulumi.get(self, "frame_capture_output_settings")

    @property
    @pulumi.getter(name="hlsOutputSettings")
    def hls_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings']:
        return pulumi.get(self, "hls_output_settings")

    @property
    @pulumi.getter(name="mediaPackageOutputSettings")
    def media_package_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings']:
        """
        Media package output settings. This can be set as an empty block.
        """
        return pulumi.get(self, "media_package_output_settings")

    @property
    @pulumi.getter(name="msSmoothOutputSettings")
    def ms_smooth_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings']:
        return pulumi.get(self, "ms_smooth_output_settings")

    @property
    @pulumi.getter(name="multiplexOutputSettings")
    def multiplex_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings']:
        """
        Multiplex output settings. See Multiplex Output Settings for more details.
        """
        return pulumi.get(self, "multiplex_output_settings")

    @property
    @pulumi.getter(name="rtmpOutputSettings")
    def rtmp_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings']:
        """
        RTMP output settings. See RTMP Output Settings for more details.
        """
        return pulumi.get(self, "rtmp_output_settings")

    @property
    @pulumi.getter(name="udpOutputSettings")
    def udp_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings']:
        """
        UDP output settings. See UDP Output Settings for more details.
        """
        return pulumi.get(self, "udp_output_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerSettings":
            suggest = "container_settings"
        elif key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings'] = None,
                 extension: Optional[str] = None,
                 name_modifier: Optional[str] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsArgs' container_settings: Settings specific to the container type of the file. See Container Settings for more details.
        :param str extension: Output file extension.
        :param str name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_settings=container_settings,
            extension=extension,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings'] = None,
             extension: Optional[str] = None,
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_settings is None and 'containerSettings' in kwargs:
            container_settings = kwargs['containerSettings']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if container_settings is not None:
            _setter("container_settings", container_settings)
        if extension is not None:
            _setter("extension", extension)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings']:
        """
        Settings specific to the container type of the file. See Container Settings for more details.
        """
        return pulumi.get(self, "container_settings")

    @property
    @pulumi.getter
    def extension(self) -> Optional[str]:
        """
        Output file extension.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "m2tsSettings":
            suggest = "m2ts_settings"
        elif key == "rawSettings":
            suggest = "raw_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m2ts_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings'] = None,
                 raw_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsArgs' m2ts_settings: M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettingsArgs' raw_settings: Raw Settings. This can be set as an empty block.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
            raw_settings=raw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings'] = None,
             raw_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m2ts_settings is None and 'm2tsSettings' in kwargs:
            m2ts_settings = kwargs['m2tsSettings']
        if raw_settings is None and 'rawSettings' in kwargs:
            raw_settings = kwargs['rawSettings']

        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)
        if raw_settings is not None:
            _setter("raw_settings", raw_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings']:
        """
        M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        return pulumi.get(self, "m2ts_settings")

    @property
    @pulumi.getter(name="rawSettings")
    def raw_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings']:
        """
        Raw Settings. This can be set as an empty block.
        """
        return pulumi.get(self, "raw_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absentInputAudioBehavior":
            suggest = "absent_input_audio_behavior"
        elif key == "aribCaptionsPid":
            suggest = "arib_captions_pid"
        elif key == "aribCaptionsPidControl":
            suggest = "arib_captions_pid_control"
        elif key == "audioBufferModel":
            suggest = "audio_buffer_model"
        elif key == "audioFramesPerPes":
            suggest = "audio_frames_per_pes"
        elif key == "audioPids":
            suggest = "audio_pids"
        elif key == "audioStreamType":
            suggest = "audio_stream_type"
        elif key == "bufferModel":
            suggest = "buffer_model"
        elif key == "ccDescriptor":
            suggest = "cc_descriptor"
        elif key == "dvbNitSettings":
            suggest = "dvb_nit_settings"
        elif key == "dvbSdtSettings":
            suggest = "dvb_sdt_settings"
        elif key == "dvbSubPids":
            suggest = "dvb_sub_pids"
        elif key == "dvbTdtSettings":
            suggest = "dvb_tdt_settings"
        elif key == "dvbTeletextPid":
            suggest = "dvb_teletext_pid"
        elif key == "ebpAudioInterval":
            suggest = "ebp_audio_interval"
        elif key == "ebpLookaheadMs":
            suggest = "ebp_lookahead_ms"
        elif key == "ebpPlacement":
            suggest = "ebp_placement"
        elif key == "ecmPid":
            suggest = "ecm_pid"
        elif key == "esRateInPes":
            suggest = "es_rate_in_pes"
        elif key == "etvPlatformPid":
            suggest = "etv_platform_pid"
        elif key == "etvSignalPid":
            suggest = "etv_signal_pid"
        elif key == "fragmentTime":
            suggest = "fragment_time"
        elif key == "klvDataPids":
            suggest = "klv_data_pids"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "nullPacketBitrate":
            suggest = "null_packet_bitrate"
        elif key == "patInterval":
            suggest = "pat_interval"
        elif key == "pcrControl":
            suggest = "pcr_control"
        elif key == "pcrPeriod":
            suggest = "pcr_period"
        elif key == "pcrPid":
            suggest = "pcr_pid"
        elif key == "pmtInterval":
            suggest = "pmt_interval"
        elif key == "pmtPid":
            suggest = "pmt_pid"
        elif key == "programNum":
            suggest = "program_num"
        elif key == "rateMode":
            suggest = "rate_mode"
        elif key == "scte27Pids":
            suggest = "scte27_pids"
        elif key == "scte35Control":
            suggest = "scte35_control"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "segmentationMarkers":
            suggest = "segmentation_markers"
        elif key == "segmentationStyle":
            suggest = "segmentation_style"
        elif key == "segmentationTime":
            suggest = "segmentation_time"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"
        elif key == "timedMetadataPid":
            suggest = "timed_metadata_pid"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "videoPid":
            suggest = "video_pid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absent_input_audio_behavior: Optional[str] = None,
                 arib: Optional[str] = None,
                 arib_captions_pid: Optional[str] = None,
                 arib_captions_pid_control: Optional[str] = None,
                 audio_buffer_model: Optional[str] = None,
                 audio_frames_per_pes: Optional[int] = None,
                 audio_pids: Optional[str] = None,
                 audio_stream_type: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buffer_model: Optional[str] = None,
                 cc_descriptor: Optional[str] = None,
                 dvb_nit_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings'] = None,
                 dvb_sdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings'] = None,
                 dvb_sub_pids: Optional[str] = None,
                 dvb_tdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings'] = None,
                 dvb_teletext_pid: Optional[str] = None,
                 ebif: Optional[str] = None,
                 ebp_audio_interval: Optional[str] = None,
                 ebp_lookahead_ms: Optional[int] = None,
                 ebp_placement: Optional[str] = None,
                 ecm_pid: Optional[str] = None,
                 es_rate_in_pes: Optional[str] = None,
                 etv_platform_pid: Optional[str] = None,
                 etv_signal_pid: Optional[str] = None,
                 fragment_time: Optional[float] = None,
                 klv: Optional[str] = None,
                 klv_data_pids: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 null_packet_bitrate: Optional[float] = None,
                 pat_interval: Optional[int] = None,
                 pcr_control: Optional[str] = None,
                 pcr_period: Optional[int] = None,
                 pcr_pid: Optional[str] = None,
                 pmt_interval: Optional[int] = None,
                 pmt_pid: Optional[str] = None,
                 program_num: Optional[int] = None,
                 rate_mode: Optional[str] = None,
                 scte27_pids: Optional[str] = None,
                 scte35_control: Optional[str] = None,
                 scte35_pid: Optional[str] = None,
                 segmentation_markers: Optional[str] = None,
                 segmentation_style: Optional[str] = None,
                 segmentation_time: Optional[float] = None,
                 timed_metadata_behavior: Optional[str] = None,
                 timed_metadata_pid: Optional[str] = None,
                 transport_stream_id: Optional[int] = None,
                 video_pid: Optional[str] = None):
        """
        :param int bitrate: Average bitrate in bits/second.
        :param str scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            absent_input_audio_behavior=absent_input_audio_behavior,
            arib=arib,
            arib_captions_pid=arib_captions_pid,
            arib_captions_pid_control=arib_captions_pid_control,
            audio_buffer_model=audio_buffer_model,
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            audio_stream_type=audio_stream_type,
            bitrate=bitrate,
            buffer_model=buffer_model,
            cc_descriptor=cc_descriptor,
            dvb_nit_settings=dvb_nit_settings,
            dvb_sdt_settings=dvb_sdt_settings,
            dvb_sub_pids=dvb_sub_pids,
            dvb_tdt_settings=dvb_tdt_settings,
            dvb_teletext_pid=dvb_teletext_pid,
            ebif=ebif,
            ebp_audio_interval=ebp_audio_interval,
            ebp_lookahead_ms=ebp_lookahead_ms,
            ebp_placement=ebp_placement,
            ecm_pid=ecm_pid,
            es_rate_in_pes=es_rate_in_pes,
            etv_platform_pid=etv_platform_pid,
            etv_signal_pid=etv_signal_pid,
            fragment_time=fragment_time,
            klv=klv,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            null_packet_bitrate=null_packet_bitrate,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            rate_mode=rate_mode,
            scte27_pids=scte27_pids,
            scte35_control=scte35_control,
            scte35_pid=scte35_pid,
            segmentation_markers=segmentation_markers,
            segmentation_style=segmentation_style,
            segmentation_time=segmentation_time,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             absent_input_audio_behavior: Optional[str] = None,
             arib: Optional[str] = None,
             arib_captions_pid: Optional[str] = None,
             arib_captions_pid_control: Optional[str] = None,
             audio_buffer_model: Optional[str] = None,
             audio_frames_per_pes: Optional[int] = None,
             audio_pids: Optional[str] = None,
             audio_stream_type: Optional[str] = None,
             bitrate: Optional[int] = None,
             buffer_model: Optional[str] = None,
             cc_descriptor: Optional[str] = None,
             dvb_nit_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings'] = None,
             dvb_sdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings'] = None,
             dvb_sub_pids: Optional[str] = None,
             dvb_tdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings'] = None,
             dvb_teletext_pid: Optional[str] = None,
             ebif: Optional[str] = None,
             ebp_audio_interval: Optional[str] = None,
             ebp_lookahead_ms: Optional[int] = None,
             ebp_placement: Optional[str] = None,
             ecm_pid: Optional[str] = None,
             es_rate_in_pes: Optional[str] = None,
             etv_platform_pid: Optional[str] = None,
             etv_signal_pid: Optional[str] = None,
             fragment_time: Optional[float] = None,
             klv: Optional[str] = None,
             klv_data_pids: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             null_packet_bitrate: Optional[float] = None,
             pat_interval: Optional[int] = None,
             pcr_control: Optional[str] = None,
             pcr_period: Optional[int] = None,
             pcr_pid: Optional[str] = None,
             pmt_interval: Optional[int] = None,
             pmt_pid: Optional[str] = None,
             program_num: Optional[int] = None,
             rate_mode: Optional[str] = None,
             scte27_pids: Optional[str] = None,
             scte35_control: Optional[str] = None,
             scte35_pid: Optional[str] = None,
             segmentation_markers: Optional[str] = None,
             segmentation_style: Optional[str] = None,
             segmentation_time: Optional[float] = None,
             timed_metadata_behavior: Optional[str] = None,
             timed_metadata_pid: Optional[str] = None,
             transport_stream_id: Optional[int] = None,
             video_pid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if absent_input_audio_behavior is None and 'absentInputAudioBehavior' in kwargs:
            absent_input_audio_behavior = kwargs['absentInputAudioBehavior']
        if arib_captions_pid is None and 'aribCaptionsPid' in kwargs:
            arib_captions_pid = kwargs['aribCaptionsPid']
        if arib_captions_pid_control is None and 'aribCaptionsPidControl' in kwargs:
            arib_captions_pid_control = kwargs['aribCaptionsPidControl']
        if audio_buffer_model is None and 'audioBufferModel' in kwargs:
            audio_buffer_model = kwargs['audioBufferModel']
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if audio_stream_type is None and 'audioStreamType' in kwargs:
            audio_stream_type = kwargs['audioStreamType']
        if buffer_model is None and 'bufferModel' in kwargs:
            buffer_model = kwargs['bufferModel']
        if cc_descriptor is None and 'ccDescriptor' in kwargs:
            cc_descriptor = kwargs['ccDescriptor']
        if dvb_nit_settings is None and 'dvbNitSettings' in kwargs:
            dvb_nit_settings = kwargs['dvbNitSettings']
        if dvb_sdt_settings is None and 'dvbSdtSettings' in kwargs:
            dvb_sdt_settings = kwargs['dvbSdtSettings']
        if dvb_sub_pids is None and 'dvbSubPids' in kwargs:
            dvb_sub_pids = kwargs['dvbSubPids']
        if dvb_tdt_settings is None and 'dvbTdtSettings' in kwargs:
            dvb_tdt_settings = kwargs['dvbTdtSettings']
        if dvb_teletext_pid is None and 'dvbTeletextPid' in kwargs:
            dvb_teletext_pid = kwargs['dvbTeletextPid']
        if ebp_audio_interval is None and 'ebpAudioInterval' in kwargs:
            ebp_audio_interval = kwargs['ebpAudioInterval']
        if ebp_lookahead_ms is None and 'ebpLookaheadMs' in kwargs:
            ebp_lookahead_ms = kwargs['ebpLookaheadMs']
        if ebp_placement is None and 'ebpPlacement' in kwargs:
            ebp_placement = kwargs['ebpPlacement']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if es_rate_in_pes is None and 'esRateInPes' in kwargs:
            es_rate_in_pes = kwargs['esRateInPes']
        if etv_platform_pid is None and 'etvPlatformPid' in kwargs:
            etv_platform_pid = kwargs['etvPlatformPid']
        if etv_signal_pid is None and 'etvSignalPid' in kwargs:
            etv_signal_pid = kwargs['etvSignalPid']
        if fragment_time is None and 'fragmentTime' in kwargs:
            fragment_time = kwargs['fragmentTime']
        if klv_data_pids is None and 'klvDataPids' in kwargs:
            klv_data_pids = kwargs['klvDataPids']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if null_packet_bitrate is None and 'nullPacketBitrate' in kwargs:
            null_packet_bitrate = kwargs['nullPacketBitrate']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if rate_mode is None and 'rateMode' in kwargs:
            rate_mode = kwargs['rateMode']
        if scte27_pids is None and 'scte27Pids' in kwargs:
            scte27_pids = kwargs['scte27Pids']
        if scte35_control is None and 'scte35Control' in kwargs:
            scte35_control = kwargs['scte35Control']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if segmentation_markers is None and 'segmentationMarkers' in kwargs:
            segmentation_markers = kwargs['segmentationMarkers']
        if segmentation_style is None and 'segmentationStyle' in kwargs:
            segmentation_style = kwargs['segmentationStyle']
        if segmentation_time is None and 'segmentationTime' in kwargs:
            segmentation_time = kwargs['segmentationTime']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if absent_input_audio_behavior is not None:
            _setter("absent_input_audio_behavior", absent_input_audio_behavior)
        if arib is not None:
            _setter("arib", arib)
        if arib_captions_pid is not None:
            _setter("arib_captions_pid", arib_captions_pid)
        if arib_captions_pid_control is not None:
            _setter("arib_captions_pid_control", arib_captions_pid_control)
        if audio_buffer_model is not None:
            _setter("audio_buffer_model", audio_buffer_model)
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if audio_stream_type is not None:
            _setter("audio_stream_type", audio_stream_type)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buffer_model is not None:
            _setter("buffer_model", buffer_model)
        if cc_descriptor is not None:
            _setter("cc_descriptor", cc_descriptor)
        if dvb_nit_settings is not None:
            _setter("dvb_nit_settings", dvb_nit_settings)
        if dvb_sdt_settings is not None:
            _setter("dvb_sdt_settings", dvb_sdt_settings)
        if dvb_sub_pids is not None:
            _setter("dvb_sub_pids", dvb_sub_pids)
        if dvb_tdt_settings is not None:
            _setter("dvb_tdt_settings", dvb_tdt_settings)
        if dvb_teletext_pid is not None:
            _setter("dvb_teletext_pid", dvb_teletext_pid)
        if ebif is not None:
            _setter("ebif", ebif)
        if ebp_audio_interval is not None:
            _setter("ebp_audio_interval", ebp_audio_interval)
        if ebp_lookahead_ms is not None:
            _setter("ebp_lookahead_ms", ebp_lookahead_ms)
        if ebp_placement is not None:
            _setter("ebp_placement", ebp_placement)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if es_rate_in_pes is not None:
            _setter("es_rate_in_pes", es_rate_in_pes)
        if etv_platform_pid is not None:
            _setter("etv_platform_pid", etv_platform_pid)
        if etv_signal_pid is not None:
            _setter("etv_signal_pid", etv_signal_pid)
        if fragment_time is not None:
            _setter("fragment_time", fragment_time)
        if klv is not None:
            _setter("klv", klv)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if null_packet_bitrate is not None:
            _setter("null_packet_bitrate", null_packet_bitrate)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if rate_mode is not None:
            _setter("rate_mode", rate_mode)
        if scte27_pids is not None:
            _setter("scte27_pids", scte27_pids)
        if scte35_control is not None:
            _setter("scte35_control", scte35_control)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if segmentation_markers is not None:
            _setter("segmentation_markers", segmentation_markers)
        if segmentation_style is not None:
            _setter("segmentation_style", segmentation_style)
        if segmentation_time is not None:
            _setter("segmentation_time", segmentation_time)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="absentInputAudioBehavior")
    def absent_input_audio_behavior(self) -> Optional[str]:
        return pulumi.get(self, "absent_input_audio_behavior")

    @property
    @pulumi.getter
    def arib(self) -> Optional[str]:
        return pulumi.get(self, "arib")

    @property
    @pulumi.getter(name="aribCaptionsPid")
    def arib_captions_pid(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid")

    @property
    @pulumi.getter(name="aribCaptionsPidControl")
    def arib_captions_pid_control(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid_control")

    @property
    @pulumi.getter(name="audioBufferModel")
    def audio_buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "audio_buffer_model")

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[int]:
        return pulumi.get(self, "audio_frames_per_pes")

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[str]:
        return pulumi.get(self, "audio_pids")

    @property
    @pulumi.getter(name="audioStreamType")
    def audio_stream_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_stream_type")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufferModel")
    def buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "buffer_model")

    @property
    @pulumi.getter(name="ccDescriptor")
    def cc_descriptor(self) -> Optional[str]:
        return pulumi.get(self, "cc_descriptor")

    @property
    @pulumi.getter(name="dvbNitSettings")
    def dvb_nit_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings']:
        return pulumi.get(self, "dvb_nit_settings")

    @property
    @pulumi.getter(name="dvbSdtSettings")
    def dvb_sdt_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings']:
        return pulumi.get(self, "dvb_sdt_settings")

    @property
    @pulumi.getter(name="dvbSubPids")
    def dvb_sub_pids(self) -> Optional[str]:
        return pulumi.get(self, "dvb_sub_pids")

    @property
    @pulumi.getter(name="dvbTdtSettings")
    def dvb_tdt_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings']:
        return pulumi.get(self, "dvb_tdt_settings")

    @property
    @pulumi.getter(name="dvbTeletextPid")
    def dvb_teletext_pid(self) -> Optional[str]:
        return pulumi.get(self, "dvb_teletext_pid")

    @property
    @pulumi.getter
    def ebif(self) -> Optional[str]:
        return pulumi.get(self, "ebif")

    @property
    @pulumi.getter(name="ebpAudioInterval")
    def ebp_audio_interval(self) -> Optional[str]:
        return pulumi.get(self, "ebp_audio_interval")

    @property
    @pulumi.getter(name="ebpLookaheadMs")
    def ebp_lookahead_ms(self) -> Optional[int]:
        return pulumi.get(self, "ebp_lookahead_ms")

    @property
    @pulumi.getter(name="ebpPlacement")
    def ebp_placement(self) -> Optional[str]:
        return pulumi.get(self, "ebp_placement")

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[str]:
        return pulumi.get(self, "ecm_pid")

    @property
    @pulumi.getter(name="esRateInPes")
    def es_rate_in_pes(self) -> Optional[str]:
        return pulumi.get(self, "es_rate_in_pes")

    @property
    @pulumi.getter(name="etvPlatformPid")
    def etv_platform_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_platform_pid")

    @property
    @pulumi.getter(name="etvSignalPid")
    def etv_signal_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_signal_pid")

    @property
    @pulumi.getter(name="fragmentTime")
    def fragment_time(self) -> Optional[float]:
        return pulumi.get(self, "fragment_time")

    @property
    @pulumi.getter
    def klv(self) -> Optional[str]:
        return pulumi.get(self, "klv")

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[str]:
        return pulumi.get(self, "klv_data_pids")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="nullPacketBitrate")
    def null_packet_bitrate(self) -> Optional[float]:
        return pulumi.get(self, "null_packet_bitrate")

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[int]:
        return pulumi.get(self, "pat_interval")

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[str]:
        return pulumi.get(self, "pcr_control")

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[int]:
        return pulumi.get(self, "pcr_period")

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[str]:
        return pulumi.get(self, "pcr_pid")

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[int]:
        return pulumi.get(self, "pmt_interval")

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[str]:
        return pulumi.get(self, "pmt_pid")

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[int]:
        return pulumi.get(self, "program_num")

    @property
    @pulumi.getter(name="rateMode")
    def rate_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_mode")

    @property
    @pulumi.getter(name="scte27Pids")
    def scte27_pids(self) -> Optional[str]:
        return pulumi.get(self, "scte27_pids")

    @property
    @pulumi.getter(name="scte35Control")
    def scte35_control(self) -> Optional[str]:
        return pulumi.get(self, "scte35_control")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[str]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="segmentationMarkers")
    def segmentation_markers(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_markers")

    @property
    @pulumi.getter(name="segmentationStyle")
    def segmentation_style(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_style")

    @property
    @pulumi.getter(name="segmentationTime")
    def segmentation_time(self) -> Optional[float]:
        return pulumi.get(self, "segmentation_time")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_pid")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[int]:
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[str]:
        return pulumi.get(self, "video_pid")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: int,
                 network_name: str,
                 rep_interval: Optional[int] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            network_name=network_name,
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[int] = None,
             network_name: Optional[str] = None,
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if network_name is None and 'networkName' in kwargs:
            network_name = kwargs['networkName']
        if network_name is None:
            raise TypeError("Missing 'network_name' argument")
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        _setter("network_id", network_id)
        _setter("network_name", network_name)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> int:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSdt":
            suggest = "output_sdt"
        elif key == "repInterval":
            suggest = "rep_interval"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceProviderName":
            suggest = "service_provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_sdt: Optional[str] = None,
                 rep_interval: Optional[int] = None,
                 service_name: Optional[str] = None,
                 service_provider_name: Optional[str] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_sdt=output_sdt,
            rep_interval=rep_interval,
            service_name=service_name,
            service_provider_name=service_provider_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_sdt: Optional[str] = None,
             rep_interval: Optional[int] = None,
             service_name: Optional[str] = None,
             service_provider_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_sdt is None and 'outputSdt' in kwargs:
            output_sdt = kwargs['outputSdt']
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_provider_name is None and 'serviceProviderName' in kwargs:
            service_provider_name = kwargs['serviceProviderName']

        if output_sdt is not None:
            _setter("output_sdt", output_sdt)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)
        if service_name is not None:
            _setter("service_name", service_name)
        if service_provider_name is not None:
            _setter("service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="outputSdt")
    def output_sdt(self) -> Optional[str]:
        return pulumi.get(self, "output_sdt")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> Optional[str]:
        return pulumi.get(self, "service_provider_name")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rep_interval: Optional[int] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_modifier: Optional[str] = None):
        """
        :param str name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsSettings":
            suggest = "hls_settings"
        elif key == "h265PackagingType":
            suggest = "h265_packaging_type"
        elif key == "nameModifier":
            suggest = "name_modifier"
        elif key == "segmentModifier":
            suggest = "segment_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_settings: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings',
                 h265_packaging_type: Optional[str] = None,
                 name_modifier: Optional[str] = None,
                 segment_modifier: Optional[str] = None):
        """
        :param str name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_settings=hls_settings,
            h265_packaging_type=h265_packaging_type,
            name_modifier=name_modifier,
            segment_modifier=segment_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings'] = None,
             h265_packaging_type: Optional[str] = None,
             name_modifier: Optional[str] = None,
             segment_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_settings is None and 'hlsSettings' in kwargs:
            hls_settings = kwargs['hlsSettings']
        if hls_settings is None:
            raise TypeError("Missing 'hls_settings' argument")
        if h265_packaging_type is None and 'h265PackagingType' in kwargs:
            h265_packaging_type = kwargs['h265PackagingType']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']
        if segment_modifier is None and 'segmentModifier' in kwargs:
            segment_modifier = kwargs['segmentModifier']

        _setter("hls_settings", hls_settings)
        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)
        if segment_modifier is not None:
            _setter("segment_modifier", segment_modifier)

    @property
    @pulumi.getter(name="hlsSettings")
    def hls_settings(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings':
        return pulumi.get(self, "hls_settings")

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[str]:
        return pulumi.get(self, "h265_packaging_type")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")

    @property
    @pulumi.getter(name="segmentModifier")
    def segment_modifier(self) -> Optional[str]:
        return pulumi.get(self, "segment_modifier")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioOnlyHlsSettings":
            suggest = "audio_only_hls_settings"
        elif key == "fmp4HlsSettings":
            suggest = "fmp4_hls_settings"
        elif key == "frameCaptureHlsSettings":
            suggest = "frame_capture_hls_settings"
        elif key == "standardHlsSettings":
            suggest = "standard_hls_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_only_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings'] = None,
                 fmp4_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings'] = None,
                 frame_capture_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings'] = None,
                 standard_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings'] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_only_hls_settings=audio_only_hls_settings,
            fmp4_hls_settings=fmp4_hls_settings,
            frame_capture_hls_settings=frame_capture_hls_settings,
            standard_hls_settings=standard_hls_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_only_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings'] = None,
             fmp4_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings'] = None,
             frame_capture_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings'] = None,
             standard_hls_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_only_hls_settings is None and 'audioOnlyHlsSettings' in kwargs:
            audio_only_hls_settings = kwargs['audioOnlyHlsSettings']
        if fmp4_hls_settings is None and 'fmp4HlsSettings' in kwargs:
            fmp4_hls_settings = kwargs['fmp4HlsSettings']
        if frame_capture_hls_settings is None and 'frameCaptureHlsSettings' in kwargs:
            frame_capture_hls_settings = kwargs['frameCaptureHlsSettings']
        if standard_hls_settings is None and 'standardHlsSettings' in kwargs:
            standard_hls_settings = kwargs['standardHlsSettings']

        if audio_only_hls_settings is not None:
            _setter("audio_only_hls_settings", audio_only_hls_settings)
        if fmp4_hls_settings is not None:
            _setter("fmp4_hls_settings", fmp4_hls_settings)
        if frame_capture_hls_settings is not None:
            _setter("frame_capture_hls_settings", frame_capture_hls_settings)
        if standard_hls_settings is not None:
            _setter("standard_hls_settings", standard_hls_settings)

    @property
    @pulumi.getter(name="audioOnlyHlsSettings")
    def audio_only_hls_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings']:
        return pulumi.get(self, "audio_only_hls_settings")

    @property
    @pulumi.getter(name="fmp4HlsSettings")
    def fmp4_hls_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings']:
        return pulumi.get(self, "fmp4_hls_settings")

    @property
    @pulumi.getter(name="frameCaptureHlsSettings")
    def frame_capture_hls_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings']:
        return pulumi.get(self, "frame_capture_hls_settings")

    @property
    @pulumi.getter(name="standardHlsSettings")
    def standard_hls_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings']:
        return pulumi.get(self, "standard_hls_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioGroupId":
            suggest = "audio_group_id"
        elif key == "audioOnlyImage":
            suggest = "audio_only_image"
        elif key == "audioTrackType":
            suggest = "audio_track_type"
        elif key == "segmentType":
            suggest = "segment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_group_id: Optional[str] = None,
                 audio_only_image: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage'] = None,
                 audio_track_type: Optional[str] = None,
                 segment_type: Optional[str] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_group_id=audio_group_id,
            audio_only_image=audio_only_image,
            audio_track_type=audio_track_type,
            segment_type=segment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_group_id: Optional[str] = None,
             audio_only_image: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage'] = None,
             audio_track_type: Optional[str] = None,
             segment_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_group_id is None and 'audioGroupId' in kwargs:
            audio_group_id = kwargs['audioGroupId']
        if audio_only_image is None and 'audioOnlyImage' in kwargs:
            audio_only_image = kwargs['audioOnlyImage']
        if audio_track_type is None and 'audioTrackType' in kwargs:
            audio_track_type = kwargs['audioTrackType']
        if segment_type is None and 'segmentType' in kwargs:
            segment_type = kwargs['segmentType']

        if audio_group_id is not None:
            _setter("audio_group_id", audio_group_id)
        if audio_only_image is not None:
            _setter("audio_only_image", audio_only_image)
        if audio_track_type is not None:
            _setter("audio_track_type", audio_track_type)
        if segment_type is not None:
            _setter("segment_type", segment_type)

    @property
    @pulumi.getter(name="audioGroupId")
    def audio_group_id(self) -> Optional[str]:
        return pulumi.get(self, "audio_group_id")

    @property
    @pulumi.getter(name="audioOnlyImage")
    def audio_only_image(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage']:
        return pulumi.get(self, "audio_only_image")

    @property
    @pulumi.getter(name="audioTrackType")
    def audio_track_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_track_type")

    @property
    @pulumi.getter(name="segmentType")
    def segment_type(self) -> Optional[str]:
        return pulumi.get(self, "segment_type")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password_param: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str uri: Path to a file accessible to the live stream.
        :param str password_param: Key used to extract the password from EC2 Parameter store.
        :param str username: . Username to be used.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            password_param=password_param,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             password_param: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']

        _setter("uri", uri)
        if password_param is not None:
            _setter("password_param", password_param)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Path to a file accessible to the live stream.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        """
        Key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        . Username to be used.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioRenditionSets":
            suggest = "audio_rendition_sets"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_rendition_sets: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 timed_metadata_behavior: Optional[str] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_rendition_sets=audio_rendition_sets,
            nielsen_id3_behavior=nielsen_id3_behavior,
            timed_metadata_behavior=timed_metadata_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_rendition_sets: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             timed_metadata_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_rendition_sets is None and 'audioRenditionSets' in kwargs:
            audio_rendition_sets = kwargs['audioRenditionSets']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']

        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[str]:
        return pulumi.get(self, "audio_rendition_sets")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "m3u8Settings":
            suggest = "m3u8_settings"
        elif key == "audioRenditionSets":
            suggest = "audio_rendition_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m3u8_settings: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings',
                 audio_rendition_sets: Optional[str] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m3u8_settings=m3u8_settings,
            audio_rendition_sets=audio_rendition_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m3u8_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings'] = None,
             audio_rendition_sets: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m3u8_settings is None and 'm3u8Settings' in kwargs:
            m3u8_settings = kwargs['m3u8Settings']
        if m3u8_settings is None:
            raise TypeError("Missing 'm3u8_settings' argument")
        if audio_rendition_sets is None and 'audioRenditionSets' in kwargs:
            audio_rendition_sets = kwargs['audioRenditionSets']

        _setter("m3u8_settings", m3u8_settings)
        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)

    @property
    @pulumi.getter(name="m3u8Settings")
    def m3u8_settings(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings':
        return pulumi.get(self, "m3u8_settings")

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[str]:
        return pulumi.get(self, "audio_rendition_sets")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioFramesPerPes":
            suggest = "audio_frames_per_pes"
        elif key == "audioPids":
            suggest = "audio_pids"
        elif key == "ecmPid":
            suggest = "ecm_pid"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "patInterval":
            suggest = "pat_interval"
        elif key == "pcrControl":
            suggest = "pcr_control"
        elif key == "pcrPeriod":
            suggest = "pcr_period"
        elif key == "pcrPid":
            suggest = "pcr_pid"
        elif key == "pmtInterval":
            suggest = "pmt_interval"
        elif key == "pmtPid":
            suggest = "pmt_pid"
        elif key == "programNum":
            suggest = "program_num"
        elif key == "scte35Behavior":
            suggest = "scte35_behavior"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"
        elif key == "timedMetadataPid":
            suggest = "timed_metadata_pid"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "videoPid":
            suggest = "video_pid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_frames_per_pes: Optional[int] = None,
                 audio_pids: Optional[str] = None,
                 ecm_pid: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 pat_interval: Optional[int] = None,
                 pcr_control: Optional[str] = None,
                 pcr_period: Optional[int] = None,
                 pcr_pid: Optional[str] = None,
                 pmt_interval: Optional[int] = None,
                 pmt_pid: Optional[str] = None,
                 program_num: Optional[int] = None,
                 scte35_behavior: Optional[str] = None,
                 scte35_pid: Optional[str] = None,
                 timed_metadata_behavior: Optional[str] = None,
                 timed_metadata_pid: Optional[str] = None,
                 transport_stream_id: Optional[int] = None,
                 video_pid: Optional[str] = None):
        """
        :param str scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            ecm_pid=ecm_pid,
            nielsen_id3_behavior=nielsen_id3_behavior,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            scte35_behavior=scte35_behavior,
            scte35_pid=scte35_pid,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_frames_per_pes: Optional[int] = None,
             audio_pids: Optional[str] = None,
             ecm_pid: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             pat_interval: Optional[int] = None,
             pcr_control: Optional[str] = None,
             pcr_period: Optional[int] = None,
             pcr_pid: Optional[str] = None,
             pmt_interval: Optional[int] = None,
             pmt_pid: Optional[str] = None,
             program_num: Optional[int] = None,
             scte35_behavior: Optional[str] = None,
             scte35_pid: Optional[str] = None,
             timed_metadata_behavior: Optional[str] = None,
             timed_metadata_pid: Optional[str] = None,
             transport_stream_id: Optional[int] = None,
             video_pid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if scte35_behavior is None and 'scte35Behavior' in kwargs:
            scte35_behavior = kwargs['scte35Behavior']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if scte35_behavior is not None:
            _setter("scte35_behavior", scte35_behavior)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[int]:
        return pulumi.get(self, "audio_frames_per_pes")

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[str]:
        return pulumi.get(self, "audio_pids")

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[str]:
        return pulumi.get(self, "ecm_pid")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[int]:
        return pulumi.get(self, "pat_interval")

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[str]:
        return pulumi.get(self, "pcr_control")

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[int]:
        return pulumi.get(self, "pcr_period")

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[str]:
        return pulumi.get(self, "pcr_pid")

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[int]:
        return pulumi.get(self, "pmt_interval")

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[str]:
        return pulumi.get(self, "pmt_pid")

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[int]:
        return pulumi.get(self, "program_num")

    @property
    @pulumi.getter(name="scte35Behavior")
    def scte35_behavior(self) -> Optional[str]:
        return pulumi.get(self, "scte35_behavior")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[str]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_pid")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[int]:
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[str]:
        return pulumi.get(self, "video_pid")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h265PackagingType":
            suggest = "h265_packaging_type"
        elif key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h265_packaging_type: Optional[str] = None,
                 name_modifier: Optional[str] = None):
        """
        :param str name_modifier: String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            h265_packaging_type=h265_packaging_type,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             h265_packaging_type: Optional[str] = None,
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if h265_packaging_type is None and 'h265PackagingType' in kwargs:
            h265_packaging_type = kwargs['h265PackagingType']
        if name_modifier is None and 'nameModifier' in kwargs:
            name_modifier = kwargs['nameModifier']

        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[str]:
        return pulumi.get(self, "h265_packaging_type")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        """
        String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
        """
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings(dict):
    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination'):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestinationArgs' destination: Destination is a multiplex. See Destination for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination':
        """
        Destination is a multiplex. See Destination for more details.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateMode":
            suggest = "certificate_mode"
        elif key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "numRetries":
            suggest = "num_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination',
                 certificate_mode: Optional[str] = None,
                 connection_retry_interval: Optional[int] = None,
                 num_retries: Optional[int] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestinationArgs' destination: The RTMP endpoint excluding the stream name. See Destination for more details.
        :param str certificate_mode: Setting to allow self signed or verified RTMP certificates.
        :param int connection_retry_interval: Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        :param int num_retries: Number of retry attempts.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            num_retries=num_retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination'] = None,
             certificate_mode: Optional[str] = None,
             connection_retry_interval: Optional[int] = None,
             num_retries: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if certificate_mode is None and 'certificateMode' in kwargs:
            certificate_mode = kwargs['certificateMode']
        if connection_retry_interval is None and 'connectionRetryInterval' in kwargs:
            connection_retry_interval = kwargs['connectionRetryInterval']
        if num_retries is None and 'numRetries' in kwargs:
            num_retries = kwargs['numRetries']

        _setter("destination", destination)
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if num_retries is not None:
            _setter("num_retries", num_retries)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination':
        """
        The RTMP endpoint excluding the stream name. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[str]:
        """
        Setting to allow self signed or verified RTMP certificates.
        """
        return pulumi.get(self, "certificate_mode")

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        """
        Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
        """
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of retry attempts.
        """
        return pulumi.get(self, "num_retries")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerSettings":
            suggest = "container_settings"
        elif key == "bufferMsec":
            suggest = "buffer_msec"
        elif key == "fecOutputSettings":
            suggest = "fec_output_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_settings: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings',
                 destination: 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination',
                 buffer_msec: Optional[int] = None,
                 fec_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsArgs' container_settings: UDP container settings. See Container Settings for more details.
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestinationArgs' destination: Destination address and port number for RTP or UDP packets. See Destination for more details.
        :param int buffer_msec: UDP output buffering in milliseconds.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_settings=container_settings,
            destination=destination,
            buffer_msec=buffer_msec,
            fec_output_settings=fec_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings'] = None,
             destination: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination'] = None,
             buffer_msec: Optional[int] = None,
             fec_output_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_settings is None and 'containerSettings' in kwargs:
            container_settings = kwargs['containerSettings']
        if container_settings is None:
            raise TypeError("Missing 'container_settings' argument")
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if buffer_msec is None and 'bufferMsec' in kwargs:
            buffer_msec = kwargs['bufferMsec']
        if fec_output_settings is None and 'fecOutputSettings' in kwargs:
            fec_output_settings = kwargs['fecOutputSettings']

        _setter("container_settings", container_settings)
        _setter("destination", destination)
        if buffer_msec is not None:
            _setter("buffer_msec", buffer_msec)
        if fec_output_settings is not None:
            _setter("fec_output_settings", fec_output_settings)

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings':
        """
        UDP container settings. See Container Settings for more details.
        """
        return pulumi.get(self, "container_settings")

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination':
        """
        Destination address and port number for RTP or UDP packets. See Destination for more details.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="bufferMsec")
    def buffer_msec(self) -> Optional[int]:
        """
        UDP output buffering in milliseconds.
        """
        return pulumi.get(self, "buffer_msec")

    @property
    @pulumi.getter(name="fecOutputSettings")
    def fec_output_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings']:
        return pulumi.get(self, "fec_output_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "m2tsSettings":
            suggest = "m2ts_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m2ts_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings'] = None):
        """
        :param 'ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsArgs' m2ts_settings: M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if m2ts_settings is None and 'm2tsSettings' in kwargs:
            m2ts_settings = kwargs['m2tsSettings']

        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings']:
        """
        M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
        """
        return pulumi.get(self, "m2ts_settings")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absentInputAudioBehavior":
            suggest = "absent_input_audio_behavior"
        elif key == "aribCaptionsPid":
            suggest = "arib_captions_pid"
        elif key == "aribCaptionsPidControl":
            suggest = "arib_captions_pid_control"
        elif key == "audioBufferModel":
            suggest = "audio_buffer_model"
        elif key == "audioFramesPerPes":
            suggest = "audio_frames_per_pes"
        elif key == "audioPids":
            suggest = "audio_pids"
        elif key == "audioStreamType":
            suggest = "audio_stream_type"
        elif key == "bufferModel":
            suggest = "buffer_model"
        elif key == "ccDescriptor":
            suggest = "cc_descriptor"
        elif key == "dvbNitSettings":
            suggest = "dvb_nit_settings"
        elif key == "dvbSdtSettings":
            suggest = "dvb_sdt_settings"
        elif key == "dvbSubPids":
            suggest = "dvb_sub_pids"
        elif key == "dvbTdtSettings":
            suggest = "dvb_tdt_settings"
        elif key == "dvbTeletextPid":
            suggest = "dvb_teletext_pid"
        elif key == "ebpAudioInterval":
            suggest = "ebp_audio_interval"
        elif key == "ebpLookaheadMs":
            suggest = "ebp_lookahead_ms"
        elif key == "ebpPlacement":
            suggest = "ebp_placement"
        elif key == "ecmPid":
            suggest = "ecm_pid"
        elif key == "esRateInPes":
            suggest = "es_rate_in_pes"
        elif key == "etvPlatformPid":
            suggest = "etv_platform_pid"
        elif key == "etvSignalPid":
            suggest = "etv_signal_pid"
        elif key == "fragmentTime":
            suggest = "fragment_time"
        elif key == "klvDataPids":
            suggest = "klv_data_pids"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "nullPacketBitrate":
            suggest = "null_packet_bitrate"
        elif key == "patInterval":
            suggest = "pat_interval"
        elif key == "pcrControl":
            suggest = "pcr_control"
        elif key == "pcrPeriod":
            suggest = "pcr_period"
        elif key == "pcrPid":
            suggest = "pcr_pid"
        elif key == "pmtInterval":
            suggest = "pmt_interval"
        elif key == "pmtPid":
            suggest = "pmt_pid"
        elif key == "programNum":
            suggest = "program_num"
        elif key == "rateMode":
            suggest = "rate_mode"
        elif key == "scte27Pids":
            suggest = "scte27_pids"
        elif key == "scte35Control":
            suggest = "scte35_control"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "segmentationMarkers":
            suggest = "segmentation_markers"
        elif key == "segmentationStyle":
            suggest = "segmentation_style"
        elif key == "segmentationTime":
            suggest = "segmentation_time"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"
        elif key == "timedMetadataPid":
            suggest = "timed_metadata_pid"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "videoPid":
            suggest = "video_pid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absent_input_audio_behavior: Optional[str] = None,
                 arib: Optional[str] = None,
                 arib_captions_pid: Optional[str] = None,
                 arib_captions_pid_control: Optional[str] = None,
                 audio_buffer_model: Optional[str] = None,
                 audio_frames_per_pes: Optional[int] = None,
                 audio_pids: Optional[str] = None,
                 audio_stream_type: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buffer_model: Optional[str] = None,
                 cc_descriptor: Optional[str] = None,
                 dvb_nit_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings'] = None,
                 dvb_sdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings'] = None,
                 dvb_sub_pids: Optional[str] = None,
                 dvb_tdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings'] = None,
                 dvb_teletext_pid: Optional[str] = None,
                 ebif: Optional[str] = None,
                 ebp_audio_interval: Optional[str] = None,
                 ebp_lookahead_ms: Optional[int] = None,
                 ebp_placement: Optional[str] = None,
                 ecm_pid: Optional[str] = None,
                 es_rate_in_pes: Optional[str] = None,
                 etv_platform_pid: Optional[str] = None,
                 etv_signal_pid: Optional[str] = None,
                 fragment_time: Optional[float] = None,
                 klv: Optional[str] = None,
                 klv_data_pids: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 null_packet_bitrate: Optional[float] = None,
                 pat_interval: Optional[int] = None,
                 pcr_control: Optional[str] = None,
                 pcr_period: Optional[int] = None,
                 pcr_pid: Optional[str] = None,
                 pmt_interval: Optional[int] = None,
                 pmt_pid: Optional[str] = None,
                 program_num: Optional[int] = None,
                 rate_mode: Optional[str] = None,
                 scte27_pids: Optional[str] = None,
                 scte35_control: Optional[str] = None,
                 scte35_pid: Optional[str] = None,
                 segmentation_markers: Optional[str] = None,
                 segmentation_style: Optional[str] = None,
                 segmentation_time: Optional[float] = None,
                 timed_metadata_behavior: Optional[str] = None,
                 timed_metadata_pid: Optional[str] = None,
                 transport_stream_id: Optional[int] = None,
                 video_pid: Optional[str] = None):
        """
        :param int bitrate: Average bitrate in bits/second.
        :param str scte35_pid: PID from which to read SCTE-35 messages.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            absent_input_audio_behavior=absent_input_audio_behavior,
            arib=arib,
            arib_captions_pid=arib_captions_pid,
            arib_captions_pid_control=arib_captions_pid_control,
            audio_buffer_model=audio_buffer_model,
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            audio_stream_type=audio_stream_type,
            bitrate=bitrate,
            buffer_model=buffer_model,
            cc_descriptor=cc_descriptor,
            dvb_nit_settings=dvb_nit_settings,
            dvb_sdt_settings=dvb_sdt_settings,
            dvb_sub_pids=dvb_sub_pids,
            dvb_tdt_settings=dvb_tdt_settings,
            dvb_teletext_pid=dvb_teletext_pid,
            ebif=ebif,
            ebp_audio_interval=ebp_audio_interval,
            ebp_lookahead_ms=ebp_lookahead_ms,
            ebp_placement=ebp_placement,
            ecm_pid=ecm_pid,
            es_rate_in_pes=es_rate_in_pes,
            etv_platform_pid=etv_platform_pid,
            etv_signal_pid=etv_signal_pid,
            fragment_time=fragment_time,
            klv=klv,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            null_packet_bitrate=null_packet_bitrate,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            rate_mode=rate_mode,
            scte27_pids=scte27_pids,
            scte35_control=scte35_control,
            scte35_pid=scte35_pid,
            segmentation_markers=segmentation_markers,
            segmentation_style=segmentation_style,
            segmentation_time=segmentation_time,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             absent_input_audio_behavior: Optional[str] = None,
             arib: Optional[str] = None,
             arib_captions_pid: Optional[str] = None,
             arib_captions_pid_control: Optional[str] = None,
             audio_buffer_model: Optional[str] = None,
             audio_frames_per_pes: Optional[int] = None,
             audio_pids: Optional[str] = None,
             audio_stream_type: Optional[str] = None,
             bitrate: Optional[int] = None,
             buffer_model: Optional[str] = None,
             cc_descriptor: Optional[str] = None,
             dvb_nit_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings'] = None,
             dvb_sdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings'] = None,
             dvb_sub_pids: Optional[str] = None,
             dvb_tdt_settings: Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings'] = None,
             dvb_teletext_pid: Optional[str] = None,
             ebif: Optional[str] = None,
             ebp_audio_interval: Optional[str] = None,
             ebp_lookahead_ms: Optional[int] = None,
             ebp_placement: Optional[str] = None,
             ecm_pid: Optional[str] = None,
             es_rate_in_pes: Optional[str] = None,
             etv_platform_pid: Optional[str] = None,
             etv_signal_pid: Optional[str] = None,
             fragment_time: Optional[float] = None,
             klv: Optional[str] = None,
             klv_data_pids: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             null_packet_bitrate: Optional[float] = None,
             pat_interval: Optional[int] = None,
             pcr_control: Optional[str] = None,
             pcr_period: Optional[int] = None,
             pcr_pid: Optional[str] = None,
             pmt_interval: Optional[int] = None,
             pmt_pid: Optional[str] = None,
             program_num: Optional[int] = None,
             rate_mode: Optional[str] = None,
             scte27_pids: Optional[str] = None,
             scte35_control: Optional[str] = None,
             scte35_pid: Optional[str] = None,
             segmentation_markers: Optional[str] = None,
             segmentation_style: Optional[str] = None,
             segmentation_time: Optional[float] = None,
             timed_metadata_behavior: Optional[str] = None,
             timed_metadata_pid: Optional[str] = None,
             transport_stream_id: Optional[int] = None,
             video_pid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if absent_input_audio_behavior is None and 'absentInputAudioBehavior' in kwargs:
            absent_input_audio_behavior = kwargs['absentInputAudioBehavior']
        if arib_captions_pid is None and 'aribCaptionsPid' in kwargs:
            arib_captions_pid = kwargs['aribCaptionsPid']
        if arib_captions_pid_control is None and 'aribCaptionsPidControl' in kwargs:
            arib_captions_pid_control = kwargs['aribCaptionsPidControl']
        if audio_buffer_model is None and 'audioBufferModel' in kwargs:
            audio_buffer_model = kwargs['audioBufferModel']
        if audio_frames_per_pes is None and 'audioFramesPerPes' in kwargs:
            audio_frames_per_pes = kwargs['audioFramesPerPes']
        if audio_pids is None and 'audioPids' in kwargs:
            audio_pids = kwargs['audioPids']
        if audio_stream_type is None and 'audioStreamType' in kwargs:
            audio_stream_type = kwargs['audioStreamType']
        if buffer_model is None and 'bufferModel' in kwargs:
            buffer_model = kwargs['bufferModel']
        if cc_descriptor is None and 'ccDescriptor' in kwargs:
            cc_descriptor = kwargs['ccDescriptor']
        if dvb_nit_settings is None and 'dvbNitSettings' in kwargs:
            dvb_nit_settings = kwargs['dvbNitSettings']
        if dvb_sdt_settings is None and 'dvbSdtSettings' in kwargs:
            dvb_sdt_settings = kwargs['dvbSdtSettings']
        if dvb_sub_pids is None and 'dvbSubPids' in kwargs:
            dvb_sub_pids = kwargs['dvbSubPids']
        if dvb_tdt_settings is None and 'dvbTdtSettings' in kwargs:
            dvb_tdt_settings = kwargs['dvbTdtSettings']
        if dvb_teletext_pid is None and 'dvbTeletextPid' in kwargs:
            dvb_teletext_pid = kwargs['dvbTeletextPid']
        if ebp_audio_interval is None and 'ebpAudioInterval' in kwargs:
            ebp_audio_interval = kwargs['ebpAudioInterval']
        if ebp_lookahead_ms is None and 'ebpLookaheadMs' in kwargs:
            ebp_lookahead_ms = kwargs['ebpLookaheadMs']
        if ebp_placement is None and 'ebpPlacement' in kwargs:
            ebp_placement = kwargs['ebpPlacement']
        if ecm_pid is None and 'ecmPid' in kwargs:
            ecm_pid = kwargs['ecmPid']
        if es_rate_in_pes is None and 'esRateInPes' in kwargs:
            es_rate_in_pes = kwargs['esRateInPes']
        if etv_platform_pid is None and 'etvPlatformPid' in kwargs:
            etv_platform_pid = kwargs['etvPlatformPid']
        if etv_signal_pid is None and 'etvSignalPid' in kwargs:
            etv_signal_pid = kwargs['etvSignalPid']
        if fragment_time is None and 'fragmentTime' in kwargs:
            fragment_time = kwargs['fragmentTime']
        if klv_data_pids is None and 'klvDataPids' in kwargs:
            klv_data_pids = kwargs['klvDataPids']
        if nielsen_id3_behavior is None and 'nielsenId3Behavior' in kwargs:
            nielsen_id3_behavior = kwargs['nielsenId3Behavior']
        if null_packet_bitrate is None and 'nullPacketBitrate' in kwargs:
            null_packet_bitrate = kwargs['nullPacketBitrate']
        if pat_interval is None and 'patInterval' in kwargs:
            pat_interval = kwargs['patInterval']
        if pcr_control is None and 'pcrControl' in kwargs:
            pcr_control = kwargs['pcrControl']
        if pcr_period is None and 'pcrPeriod' in kwargs:
            pcr_period = kwargs['pcrPeriod']
        if pcr_pid is None and 'pcrPid' in kwargs:
            pcr_pid = kwargs['pcrPid']
        if pmt_interval is None and 'pmtInterval' in kwargs:
            pmt_interval = kwargs['pmtInterval']
        if pmt_pid is None and 'pmtPid' in kwargs:
            pmt_pid = kwargs['pmtPid']
        if program_num is None and 'programNum' in kwargs:
            program_num = kwargs['programNum']
        if rate_mode is None and 'rateMode' in kwargs:
            rate_mode = kwargs['rateMode']
        if scte27_pids is None and 'scte27Pids' in kwargs:
            scte27_pids = kwargs['scte27Pids']
        if scte35_control is None and 'scte35Control' in kwargs:
            scte35_control = kwargs['scte35Control']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if segmentation_markers is None and 'segmentationMarkers' in kwargs:
            segmentation_markers = kwargs['segmentationMarkers']
        if segmentation_style is None and 'segmentationStyle' in kwargs:
            segmentation_style = kwargs['segmentationStyle']
        if segmentation_time is None and 'segmentationTime' in kwargs:
            segmentation_time = kwargs['segmentationTime']
        if timed_metadata_behavior is None and 'timedMetadataBehavior' in kwargs:
            timed_metadata_behavior = kwargs['timedMetadataBehavior']
        if timed_metadata_pid is None and 'timedMetadataPid' in kwargs:
            timed_metadata_pid = kwargs['timedMetadataPid']
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if video_pid is None and 'videoPid' in kwargs:
            video_pid = kwargs['videoPid']

        if absent_input_audio_behavior is not None:
            _setter("absent_input_audio_behavior", absent_input_audio_behavior)
        if arib is not None:
            _setter("arib", arib)
        if arib_captions_pid is not None:
            _setter("arib_captions_pid", arib_captions_pid)
        if arib_captions_pid_control is not None:
            _setter("arib_captions_pid_control", arib_captions_pid_control)
        if audio_buffer_model is not None:
            _setter("audio_buffer_model", audio_buffer_model)
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if audio_stream_type is not None:
            _setter("audio_stream_type", audio_stream_type)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buffer_model is not None:
            _setter("buffer_model", buffer_model)
        if cc_descriptor is not None:
            _setter("cc_descriptor", cc_descriptor)
        if dvb_nit_settings is not None:
            _setter("dvb_nit_settings", dvb_nit_settings)
        if dvb_sdt_settings is not None:
            _setter("dvb_sdt_settings", dvb_sdt_settings)
        if dvb_sub_pids is not None:
            _setter("dvb_sub_pids", dvb_sub_pids)
        if dvb_tdt_settings is not None:
            _setter("dvb_tdt_settings", dvb_tdt_settings)
        if dvb_teletext_pid is not None:
            _setter("dvb_teletext_pid", dvb_teletext_pid)
        if ebif is not None:
            _setter("ebif", ebif)
        if ebp_audio_interval is not None:
            _setter("ebp_audio_interval", ebp_audio_interval)
        if ebp_lookahead_ms is not None:
            _setter("ebp_lookahead_ms", ebp_lookahead_ms)
        if ebp_placement is not None:
            _setter("ebp_placement", ebp_placement)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if es_rate_in_pes is not None:
            _setter("es_rate_in_pes", es_rate_in_pes)
        if etv_platform_pid is not None:
            _setter("etv_platform_pid", etv_platform_pid)
        if etv_signal_pid is not None:
            _setter("etv_signal_pid", etv_signal_pid)
        if fragment_time is not None:
            _setter("fragment_time", fragment_time)
        if klv is not None:
            _setter("klv", klv)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if null_packet_bitrate is not None:
            _setter("null_packet_bitrate", null_packet_bitrate)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if rate_mode is not None:
            _setter("rate_mode", rate_mode)
        if scte27_pids is not None:
            _setter("scte27_pids", scte27_pids)
        if scte35_control is not None:
            _setter("scte35_control", scte35_control)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if segmentation_markers is not None:
            _setter("segmentation_markers", segmentation_markers)
        if segmentation_style is not None:
            _setter("segmentation_style", segmentation_style)
        if segmentation_time is not None:
            _setter("segmentation_time", segmentation_time)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="absentInputAudioBehavior")
    def absent_input_audio_behavior(self) -> Optional[str]:
        return pulumi.get(self, "absent_input_audio_behavior")

    @property
    @pulumi.getter
    def arib(self) -> Optional[str]:
        return pulumi.get(self, "arib")

    @property
    @pulumi.getter(name="aribCaptionsPid")
    def arib_captions_pid(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid")

    @property
    @pulumi.getter(name="aribCaptionsPidControl")
    def arib_captions_pid_control(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid_control")

    @property
    @pulumi.getter(name="audioBufferModel")
    def audio_buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "audio_buffer_model")

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[int]:
        return pulumi.get(self, "audio_frames_per_pes")

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[str]:
        return pulumi.get(self, "audio_pids")

    @property
    @pulumi.getter(name="audioStreamType")
    def audio_stream_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_stream_type")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufferModel")
    def buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "buffer_model")

    @property
    @pulumi.getter(name="ccDescriptor")
    def cc_descriptor(self) -> Optional[str]:
        return pulumi.get(self, "cc_descriptor")

    @property
    @pulumi.getter(name="dvbNitSettings")
    def dvb_nit_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings']:
        return pulumi.get(self, "dvb_nit_settings")

    @property
    @pulumi.getter(name="dvbSdtSettings")
    def dvb_sdt_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings']:
        return pulumi.get(self, "dvb_sdt_settings")

    @property
    @pulumi.getter(name="dvbSubPids")
    def dvb_sub_pids(self) -> Optional[str]:
        return pulumi.get(self, "dvb_sub_pids")

    @property
    @pulumi.getter(name="dvbTdtSettings")
    def dvb_tdt_settings(self) -> Optional['outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings']:
        return pulumi.get(self, "dvb_tdt_settings")

    @property
    @pulumi.getter(name="dvbTeletextPid")
    def dvb_teletext_pid(self) -> Optional[str]:
        return pulumi.get(self, "dvb_teletext_pid")

    @property
    @pulumi.getter
    def ebif(self) -> Optional[str]:
        return pulumi.get(self, "ebif")

    @property
    @pulumi.getter(name="ebpAudioInterval")
    def ebp_audio_interval(self) -> Optional[str]:
        return pulumi.get(self, "ebp_audio_interval")

    @property
    @pulumi.getter(name="ebpLookaheadMs")
    def ebp_lookahead_ms(self) -> Optional[int]:
        return pulumi.get(self, "ebp_lookahead_ms")

    @property
    @pulumi.getter(name="ebpPlacement")
    def ebp_placement(self) -> Optional[str]:
        return pulumi.get(self, "ebp_placement")

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[str]:
        return pulumi.get(self, "ecm_pid")

    @property
    @pulumi.getter(name="esRateInPes")
    def es_rate_in_pes(self) -> Optional[str]:
        return pulumi.get(self, "es_rate_in_pes")

    @property
    @pulumi.getter(name="etvPlatformPid")
    def etv_platform_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_platform_pid")

    @property
    @pulumi.getter(name="etvSignalPid")
    def etv_signal_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_signal_pid")

    @property
    @pulumi.getter(name="fragmentTime")
    def fragment_time(self) -> Optional[float]:
        return pulumi.get(self, "fragment_time")

    @property
    @pulumi.getter
    def klv(self) -> Optional[str]:
        return pulumi.get(self, "klv")

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[str]:
        return pulumi.get(self, "klv_data_pids")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="nullPacketBitrate")
    def null_packet_bitrate(self) -> Optional[float]:
        return pulumi.get(self, "null_packet_bitrate")

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[int]:
        return pulumi.get(self, "pat_interval")

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[str]:
        return pulumi.get(self, "pcr_control")

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[int]:
        return pulumi.get(self, "pcr_period")

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[str]:
        return pulumi.get(self, "pcr_pid")

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[int]:
        return pulumi.get(self, "pmt_interval")

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[str]:
        return pulumi.get(self, "pmt_pid")

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[int]:
        return pulumi.get(self, "program_num")

    @property
    @pulumi.getter(name="rateMode")
    def rate_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_mode")

    @property
    @pulumi.getter(name="scte27Pids")
    def scte27_pids(self) -> Optional[str]:
        return pulumi.get(self, "scte27_pids")

    @property
    @pulumi.getter(name="scte35Control")
    def scte35_control(self) -> Optional[str]:
        return pulumi.get(self, "scte35_control")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[str]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="segmentationMarkers")
    def segmentation_markers(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_markers")

    @property
    @pulumi.getter(name="segmentationStyle")
    def segmentation_style(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_style")

    @property
    @pulumi.getter(name="segmentationTime")
    def segmentation_time(self) -> Optional[float]:
        return pulumi.get(self, "segmentation_time")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_pid")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[int]:
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[str]:
        return pulumi.get(self, "video_pid")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: int,
                 network_name: str,
                 rep_interval: Optional[int] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            network_name=network_name,
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[int] = None,
             network_name: Optional[str] = None,
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if network_name is None and 'networkName' in kwargs:
            network_name = kwargs['networkName']
        if network_name is None:
            raise TypeError("Missing 'network_name' argument")
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        _setter("network_id", network_id)
        _setter("network_name", network_name)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> int:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSdt":
            suggest = "output_sdt"
        elif key == "repInterval":
            suggest = "rep_interval"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceProviderName":
            suggest = "service_provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_sdt: Optional[str] = None,
                 rep_interval: Optional[int] = None,
                 service_name: Optional[str] = None,
                 service_provider_name: Optional[str] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_sdt=output_sdt,
            rep_interval=rep_interval,
            service_name=service_name,
            service_provider_name=service_provider_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_sdt: Optional[str] = None,
             rep_interval: Optional[int] = None,
             service_name: Optional[str] = None,
             service_provider_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_sdt is None and 'outputSdt' in kwargs:
            output_sdt = kwargs['outputSdt']
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_provider_name is None and 'serviceProviderName' in kwargs:
            service_provider_name = kwargs['serviceProviderName']

        if output_sdt is not None:
            _setter("output_sdt", output_sdt)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)
        if service_name is not None:
            _setter("service_name", service_name)
        if service_provider_name is not None:
            _setter("service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="outputSdt")
    def output_sdt(self) -> Optional[str]:
        return pulumi.get(self, "output_sdt")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> Optional[str]:
        return pulumi.get(self, "service_provider_name")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rep_interval: Optional[int] = None):
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rep_interval is None and 'repInterval' in kwargs:
            rep_interval = kwargs['repInterval']

        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: str):
        """
        :param str destination_ref_id: Reference ID for the destination.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ref_id is None and 'destinationRefId' in kwargs:
            destination_ref_id = kwargs['destinationRefId']
        if destination_ref_id is None:
            raise TypeError("Missing 'destination_ref_id' argument")

        _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> str:
        """
        Reference ID for the destination.
        """
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnDepth":
            suggest = "column_depth"
        elif key == "includeFec":
            suggest = "include_fec"
        elif key == "rowLength":
            suggest = "row_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_depth: Optional[int] = None,
                 include_fec: Optional[str] = None,
                 row_length: Optional[int] = None):
        """
        :param int column_depth: The height of the FEC protection matrix.
        :param str include_fec: Enables column only or column and row based FEC.
        :param int row_length: The width of the FEC protection matrix.
        """
        ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_depth=column_depth,
            include_fec=include_fec,
            row_length=row_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_depth: Optional[int] = None,
             include_fec: Optional[str] = None,
             row_length: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_depth is None and 'columnDepth' in kwargs:
            column_depth = kwargs['columnDepth']
        if include_fec is None and 'includeFec' in kwargs:
            include_fec = kwargs['includeFec']
        if row_length is None and 'rowLength' in kwargs:
            row_length = kwargs['rowLength']

        if column_depth is not None:
            _setter("column_depth", column_depth)
        if include_fec is not None:
            _setter("include_fec", include_fec)
        if row_length is not None:
            _setter("row_length", row_length)

    @property
    @pulumi.getter(name="columnDepth")
    def column_depth(self) -> Optional[int]:
        """
        The height of the FEC protection matrix.
        """
        return pulumi.get(self, "column_depth")

    @property
    @pulumi.getter(name="includeFec")
    def include_fec(self) -> Optional[str]:
        """
        Enables column only or column and row based FEC.
        """
        return pulumi.get(self, "include_fec")

    @property
    @pulumi.getter(name="rowLength")
    def row_length(self) -> Optional[int]:
        """
        The width of the FEC protection matrix.
        """
        return pulumi.get(self, "row_length")


@pulumi.output_type
class ChannelEncoderSettingsTimecodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "syncThreshold":
            suggest = "sync_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsTimecodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsTimecodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsTimecodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: str,
                 sync_threshold: Optional[int] = None):
        """
        :param str source: The source for the timecode that will be associated with the events outputs.
        :param int sync_threshold: Threshold in frames beyond which output timecode is resynchronized to the input timecode.
        """
        ChannelEncoderSettingsTimecodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            sync_threshold=sync_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: Optional[str] = None,
             sync_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source is None:
            raise TypeError("Missing 'source' argument")
        if sync_threshold is None and 'syncThreshold' in kwargs:
            sync_threshold = kwargs['syncThreshold']

        _setter("source", source)
        if sync_threshold is not None:
            _setter("sync_threshold", sync_threshold)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source for the timecode that will be associated with the events outputs.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="syncThreshold")
    def sync_threshold(self) -> Optional[int]:
        """
        Threshold in frames beyond which output timecode is resynchronized to the input timecode.
        """
        return pulumi.get(self, "sync_threshold")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codecSettings":
            suggest = "codec_settings"
        elif key == "respondToAfd":
            suggest = "respond_to_afd"
        elif key == "scalingBehavior":
            suggest = "scaling_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 codec_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettings'] = None,
                 height: Optional[int] = None,
                 respond_to_afd: Optional[str] = None,
                 scaling_behavior: Optional[str] = None,
                 sharpness: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param str name: The name of the video description.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsArgs' codec_settings: The video codec settings. See Video Codec Settings for more details.
        :param int height: Output video height in pixels.
        :param str respond_to_afd: Indicate how to respond to the AFD values that might be in the input video.
        :param str scaling_behavior: Behavior on how to scale.
        :param int sharpness: Changes the strength of the anti-alias filter used for scaling.
        :param int width: Output video width in pixels.
        """
        ChannelEncoderSettingsVideoDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            codec_settings=codec_settings,
            height=height,
            respond_to_afd=respond_to_afd,
            scaling_behavior=scaling_behavior,
            sharpness=sharpness,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             codec_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettings'] = None,
             height: Optional[int] = None,
             respond_to_afd: Optional[str] = None,
             scaling_behavior: Optional[str] = None,
             sharpness: Optional[int] = None,
             width: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if codec_settings is None and 'codecSettings' in kwargs:
            codec_settings = kwargs['codecSettings']
        if respond_to_afd is None and 'respondToAfd' in kwargs:
            respond_to_afd = kwargs['respondToAfd']
        if scaling_behavior is None and 'scalingBehavior' in kwargs:
            scaling_behavior = kwargs['scalingBehavior']

        _setter("name", name)
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if height is not None:
            _setter("height", height)
        if respond_to_afd is not None:
            _setter("respond_to_afd", respond_to_afd)
        if scaling_behavior is not None:
            _setter("scaling_behavior", scaling_behavior)
        if sharpness is not None:
            _setter("sharpness", sharpness)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the video description.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettings']:
        """
        The video codec settings. See Video Codec Settings for more details.
        """
        return pulumi.get(self, "codec_settings")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        Output video height in pixels.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="respondToAfd")
    def respond_to_afd(self) -> Optional[str]:
        """
        Indicate how to respond to the AFD values that might be in the input video.
        """
        return pulumi.get(self, "respond_to_afd")

    @property
    @pulumi.getter(name="scalingBehavior")
    def scaling_behavior(self) -> Optional[str]:
        """
        Behavior on how to scale.
        """
        return pulumi.get(self, "scaling_behavior")

    @property
    @pulumi.getter
    def sharpness(self) -> Optional[int]:
        """
        Changes the strength of the anti-alias filter used for scaling.
        """
        return pulumi.get(self, "sharpness")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        Output video width in pixels.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureSettings":
            suggest = "frame_capture_settings"
        elif key == "h264Settings":
            suggest = "h264_settings"
        elif key == "h265Settings":
            suggest = "h265_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frame_capture_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings'] = None,
                 h264_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings'] = None,
                 h265_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings'] = None):
        """
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettingsArgs' frame_capture_settings: Frame capture settings. See Frame Capture Settings for more details.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsArgs' h264_settings: H264 settings. See H264 Settings for more details.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_settings=frame_capture_settings,
            h264_settings=h264_settings,
            h265_settings=h265_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings'] = None,
             h264_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings'] = None,
             h265_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if frame_capture_settings is None and 'frameCaptureSettings' in kwargs:
            frame_capture_settings = kwargs['frameCaptureSettings']
        if h264_settings is None and 'h264Settings' in kwargs:
            h264_settings = kwargs['h264Settings']
        if h265_settings is None and 'h265Settings' in kwargs:
            h265_settings = kwargs['h265Settings']

        if frame_capture_settings is not None:
            _setter("frame_capture_settings", frame_capture_settings)
        if h264_settings is not None:
            _setter("h264_settings", h264_settings)
        if h265_settings is not None:
            _setter("h265_settings", h265_settings)

    @property
    @pulumi.getter(name="frameCaptureSettings")
    def frame_capture_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings']:
        """
        Frame capture settings. See Frame Capture Settings for more details.
        """
        return pulumi.get(self, "frame_capture_settings")

    @property
    @pulumi.getter(name="h264Settings")
    def h264_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings']:
        """
        H264 settings. See H264 Settings for more details.
        """
        return pulumi.get(self, "h264_settings")

    @property
    @pulumi.getter(name="h265Settings")
    def h265_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings']:
        return pulumi.get(self, "h265_settings")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureInterval":
            suggest = "capture_interval"
        elif key == "captureIntervalUnits":
            suggest = "capture_interval_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_interval: Optional[int] = None,
                 capture_interval_units: Optional[str] = None):
        """
        :param int capture_interval: The frequency at which to capture frames for inclusion in the output.
        :param str capture_interval_units: Unit for the frame capture interval.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capture_interval=capture_interval,
            capture_interval_units=capture_interval_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capture_interval: Optional[int] = None,
             capture_interval_units: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capture_interval is None and 'captureInterval' in kwargs:
            capture_interval = kwargs['captureInterval']
        if capture_interval_units is None and 'captureIntervalUnits' in kwargs:
            capture_interval_units = kwargs['captureIntervalUnits']

        if capture_interval is not None:
            _setter("capture_interval", capture_interval)
        if capture_interval_units is not None:
            _setter("capture_interval_units", capture_interval_units)

    @property
    @pulumi.getter(name="captureInterval")
    def capture_interval(self) -> Optional[int]:
        """
        The frequency at which to capture frames for inclusion in the output.
        """
        return pulumi.get(self, "capture_interval")

    @property
    @pulumi.getter(name="captureIntervalUnits")
    def capture_interval_units(self) -> Optional[str]:
        """
        Unit for the frame capture interval.
        """
        return pulumi.get(self, "capture_interval_units")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveQuantization":
            suggest = "adaptive_quantization"
        elif key == "afdSignaling":
            suggest = "afd_signaling"
        elif key == "bufFillPct":
            suggest = "buf_fill_pct"
        elif key == "bufSize":
            suggest = "buf_size"
        elif key == "colorMetadata":
            suggest = "color_metadata"
        elif key == "entropyEncoding":
            suggest = "entropy_encoding"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "fixedAfd":
            suggest = "fixed_afd"
        elif key == "flickerAq":
            suggest = "flicker_aq"
        elif key == "forceFieldPictures":
            suggest = "force_field_pictures"
        elif key == "framerateControl":
            suggest = "framerate_control"
        elif key == "framerateDenominator":
            suggest = "framerate_denominator"
        elif key == "framerateNumerator":
            suggest = "framerate_numerator"
        elif key == "gopBReference":
            suggest = "gop_b_reference"
        elif key == "gopClosedCadence":
            suggest = "gop_closed_cadence"
        elif key == "gopNumBFrames":
            suggest = "gop_num_b_frames"
        elif key == "gopSize":
            suggest = "gop_size"
        elif key == "gopSizeUnits":
            suggest = "gop_size_units"
        elif key == "lookAheadRateControl":
            suggest = "look_ahead_rate_control"
        elif key == "maxBitrate":
            suggest = "max_bitrate"
        elif key == "minIInterval":
            suggest = "min_i_interval"
        elif key == "numRefFrames":
            suggest = "num_ref_frames"
        elif key == "parControl":
            suggest = "par_control"
        elif key == "parDenominator":
            suggest = "par_denominator"
        elif key == "parNumerator":
            suggest = "par_numerator"
        elif key == "qualityLevel":
            suggest = "quality_level"
        elif key == "qvbrQualityLevel":
            suggest = "qvbr_quality_level"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "scanType":
            suggest = "scan_type"
        elif key == "sceneChangeDetect":
            suggest = "scene_change_detect"
        elif key == "spatialAq":
            suggest = "spatial_aq"
        elif key == "subgopLength":
            suggest = "subgop_length"
        elif key == "temporalAq":
            suggest = "temporal_aq"
        elif key == "timecodeInsertion":
            suggest = "timecode_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_quantization: Optional[str] = None,
                 afd_signaling: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buf_fill_pct: Optional[int] = None,
                 buf_size: Optional[int] = None,
                 color_metadata: Optional[str] = None,
                 entropy_encoding: Optional[str] = None,
                 filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings'] = None,
                 fixed_afd: Optional[str] = None,
                 flicker_aq: Optional[str] = None,
                 force_field_pictures: Optional[str] = None,
                 framerate_control: Optional[str] = None,
                 framerate_denominator: Optional[int] = None,
                 framerate_numerator: Optional[int] = None,
                 gop_b_reference: Optional[str] = None,
                 gop_closed_cadence: Optional[int] = None,
                 gop_num_b_frames: Optional[int] = None,
                 gop_size: Optional[float] = None,
                 gop_size_units: Optional[str] = None,
                 level: Optional[str] = None,
                 look_ahead_rate_control: Optional[str] = None,
                 max_bitrate: Optional[int] = None,
                 min_i_interval: Optional[int] = None,
                 num_ref_frames: Optional[int] = None,
                 par_control: Optional[str] = None,
                 par_denominator: Optional[int] = None,
                 par_numerator: Optional[int] = None,
                 profile: Optional[str] = None,
                 quality_level: Optional[str] = None,
                 qvbr_quality_level: Optional[int] = None,
                 rate_control_mode: Optional[str] = None,
                 scan_type: Optional[str] = None,
                 scene_change_detect: Optional[str] = None,
                 slices: Optional[int] = None,
                 softness: Optional[int] = None,
                 spatial_aq: Optional[str] = None,
                 subgop_length: Optional[str] = None,
                 syntax: Optional[str] = None,
                 temporal_aq: Optional[str] = None,
                 timecode_insertion: Optional[str] = None):
        """
        :param str adaptive_quantization: Enables or disables adaptive quantization.
        :param str afd_signaling: Indicates that AFD values will be written into the output stream.
        :param int bitrate: Average bitrate in bits/second.
        :param int buf_size: Size of buffer in bits.
        :param str color_metadata: Includes color space metadata in the output.
        :param str entropy_encoding: Entropy encoding mode.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsArgs' filter_settings: Filters to apply to an encode. See H265 Filter Settings for more details.
        :param str fixed_afd: Four bit AFD value to write on all frames of video in the output stream.
        :param str force_field_pictures: Controls whether coding is performed on a field basis or on a frame basis.
        :param str framerate_control: Indicates how the output video frame rate is specified.
        :param int framerate_denominator: Framerate denominator.
        :param int framerate_numerator: Framerate numerator.
        :param str gop_b_reference: GOP-B reference.
        :param int gop_closed_cadence: Frequency of closed GOPs.
        :param int gop_num_b_frames: Number of B-frames between reference frames.
        :param float gop_size: GOP size in units of either frames of seconds per `gop_size_units`.
        :param str gop_size_units: Indicates if the `gop_size` is specified in frames or seconds.
        :param str level: H265 level.
        :param str look_ahead_rate_control: Amount of lookahead.
        :param int max_bitrate: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        :param int num_ref_frames: Number of reference frames to use.
        :param str par_control: Indicates how the output pixel aspect ratio is specified.
        :param int par_denominator: Pixel Aspect Ratio denominator.
        :param int par_numerator: Pixel Aspect Ratio numerator.
        :param str profile: AAC profile.
        :param str quality_level: Quality level.
        :param int qvbr_quality_level: Controls the target quality for the video encode.
        :param str rate_control_mode: The rate control mode.
        :param str scan_type: Sets the scan type of the output.
        :param str scene_change_detect: Scene change detection.
        :param int slices: Number of slices per picture.
        :param int softness: Softness.
        :param str spatial_aq: Makes adjustments within each frame based on spatial variation of content complexity.
        :param str subgop_length: Subgop length.
        :param str syntax: Produces a bitstream compliant with SMPTE RP-2027.
        :param str temporal_aq: Makes adjustments within each frame based on temporal variation of content complexity.
        :param str timecode_insertion: Determines how timecodes should be inserted into the video elementary stream.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            bitrate=bitrate,
            buf_fill_pct=buf_fill_pct,
            buf_size=buf_size,
            color_metadata=color_metadata,
            entropy_encoding=entropy_encoding,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            force_field_pictures=force_field_pictures,
            framerate_control=framerate_control,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            gop_b_reference=gop_b_reference,
            gop_closed_cadence=gop_closed_cadence,
            gop_num_b_frames=gop_num_b_frames,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            num_ref_frames=num_ref_frames,
            par_control=par_control,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            quality_level=quality_level,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            softness=softness,
            spatial_aq=spatial_aq,
            subgop_length=subgop_length,
            syntax=syntax,
            temporal_aq=temporal_aq,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_quantization: Optional[str] = None,
             afd_signaling: Optional[str] = None,
             bitrate: Optional[int] = None,
             buf_fill_pct: Optional[int] = None,
             buf_size: Optional[int] = None,
             color_metadata: Optional[str] = None,
             entropy_encoding: Optional[str] = None,
             filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings'] = None,
             fixed_afd: Optional[str] = None,
             flicker_aq: Optional[str] = None,
             force_field_pictures: Optional[str] = None,
             framerate_control: Optional[str] = None,
             framerate_denominator: Optional[int] = None,
             framerate_numerator: Optional[int] = None,
             gop_b_reference: Optional[str] = None,
             gop_closed_cadence: Optional[int] = None,
             gop_num_b_frames: Optional[int] = None,
             gop_size: Optional[float] = None,
             gop_size_units: Optional[str] = None,
             level: Optional[str] = None,
             look_ahead_rate_control: Optional[str] = None,
             max_bitrate: Optional[int] = None,
             min_i_interval: Optional[int] = None,
             num_ref_frames: Optional[int] = None,
             par_control: Optional[str] = None,
             par_denominator: Optional[int] = None,
             par_numerator: Optional[int] = None,
             profile: Optional[str] = None,
             quality_level: Optional[str] = None,
             qvbr_quality_level: Optional[int] = None,
             rate_control_mode: Optional[str] = None,
             scan_type: Optional[str] = None,
             scene_change_detect: Optional[str] = None,
             slices: Optional[int] = None,
             softness: Optional[int] = None,
             spatial_aq: Optional[str] = None,
             subgop_length: Optional[str] = None,
             syntax: Optional[str] = None,
             temporal_aq: Optional[str] = None,
             timecode_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if adaptive_quantization is None and 'adaptiveQuantization' in kwargs:
            adaptive_quantization = kwargs['adaptiveQuantization']
        if afd_signaling is None and 'afdSignaling' in kwargs:
            afd_signaling = kwargs['afdSignaling']
        if buf_fill_pct is None and 'bufFillPct' in kwargs:
            buf_fill_pct = kwargs['bufFillPct']
        if buf_size is None and 'bufSize' in kwargs:
            buf_size = kwargs['bufSize']
        if color_metadata is None and 'colorMetadata' in kwargs:
            color_metadata = kwargs['colorMetadata']
        if entropy_encoding is None and 'entropyEncoding' in kwargs:
            entropy_encoding = kwargs['entropyEncoding']
        if filter_settings is None and 'filterSettings' in kwargs:
            filter_settings = kwargs['filterSettings']
        if fixed_afd is None and 'fixedAfd' in kwargs:
            fixed_afd = kwargs['fixedAfd']
        if flicker_aq is None and 'flickerAq' in kwargs:
            flicker_aq = kwargs['flickerAq']
        if force_field_pictures is None and 'forceFieldPictures' in kwargs:
            force_field_pictures = kwargs['forceFieldPictures']
        if framerate_control is None and 'framerateControl' in kwargs:
            framerate_control = kwargs['framerateControl']
        if framerate_denominator is None and 'framerateDenominator' in kwargs:
            framerate_denominator = kwargs['framerateDenominator']
        if framerate_numerator is None and 'framerateNumerator' in kwargs:
            framerate_numerator = kwargs['framerateNumerator']
        if gop_b_reference is None and 'gopBReference' in kwargs:
            gop_b_reference = kwargs['gopBReference']
        if gop_closed_cadence is None and 'gopClosedCadence' in kwargs:
            gop_closed_cadence = kwargs['gopClosedCadence']
        if gop_num_b_frames is None and 'gopNumBFrames' in kwargs:
            gop_num_b_frames = kwargs['gopNumBFrames']
        if gop_size is None and 'gopSize' in kwargs:
            gop_size = kwargs['gopSize']
        if gop_size_units is None and 'gopSizeUnits' in kwargs:
            gop_size_units = kwargs['gopSizeUnits']
        if look_ahead_rate_control is None and 'lookAheadRateControl' in kwargs:
            look_ahead_rate_control = kwargs['lookAheadRateControl']
        if max_bitrate is None and 'maxBitrate' in kwargs:
            max_bitrate = kwargs['maxBitrate']
        if min_i_interval is None and 'minIInterval' in kwargs:
            min_i_interval = kwargs['minIInterval']
        if num_ref_frames is None and 'numRefFrames' in kwargs:
            num_ref_frames = kwargs['numRefFrames']
        if par_control is None and 'parControl' in kwargs:
            par_control = kwargs['parControl']
        if par_denominator is None and 'parDenominator' in kwargs:
            par_denominator = kwargs['parDenominator']
        if par_numerator is None and 'parNumerator' in kwargs:
            par_numerator = kwargs['parNumerator']
        if quality_level is None and 'qualityLevel' in kwargs:
            quality_level = kwargs['qualityLevel']
        if qvbr_quality_level is None and 'qvbrQualityLevel' in kwargs:
            qvbr_quality_level = kwargs['qvbrQualityLevel']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if scan_type is None and 'scanType' in kwargs:
            scan_type = kwargs['scanType']
        if scene_change_detect is None and 'sceneChangeDetect' in kwargs:
            scene_change_detect = kwargs['sceneChangeDetect']
        if spatial_aq is None and 'spatialAq' in kwargs:
            spatial_aq = kwargs['spatialAq']
        if subgop_length is None and 'subgopLength' in kwargs:
            subgop_length = kwargs['subgopLength']
        if temporal_aq is None and 'temporalAq' in kwargs:
            temporal_aq = kwargs['temporalAq']
        if timecode_insertion is None and 'timecodeInsertion' in kwargs:
            timecode_insertion = kwargs['timecodeInsertion']

        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buf_fill_pct is not None:
            _setter("buf_fill_pct", buf_fill_pct)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if entropy_encoding is not None:
            _setter("entropy_encoding", entropy_encoding)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if force_field_pictures is not None:
            _setter("force_field_pictures", force_field_pictures)
        if framerate_control is not None:
            _setter("framerate_control", framerate_control)
        if framerate_denominator is not None:
            _setter("framerate_denominator", framerate_denominator)
        if framerate_numerator is not None:
            _setter("framerate_numerator", framerate_numerator)
        if gop_b_reference is not None:
            _setter("gop_b_reference", gop_b_reference)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_num_b_frames is not None:
            _setter("gop_num_b_frames", gop_num_b_frames)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if num_ref_frames is not None:
            _setter("num_ref_frames", num_ref_frames)
        if par_control is not None:
            _setter("par_control", par_control)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if quality_level is not None:
            _setter("quality_level", quality_level)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if softness is not None:
            _setter("softness", softness)
        if spatial_aq is not None:
            _setter("spatial_aq", spatial_aq)
        if subgop_length is not None:
            _setter("subgop_length", subgop_length)
        if syntax is not None:
            _setter("syntax", syntax)
        if temporal_aq is not None:
            _setter("temporal_aq", temporal_aq)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[str]:
        """
        Enables or disables adaptive quantization.
        """
        return pulumi.get(self, "adaptive_quantization")

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[str]:
        """
        Indicates that AFD values will be written into the output stream.
        """
        return pulumi.get(self, "afd_signaling")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufFillPct")
    def buf_fill_pct(self) -> Optional[int]:
        return pulumi.get(self, "buf_fill_pct")

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[int]:
        """
        Size of buffer in bits.
        """
        return pulumi.get(self, "buf_size")

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[str]:
        """
        Includes color space metadata in the output.
        """
        return pulumi.get(self, "color_metadata")

    @property
    @pulumi.getter(name="entropyEncoding")
    def entropy_encoding(self) -> Optional[str]:
        """
        Entropy encoding mode.
        """
        return pulumi.get(self, "entropy_encoding")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings']:
        """
        Filters to apply to an encode. See H265 Filter Settings for more details.
        """
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[str]:
        """
        Four bit AFD value to write on all frames of video in the output stream.
        """
        return pulumi.get(self, "fixed_afd")

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[str]:
        return pulumi.get(self, "flicker_aq")

    @property
    @pulumi.getter(name="forceFieldPictures")
    def force_field_pictures(self) -> Optional[str]:
        """
        Controls whether coding is performed on a field basis or on a frame basis.
        """
        return pulumi.get(self, "force_field_pictures")

    @property
    @pulumi.getter(name="framerateControl")
    def framerate_control(self) -> Optional[str]:
        """
        Indicates how the output video frame rate is specified.
        """
        return pulumi.get(self, "framerate_control")

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> Optional[int]:
        """
        Framerate denominator.
        """
        return pulumi.get(self, "framerate_denominator")

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> Optional[int]:
        """
        Framerate numerator.
        """
        return pulumi.get(self, "framerate_numerator")

    @property
    @pulumi.getter(name="gopBReference")
    def gop_b_reference(self) -> Optional[str]:
        """
        GOP-B reference.
        """
        return pulumi.get(self, "gop_b_reference")

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[int]:
        """
        Frequency of closed GOPs.
        """
        return pulumi.get(self, "gop_closed_cadence")

    @property
    @pulumi.getter(name="gopNumBFrames")
    def gop_num_b_frames(self) -> Optional[int]:
        """
        Number of B-frames between reference frames.
        """
        return pulumi.get(self, "gop_num_b_frames")

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[float]:
        """
        GOP size in units of either frames of seconds per `gop_size_units`.
        """
        return pulumi.get(self, "gop_size")

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[str]:
        """
        Indicates if the `gop_size` is specified in frames or seconds.
        """
        return pulumi.get(self, "gop_size_units")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        H265 level.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[str]:
        """
        Amount of lookahead.
        """
        return pulumi.get(self, "look_ahead_rate_control")

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[int]:
        """
        Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        """
        return pulumi.get(self, "max_bitrate")

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[int]:
        return pulumi.get(self, "min_i_interval")

    @property
    @pulumi.getter(name="numRefFrames")
    def num_ref_frames(self) -> Optional[int]:
        """
        Number of reference frames to use.
        """
        return pulumi.get(self, "num_ref_frames")

    @property
    @pulumi.getter(name="parControl")
    def par_control(self) -> Optional[str]:
        """
        Indicates how the output pixel aspect ratio is specified.
        """
        return pulumi.get(self, "par_control")

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[int]:
        """
        Pixel Aspect Ratio denominator.
        """
        return pulumi.get(self, "par_denominator")

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[int]:
        """
        Pixel Aspect Ratio numerator.
        """
        return pulumi.get(self, "par_numerator")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="qualityLevel")
    def quality_level(self) -> Optional[str]:
        """
        Quality level.
        """
        return pulumi.get(self, "quality_level")

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[int]:
        """
        Controls the target quality for the video encode.
        """
        return pulumi.get(self, "qvbr_quality_level")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[str]:
        """
        Sets the scan type of the output.
        """
        return pulumi.get(self, "scan_type")

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[str]:
        """
        Scene change detection.
        """
        return pulumi.get(self, "scene_change_detect")

    @property
    @pulumi.getter
    def slices(self) -> Optional[int]:
        """
        Number of slices per picture.
        """
        return pulumi.get(self, "slices")

    @property
    @pulumi.getter
    def softness(self) -> Optional[int]:
        """
        Softness.
        """
        return pulumi.get(self, "softness")

    @property
    @pulumi.getter(name="spatialAq")
    def spatial_aq(self) -> Optional[str]:
        """
        Makes adjustments within each frame based on spatial variation of content complexity.
        """
        return pulumi.get(self, "spatial_aq")

    @property
    @pulumi.getter(name="subgopLength")
    def subgop_length(self) -> Optional[str]:
        """
        Subgop length.
        """
        return pulumi.get(self, "subgop_length")

    @property
    @pulumi.getter
    def syntax(self) -> Optional[str]:
        """
        Produces a bitstream compliant with SMPTE RP-2027.
        """
        return pulumi.get(self, "syntax")

    @property
    @pulumi.getter(name="temporalAq")
    def temporal_aq(self) -> Optional[str]:
        """
        Makes adjustments within each frame based on temporal variation of content complexity.
        """
        return pulumi.get(self, "temporal_aq")

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[str]:
        """
        Determines how timecodes should be inserted into the video elementary stream.
        """
        return pulumi.get(self, "timecode_insertion")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporalFilterSettings":
            suggest = "temporal_filter_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporal_filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings'] = None):
        """
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettingsArgs' temporal_filter_settings: Temporal filter settings. See Temporal Filter Settings
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if temporal_filter_settings is None and 'temporalFilterSettings' in kwargs:
            temporal_filter_settings = kwargs['temporalFilterSettings']

        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings']:
        """
        Temporal filter settings. See Temporal Filter Settings
        """
        return pulumi.get(self, "temporal_filter_settings")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postFilterSharpening":
            suggest = "post_filter_sharpening"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_filter_sharpening: Optional[str] = None,
                 strength: Optional[str] = None):
        """
        :param str post_filter_sharpening: Post filter sharpening.
        :param str strength: Filter strength.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_filter_sharpening=post_filter_sharpening,
            strength=strength,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_filter_sharpening: Optional[str] = None,
             strength: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if post_filter_sharpening is None and 'postFilterSharpening' in kwargs:
            post_filter_sharpening = kwargs['postFilterSharpening']

        if post_filter_sharpening is not None:
            _setter("post_filter_sharpening", post_filter_sharpening)
        if strength is not None:
            _setter("strength", strength)

    @property
    @pulumi.getter(name="postFilterSharpening")
    def post_filter_sharpening(self) -> Optional[str]:
        """
        Post filter sharpening.
        """
        return pulumi.get(self, "post_filter_sharpening")

    @property
    @pulumi.getter
    def strength(self) -> Optional[str]:
        """
        Filter strength.
        """
        return pulumi.get(self, "strength")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "framerateDenominator":
            suggest = "framerate_denominator"
        elif key == "framerateNumerator":
            suggest = "framerate_numerator"
        elif key == "adaptiveQuantization":
            suggest = "adaptive_quantization"
        elif key == "afdSignaling":
            suggest = "afd_signaling"
        elif key == "alternativeTransferFunction":
            suggest = "alternative_transfer_function"
        elif key == "bufSize":
            suggest = "buf_size"
        elif key == "colorMetadata":
            suggest = "color_metadata"
        elif key == "colorSpaceSettings":
            suggest = "color_space_settings"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "fixedAfd":
            suggest = "fixed_afd"
        elif key == "flickerAq":
            suggest = "flicker_aq"
        elif key == "gopClosedCadence":
            suggest = "gop_closed_cadence"
        elif key == "gopSize":
            suggest = "gop_size"
        elif key == "gopSizeUnits":
            suggest = "gop_size_units"
        elif key == "lookAheadRateControl":
            suggest = "look_ahead_rate_control"
        elif key == "maxBitrate":
            suggest = "max_bitrate"
        elif key == "minIInterval":
            suggest = "min_i_interval"
        elif key == "parDenominator":
            suggest = "par_denominator"
        elif key == "parNumerator":
            suggest = "par_numerator"
        elif key == "qvbrQualityLevel":
            suggest = "qvbr_quality_level"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "scanType":
            suggest = "scan_type"
        elif key == "sceneChangeDetect":
            suggest = "scene_change_detect"
        elif key == "timecodeBurninSettings":
            suggest = "timecode_burnin_settings"
        elif key == "timecodeInsertion":
            suggest = "timecode_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 framerate_denominator: int,
                 framerate_numerator: int,
                 adaptive_quantization: Optional[str] = None,
                 afd_signaling: Optional[str] = None,
                 alternative_transfer_function: Optional[str] = None,
                 buf_size: Optional[int] = None,
                 color_metadata: Optional[str] = None,
                 color_space_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings'] = None,
                 filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings'] = None,
                 fixed_afd: Optional[str] = None,
                 flicker_aq: Optional[str] = None,
                 gop_closed_cadence: Optional[int] = None,
                 gop_size: Optional[float] = None,
                 gop_size_units: Optional[str] = None,
                 level: Optional[str] = None,
                 look_ahead_rate_control: Optional[str] = None,
                 max_bitrate: Optional[int] = None,
                 min_i_interval: Optional[int] = None,
                 par_denominator: Optional[int] = None,
                 par_numerator: Optional[int] = None,
                 profile: Optional[str] = None,
                 qvbr_quality_level: Optional[int] = None,
                 rate_control_mode: Optional[str] = None,
                 scan_type: Optional[str] = None,
                 scene_change_detect: Optional[str] = None,
                 slices: Optional[int] = None,
                 tier: Optional[str] = None,
                 timecode_burnin_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings'] = None,
                 timecode_insertion: Optional[str] = None):
        """
        :param int bitrate: Average bitrate in bits/second.
        :param int framerate_denominator: Framerate denominator.
        :param int framerate_numerator: Framerate numerator.
        :param str adaptive_quantization: Enables or disables adaptive quantization.
        :param str afd_signaling: Indicates that AFD values will be written into the output stream.
        :param str alternative_transfer_function: Whether or not EML should insert an Alternative Transfer Function SEI message.
        :param int buf_size: Size of buffer in bits.
        :param str color_metadata: Includes color space metadata in the output.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs' color_space_settings: Define the color metadata for the output. H265 Color Space Settings for more details.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs' filter_settings: Filters to apply to an encode. See H265 Filter Settings for more details.
        :param str fixed_afd: Four bit AFD value to write on all frames of video in the output stream.
        :param int gop_closed_cadence: Frequency of closed GOPs.
        :param float gop_size: GOP size in units of either frames of seconds per `gop_size_units`.
        :param str gop_size_units: Indicates if the `gop_size` is specified in frames or seconds.
        :param str level: H265 level.
        :param str look_ahead_rate_control: Amount of lookahead.
        :param int max_bitrate: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        :param int par_denominator: Pixel Aspect Ratio denominator.
        :param int par_numerator: Pixel Aspect Ratio numerator.
        :param str profile: AAC profile.
        :param int qvbr_quality_level: Controls the target quality for the video encode.
        :param str rate_control_mode: The rate control mode.
        :param str scan_type: Sets the scan type of the output.
        :param str scene_change_detect: Scene change detection.
        :param int slices: Number of slices per picture.
        :param str tier: Set the H265 tier in the output.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs' timecode_burnin_settings: Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
        :param str timecode_insertion: Determines how timecodes should be inserted into the video elementary stream.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            alternative_transfer_function=alternative_transfer_function,
            buf_size=buf_size,
            color_metadata=color_metadata,
            color_space_settings=color_space_settings,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            gop_closed_cadence=gop_closed_cadence,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            tier=tier,
            timecode_burnin_settings=timecode_burnin_settings,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[int] = None,
             framerate_denominator: Optional[int] = None,
             framerate_numerator: Optional[int] = None,
             adaptive_quantization: Optional[str] = None,
             afd_signaling: Optional[str] = None,
             alternative_transfer_function: Optional[str] = None,
             buf_size: Optional[int] = None,
             color_metadata: Optional[str] = None,
             color_space_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings'] = None,
             filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings'] = None,
             fixed_afd: Optional[str] = None,
             flicker_aq: Optional[str] = None,
             gop_closed_cadence: Optional[int] = None,
             gop_size: Optional[float] = None,
             gop_size_units: Optional[str] = None,
             level: Optional[str] = None,
             look_ahead_rate_control: Optional[str] = None,
             max_bitrate: Optional[int] = None,
             min_i_interval: Optional[int] = None,
             par_denominator: Optional[int] = None,
             par_numerator: Optional[int] = None,
             profile: Optional[str] = None,
             qvbr_quality_level: Optional[int] = None,
             rate_control_mode: Optional[str] = None,
             scan_type: Optional[str] = None,
             scene_change_detect: Optional[str] = None,
             slices: Optional[int] = None,
             tier: Optional[str] = None,
             timecode_burnin_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings'] = None,
             timecode_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bitrate is None:
            raise TypeError("Missing 'bitrate' argument")
        if framerate_denominator is None and 'framerateDenominator' in kwargs:
            framerate_denominator = kwargs['framerateDenominator']
        if framerate_denominator is None:
            raise TypeError("Missing 'framerate_denominator' argument")
        if framerate_numerator is None and 'framerateNumerator' in kwargs:
            framerate_numerator = kwargs['framerateNumerator']
        if framerate_numerator is None:
            raise TypeError("Missing 'framerate_numerator' argument")
        if adaptive_quantization is None and 'adaptiveQuantization' in kwargs:
            adaptive_quantization = kwargs['adaptiveQuantization']
        if afd_signaling is None and 'afdSignaling' in kwargs:
            afd_signaling = kwargs['afdSignaling']
        if alternative_transfer_function is None and 'alternativeTransferFunction' in kwargs:
            alternative_transfer_function = kwargs['alternativeTransferFunction']
        if buf_size is None and 'bufSize' in kwargs:
            buf_size = kwargs['bufSize']
        if color_metadata is None and 'colorMetadata' in kwargs:
            color_metadata = kwargs['colorMetadata']
        if color_space_settings is None and 'colorSpaceSettings' in kwargs:
            color_space_settings = kwargs['colorSpaceSettings']
        if filter_settings is None and 'filterSettings' in kwargs:
            filter_settings = kwargs['filterSettings']
        if fixed_afd is None and 'fixedAfd' in kwargs:
            fixed_afd = kwargs['fixedAfd']
        if flicker_aq is None and 'flickerAq' in kwargs:
            flicker_aq = kwargs['flickerAq']
        if gop_closed_cadence is None and 'gopClosedCadence' in kwargs:
            gop_closed_cadence = kwargs['gopClosedCadence']
        if gop_size is None and 'gopSize' in kwargs:
            gop_size = kwargs['gopSize']
        if gop_size_units is None and 'gopSizeUnits' in kwargs:
            gop_size_units = kwargs['gopSizeUnits']
        if look_ahead_rate_control is None and 'lookAheadRateControl' in kwargs:
            look_ahead_rate_control = kwargs['lookAheadRateControl']
        if max_bitrate is None and 'maxBitrate' in kwargs:
            max_bitrate = kwargs['maxBitrate']
        if min_i_interval is None and 'minIInterval' in kwargs:
            min_i_interval = kwargs['minIInterval']
        if par_denominator is None and 'parDenominator' in kwargs:
            par_denominator = kwargs['parDenominator']
        if par_numerator is None and 'parNumerator' in kwargs:
            par_numerator = kwargs['parNumerator']
        if qvbr_quality_level is None and 'qvbrQualityLevel' in kwargs:
            qvbr_quality_level = kwargs['qvbrQualityLevel']
        if rate_control_mode is None and 'rateControlMode' in kwargs:
            rate_control_mode = kwargs['rateControlMode']
        if scan_type is None and 'scanType' in kwargs:
            scan_type = kwargs['scanType']
        if scene_change_detect is None and 'sceneChangeDetect' in kwargs:
            scene_change_detect = kwargs['sceneChangeDetect']
        if timecode_burnin_settings is None and 'timecodeBurninSettings' in kwargs:
            timecode_burnin_settings = kwargs['timecodeBurninSettings']
        if timecode_insertion is None and 'timecodeInsertion' in kwargs:
            timecode_insertion = kwargs['timecodeInsertion']

        _setter("bitrate", bitrate)
        _setter("framerate_denominator", framerate_denominator)
        _setter("framerate_numerator", framerate_numerator)
        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if alternative_transfer_function is not None:
            _setter("alternative_transfer_function", alternative_transfer_function)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if color_space_settings is not None:
            _setter("color_space_settings", color_space_settings)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if tier is not None:
            _setter("tier", tier)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Average bitrate in bits/second.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> int:
        """
        Framerate denominator.
        """
        return pulumi.get(self, "framerate_denominator")

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> int:
        """
        Framerate numerator.
        """
        return pulumi.get(self, "framerate_numerator")

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[str]:
        """
        Enables or disables adaptive quantization.
        """
        return pulumi.get(self, "adaptive_quantization")

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[str]:
        """
        Indicates that AFD values will be written into the output stream.
        """
        return pulumi.get(self, "afd_signaling")

    @property
    @pulumi.getter(name="alternativeTransferFunction")
    def alternative_transfer_function(self) -> Optional[str]:
        """
        Whether or not EML should insert an Alternative Transfer Function SEI message.
        """
        return pulumi.get(self, "alternative_transfer_function")

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[int]:
        """
        Size of buffer in bits.
        """
        return pulumi.get(self, "buf_size")

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[str]:
        """
        Includes color space metadata in the output.
        """
        return pulumi.get(self, "color_metadata")

    @property
    @pulumi.getter(name="colorSpaceSettings")
    def color_space_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings']:
        """
        Define the color metadata for the output. H265 Color Space Settings for more details.
        """
        return pulumi.get(self, "color_space_settings")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings']:
        """
        Filters to apply to an encode. See H265 Filter Settings for more details.
        """
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[str]:
        """
        Four bit AFD value to write on all frames of video in the output stream.
        """
        return pulumi.get(self, "fixed_afd")

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[str]:
        return pulumi.get(self, "flicker_aq")

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[int]:
        """
        Frequency of closed GOPs.
        """
        return pulumi.get(self, "gop_closed_cadence")

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[float]:
        """
        GOP size in units of either frames of seconds per `gop_size_units`.
        """
        return pulumi.get(self, "gop_size")

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[str]:
        """
        Indicates if the `gop_size` is specified in frames or seconds.
        """
        return pulumi.get(self, "gop_size_units")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        H265 level.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[str]:
        """
        Amount of lookahead.
        """
        return pulumi.get(self, "look_ahead_rate_control")

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[int]:
        """
        Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
        """
        return pulumi.get(self, "max_bitrate")

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[int]:
        return pulumi.get(self, "min_i_interval")

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[int]:
        """
        Pixel Aspect Ratio denominator.
        """
        return pulumi.get(self, "par_denominator")

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[int]:
        """
        Pixel Aspect Ratio numerator.
        """
        return pulumi.get(self, "par_numerator")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        AAC profile.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[int]:
        """
        Controls the target quality for the video encode.
        """
        return pulumi.get(self, "qvbr_quality_level")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        """
        The rate control mode.
        """
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[str]:
        """
        Sets the scan type of the output.
        """
        return pulumi.get(self, "scan_type")

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[str]:
        """
        Scene change detection.
        """
        return pulumi.get(self, "scene_change_detect")

    @property
    @pulumi.getter
    def slices(self) -> Optional[int]:
        """
        Number of slices per picture.
        """
        return pulumi.get(self, "slices")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Set the H265 tier in the output.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings']:
        """
        Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
        """
        return pulumi.get(self, "timecode_burnin_settings")

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[str]:
        """
        Determines how timecodes should be inserted into the video elementary stream.
        """
        return pulumi.get(self, "timecode_insertion")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSpacePassthroughSettings":
            suggest = "color_space_passthrough_settings"
        elif key == "dolbyVision81Settings":
            suggest = "dolby_vision81_settings"
        elif key == "hdr10Settings":
            suggest = "hdr10_settings"
        elif key == "rec601Settings":
            suggest = "rec601_settings"
        elif key == "rec709Settings":
            suggest = "rec709_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_space_passthrough_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings'] = None,
                 dolby_vision81_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings'] = None,
                 hdr10_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings'] = None,
                 rec601_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings'] = None,
                 rec709_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings'] = None):
        """
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettingsArgs' color_space_passthrough_settings: Sets the colorspace metadata to be passed through.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81SettingsArgs' dolby_vision81_settings: Set the colorspace to Dolby Vision81.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10SettingsArgs' hdr10_settings: Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601SettingsArgs' rec601_settings: Set the colorspace to Rec. 601.
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709SettingsArgs' rec709_settings: Set the colorspace to Rec. 709.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space_passthrough_settings=color_space_passthrough_settings,
            dolby_vision81_settings=dolby_vision81_settings,
            hdr10_settings=hdr10_settings,
            rec601_settings=rec601_settings,
            rec709_settings=rec709_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space_passthrough_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings'] = None,
             dolby_vision81_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings'] = None,
             hdr10_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings'] = None,
             rec601_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings'] = None,
             rec709_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if color_space_passthrough_settings is None and 'colorSpacePassthroughSettings' in kwargs:
            color_space_passthrough_settings = kwargs['colorSpacePassthroughSettings']
        if dolby_vision81_settings is None and 'dolbyVision81Settings' in kwargs:
            dolby_vision81_settings = kwargs['dolbyVision81Settings']
        if hdr10_settings is None and 'hdr10Settings' in kwargs:
            hdr10_settings = kwargs['hdr10Settings']
        if rec601_settings is None and 'rec601Settings' in kwargs:
            rec601_settings = kwargs['rec601Settings']
        if rec709_settings is None and 'rec709Settings' in kwargs:
            rec709_settings = kwargs['rec709Settings']

        if color_space_passthrough_settings is not None:
            _setter("color_space_passthrough_settings", color_space_passthrough_settings)
        if dolby_vision81_settings is not None:
            _setter("dolby_vision81_settings", dolby_vision81_settings)
        if hdr10_settings is not None:
            _setter("hdr10_settings", hdr10_settings)
        if rec601_settings is not None:
            _setter("rec601_settings", rec601_settings)
        if rec709_settings is not None:
            _setter("rec709_settings", rec709_settings)

    @property
    @pulumi.getter(name="colorSpacePassthroughSettings")
    def color_space_passthrough_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings']:
        """
        Sets the colorspace metadata to be passed through.
        """
        return pulumi.get(self, "color_space_passthrough_settings")

    @property
    @pulumi.getter(name="dolbyVision81Settings")
    def dolby_vision81_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings']:
        """
        Set the colorspace to Dolby Vision81.
        """
        return pulumi.get(self, "dolby_vision81_settings")

    @property
    @pulumi.getter(name="hdr10Settings")
    def hdr10_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings']:
        """
        Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
        """
        return pulumi.get(self, "hdr10_settings")

    @property
    @pulumi.getter(name="rec601Settings")
    def rec601_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings']:
        """
        Set the colorspace to Rec. 601.
        """
        return pulumi.get(self, "rec601_settings")

    @property
    @pulumi.getter(name="rec709Settings")
    def rec709_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings']:
        """
        Set the colorspace to Rec. 709.
        """
        return pulumi.get(self, "rec709_settings")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCll":
            suggest = "max_cll"
        elif key == "maxFall":
            suggest = "max_fall"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cll: Optional[int] = None,
                 max_fall: Optional[int] = None):
        """
        :param int max_cll: Sets the MaxCLL value for HDR10.
        :param int max_fall: Sets the MaxFALL value for HDR10.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_cll=max_cll,
            max_fall=max_fall,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_cll: Optional[int] = None,
             max_fall: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_cll is None and 'maxCll' in kwargs:
            max_cll = kwargs['maxCll']
        if max_fall is None and 'maxFall' in kwargs:
            max_fall = kwargs['maxFall']

        if max_cll is not None:
            _setter("max_cll", max_cll)
        if max_fall is not None:
            _setter("max_fall", max_fall)

    @property
    @pulumi.getter(name="maxCll")
    def max_cll(self) -> Optional[int]:
        """
        Sets the MaxCLL value for HDR10.
        """
        return pulumi.get(self, "max_cll")

    @property
    @pulumi.getter(name="maxFall")
    def max_fall(self) -> Optional[int]:
        """
        Sets the MaxFALL value for HDR10.
        """
        return pulumi.get(self, "max_fall")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporalFilterSettings":
            suggest = "temporal_filter_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporal_filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings'] = None):
        """
        :param 'ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettingsArgs' temporal_filter_settings: Temporal filter settings. See Temporal Filter Settings
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if temporal_filter_settings is None and 'temporalFilterSettings' in kwargs:
            temporal_filter_settings = kwargs['temporalFilterSettings']

        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional['outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings']:
        """
        Temporal filter settings. See Temporal Filter Settings
        """
        return pulumi.get(self, "temporal_filter_settings")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postFilterSharpening":
            suggest = "post_filter_sharpening"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_filter_sharpening: Optional[str] = None,
                 strength: Optional[str] = None):
        """
        :param str post_filter_sharpening: Post filter sharpening.
        :param str strength: Filter strength.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_filter_sharpening=post_filter_sharpening,
            strength=strength,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_filter_sharpening: Optional[str] = None,
             strength: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if post_filter_sharpening is None and 'postFilterSharpening' in kwargs:
            post_filter_sharpening = kwargs['postFilterSharpening']

        if post_filter_sharpening is not None:
            _setter("post_filter_sharpening", post_filter_sharpening)
        if strength is not None:
            _setter("strength", strength)

    @property
    @pulumi.getter(name="postFilterSharpening")
    def post_filter_sharpening(self) -> Optional[str]:
        """
        Post filter sharpening.
        """
        return pulumi.get(self, "post_filter_sharpening")

    @property
    @pulumi.getter
    def strength(self) -> Optional[str]:
        """
        Filter strength.
        """
        return pulumi.get(self, "strength")


@pulumi.output_type
class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timecodeBurninFontSize":
            suggest = "timecode_burnin_font_size"
        elif key == "timecodeBurninPosition":
            suggest = "timecode_burnin_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix: Optional[str] = None,
                 timecode_burnin_font_size: Optional[str] = None,
                 timecode_burnin_position: Optional[str] = None):
        """
        :param str prefix: Set a prefix on the burned in timecode.
        :param str timecode_burnin_font_size: Sets the size of the burned in timecode.
        :param str timecode_burnin_position: Sets the position of the burned in timecode.
        """
        ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            timecode_burnin_font_size=timecode_burnin_font_size,
            timecode_burnin_position=timecode_burnin_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[str] = None,
             timecode_burnin_font_size: Optional[str] = None,
             timecode_burnin_position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if timecode_burnin_font_size is None and 'timecodeBurninFontSize' in kwargs:
            timecode_burnin_font_size = kwargs['timecodeBurninFontSize']
        if timecode_burnin_position is None and 'timecodeBurninPosition' in kwargs:
            timecode_burnin_position = kwargs['timecodeBurninPosition']

        if prefix is not None:
            _setter("prefix", prefix)
        if timecode_burnin_font_size is not None:
            _setter("timecode_burnin_font_size", timecode_burnin_font_size)
        if timecode_burnin_position is not None:
            _setter("timecode_burnin_position", timecode_burnin_position)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Set a prefix on the burned in timecode.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="timecodeBurninFontSize")
    def timecode_burnin_font_size(self) -> Optional[str]:
        """
        Sets the size of the burned in timecode.
        """
        return pulumi.get(self, "timecode_burnin_font_size")

    @property
    @pulumi.getter(name="timecodeBurninPosition")
    def timecode_burnin_position(self) -> Optional[str]:
        """
        Sets the position of the burned in timecode.
        """
        return pulumi.get(self, "timecode_burnin_position")


@pulumi.output_type
class ChannelInputAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAttachmentName":
            suggest = "input_attachment_name"
        elif key == "inputId":
            suggest = "input_id"
        elif key == "automaticInputFailoverSettings":
            suggest = "automatic_input_failover_settings"
        elif key == "inputSettings":
            suggest = "input_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_attachment_name: str,
                 input_id: str,
                 automatic_input_failover_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettings'] = None,
                 input_settings: Optional['outputs.ChannelInputAttachmentInputSettings'] = None):
        """
        :param str input_attachment_name: User-specified name for the attachment.
        :param str input_id: The ID of the input.
        :param 'ChannelInputAttachmentAutomaticInputFailoverSettingsArgs' automatic_input_failover_settings: User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsArgs' input_settings: Settings of an input. See Input Settings for more details.
        """
        ChannelInputAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_attachment_name=input_attachment_name,
            input_id=input_id,
            automatic_input_failover_settings=automatic_input_failover_settings,
            input_settings=input_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_attachment_name: Optional[str] = None,
             input_id: Optional[str] = None,
             automatic_input_failover_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettings'] = None,
             input_settings: Optional['outputs.ChannelInputAttachmentInputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_attachment_name is None and 'inputAttachmentName' in kwargs:
            input_attachment_name = kwargs['inputAttachmentName']
        if input_attachment_name is None:
            raise TypeError("Missing 'input_attachment_name' argument")
        if input_id is None and 'inputId' in kwargs:
            input_id = kwargs['inputId']
        if input_id is None:
            raise TypeError("Missing 'input_id' argument")
        if automatic_input_failover_settings is None and 'automaticInputFailoverSettings' in kwargs:
            automatic_input_failover_settings = kwargs['automaticInputFailoverSettings']
        if input_settings is None and 'inputSettings' in kwargs:
            input_settings = kwargs['inputSettings']

        _setter("input_attachment_name", input_attachment_name)
        _setter("input_id", input_id)
        if automatic_input_failover_settings is not None:
            _setter("automatic_input_failover_settings", automatic_input_failover_settings)
        if input_settings is not None:
            _setter("input_settings", input_settings)

    @property
    @pulumi.getter(name="inputAttachmentName")
    def input_attachment_name(self) -> str:
        """
        User-specified name for the attachment.
        """
        return pulumi.get(self, "input_attachment_name")

    @property
    @pulumi.getter(name="inputId")
    def input_id(self) -> str:
        """
        The ID of the input.
        """
        return pulumi.get(self, "input_id")

    @property
    @pulumi.getter(name="automaticInputFailoverSettings")
    def automatic_input_failover_settings(self) -> Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettings']:
        """
        User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
        """
        return pulumi.get(self, "automatic_input_failover_settings")

    @property
    @pulumi.getter(name="inputSettings")
    def input_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettings']:
        """
        Settings of an input. See Input Settings for more details.
        """
        return pulumi.get(self, "input_settings")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryInputId":
            suggest = "secondary_input_id"
        elif key == "errorClearTimeMsec":
            suggest = "error_clear_time_msec"
        elif key == "failoverConditions":
            suggest = "failover_conditions"
        elif key == "inputPreference":
            suggest = "input_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secondary_input_id: str,
                 error_clear_time_msec: Optional[int] = None,
                 failover_conditions: Optional[Sequence['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition']] = None,
                 input_preference: Optional[str] = None):
        """
        :param str secondary_input_id: The input ID of the secondary input in the automatic input failover pair.
        :param int error_clear_time_msec: This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\\_preference for the failover pair is set to PRIMARY\\_INPUT\\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
        :param str input_preference: Input preference when deciding which input to make active when a previously failed input has recovered.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secondary_input_id=secondary_input_id,
            error_clear_time_msec=error_clear_time_msec,
            failover_conditions=failover_conditions,
            input_preference=input_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secondary_input_id: Optional[str] = None,
             error_clear_time_msec: Optional[int] = None,
             failover_conditions: Optional[Sequence['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition']] = None,
             input_preference: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secondary_input_id is None and 'secondaryInputId' in kwargs:
            secondary_input_id = kwargs['secondaryInputId']
        if secondary_input_id is None:
            raise TypeError("Missing 'secondary_input_id' argument")
        if error_clear_time_msec is None and 'errorClearTimeMsec' in kwargs:
            error_clear_time_msec = kwargs['errorClearTimeMsec']
        if failover_conditions is None and 'failoverConditions' in kwargs:
            failover_conditions = kwargs['failoverConditions']
        if input_preference is None and 'inputPreference' in kwargs:
            input_preference = kwargs['inputPreference']

        _setter("secondary_input_id", secondary_input_id)
        if error_clear_time_msec is not None:
            _setter("error_clear_time_msec", error_clear_time_msec)
        if failover_conditions is not None:
            _setter("failover_conditions", failover_conditions)
        if input_preference is not None:
            _setter("input_preference", input_preference)

    @property
    @pulumi.getter(name="secondaryInputId")
    def secondary_input_id(self) -> str:
        """
        The input ID of the secondary input in the automatic input failover pair.
        """
        return pulumi.get(self, "secondary_input_id")

    @property
    @pulumi.getter(name="errorClearTimeMsec")
    def error_clear_time_msec(self) -> Optional[int]:
        """
        This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\\_preference for the failover pair is set to PRIMARY\\_INPUT\\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
        """
        return pulumi.get(self, "error_clear_time_msec")

    @property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Optional[Sequence['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition']]:
        return pulumi.get(self, "failover_conditions")

    @property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> Optional[str]:
        """
        Input preference when deciding which input to make active when a previously failed input has recovered.
        """
        return pulumi.get(self, "input_preference")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverConditionSettings":
            suggest = "failover_condition_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_condition_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings'] = None):
        """
        :param 'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsArgs' failover_condition_settings: Failover condition type-specific settings. See Failover Condition Settings for more details.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_condition_settings=failover_condition_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_condition_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failover_condition_settings is None and 'failoverConditionSettings' in kwargs:
            failover_condition_settings = kwargs['failoverConditionSettings']

        if failover_condition_settings is not None:
            _setter("failover_condition_settings", failover_condition_settings)

    @property
    @pulumi.getter(name="failoverConditionSettings")
    def failover_condition_settings(self) -> Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings']:
        """
        Failover condition type-specific settings. See Failover Condition Settings for more details.
        """
        return pulumi.get(self, "failover_condition_settings")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSilenceSettings":
            suggest = "audio_silence_settings"
        elif key == "inputLossSettings":
            suggest = "input_loss_settings"
        elif key == "videoBlackSettings":
            suggest = "video_black_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_silence_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings'] = None,
                 input_loss_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings'] = None,
                 video_black_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings'] = None):
        """
        :param 'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettingsArgs' audio_silence_settings: MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
        :param 'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettingsArgs' input_loss_settings: MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
        :param 'ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettingsArgs' video_black_settings: MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_silence_settings=audio_silence_settings,
            input_loss_settings=input_loss_settings,
            video_black_settings=video_black_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_silence_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings'] = None,
             input_loss_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings'] = None,
             video_black_settings: Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_silence_settings is None and 'audioSilenceSettings' in kwargs:
            audio_silence_settings = kwargs['audioSilenceSettings']
        if input_loss_settings is None and 'inputLossSettings' in kwargs:
            input_loss_settings = kwargs['inputLossSettings']
        if video_black_settings is None and 'videoBlackSettings' in kwargs:
            video_black_settings = kwargs['videoBlackSettings']

        if audio_silence_settings is not None:
            _setter("audio_silence_settings", audio_silence_settings)
        if input_loss_settings is not None:
            _setter("input_loss_settings", input_loss_settings)
        if video_black_settings is not None:
            _setter("video_black_settings", video_black_settings)

    @property
    @pulumi.getter(name="audioSilenceSettings")
    def audio_silence_settings(self) -> Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings']:
        """
        MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
        """
        return pulumi.get(self, "audio_silence_settings")

    @property
    @pulumi.getter(name="inputLossSettings")
    def input_loss_settings(self) -> Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings']:
        """
        MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
        """
        return pulumi.get(self, "input_loss_settings")

    @property
    @pulumi.getter(name="videoBlackSettings")
    def video_black_settings(self) -> Optional['outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings']:
        """
        MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
        """
        return pulumi.get(self, "video_black_settings")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectorName":
            suggest = "audio_selector_name"
        elif key == "audioSilenceThresholdMsec":
            suggest = "audio_silence_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selector_name: str,
                 audio_silence_threshold_msec: Optional[int] = None):
        """
        :param str audio_selector_name: The name of the audio selector used as the source for this AudioDescription.
        :param int audio_silence_threshold_msec: The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selector_name=audio_selector_name,
            audio_silence_threshold_msec=audio_silence_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selector_name: Optional[str] = None,
             audio_silence_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selector_name is None and 'audioSelectorName' in kwargs:
            audio_selector_name = kwargs['audioSelectorName']
        if audio_selector_name is None:
            raise TypeError("Missing 'audio_selector_name' argument")
        if audio_silence_threshold_msec is None and 'audioSilenceThresholdMsec' in kwargs:
            audio_silence_threshold_msec = kwargs['audioSilenceThresholdMsec']

        _setter("audio_selector_name", audio_selector_name)
        if audio_silence_threshold_msec is not None:
            _setter("audio_silence_threshold_msec", audio_silence_threshold_msec)

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> str:
        """
        The name of the audio selector used as the source for this AudioDescription.
        """
        return pulumi.get(self, "audio_selector_name")

    @property
    @pulumi.getter(name="audioSilenceThresholdMsec")
    def audio_silence_threshold_msec(self) -> Optional[int]:
        """
        The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS.
        """
        return pulumi.get(self, "audio_silence_threshold_msec")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLossThresholdMsec":
            suggest = "input_loss_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_loss_threshold_msec: Optional[int] = None):
        """
        :param int input_loss_threshold_msec: The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_threshold_msec=input_loss_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_loss_threshold_msec is None and 'inputLossThresholdMsec' in kwargs:
            input_loss_threshold_msec = kwargs['inputLossThresholdMsec']

        if input_loss_threshold_msec is not None:
            _setter("input_loss_threshold_msec", input_loss_threshold_msec)

    @property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> Optional[int]:
        """
        The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur.
        """
        return pulumi.get(self, "input_loss_threshold_msec")


@pulumi.output_type
class ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackDetectThreshold":
            suggest = "black_detect_threshold"
        elif key == "videoBlackThresholdMsec":
            suggest = "video_black_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 black_detect_threshold: Optional[float] = None,
                 video_black_threshold_msec: Optional[int] = None):
        """
        :param float black_detect_threshold: A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
        :param int video_black_threshold_msec: The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
        """
        ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_detect_threshold=black_detect_threshold,
            video_black_threshold_msec=video_black_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_detect_threshold: Optional[float] = None,
             video_black_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if black_detect_threshold is None and 'blackDetectThreshold' in kwargs:
            black_detect_threshold = kwargs['blackDetectThreshold']
        if video_black_threshold_msec is None and 'videoBlackThresholdMsec' in kwargs:
            video_black_threshold_msec = kwargs['videoBlackThresholdMsec']

        if black_detect_threshold is not None:
            _setter("black_detect_threshold", black_detect_threshold)
        if video_black_threshold_msec is not None:
            _setter("video_black_threshold_msec", video_black_threshold_msec)

    @property
    @pulumi.getter(name="blackDetectThreshold")
    def black_detect_threshold(self) -> Optional[float]:
        """
        A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
        """
        return pulumi.get(self, "black_detect_threshold")

    @property
    @pulumi.getter(name="videoBlackThresholdMsec")
    def video_black_threshold_msec(self) -> Optional[int]:
        """
        The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
        """
        return pulumi.get(self, "video_black_threshold_msec")


@pulumi.output_type
class ChannelInputAttachmentInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectors":
            suggest = "audio_selectors"
        elif key == "captionSelectors":
            suggest = "caption_selectors"
        elif key == "deblockFilter":
            suggest = "deblock_filter"
        elif key == "denoiseFilter":
            suggest = "denoise_filter"
        elif key == "filterStrength":
            suggest = "filter_strength"
        elif key == "inputFilter":
            suggest = "input_filter"
        elif key == "networkInputSettings":
            suggest = "network_input_settings"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "smpte2038DataPreference":
            suggest = "smpte2038_data_preference"
        elif key == "sourceEndBehavior":
            suggest = "source_end_behavior"
        elif key == "videoSelector":
            suggest = "video_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selectors: Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelector']] = None,
                 caption_selectors: Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsCaptionSelector']] = None,
                 deblock_filter: Optional[str] = None,
                 denoise_filter: Optional[str] = None,
                 filter_strength: Optional[int] = None,
                 input_filter: Optional[str] = None,
                 network_input_settings: Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettings'] = None,
                 scte35_pid: Optional[int] = None,
                 smpte2038_data_preference: Optional[str] = None,
                 source_end_behavior: Optional[str] = None,
                 video_selector: Optional['outputs.ChannelInputAttachmentInputSettingsVideoSelector'] = None):
        """
        :param str deblock_filter: Enable or disable the deblock filter when filtering.
        :param str denoise_filter: Enable or disable the denoise filter when filtering.
        :param int filter_strength: Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
        :param str input_filter: Turns on the filter for the input.
        :param 'ChannelInputAttachmentInputSettingsNetworkInputSettingsArgs' network_input_settings: Input settings. See Network Input Settings for more details.
        :param int scte35_pid: PID from which to read SCTE-35 messages.
        :param str smpte2038_data_preference: Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
        :param str source_end_behavior: Loop input if it is a file.
        """
        ChannelInputAttachmentInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selectors=audio_selectors,
            caption_selectors=caption_selectors,
            deblock_filter=deblock_filter,
            denoise_filter=denoise_filter,
            filter_strength=filter_strength,
            input_filter=input_filter,
            network_input_settings=network_input_settings,
            scte35_pid=scte35_pid,
            smpte2038_data_preference=smpte2038_data_preference,
            source_end_behavior=source_end_behavior,
            video_selector=video_selector,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selectors: Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelector']] = None,
             caption_selectors: Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsCaptionSelector']] = None,
             deblock_filter: Optional[str] = None,
             denoise_filter: Optional[str] = None,
             filter_strength: Optional[int] = None,
             input_filter: Optional[str] = None,
             network_input_settings: Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettings'] = None,
             scte35_pid: Optional[int] = None,
             smpte2038_data_preference: Optional[str] = None,
             source_end_behavior: Optional[str] = None,
             video_selector: Optional['outputs.ChannelInputAttachmentInputSettingsVideoSelector'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_selectors is None and 'audioSelectors' in kwargs:
            audio_selectors = kwargs['audioSelectors']
        if caption_selectors is None and 'captionSelectors' in kwargs:
            caption_selectors = kwargs['captionSelectors']
        if deblock_filter is None and 'deblockFilter' in kwargs:
            deblock_filter = kwargs['deblockFilter']
        if denoise_filter is None and 'denoiseFilter' in kwargs:
            denoise_filter = kwargs['denoiseFilter']
        if filter_strength is None and 'filterStrength' in kwargs:
            filter_strength = kwargs['filterStrength']
        if input_filter is None and 'inputFilter' in kwargs:
            input_filter = kwargs['inputFilter']
        if network_input_settings is None and 'networkInputSettings' in kwargs:
            network_input_settings = kwargs['networkInputSettings']
        if scte35_pid is None and 'scte35Pid' in kwargs:
            scte35_pid = kwargs['scte35Pid']
        if smpte2038_data_preference is None and 'smpte2038DataPreference' in kwargs:
            smpte2038_data_preference = kwargs['smpte2038DataPreference']
        if source_end_behavior is None and 'sourceEndBehavior' in kwargs:
            source_end_behavior = kwargs['sourceEndBehavior']
        if video_selector is None and 'videoSelector' in kwargs:
            video_selector = kwargs['videoSelector']

        if audio_selectors is not None:
            _setter("audio_selectors", audio_selectors)
        if caption_selectors is not None:
            _setter("caption_selectors", caption_selectors)
        if deblock_filter is not None:
            _setter("deblock_filter", deblock_filter)
        if denoise_filter is not None:
            _setter("denoise_filter", denoise_filter)
        if filter_strength is not None:
            _setter("filter_strength", filter_strength)
        if input_filter is not None:
            _setter("input_filter", input_filter)
        if network_input_settings is not None:
            _setter("network_input_settings", network_input_settings)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if smpte2038_data_preference is not None:
            _setter("smpte2038_data_preference", smpte2038_data_preference)
        if source_end_behavior is not None:
            _setter("source_end_behavior", source_end_behavior)
        if video_selector is not None:
            _setter("video_selector", video_selector)

    @property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelector']]:
        return pulumi.get(self, "audio_selectors")

    @property
    @pulumi.getter(name="captionSelectors")
    def caption_selectors(self) -> Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsCaptionSelector']]:
        return pulumi.get(self, "caption_selectors")

    @property
    @pulumi.getter(name="deblockFilter")
    def deblock_filter(self) -> Optional[str]:
        """
        Enable or disable the deblock filter when filtering.
        """
        return pulumi.get(self, "deblock_filter")

    @property
    @pulumi.getter(name="denoiseFilter")
    def denoise_filter(self) -> Optional[str]:
        """
        Enable or disable the denoise filter when filtering.
        """
        return pulumi.get(self, "denoise_filter")

    @property
    @pulumi.getter(name="filterStrength")
    def filter_strength(self) -> Optional[int]:
        """
        Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
        """
        return pulumi.get(self, "filter_strength")

    @property
    @pulumi.getter(name="inputFilter")
    def input_filter(self) -> Optional[str]:
        """
        Turns on the filter for the input.
        """
        return pulumi.get(self, "input_filter")

    @property
    @pulumi.getter(name="networkInputSettings")
    def network_input_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettings']:
        """
        Input settings. See Network Input Settings for more details.
        """
        return pulumi.get(self, "network_input_settings")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[int]:
        """
        PID from which to read SCTE-35 messages.
        """
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="smpte2038DataPreference")
    def smpte2038_data_preference(self) -> Optional[str]:
        """
        Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
        """
        return pulumi.get(self, "smpte2038_data_preference")

    @property
    @pulumi.getter(name="sourceEndBehavior")
    def source_end_behavior(self) -> Optional[str]:
        """
        Loop input if it is a file.
        """
        return pulumi.get(self, "source_end_behavior")

    @property
    @pulumi.getter(name="videoSelector")
    def video_selector(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsVideoSelector']:
        return pulumi.get(self, "video_selector")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 selector_settings: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings'] = None):
        """
        :param str name: Name of the Channel.
               
               The following arguments are optional:
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsArgs' selector_settings: The audio selector settings. See Audio Selector Settings for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             selector_settings: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if selector_settings is None and 'selectorSettings' in kwargs:
            selector_settings = kwargs['selectorSettings']

        _setter("name", name)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Channel.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings']:
        """
        The audio selector settings. See Audio Selector Settings for more details.
        """
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioHlsRenditionSelection":
            suggest = "audio_hls_rendition_selection"
        elif key == "audioLanguageSelection":
            suggest = "audio_language_selection"
        elif key == "audioPidSelection":
            suggest = "audio_pid_selection"
        elif key == "audioTrackSelection":
            suggest = "audio_track_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_hls_rendition_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection'] = None,
                 audio_language_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection'] = None,
                 audio_pid_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection'] = None,
                 audio_track_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection'] = None):
        """
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelectionArgs' audio_hls_rendition_selection: Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details.
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelectionArgs' audio_language_selection: Audio Language Selection. See Audio Language Selection for more details.
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelectionArgs' audio_pid_selection: Audio Pid Selection. See Audio PID Selection for more details.
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionArgs' audio_track_selection: Audio Track Selection. See Audio Track Selection for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_hls_rendition_selection=audio_hls_rendition_selection,
            audio_language_selection=audio_language_selection,
            audio_pid_selection=audio_pid_selection,
            audio_track_selection=audio_track_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_hls_rendition_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection'] = None,
             audio_language_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection'] = None,
             audio_pid_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection'] = None,
             audio_track_selection: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audio_hls_rendition_selection is None and 'audioHlsRenditionSelection' in kwargs:
            audio_hls_rendition_selection = kwargs['audioHlsRenditionSelection']
        if audio_language_selection is None and 'audioLanguageSelection' in kwargs:
            audio_language_selection = kwargs['audioLanguageSelection']
        if audio_pid_selection is None and 'audioPidSelection' in kwargs:
            audio_pid_selection = kwargs['audioPidSelection']
        if audio_track_selection is None and 'audioTrackSelection' in kwargs:
            audio_track_selection = kwargs['audioTrackSelection']

        if audio_hls_rendition_selection is not None:
            _setter("audio_hls_rendition_selection", audio_hls_rendition_selection)
        if audio_language_selection is not None:
            _setter("audio_language_selection", audio_language_selection)
        if audio_pid_selection is not None:
            _setter("audio_pid_selection", audio_pid_selection)
        if audio_track_selection is not None:
            _setter("audio_track_selection", audio_track_selection)

    @property
    @pulumi.getter(name="audioHlsRenditionSelection")
    def audio_hls_rendition_selection(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection']:
        """
        Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details.
        """
        return pulumi.get(self, "audio_hls_rendition_selection")

    @property
    @pulumi.getter(name="audioLanguageSelection")
    def audio_language_selection(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection']:
        """
        Audio Language Selection. See Audio Language Selection for more details.
        """
        return pulumi.get(self, "audio_language_selection")

    @property
    @pulumi.getter(name="audioPidSelection")
    def audio_pid_selection(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection']:
        """
        Audio Pid Selection. See Audio PID Selection for more details.
        """
        return pulumi.get(self, "audio_pid_selection")

    @property
    @pulumi.getter(name="audioTrackSelection")
    def audio_track_selection(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection']:
        """
        Audio Track Selection. See Audio Track Selection for more details.
        """
        return pulumi.get(self, "audio_track_selection")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: str,
                 name: str):
        """
        :param str group_id: Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        :param str name: Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("group_id", group_id)
        _setter("name", name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "languageSelectionPolicy":
            suggest = "language_selection_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: str,
                 language_selection_policy: Optional[str] = None):
        """
        :param str language_code: Selects a specific three-letter language code from within an audio source.
        :param str language_selection_policy: When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            language_selection_policy=language_selection_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[str] = None,
             language_selection_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if language_selection_policy is None and 'languageSelectionPolicy' in kwargs:
            language_selection_policy = kwargs['languageSelectionPolicy']

        _setter("language_code", language_code)
        if language_selection_policy is not None:
            _setter("language_selection_policy", language_selection_policy)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> str:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> Optional[str]:
        """
        When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language.
        """
        return pulumi.get(self, "language_selection_policy")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection(dict):
    def __init__(__self__, *,
                 pid: int):
        """
        :param int pid: Selects a specific PID from within a source.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if pid is None:
            raise TypeError("Missing 'pid' argument")

        _setter("pid", pid)

    @property
    @pulumi.getter
    def pid(self) -> int:
        """
        Selects a specific PID from within a source.
        """
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dolbyEDecode":
            suggest = "dolby_e_decode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tracks: Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack'],
                 dolby_e_decode: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode'] = None):
        """
        :param Sequence['ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrackArgs'] tracks: Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
        :param 'ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecodeArgs' dolby_e_decode: Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tracks=tracks,
            dolby_e_decode=dolby_e_decode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tracks: Optional[Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack']] = None,
             dolby_e_decode: Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tracks is None:
            raise TypeError("Missing 'tracks' argument")
        if dolby_e_decode is None and 'dolbyEDecode' in kwargs:
            dolby_e_decode = kwargs['dolbyEDecode']

        _setter("tracks", tracks)
        if dolby_e_decode is not None:
            _setter("dolby_e_decode", dolby_e_decode)

    @property
    @pulumi.getter
    def tracks(self) -> Sequence['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack']:
        """
        Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
        """
        return pulumi.get(self, "tracks")

    @property
    @pulumi.getter(name="dolbyEDecode")
    def dolby_e_decode(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode']:
        """
        Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
        """
        return pulumi.get(self, "dolby_e_decode")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "programSelection":
            suggest = "program_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 program_selection: str):
        """
        :param str program_selection: Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            program_selection=program_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             program_selection: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if program_selection is None and 'programSelection' in kwargs:
            program_selection = kwargs['programSelection']
        if program_selection is None:
            raise TypeError("Missing 'program_selection' argument")

        _setter("program_selection", program_selection)

    @property
    @pulumi.getter(name="programSelection")
    def program_selection(self) -> str:
        """
        Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
        """
        return pulumi.get(self, "program_selection")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack(dict):
    def __init__(__self__, *,
                 track: int):
        """
        :param int track: 1-based integer value that maps to a specific audio track.
        """
        ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            track=track,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             track: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if track is None:
            raise TypeError("Missing 'track' argument")

        _setter("track", track)

    @property
    @pulumi.getter
    def track(self) -> int:
        """
        1-based integer value that maps to a specific audio track.
        """
        return pulumi.get(self, "track")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 language_code: Optional[str] = None,
                 selector_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings'] = None):
        """
        :param str name: Name of the Channel.
               
               The following arguments are optional:
        :param str language_code: Selects a specific three-letter language code from within an audio source.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsArgs' selector_settings: The audio selector settings. See Audio Selector Settings for more details.
        """
        ChannelInputAttachmentInputSettingsCaptionSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            language_code=language_code,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             language_code: Optional[str] = None,
             selector_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if selector_settings is None and 'selectorSettings' in kwargs:
            selector_settings = kwargs['selectorSettings']

        _setter("name", name)
        if language_code is not None:
            _setter("language_code", language_code)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Channel.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        """
        Selects a specific three-letter language code from within an audio source.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings']:
        """
        The audio selector settings. See Audio Selector Settings for more details.
        """
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ancillarySourceSettings":
            suggest = "ancillary_source_settings"
        elif key == "aribSourceSettings":
            suggest = "arib_source_settings"
        elif key == "dvbSubSourceSettings":
            suggest = "dvb_sub_source_settings"
        elif key == "embeddedSourceSettings":
            suggest = "embedded_source_settings"
        elif key == "scte20SourceSettings":
            suggest = "scte20_source_settings"
        elif key == "scte27SourceSettings":
            suggest = "scte27_source_settings"
        elif key == "teletextSourceSettings":
            suggest = "teletext_source_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ancillary_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings'] = None,
                 arib_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings'] = None,
                 dvb_sub_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings'] = None,
                 embedded_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings'] = None,
                 scte20_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings'] = None,
                 scte27_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings'] = None,
                 teletext_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings'] = None):
        """
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettingsArgs' ancillary_source_settings: Ancillary Source Settings. See Ancillary Source Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettingsArgs' arib_source_settings: ARIB Source Settings.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettingsArgs' dvb_sub_source_settings: DVB Sub Source Settings. See DVB Sub Source Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettingsArgs' embedded_source_settings: Embedded Source Settings. See Embedded Source Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettingsArgs' scte20_source_settings: SCTE20 Source Settings. See SCTE 20 Source Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettingsArgs' scte27_source_settings: SCTE27 Source Settings. See SCTE 27 Source Settings for more details.
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsArgs' teletext_source_settings: Teletext Source Settings. See Teletext Source Settings for more details.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ancillary_source_settings=ancillary_source_settings,
            arib_source_settings=arib_source_settings,
            dvb_sub_source_settings=dvb_sub_source_settings,
            embedded_source_settings=embedded_source_settings,
            scte20_source_settings=scte20_source_settings,
            scte27_source_settings=scte27_source_settings,
            teletext_source_settings=teletext_source_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ancillary_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings'] = None,
             arib_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings'] = None,
             dvb_sub_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings'] = None,
             embedded_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings'] = None,
             scte20_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings'] = None,
             scte27_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings'] = None,
             teletext_source_settings: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ancillary_source_settings is None and 'ancillarySourceSettings' in kwargs:
            ancillary_source_settings = kwargs['ancillarySourceSettings']
        if arib_source_settings is None and 'aribSourceSettings' in kwargs:
            arib_source_settings = kwargs['aribSourceSettings']
        if dvb_sub_source_settings is None and 'dvbSubSourceSettings' in kwargs:
            dvb_sub_source_settings = kwargs['dvbSubSourceSettings']
        if embedded_source_settings is None and 'embeddedSourceSettings' in kwargs:
            embedded_source_settings = kwargs['embeddedSourceSettings']
        if scte20_source_settings is None and 'scte20SourceSettings' in kwargs:
            scte20_source_settings = kwargs['scte20SourceSettings']
        if scte27_source_settings is None and 'scte27SourceSettings' in kwargs:
            scte27_source_settings = kwargs['scte27SourceSettings']
        if teletext_source_settings is None and 'teletextSourceSettings' in kwargs:
            teletext_source_settings = kwargs['teletextSourceSettings']

        if ancillary_source_settings is not None:
            _setter("ancillary_source_settings", ancillary_source_settings)
        if arib_source_settings is not None:
            _setter("arib_source_settings", arib_source_settings)
        if dvb_sub_source_settings is not None:
            _setter("dvb_sub_source_settings", dvb_sub_source_settings)
        if embedded_source_settings is not None:
            _setter("embedded_source_settings", embedded_source_settings)
        if scte20_source_settings is not None:
            _setter("scte20_source_settings", scte20_source_settings)
        if scte27_source_settings is not None:
            _setter("scte27_source_settings", scte27_source_settings)
        if teletext_source_settings is not None:
            _setter("teletext_source_settings", teletext_source_settings)

    @property
    @pulumi.getter(name="ancillarySourceSettings")
    def ancillary_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings']:
        """
        Ancillary Source Settings. See Ancillary Source Settings for more details.
        """
        return pulumi.get(self, "ancillary_source_settings")

    @property
    @pulumi.getter(name="aribSourceSettings")
    def arib_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings']:
        """
        ARIB Source Settings.
        """
        return pulumi.get(self, "arib_source_settings")

    @property
    @pulumi.getter(name="dvbSubSourceSettings")
    def dvb_sub_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings']:
        """
        DVB Sub Source Settings. See DVB Sub Source Settings for more details.
        """
        return pulumi.get(self, "dvb_sub_source_settings")

    @property
    @pulumi.getter(name="embeddedSourceSettings")
    def embedded_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings']:
        """
        Embedded Source Settings. See Embedded Source Settings for more details.
        """
        return pulumi.get(self, "embedded_source_settings")

    @property
    @pulumi.getter(name="scte20SourceSettings")
    def scte20_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings']:
        """
        SCTE20 Source Settings. See SCTE 20 Source Settings for more details.
        """
        return pulumi.get(self, "scte20_source_settings")

    @property
    @pulumi.getter(name="scte27SourceSettings")
    def scte27_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings']:
        """
        SCTE27 Source Settings. See SCTE 27 Source Settings for more details.
        """
        return pulumi.get(self, "scte27_source_settings")

    @property
    @pulumi.getter(name="teletextSourceSettings")
    def teletext_source_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings']:
        """
        Teletext Source Settings. See Teletext Source Settings for more details.
        """
        return pulumi.get(self, "teletext_source_settings")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAncillaryChannelNumber":
            suggest = "source_ancillary_channel_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_ancillary_channel_number: Optional[int] = None):
        """
        :param int source_ancillary_channel_number: Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_ancillary_channel_number=source_ancillary_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_ancillary_channel_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_ancillary_channel_number is None and 'sourceAncillaryChannelNumber' in kwargs:
            source_ancillary_channel_number = kwargs['sourceAncillaryChannelNumber']

        if source_ancillary_channel_number is not None:
            _setter("source_ancillary_channel_number", source_ancillary_channel_number)

    @property
    @pulumi.getter(name="sourceAncillaryChannelNumber")
    def source_ancillary_channel_number(self) -> Optional[int]:
        """
        Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
        """
        return pulumi.get(self, "source_ancillary_channel_number")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocrLanguage":
            suggest = "ocr_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocr_language: Optional[str] = None,
                 pid: Optional[int] = None):
        """
        :param str ocr_language: If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        :param int pid: When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[str] = None,
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ocr_language is None and 'ocrLanguage' in kwargs:
            ocr_language = kwargs['ocrLanguage']

        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[str]:
        """
        If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        """
        return pulumi.get(self, "ocr_language")

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        """
        When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        """
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "convert608To708":
            suggest = "convert608_to708"
        elif key == "scte20Detection":
            suggest = "scte20_detection"
        elif key == "source608ChannelNumber":
            suggest = "source608_channel_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convert608_to708: Optional[str] = None,
                 scte20_detection: Optional[str] = None,
                 source608_channel_number: Optional[int] = None):
        """
        :param str convert608_to708: If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        :param str scte20_detection: Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
        :param int source608_channel_number: Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            scte20_detection=scte20_detection,
            source608_channel_number=source608_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[str] = None,
             scte20_detection: Optional[str] = None,
             source608_channel_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if convert608_to708 is None and 'convert608To708' in kwargs:
            convert608_to708 = kwargs['convert608To708']
        if scte20_detection is None and 'scte20Detection' in kwargs:
            scte20_detection = kwargs['scte20Detection']
        if source608_channel_number is None and 'source608ChannelNumber' in kwargs:
            source608_channel_number = kwargs['source608ChannelNumber']

        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if scte20_detection is not None:
            _setter("scte20_detection", scte20_detection)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[str]:
        """
        If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        """
        return pulumi.get(self, "convert608_to708")

    @property
    @pulumi.getter(name="scte20Detection")
    def scte20_detection(self) -> Optional[str]:
        """
        Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
        """
        return pulumi.get(self, "scte20_detection")

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[int]:
        """
        Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        return pulumi.get(self, "source608_channel_number")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "convert608To708":
            suggest = "convert608_to708"
        elif key == "source608ChannelNumber":
            suggest = "source608_channel_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convert608_to708: Optional[str] = None,
                 source608_channel_number: Optional[int] = None):
        """
        :param str convert608_to708: If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        :param int source608_channel_number: Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            source608_channel_number=source608_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[str] = None,
             source608_channel_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if convert608_to708 is None and 'convert608To708' in kwargs:
            convert608_to708 = kwargs['convert608To708']
        if source608_channel_number is None and 'source608ChannelNumber' in kwargs:
            source608_channel_number = kwargs['source608ChannelNumber']

        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[str]:
        """
        If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
        """
        return pulumi.get(self, "convert608_to708")

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[int]:
        """
        Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        """
        return pulumi.get(self, "source608_channel_number")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocrLanguage":
            suggest = "ocr_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocr_language: Optional[str] = None,
                 pid: Optional[int] = None):
        """
        :param str ocr_language: If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        :param int pid: Selects a specific PID from within a source.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[str] = None,
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ocr_language is None and 'ocrLanguage' in kwargs:
            ocr_language = kwargs['ocrLanguage']

        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[str]:
        """
        If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
        """
        return pulumi.get(self, "ocr_language")

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        """
        Selects a specific PID from within a source.
        """
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputRectangle":
            suggest = "output_rectangle"
        elif key == "pageNumber":
            suggest = "page_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_rectangle: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle'] = None,
                 page_number: Optional[str] = None):
        """
        :param 'ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangleArgs' output_rectangle: Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
        :param str page_number: Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_rectangle=output_rectangle,
            page_number=page_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_rectangle: Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle'] = None,
             page_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_rectangle is None and 'outputRectangle' in kwargs:
            output_rectangle = kwargs['outputRectangle']
        if page_number is None and 'pageNumber' in kwargs:
            page_number = kwargs['pageNumber']

        if output_rectangle is not None:
            _setter("output_rectangle", output_rectangle)
        if page_number is not None:
            _setter("page_number", page_number)

    @property
    @pulumi.getter(name="outputRectangle")
    def output_rectangle(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle']:
        """
        Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
        """
        return pulumi.get(self, "output_rectangle")

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> Optional[str]:
        """
        Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix.
        """
        return pulumi.get(self, "page_number")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leftOffset":
            suggest = "left_offset"
        elif key == "topOffset":
            suggest = "top_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: float,
                 left_offset: float,
                 top_offset: float,
                 width: float):
        """
        :param float height: See the description in left\\_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, "80" means the rectangle height is 80% of the underlying frame height. The top\\_offset and rectangle\\_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard.
        :param float left_offset: Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you don’t have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, "10" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard.
        :param float top_offset: See the description in left\\_offset. For top\\_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, "10" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard.
        :param float width: See the description in left\\_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, "80" means the rectangle width is 80% of the underlying frame width. The left\\_offset and rectangle\\_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard.
        """
        ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            left_offset=left_offset,
            top_offset=top_offset,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[float] = None,
             left_offset: Optional[float] = None,
             top_offset: Optional[float] = None,
             width: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if height is None:
            raise TypeError("Missing 'height' argument")
        if left_offset is None and 'leftOffset' in kwargs:
            left_offset = kwargs['leftOffset']
        if left_offset is None:
            raise TypeError("Missing 'left_offset' argument")
        if top_offset is None and 'topOffset' in kwargs:
            top_offset = kwargs['topOffset']
        if top_offset is None:
            raise TypeError("Missing 'top_offset' argument")
        if width is None:
            raise TypeError("Missing 'width' argument")

        _setter("height", height)
        _setter("left_offset", left_offset)
        _setter("top_offset", top_offset)
        _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> float:
        """
        See the description in left\\_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, "80" means the rectangle height is 80% of the underlying frame height. The top\\_offset and rectangle\\_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="leftOffset")
    def left_offset(self) -> float:
        """
        Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you don’t have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, "10" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard.
        """
        return pulumi.get(self, "left_offset")

    @property
    @pulumi.getter(name="topOffset")
    def top_offset(self) -> float:
        """
        See the description in left\\_offset. For top\\_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, "10" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard.
        """
        return pulumi.get(self, "top_offset")

    @property
    @pulumi.getter
    def width(self) -> float:
        """
        See the description in left\\_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, "80" means the rectangle width is 80% of the underlying frame width. The left\\_offset and rectangle\\_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsNetworkInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsInputSettings":
            suggest = "hls_input_settings"
        elif key == "serverValidation":
            suggest = "server_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsNetworkInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsNetworkInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsNetworkInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_input_settings: Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings'] = None,
                 server_validation: Optional[str] = None):
        """
        :param 'ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettingsArgs' hls_input_settings: Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
        :param str server_validation: Check HTTPS server certificates.
        """
        ChannelInputAttachmentInputSettingsNetworkInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_input_settings=hls_input_settings,
            server_validation=server_validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_input_settings: Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings'] = None,
             server_validation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hls_input_settings is None and 'hlsInputSettings' in kwargs:
            hls_input_settings = kwargs['hlsInputSettings']
        if server_validation is None and 'serverValidation' in kwargs:
            server_validation = kwargs['serverValidation']

        if hls_input_settings is not None:
            _setter("hls_input_settings", hls_input_settings)
        if server_validation is not None:
            _setter("server_validation", server_validation)

    @property
    @pulumi.getter(name="hlsInputSettings")
    def hls_input_settings(self) -> Optional['outputs.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings']:
        """
        Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
        """
        return pulumi.get(self, "hls_input_settings")

    @property
    @pulumi.getter(name="serverValidation")
    def server_validation(self) -> Optional[str]:
        """
        Check HTTPS server certificates.
        """
        return pulumi.get(self, "server_validation")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferSegments":
            suggest = "buffer_segments"
        elif key == "retryInterval":
            suggest = "retry_interval"
        elif key == "scte35Source":
            suggest = "scte35_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional[int] = None,
                 buffer_segments: Optional[int] = None,
                 retries: Optional[int] = None,
                 retry_interval: Optional[int] = None,
                 scte35_source: Optional[str] = None):
        """
        :param int bandwidth: The bitrate is specified in bits per second, as in an HLS manifest.
        :param int buffer_segments: Buffer segments.
        :param int retries: The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
        :param int retry_interval: The number of seconds between retries when an attempt to read a manifest or segment fails.
        """
        ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bandwidth=bandwidth,
            buffer_segments=buffer_segments,
            retries=retries,
            retry_interval=retry_interval,
            scte35_source=scte35_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bandwidth: Optional[int] = None,
             buffer_segments: Optional[int] = None,
             retries: Optional[int] = None,
             retry_interval: Optional[int] = None,
             scte35_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if buffer_segments is None and 'bufferSegments' in kwargs:
            buffer_segments = kwargs['bufferSegments']
        if retry_interval is None and 'retryInterval' in kwargs:
            retry_interval = kwargs['retryInterval']
        if scte35_source is None and 'scte35Source' in kwargs:
            scte35_source = kwargs['scte35Source']

        if bandwidth is not None:
            _setter("bandwidth", bandwidth)
        if buffer_segments is not None:
            _setter("buffer_segments", buffer_segments)
        if retries is not None:
            _setter("retries", retries)
        if retry_interval is not None:
            _setter("retry_interval", retry_interval)
        if scte35_source is not None:
            _setter("scte35_source", scte35_source)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[int]:
        """
        The bitrate is specified in bits per second, as in an HLS manifest.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="bufferSegments")
    def buffer_segments(self) -> Optional[int]:
        """
        Buffer segments.
        """
        return pulumi.get(self, "buffer_segments")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[int]:
        """
        The number of seconds between retries when an attempt to read a manifest or segment fails.
        """
        return pulumi.get(self, "retry_interval")

    @property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> Optional[str]:
        return pulumi.get(self, "scte35_source")


@pulumi.output_type
class ChannelInputAttachmentInputSettingsVideoSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSpace":
            suggest = "color_space"
        elif key == "colorSpaceUsage":
            suggest = "color_space_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachmentInputSettingsVideoSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachmentInputSettingsVideoSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachmentInputSettingsVideoSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_space: Optional[str] = None,
                 color_space_usage: Optional[str] = None):
        ChannelInputAttachmentInputSettingsVideoSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space=color_space,
            color_space_usage=color_space_usage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space: Optional[str] = None,
             color_space_usage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if color_space is None and 'colorSpace' in kwargs:
            color_space = kwargs['colorSpace']
        if color_space_usage is None and 'colorSpaceUsage' in kwargs:
            color_space_usage = kwargs['colorSpaceUsage']

        if color_space is not None:
            _setter("color_space", color_space)
        if color_space_usage is not None:
            _setter("color_space_usage", color_space_usage)

    @property
    @pulumi.getter(name="colorSpace")
    def color_space(self) -> Optional[str]:
        return pulumi.get(self, "color_space")

    @property
    @pulumi.getter(name="colorSpaceUsage")
    def color_space_usage(self) -> Optional[str]:
        return pulumi.get(self, "color_space_usage")


@pulumi.output_type
class ChannelInputSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputResolution":
            suggest = "input_resolution"
        elif key == "maximumBitrate":
            suggest = "maximum_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: str,
                 input_resolution: str,
                 maximum_bitrate: str):
        ChannelInputSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            codec=codec,
            input_resolution=input_resolution,
            maximum_bitrate=maximum_bitrate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             codec: Optional[str] = None,
             input_resolution: Optional[str] = None,
             maximum_bitrate: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if codec is None:
            raise TypeError("Missing 'codec' argument")
        if input_resolution is None and 'inputResolution' in kwargs:
            input_resolution = kwargs['inputResolution']
        if input_resolution is None:
            raise TypeError("Missing 'input_resolution' argument")
        if maximum_bitrate is None and 'maximumBitrate' in kwargs:
            maximum_bitrate = kwargs['maximumBitrate']
        if maximum_bitrate is None:
            raise TypeError("Missing 'maximum_bitrate' argument")

        _setter("codec", codec)
        _setter("input_resolution", input_resolution)
        _setter("maximum_bitrate", maximum_bitrate)

    @property
    @pulumi.getter
    def codec(self) -> str:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="inputResolution")
    def input_resolution(self) -> str:
        return pulumi.get(self, "input_resolution")

    @property
    @pulumi.getter(name="maximumBitrate")
    def maximum_bitrate(self) -> str:
        return pulumi.get(self, "maximum_bitrate")


@pulumi.output_type
class ChannelMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceDay":
            suggest = "maintenance_day"
        elif key == "maintenanceStartTime":
            suggest = "maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_day: str,
                 maintenance_start_time: str):
        """
        :param str maintenance_day: The day of the week to use for maintenance.
        :param str maintenance_start_time: The hour maintenance will start.
        """
        ChannelMaintenance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maintenance_day=maintenance_day,
            maintenance_start_time=maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maintenance_day: Optional[str] = None,
             maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maintenance_day is None and 'maintenanceDay' in kwargs:
            maintenance_day = kwargs['maintenanceDay']
        if maintenance_day is None:
            raise TypeError("Missing 'maintenance_day' argument")
        if maintenance_start_time is None and 'maintenanceStartTime' in kwargs:
            maintenance_start_time = kwargs['maintenanceStartTime']
        if maintenance_start_time is None:
            raise TypeError("Missing 'maintenance_start_time' argument")

        _setter("maintenance_day", maintenance_day)
        _setter("maintenance_start_time", maintenance_start_time)

    @property
    @pulumi.getter(name="maintenanceDay")
    def maintenance_day(self) -> str:
        """
        The day of the week to use for maintenance.
        """
        return pulumi.get(self, "maintenance_day")

    @property
    @pulumi.getter(name="maintenanceStartTime")
    def maintenance_start_time(self) -> str:
        """
        The hour maintenance will start.
        """
        return pulumi.get(self, "maintenance_start_time")


@pulumi.output_type
class ChannelVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicAddressAllocationIds":
            suggest = "public_address_allocation_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "networkInterfaceIds":
            suggest = "network_interface_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_address_allocation_ids: Sequence[str],
                 subnet_ids: Sequence[str],
                 availability_zones: Optional[Sequence[str]] = None,
                 network_interface_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] public_address_allocation_ids: List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
        :param Sequence[str] subnet_ids: A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
        :param Sequence[str] security_group_ids: A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
        """
        ChannelVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_address_allocation_ids=public_address_allocation_ids,
            subnet_ids=subnet_ids,
            availability_zones=availability_zones,
            network_interface_ids=network_interface_ids,
            security_group_ids=security_group_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_address_allocation_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             availability_zones: Optional[Sequence[str]] = None,
             network_interface_ids: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_address_allocation_ids is None and 'publicAddressAllocationIds' in kwargs:
            public_address_allocation_ids = kwargs['publicAddressAllocationIds']
        if public_address_allocation_ids is None:
            raise TypeError("Missing 'public_address_allocation_ids' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if network_interface_ids is None and 'networkInterfaceIds' in kwargs:
            network_interface_ids = kwargs['networkInterfaceIds']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']

        _setter("public_address_allocation_ids", public_address_allocation_ids)
        _setter("subnet_ids", subnet_ids)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if network_interface_ids is not None:
            _setter("network_interface_ids", network_interface_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="publicAddressAllocationIds")
    def public_address_allocation_ids(self) -> Sequence[str]:
        """
        List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
        """
        return pulumi.get(self, "public_address_allocation_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="networkInterfaceIds")
    def network_interface_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "network_interface_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class InputDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stream_name: str):
        """
        :param str stream_name: A unique name for the location the RTMP stream is being pushed to.
        """
        InputDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")

        _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        A unique name for the location the RTMP stream is being pushed to.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class InputInputDevice(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The unique ID for the device.
        """
        InputInputDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID for the device.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class InputMediaConnectFlow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowArn":
            suggest = "flow_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputMediaConnectFlow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputMediaConnectFlow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputMediaConnectFlow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_arn: str):
        """
        :param str flow_arn: The ARN of the MediaConnect Flow
        """
        InputMediaConnectFlow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flow_arn=flow_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flow_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if flow_arn is None and 'flowArn' in kwargs:
            flow_arn = kwargs['flowArn']
        if flow_arn is None:
            raise TypeError("Missing 'flow_arn' argument")

        _setter("flow_arn", flow_arn)

    @property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> str:
        """
        The ARN of the MediaConnect Flow
        """
        return pulumi.get(self, "flow_arn")


@pulumi.output_type
class InputSecurityGroupWhitelistRule(dict):
    def __init__(__self__, *,
                 cidr: str):
        """
        :param str cidr: The IPv4 CIDR that's whitelisted.
        """
        InputSecurityGroupWhitelistRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")

        _setter("cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The IPv4 CIDR that's whitelisted.
        """
        return pulumi.get(self, "cidr")


@pulumi.output_type
class InputSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_param: str,
                 url: str,
                 username: str):
        """
        :param str password_param: The key used to extract the password from EC2 Parameter store.
        :param str url: The URL where the stream is pulled from.
        :param str username: The username for the input source.
        """
        InputSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_param is None and 'passwordParam' in kwargs:
            password_param = kwargs['passwordParam']
        if password_param is None:
            raise TypeError("Missing 'password_param' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password_param", password_param)
        _setter("url", url)
        _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> str:
        """
        The key used to extract the password from EC2 Parameter store.
        """
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL where the stream is pulled from.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username for the input source.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InputVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 security_group_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] subnet_ids: A list of 2 VPC subnet IDs from the same VPC.
        :param Sequence[str] security_group_ids: A list of up to 5 EC2 VPC security group IDs to attach to the Input.
        """
        InputVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            security_group_ids=security_group_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']

        _setter("subnet_ids", subnet_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        A list of 2 VPC subnet IDs from the same VPC.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of up to 5 EC2 VPC security group IDs to attach to the Input.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class MultiplexMultiplexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transportStreamBitrate":
            suggest = "transport_stream_bitrate"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "maximumVideoBufferDelayMilliseconds":
            suggest = "maximum_video_buffer_delay_milliseconds"
        elif key == "transportStreamReservedBitrate":
            suggest = "transport_stream_reserved_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiplexMultiplexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiplexMultiplexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiplexMultiplexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transport_stream_bitrate: int,
                 transport_stream_id: int,
                 maximum_video_buffer_delay_milliseconds: Optional[int] = None,
                 transport_stream_reserved_bitrate: Optional[int] = None):
        """
        :param int transport_stream_bitrate: Transport stream bit rate.
        :param int transport_stream_id: Unique ID for each multiplex.
        :param int maximum_video_buffer_delay_milliseconds: Maximum video buffer delay.
        :param int transport_stream_reserved_bitrate: Transport stream reserved bit rate.
        """
        MultiplexMultiplexSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            transport_stream_bitrate=transport_stream_bitrate,
            transport_stream_id=transport_stream_id,
            maximum_video_buffer_delay_milliseconds=maximum_video_buffer_delay_milliseconds,
            transport_stream_reserved_bitrate=transport_stream_reserved_bitrate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             transport_stream_bitrate: Optional[int] = None,
             transport_stream_id: Optional[int] = None,
             maximum_video_buffer_delay_milliseconds: Optional[int] = None,
             transport_stream_reserved_bitrate: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if transport_stream_bitrate is None and 'transportStreamBitrate' in kwargs:
            transport_stream_bitrate = kwargs['transportStreamBitrate']
        if transport_stream_bitrate is None:
            raise TypeError("Missing 'transport_stream_bitrate' argument")
        if transport_stream_id is None and 'transportStreamId' in kwargs:
            transport_stream_id = kwargs['transportStreamId']
        if transport_stream_id is None:
            raise TypeError("Missing 'transport_stream_id' argument")
        if maximum_video_buffer_delay_milliseconds is None and 'maximumVideoBufferDelayMilliseconds' in kwargs:
            maximum_video_buffer_delay_milliseconds = kwargs['maximumVideoBufferDelayMilliseconds']
        if transport_stream_reserved_bitrate is None and 'transportStreamReservedBitrate' in kwargs:
            transport_stream_reserved_bitrate = kwargs['transportStreamReservedBitrate']

        _setter("transport_stream_bitrate", transport_stream_bitrate)
        _setter("transport_stream_id", transport_stream_id)
        if maximum_video_buffer_delay_milliseconds is not None:
            _setter("maximum_video_buffer_delay_milliseconds", maximum_video_buffer_delay_milliseconds)
        if transport_stream_reserved_bitrate is not None:
            _setter("transport_stream_reserved_bitrate", transport_stream_reserved_bitrate)

    @property
    @pulumi.getter(name="transportStreamBitrate")
    def transport_stream_bitrate(self) -> int:
        """
        Transport stream bit rate.
        """
        return pulumi.get(self, "transport_stream_bitrate")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> int:
        """
        Unique ID for each multiplex.
        """
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="maximumVideoBufferDelayMilliseconds")
    def maximum_video_buffer_delay_milliseconds(self) -> Optional[int]:
        """
        Maximum video buffer delay.
        """
        return pulumi.get(self, "maximum_video_buffer_delay_milliseconds")

    @property
    @pulumi.getter(name="transportStreamReservedBitrate")
    def transport_stream_reserved_bitrate(self) -> Optional[int]:
        """
        Transport stream reserved bit rate.
        """
        return pulumi.get(self, "transport_stream_reserved_bitrate")


@pulumi.output_type
class MultiplexProgramMultiplexProgramSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredChannelPipeline":
            suggest = "preferred_channel_pipeline"
        elif key == "programNumber":
            suggest = "program_number"
        elif key == "serviceDescriptor":
            suggest = "service_descriptor"
        elif key == "videoSettings":
            suggest = "video_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiplexProgramMultiplexProgramSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiplexProgramMultiplexProgramSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiplexProgramMultiplexProgramSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_channel_pipeline: str,
                 program_number: int,
                 service_descriptor: Optional['outputs.MultiplexProgramMultiplexProgramSettingsServiceDescriptor'] = None,
                 video_settings: Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettings'] = None):
        """
        :param str preferred_channel_pipeline: Enum for preferred channel pipeline. Options are `CURRENTLY_ACTIVE`, `PIPELINE_0`, or `PIPELINE_1`.
        :param int program_number: Unique program number.
        :param 'MultiplexProgramMultiplexProgramSettingsServiceDescriptorArgs' service_descriptor: Service Descriptor. See Service Descriptor for more details.
        :param 'MultiplexProgramMultiplexProgramSettingsVideoSettingsArgs' video_settings: Video settings. See Video Settings for more details.
        """
        MultiplexProgramMultiplexProgramSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preferred_channel_pipeline=preferred_channel_pipeline,
            program_number=program_number,
            service_descriptor=service_descriptor,
            video_settings=video_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preferred_channel_pipeline: Optional[str] = None,
             program_number: Optional[int] = None,
             service_descriptor: Optional['outputs.MultiplexProgramMultiplexProgramSettingsServiceDescriptor'] = None,
             video_settings: Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if preferred_channel_pipeline is None and 'preferredChannelPipeline' in kwargs:
            preferred_channel_pipeline = kwargs['preferredChannelPipeline']
        if preferred_channel_pipeline is None:
            raise TypeError("Missing 'preferred_channel_pipeline' argument")
        if program_number is None and 'programNumber' in kwargs:
            program_number = kwargs['programNumber']
        if program_number is None:
            raise TypeError("Missing 'program_number' argument")
        if service_descriptor is None and 'serviceDescriptor' in kwargs:
            service_descriptor = kwargs['serviceDescriptor']
        if video_settings is None and 'videoSettings' in kwargs:
            video_settings = kwargs['videoSettings']

        _setter("preferred_channel_pipeline", preferred_channel_pipeline)
        _setter("program_number", program_number)
        if service_descriptor is not None:
            _setter("service_descriptor", service_descriptor)
        if video_settings is not None:
            _setter("video_settings", video_settings)

    @property
    @pulumi.getter(name="preferredChannelPipeline")
    def preferred_channel_pipeline(self) -> str:
        """
        Enum for preferred channel pipeline. Options are `CURRENTLY_ACTIVE`, `PIPELINE_0`, or `PIPELINE_1`.
        """
        return pulumi.get(self, "preferred_channel_pipeline")

    @property
    @pulumi.getter(name="programNumber")
    def program_number(self) -> int:
        """
        Unique program number.
        """
        return pulumi.get(self, "program_number")

    @property
    @pulumi.getter(name="serviceDescriptor")
    def service_descriptor(self) -> Optional['outputs.MultiplexProgramMultiplexProgramSettingsServiceDescriptor']:
        """
        Service Descriptor. See Service Descriptor for more details.
        """
        return pulumi.get(self, "service_descriptor")

    @property
    @pulumi.getter(name="videoSettings")
    def video_settings(self) -> Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettings']:
        """
        Video settings. See Video Settings for more details.
        """
        return pulumi.get(self, "video_settings")


@pulumi.output_type
class MultiplexProgramMultiplexProgramSettingsServiceDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerName":
            suggest = "provider_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiplexProgramMultiplexProgramSettingsServiceDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiplexProgramMultiplexProgramSettingsServiceDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiplexProgramMultiplexProgramSettingsServiceDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_name: str,
                 service_name: str):
        """
        :param str provider_name: Unique provider name.
        :param str service_name: Unique service name.
        """
        MultiplexProgramMultiplexProgramSettingsServiceDescriptor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provider_name=provider_name,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provider_name: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provider_name is None and 'providerName' in kwargs:
            provider_name = kwargs['providerName']
        if provider_name is None:
            raise TypeError("Missing 'provider_name' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("provider_name", provider_name)
        _setter("service_name", service_name)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Unique provider name.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Unique service name.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class MultiplexProgramMultiplexProgramSettingsVideoSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "constantBitrate":
            suggest = "constant_bitrate"
        elif key == "statmuxSettings":
            suggest = "statmux_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiplexProgramMultiplexProgramSettingsVideoSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiplexProgramMultiplexProgramSettingsVideoSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiplexProgramMultiplexProgramSettingsVideoSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constant_bitrate: Optional[int] = None,
                 statmux_settings: Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings'] = None):
        """
        :param int constant_bitrate: Constant bitrate value.
        :param 'MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettingsArgs' statmux_settings: Statmux settings. See Statmux Settings for more details.
        """
        MultiplexProgramMultiplexProgramSettingsVideoSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant_bitrate=constant_bitrate,
            statmux_settings=statmux_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant_bitrate: Optional[int] = None,
             statmux_settings: Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if constant_bitrate is None and 'constantBitrate' in kwargs:
            constant_bitrate = kwargs['constantBitrate']
        if statmux_settings is None and 'statmuxSettings' in kwargs:
            statmux_settings = kwargs['statmuxSettings']

        if constant_bitrate is not None:
            _setter("constant_bitrate", constant_bitrate)
        if statmux_settings is not None:
            _setter("statmux_settings", statmux_settings)

    @property
    @pulumi.getter(name="constantBitrate")
    def constant_bitrate(self) -> Optional[int]:
        """
        Constant bitrate value.
        """
        return pulumi.get(self, "constant_bitrate")

    @property
    @pulumi.getter(name="statmuxSettings")
    def statmux_settings(self) -> Optional['outputs.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings']:
        """
        Statmux settings. See Statmux Settings for more details.
        """
        return pulumi.get(self, "statmux_settings")


@pulumi.output_type
class MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumBitrate":
            suggest = "maximum_bitrate"
        elif key == "minimumBitrate":
            suggest = "minimum_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_bitrate: Optional[int] = None,
                 minimum_bitrate: Optional[int] = None,
                 priority: Optional[int] = None):
        """
        :param int maximum_bitrate: Maximum bitrate.
        :param int minimum_bitrate: Minimum bitrate.
        :param int priority: Priority value.
        """
        MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_bitrate=maximum_bitrate,
            minimum_bitrate=minimum_bitrate,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_bitrate: Optional[int] = None,
             minimum_bitrate: Optional[int] = None,
             priority: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_bitrate is None and 'maximumBitrate' in kwargs:
            maximum_bitrate = kwargs['maximumBitrate']
        if minimum_bitrate is None and 'minimumBitrate' in kwargs:
            minimum_bitrate = kwargs['minimumBitrate']

        if maximum_bitrate is not None:
            _setter("maximum_bitrate", maximum_bitrate)
        if minimum_bitrate is not None:
            _setter("minimum_bitrate", minimum_bitrate)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="maximumBitrate")
    def maximum_bitrate(self) -> Optional[int]:
        """
        Maximum bitrate.
        """
        return pulumi.get(self, "maximum_bitrate")

    @property
    @pulumi.getter(name="minimumBitrate")
    def minimum_bitrate(self) -> Optional[int]:
        """
        Minimum bitrate.
        """
        return pulumi.get(self, "minimum_bitrate")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority value.
        """
        return pulumi.get(self, "priority")


