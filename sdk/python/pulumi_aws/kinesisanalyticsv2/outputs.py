# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationApplicationConfiguration',
    'ApplicationApplicationConfigurationApplicationCodeConfiguration',
    'ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent',
    'ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation',
    'ApplicationApplicationConfigurationApplicationSnapshotConfiguration',
    'ApplicationApplicationConfigurationEnvironmentProperties',
    'ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup',
    'ApplicationApplicationConfigurationFlinkApplicationConfiguration',
    'ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration',
    'ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration',
    'ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration',
    'ApplicationApplicationConfigurationRunConfiguration',
    'ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration',
    'ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration',
    'ApplicationApplicationConfigurationSqlApplicationConfiguration',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationOutput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters',
    'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource',
    'ApplicationApplicationConfigurationVpcConfiguration',
    'ApplicationCloudwatchLoggingOptions',
]

@pulumi.output_type
class ApplicationApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationCodeConfiguration":
            suggest = "application_code_configuration"
        elif key == "applicationSnapshotConfiguration":
            suggest = "application_snapshot_configuration"
        elif key == "environmentProperties":
            suggest = "environment_properties"
        elif key == "flinkApplicationConfiguration":
            suggest = "flink_application_configuration"
        elif key == "runConfiguration":
            suggest = "run_configuration"
        elif key == "sqlApplicationConfiguration":
            suggest = "sql_application_configuration"
        elif key == "vpcConfiguration":
            suggest = "vpc_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_code_configuration: 'outputs.ApplicationApplicationConfigurationApplicationCodeConfiguration',
                 application_snapshot_configuration: Optional['outputs.ApplicationApplicationConfigurationApplicationSnapshotConfiguration'] = None,
                 environment_properties: Optional['outputs.ApplicationApplicationConfigurationEnvironmentProperties'] = None,
                 flink_application_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfiguration'] = None,
                 run_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfiguration'] = None,
                 sql_application_configuration: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfiguration'] = None,
                 vpc_configuration: Optional['outputs.ApplicationApplicationConfigurationVpcConfiguration'] = None):
        """
        :param 'ApplicationApplicationConfigurationApplicationCodeConfigurationArgs' application_code_configuration: The code location and type parameters for the application.
        :param 'ApplicationApplicationConfigurationApplicationSnapshotConfigurationArgs' application_snapshot_configuration: Describes whether snapshots are enabled for a Flink-based application.
        :param 'ApplicationApplicationConfigurationEnvironmentPropertiesArgs' environment_properties: Describes execution properties for a Flink-based application.
        :param 'ApplicationApplicationConfigurationFlinkApplicationConfigurationArgs' flink_application_configuration: The configuration of a Flink-based application.
        :param 'ApplicationApplicationConfigurationRunConfigurationArgs' run_configuration: Describes the starting properties for a Flink-based application.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationArgs' sql_application_configuration: The configuration of a SQL-based application.
        :param 'ApplicationApplicationConfigurationVpcConfigurationArgs' vpc_configuration: The VPC configuration of a Flink-based application.
        """
        ApplicationApplicationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_code_configuration=application_code_configuration,
            application_snapshot_configuration=application_snapshot_configuration,
            environment_properties=environment_properties,
            flink_application_configuration=flink_application_configuration,
            run_configuration=run_configuration,
            sql_application_configuration=sql_application_configuration,
            vpc_configuration=vpc_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_code_configuration: Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfiguration'] = None,
             application_snapshot_configuration: Optional['outputs.ApplicationApplicationConfigurationApplicationSnapshotConfiguration'] = None,
             environment_properties: Optional['outputs.ApplicationApplicationConfigurationEnvironmentProperties'] = None,
             flink_application_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfiguration'] = None,
             run_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfiguration'] = None,
             sql_application_configuration: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfiguration'] = None,
             vpc_configuration: Optional['outputs.ApplicationApplicationConfigurationVpcConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_code_configuration is None and 'applicationCodeConfiguration' in kwargs:
            application_code_configuration = kwargs['applicationCodeConfiguration']
        if application_code_configuration is None:
            raise TypeError("Missing 'application_code_configuration' argument")
        if application_snapshot_configuration is None and 'applicationSnapshotConfiguration' in kwargs:
            application_snapshot_configuration = kwargs['applicationSnapshotConfiguration']
        if environment_properties is None and 'environmentProperties' in kwargs:
            environment_properties = kwargs['environmentProperties']
        if flink_application_configuration is None and 'flinkApplicationConfiguration' in kwargs:
            flink_application_configuration = kwargs['flinkApplicationConfiguration']
        if run_configuration is None and 'runConfiguration' in kwargs:
            run_configuration = kwargs['runConfiguration']
        if sql_application_configuration is None and 'sqlApplicationConfiguration' in kwargs:
            sql_application_configuration = kwargs['sqlApplicationConfiguration']
        if vpc_configuration is None and 'vpcConfiguration' in kwargs:
            vpc_configuration = kwargs['vpcConfiguration']

        _setter("application_code_configuration", application_code_configuration)
        if application_snapshot_configuration is not None:
            _setter("application_snapshot_configuration", application_snapshot_configuration)
        if environment_properties is not None:
            _setter("environment_properties", environment_properties)
        if flink_application_configuration is not None:
            _setter("flink_application_configuration", flink_application_configuration)
        if run_configuration is not None:
            _setter("run_configuration", run_configuration)
        if sql_application_configuration is not None:
            _setter("sql_application_configuration", sql_application_configuration)
        if vpc_configuration is not None:
            _setter("vpc_configuration", vpc_configuration)

    @property
    @pulumi.getter(name="applicationCodeConfiguration")
    def application_code_configuration(self) -> 'outputs.ApplicationApplicationConfigurationApplicationCodeConfiguration':
        """
        The code location and type parameters for the application.
        """
        return pulumi.get(self, "application_code_configuration")

    @property
    @pulumi.getter(name="applicationSnapshotConfiguration")
    def application_snapshot_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationApplicationSnapshotConfiguration']:
        """
        Describes whether snapshots are enabled for a Flink-based application.
        """
        return pulumi.get(self, "application_snapshot_configuration")

    @property
    @pulumi.getter(name="environmentProperties")
    def environment_properties(self) -> Optional['outputs.ApplicationApplicationConfigurationEnvironmentProperties']:
        """
        Describes execution properties for a Flink-based application.
        """
        return pulumi.get(self, "environment_properties")

    @property
    @pulumi.getter(name="flinkApplicationConfiguration")
    def flink_application_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfiguration']:
        """
        The configuration of a Flink-based application.
        """
        return pulumi.get(self, "flink_application_configuration")

    @property
    @pulumi.getter(name="runConfiguration")
    def run_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationRunConfiguration']:
        """
        Describes the starting properties for a Flink-based application.
        """
        return pulumi.get(self, "run_configuration")

    @property
    @pulumi.getter(name="sqlApplicationConfiguration")
    def sql_application_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfiguration']:
        """
        The configuration of a SQL-based application.
        """
        return pulumi.get(self, "sql_application_configuration")

    @property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationVpcConfiguration']:
        """
        The VPC configuration of a Flink-based application.
        """
        return pulumi.get(self, "vpc_configuration")


@pulumi.output_type
class ApplicationApplicationConfigurationApplicationCodeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeContentType":
            suggest = "code_content_type"
        elif key == "codeContent":
            suggest = "code_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationApplicationCodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_content_type: str,
                 code_content: Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent'] = None):
        """
        :param str code_content_type: Specifies whether the code content is in text or zip format. Valid values: `PLAINTEXT`, `ZIPFILE`.
        :param 'ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentArgs' code_content: The location and type of the application code.
        """
        ApplicationApplicationConfigurationApplicationCodeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code_content_type=code_content_type,
            code_content=code_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code_content_type: Optional[str] = None,
             code_content: Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code_content_type is None and 'codeContentType' in kwargs:
            code_content_type = kwargs['codeContentType']
        if code_content_type is None:
            raise TypeError("Missing 'code_content_type' argument")
        if code_content is None and 'codeContent' in kwargs:
            code_content = kwargs['codeContent']

        _setter("code_content_type", code_content_type)
        if code_content is not None:
            _setter("code_content", code_content)

    @property
    @pulumi.getter(name="codeContentType")
    def code_content_type(self) -> str:
        """
        Specifies whether the code content is in text or zip format. Valid values: `PLAINTEXT`, `ZIPFILE`.
        """
        return pulumi.get(self, "code_content_type")

    @property
    @pulumi.getter(name="codeContent")
    def code_content(self) -> Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent']:
        """
        The location and type of the application code.
        """
        return pulumi.get(self, "code_content")


@pulumi.output_type
class ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3ContentLocation":
            suggest = "s3_content_location"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_content_location: Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation'] = None,
                 text_content: Optional[str] = None):
        """
        :param 'ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationArgs' s3_content_location: Information about the Amazon S3 bucket containing the application code.
        :param str text_content: The text-format code for the application.
               
               The `s3_content_location` object supports the following:
        """
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_content_location=s3_content_location,
            text_content=text_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_content_location: Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation'] = None,
             text_content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3_content_location is None and 's3ContentLocation' in kwargs:
            s3_content_location = kwargs['s3ContentLocation']
        if text_content is None and 'textContent' in kwargs:
            text_content = kwargs['textContent']

        if s3_content_location is not None:
            _setter("s3_content_location", s3_content_location)
        if text_content is not None:
            _setter("text_content", text_content)

    @property
    @pulumi.getter(name="s3ContentLocation")
    def s3_content_location(self) -> Optional['outputs.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation']:
        """
        Information about the Amazon S3 bucket containing the application code.
        """
        return pulumi.get(self, "s3_content_location")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        The text-format code for the application.

        The `s3_content_location` object supports the following:
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "fileKey":
            suggest = "file_key"
        elif key == "objectVersion":
            suggest = "object_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: str,
                 file_key: str,
                 object_version: Optional[str] = None):
        """
        :param str bucket_arn: The ARN for the S3 bucket containing the application code.
        :param str file_key: The file key for the object containing the application code.
        :param str object_version: The version of the object containing the application code.
        """
        ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_arn=bucket_arn,
            file_key=file_key,
            object_version=object_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_arn: Optional[str] = None,
             file_key: Optional[str] = None,
             object_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_arn is None and 'bucketArn' in kwargs:
            bucket_arn = kwargs['bucketArn']
        if bucket_arn is None:
            raise TypeError("Missing 'bucket_arn' argument")
        if file_key is None and 'fileKey' in kwargs:
            file_key = kwargs['fileKey']
        if file_key is None:
            raise TypeError("Missing 'file_key' argument")
        if object_version is None and 'objectVersion' in kwargs:
            object_version = kwargs['objectVersion']

        _setter("bucket_arn", bucket_arn)
        _setter("file_key", file_key)
        if object_version is not None:
            _setter("object_version", object_version)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> str:
        """
        The ARN for the S3 bucket containing the application code.
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="fileKey")
    def file_key(self) -> str:
        """
        The file key for the object containing the application code.
        """
        return pulumi.get(self, "file_key")

    @property
    @pulumi.getter(name="objectVersion")
    def object_version(self) -> Optional[str]:
        """
        The version of the object containing the application code.
        """
        return pulumi.get(self, "object_version")


@pulumi.output_type
class ApplicationApplicationConfigurationApplicationSnapshotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsEnabled":
            suggest = "snapshots_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationApplicationSnapshotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationApplicationSnapshotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationApplicationSnapshotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshots_enabled: bool):
        """
        :param bool snapshots_enabled: Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        """
        ApplicationApplicationConfigurationApplicationSnapshotConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            snapshots_enabled=snapshots_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             snapshots_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshots_enabled is None and 'snapshotsEnabled' in kwargs:
            snapshots_enabled = kwargs['snapshotsEnabled']
        if snapshots_enabled is None:
            raise TypeError("Missing 'snapshots_enabled' argument")

        _setter("snapshots_enabled", snapshots_enabled)

    @property
    @pulumi.getter(name="snapshotsEnabled")
    def snapshots_enabled(self) -> bool:
        """
        Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        """
        return pulumi.get(self, "snapshots_enabled")


@pulumi.output_type
class ApplicationApplicationConfigurationEnvironmentProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyGroups":
            suggest = "property_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationEnvironmentProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationEnvironmentProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationEnvironmentProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_groups: Sequence['outputs.ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup']):
        """
        :param Sequence['ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroupArgs'] property_groups: Describes the execution property groups.
        """
        ApplicationApplicationConfigurationEnvironmentProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            property_groups=property_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             property_groups: Optional[Sequence['outputs.ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if property_groups is None and 'propertyGroups' in kwargs:
            property_groups = kwargs['propertyGroups']
        if property_groups is None:
            raise TypeError("Missing 'property_groups' argument")

        _setter("property_groups", property_groups)

    @property
    @pulumi.getter(name="propertyGroups")
    def property_groups(self) -> Sequence['outputs.ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup']:
        """
        Describes the execution property groups.
        """
        return pulumi.get(self, "property_groups")


@pulumi.output_type
class ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyGroupId":
            suggest = "property_group_id"
        elif key == "propertyMap":
            suggest = "property_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_group_id: str,
                 property_map: Mapping[str, str]):
        """
        :param str property_group_id: The key of the application execution property key-value map.
        :param Mapping[str, str] property_map: Application execution property key-value map.
        """
        ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            property_group_id=property_group_id,
            property_map=property_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             property_group_id: Optional[str] = None,
             property_map: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if property_group_id is None and 'propertyGroupId' in kwargs:
            property_group_id = kwargs['propertyGroupId']
        if property_group_id is None:
            raise TypeError("Missing 'property_group_id' argument")
        if property_map is None and 'propertyMap' in kwargs:
            property_map = kwargs['propertyMap']
        if property_map is None:
            raise TypeError("Missing 'property_map' argument")

        _setter("property_group_id", property_group_id)
        _setter("property_map", property_map)

    @property
    @pulumi.getter(name="propertyGroupId")
    def property_group_id(self) -> str:
        """
        The key of the application execution property key-value map.
        """
        return pulumi.get(self, "property_group_id")

    @property
    @pulumi.getter(name="propertyMap")
    def property_map(self) -> Mapping[str, str]:
        """
        Application execution property key-value map.
        """
        return pulumi.get(self, "property_map")


@pulumi.output_type
class ApplicationApplicationConfigurationFlinkApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkpointConfiguration":
            suggest = "checkpoint_configuration"
        elif key == "monitoringConfiguration":
            suggest = "monitoring_configuration"
        elif key == "parallelismConfiguration":
            suggest = "parallelism_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationFlinkApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 checkpoint_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration'] = None,
                 monitoring_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration'] = None,
                 parallelism_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration'] = None):
        """
        :param 'ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationArgs' checkpoint_configuration: Describes an application's checkpointing configuration.
        :param 'ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationArgs' monitoring_configuration: Describes configuration parameters for CloudWatch logging for an application.
        :param 'ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationArgs' parallelism_configuration: Describes parameters for how an application executes multiple tasks simultaneously.
        """
        ApplicationApplicationConfigurationFlinkApplicationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            checkpoint_configuration=checkpoint_configuration,
            monitoring_configuration=monitoring_configuration,
            parallelism_configuration=parallelism_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             checkpoint_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration'] = None,
             monitoring_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration'] = None,
             parallelism_configuration: Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if checkpoint_configuration is None and 'checkpointConfiguration' in kwargs:
            checkpoint_configuration = kwargs['checkpointConfiguration']
        if monitoring_configuration is None and 'monitoringConfiguration' in kwargs:
            monitoring_configuration = kwargs['monitoringConfiguration']
        if parallelism_configuration is None and 'parallelismConfiguration' in kwargs:
            parallelism_configuration = kwargs['parallelismConfiguration']

        if checkpoint_configuration is not None:
            _setter("checkpoint_configuration", checkpoint_configuration)
        if monitoring_configuration is not None:
            _setter("monitoring_configuration", monitoring_configuration)
        if parallelism_configuration is not None:
            _setter("parallelism_configuration", parallelism_configuration)

    @property
    @pulumi.getter(name="checkpointConfiguration")
    def checkpoint_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration']:
        """
        Describes an application's checkpointing configuration.
        """
        return pulumi.get(self, "checkpoint_configuration")

    @property
    @pulumi.getter(name="monitoringConfiguration")
    def monitoring_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration']:
        """
        Describes configuration parameters for CloudWatch logging for an application.
        """
        return pulumi.get(self, "monitoring_configuration")

    @property
    @pulumi.getter(name="parallelismConfiguration")
    def parallelism_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration']:
        """
        Describes parameters for how an application executes multiple tasks simultaneously.
        """
        return pulumi.get(self, "parallelism_configuration")


@pulumi.output_type
class ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationType":
            suggest = "configuration_type"
        elif key == "checkpointInterval":
            suggest = "checkpoint_interval"
        elif key == "checkpointingEnabled":
            suggest = "checkpointing_enabled"
        elif key == "minPauseBetweenCheckpoints":
            suggest = "min_pause_between_checkpoints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_type: str,
                 checkpoint_interval: Optional[int] = None,
                 checkpointing_enabled: Optional[bool] = None,
                 min_pause_between_checkpoints: Optional[int] = None):
        """
        :param str configuration_type: Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `checkpointing_enabled`, `checkpoint_interval`, or `min_pause_between_checkpoints` attribute values to be effective. If this attribute is set to `DEFAULT`, the application will always use the following values:
               * `checkpointing_enabled = true`
               * `checkpoint_interval = 60000`
               * `min_pause_between_checkpoints = 5000`
        :param int checkpoint_interval: Describes the interval in milliseconds between checkpoint operations.
        :param bool checkpointing_enabled: Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
        :param int min_pause_between_checkpoints: Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
        """
        ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_type=configuration_type,
            checkpoint_interval=checkpoint_interval,
            checkpointing_enabled=checkpointing_enabled,
            min_pause_between_checkpoints=min_pause_between_checkpoints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_type: Optional[str] = None,
             checkpoint_interval: Optional[int] = None,
             checkpointing_enabled: Optional[bool] = None,
             min_pause_between_checkpoints: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_type is None and 'configurationType' in kwargs:
            configuration_type = kwargs['configurationType']
        if configuration_type is None:
            raise TypeError("Missing 'configuration_type' argument")
        if checkpoint_interval is None and 'checkpointInterval' in kwargs:
            checkpoint_interval = kwargs['checkpointInterval']
        if checkpointing_enabled is None and 'checkpointingEnabled' in kwargs:
            checkpointing_enabled = kwargs['checkpointingEnabled']
        if min_pause_between_checkpoints is None and 'minPauseBetweenCheckpoints' in kwargs:
            min_pause_between_checkpoints = kwargs['minPauseBetweenCheckpoints']

        _setter("configuration_type", configuration_type)
        if checkpoint_interval is not None:
            _setter("checkpoint_interval", checkpoint_interval)
        if checkpointing_enabled is not None:
            _setter("checkpointing_enabled", checkpointing_enabled)
        if min_pause_between_checkpoints is not None:
            _setter("min_pause_between_checkpoints", min_pause_between_checkpoints)

    @property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> str:
        """
        Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `checkpointing_enabled`, `checkpoint_interval`, or `min_pause_between_checkpoints` attribute values to be effective. If this attribute is set to `DEFAULT`, the application will always use the following values:
        * `checkpointing_enabled = true`
        * `checkpoint_interval = 60000`
        * `min_pause_between_checkpoints = 5000`
        """
        return pulumi.get(self, "configuration_type")

    @property
    @pulumi.getter(name="checkpointInterval")
    def checkpoint_interval(self) -> Optional[int]:
        """
        Describes the interval in milliseconds between checkpoint operations.
        """
        return pulumi.get(self, "checkpoint_interval")

    @property
    @pulumi.getter(name="checkpointingEnabled")
    def checkpointing_enabled(self) -> Optional[bool]:
        """
        Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
        """
        return pulumi.get(self, "checkpointing_enabled")

    @property
    @pulumi.getter(name="minPauseBetweenCheckpoints")
    def min_pause_between_checkpoints(self) -> Optional[int]:
        """
        Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
        """
        return pulumi.get(self, "min_pause_between_checkpoints")


@pulumi.output_type
class ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationType":
            suggest = "configuration_type"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "metricsLevel":
            suggest = "metrics_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_type: str,
                 log_level: Optional[str] = None,
                 metrics_level: Optional[str] = None):
        """
        :param str configuration_type: Describes whether to use the default CloudWatch logging configuration for an application. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `log_level` or `metrics_level` attribute values to be effective.
        :param str log_level: Describes the verbosity of the CloudWatch Logs for an application. Valid values: `DEBUG`, `ERROR`, `INFO`, `WARN`.
        :param str metrics_level: Describes the granularity of the CloudWatch Logs for an application. Valid values: `APPLICATION`, `OPERATOR`, `PARALLELISM`, `TASK`.
        """
        ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_type=configuration_type,
            log_level=log_level,
            metrics_level=metrics_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_type: Optional[str] = None,
             log_level: Optional[str] = None,
             metrics_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_type is None and 'configurationType' in kwargs:
            configuration_type = kwargs['configurationType']
        if configuration_type is None:
            raise TypeError("Missing 'configuration_type' argument")
        if log_level is None and 'logLevel' in kwargs:
            log_level = kwargs['logLevel']
        if metrics_level is None and 'metricsLevel' in kwargs:
            metrics_level = kwargs['metricsLevel']

        _setter("configuration_type", configuration_type)
        if log_level is not None:
            _setter("log_level", log_level)
        if metrics_level is not None:
            _setter("metrics_level", metrics_level)

    @property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> str:
        """
        Describes whether to use the default CloudWatch logging configuration for an application. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `log_level` or `metrics_level` attribute values to be effective.
        """
        return pulumi.get(self, "configuration_type")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        Describes the verbosity of the CloudWatch Logs for an application. Valid values: `DEBUG`, `ERROR`, `INFO`, `WARN`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="metricsLevel")
    def metrics_level(self) -> Optional[str]:
        """
        Describes the granularity of the CloudWatch Logs for an application. Valid values: `APPLICATION`, `OPERATOR`, `PARALLELISM`, `TASK`.
        """
        return pulumi.get(self, "metrics_level")


@pulumi.output_type
class ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationType":
            suggest = "configuration_type"
        elif key == "autoScalingEnabled":
            suggest = "auto_scaling_enabled"
        elif key == "parallelismPerKpu":
            suggest = "parallelism_per_kpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_type: str,
                 auto_scaling_enabled: Optional[bool] = None,
                 parallelism: Optional[int] = None,
                 parallelism_per_kpu: Optional[int] = None):
        """
        :param str configuration_type: Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `auto_scaling_enabled`, `parallelism`, or `parallelism_per_kpu` attribute values to be effective.
        :param bool auto_scaling_enabled: Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        :param int parallelism: Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        :param int parallelism_per_kpu: Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
        """
        ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_type=configuration_type,
            auto_scaling_enabled=auto_scaling_enabled,
            parallelism=parallelism,
            parallelism_per_kpu=parallelism_per_kpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_type: Optional[str] = None,
             auto_scaling_enabled: Optional[bool] = None,
             parallelism: Optional[int] = None,
             parallelism_per_kpu: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_type is None and 'configurationType' in kwargs:
            configuration_type = kwargs['configurationType']
        if configuration_type is None:
            raise TypeError("Missing 'configuration_type' argument")
        if auto_scaling_enabled is None and 'autoScalingEnabled' in kwargs:
            auto_scaling_enabled = kwargs['autoScalingEnabled']
        if parallelism_per_kpu is None and 'parallelismPerKpu' in kwargs:
            parallelism_per_kpu = kwargs['parallelismPerKpu']

        _setter("configuration_type", configuration_type)
        if auto_scaling_enabled is not None:
            _setter("auto_scaling_enabled", auto_scaling_enabled)
        if parallelism is not None:
            _setter("parallelism", parallelism)
        if parallelism_per_kpu is not None:
            _setter("parallelism_per_kpu", parallelism_per_kpu)

    @property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> str:
        """
        Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `auto_scaling_enabled`, `parallelism`, or `parallelism_per_kpu` attribute values to be effective.
        """
        return pulumi.get(self, "configuration_type")

    @property
    @pulumi.getter(name="autoScalingEnabled")
    def auto_scaling_enabled(self) -> Optional[bool]:
        """
        Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        """
        return pulumi.get(self, "auto_scaling_enabled")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="parallelismPerKpu")
    def parallelism_per_kpu(self) -> Optional[int]:
        """
        Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
        """
        return pulumi.get(self, "parallelism_per_kpu")


@pulumi.output_type
class ApplicationApplicationConfigurationRunConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationRestoreConfiguration":
            suggest = "application_restore_configuration"
        elif key == "flinkRunConfiguration":
            suggest = "flink_run_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationRunConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationRunConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationRunConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_restore_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration'] = None,
                 flink_run_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration'] = None):
        """
        :param 'ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfigurationArgs' application_restore_configuration: The restore behavior of a restarting application.
        :param 'ApplicationApplicationConfigurationRunConfigurationFlinkRunConfigurationArgs' flink_run_configuration: The starting parameters for a Flink-based Kinesis Data Analytics application.
        """
        ApplicationApplicationConfigurationRunConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_restore_configuration=application_restore_configuration,
            flink_run_configuration=flink_run_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_restore_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration'] = None,
             flink_run_configuration: Optional['outputs.ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_restore_configuration is None and 'applicationRestoreConfiguration' in kwargs:
            application_restore_configuration = kwargs['applicationRestoreConfiguration']
        if flink_run_configuration is None and 'flinkRunConfiguration' in kwargs:
            flink_run_configuration = kwargs['flinkRunConfiguration']

        if application_restore_configuration is not None:
            _setter("application_restore_configuration", application_restore_configuration)
        if flink_run_configuration is not None:
            _setter("flink_run_configuration", flink_run_configuration)

    @property
    @pulumi.getter(name="applicationRestoreConfiguration")
    def application_restore_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration']:
        """
        The restore behavior of a restarting application.
        """
        return pulumi.get(self, "application_restore_configuration")

    @property
    @pulumi.getter(name="flinkRunConfiguration")
    def flink_run_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration']:
        """
        The starting parameters for a Flink-based Kinesis Data Analytics application.
        """
        return pulumi.get(self, "flink_run_configuration")


@pulumi.output_type
class ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationRestoreType":
            suggest = "application_restore_type"
        elif key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_restore_type: Optional[str] = None,
                 snapshot_name: Optional[str] = None):
        """
        :param str application_restore_type: Specifies how the application should be restored. Valid values: `RESTORE_FROM_CUSTOM_SNAPSHOT`, `RESTORE_FROM_LATEST_SNAPSHOT`, `SKIP_RESTORE_FROM_SNAPSHOT`.
        :param str snapshot_name: The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if `RESTORE_FROM_CUSTOM_SNAPSHOT` is specified for `application_restore_type`.
        """
        ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_restore_type=application_restore_type,
            snapshot_name=snapshot_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_restore_type: Optional[str] = None,
             snapshot_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_restore_type is None and 'applicationRestoreType' in kwargs:
            application_restore_type = kwargs['applicationRestoreType']
        if snapshot_name is None and 'snapshotName' in kwargs:
            snapshot_name = kwargs['snapshotName']

        if application_restore_type is not None:
            _setter("application_restore_type", application_restore_type)
        if snapshot_name is not None:
            _setter("snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="applicationRestoreType")
    def application_restore_type(self) -> Optional[str]:
        """
        Specifies how the application should be restored. Valid values: `RESTORE_FROM_CUSTOM_SNAPSHOT`, `RESTORE_FROM_LATEST_SNAPSHOT`, `SKIP_RESTORE_FROM_SNAPSHOT`.
        """
        return pulumi.get(self, "application_restore_type")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if `RESTORE_FROM_CUSTOM_SNAPSHOT` is specified for `application_restore_type`.
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNonRestoredState":
            suggest = "allow_non_restored_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_non_restored_state: Optional[bool] = None):
        """
        :param bool allow_non_restored_state: When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is `false`.
        """
        ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_non_restored_state=allow_non_restored_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_non_restored_state: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_non_restored_state is None and 'allowNonRestoredState' in kwargs:
            allow_non_restored_state = kwargs['allowNonRestoredState']

        if allow_non_restored_state is not None:
            _setter("allow_non_restored_state", allow_non_restored_state)

    @property
    @pulumi.getter(name="allowNonRestoredState")
    def allow_non_restored_state(self) -> Optional[bool]:
        """
        When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is `false`.
        """
        return pulumi.get(self, "allow_non_restored_state")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceDataSource":
            suggest = "reference_data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInput'] = None,
                 outputs: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutput']] = None,
                 reference_data_source: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource'] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputArgs' input: The input stream used by the application.
        :param Sequence['ApplicationApplicationConfigurationSqlApplicationConfigurationOutputArgs'] outputs: The destination streams used by the application.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceArgs' reference_data_source: The reference data source used by the application.
        """
        ApplicationApplicationConfigurationSqlApplicationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input=input,
            outputs=outputs,
            reference_data_source=reference_data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInput'] = None,
             outputs: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutput']] = None,
             reference_data_source: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_data_source is None and 'referenceDataSource' in kwargs:
            reference_data_source = kwargs['referenceDataSource']

        if input is not None:
            _setter("input", input)
        if outputs is not None:
            _setter("outputs", outputs)
        if reference_data_source is not None:
            _setter("reference_data_source", reference_data_source)

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInput']:
        """
        The input stream used by the application.
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutput']]:
        """
        The destination streams used by the application.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter(name="referenceDataSource")
    def reference_data_source(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource']:
        """
        The reference data source used by the application.
        """
        return pulumi.get(self, "reference_data_source")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSchema":
            suggest = "input_schema"
        elif key == "namePrefix":
            suggest = "name_prefix"
        elif key == "inAppStreamNames":
            suggest = "in_app_stream_names"
        elif key == "inputId":
            suggest = "input_id"
        elif key == "inputParallelism":
            suggest = "input_parallelism"
        elif key == "inputProcessingConfiguration":
            suggest = "input_processing_configuration"
        elif key == "inputStartingPositionConfigurations":
            suggest = "input_starting_position_configurations"
        elif key == "kinesisFirehoseInput":
            suggest = "kinesis_firehose_input"
        elif key == "kinesisStreamsInput":
            suggest = "kinesis_streams_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_schema: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema',
                 name_prefix: str,
                 in_app_stream_names: Optional[Sequence[str]] = None,
                 input_id: Optional[str] = None,
                 input_parallelism: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism'] = None,
                 input_processing_configuration: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration'] = None,
                 input_starting_position_configurations: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration']] = None,
                 kinesis_firehose_input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput'] = None,
                 kinesis_streams_input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput'] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaArgs' input_schema: Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        :param str name_prefix: The name prefix to use when creating an in-application stream.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelismArgs' input_parallelism: Describes the number of in-application streams to create.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationArgs' input_processing_configuration: The input processing configuration for the input.
               An input processor transforms records as they are received from the stream, before the application's SQL code executes.
        :param Sequence['ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfigurationArgs'] input_starting_position_configurations: The point at which the application starts processing records from the streaming source.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputArgs' kinesis_firehose_input: If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputArgs' kinesis_streams_input: If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_schema=input_schema,
            name_prefix=name_prefix,
            in_app_stream_names=in_app_stream_names,
            input_id=input_id,
            input_parallelism=input_parallelism,
            input_processing_configuration=input_processing_configuration,
            input_starting_position_configurations=input_starting_position_configurations,
            kinesis_firehose_input=kinesis_firehose_input,
            kinesis_streams_input=kinesis_streams_input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_schema: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema'] = None,
             name_prefix: Optional[str] = None,
             in_app_stream_names: Optional[Sequence[str]] = None,
             input_id: Optional[str] = None,
             input_parallelism: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism'] = None,
             input_processing_configuration: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration'] = None,
             input_starting_position_configurations: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration']] = None,
             kinesis_firehose_input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput'] = None,
             kinesis_streams_input: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_schema is None and 'inputSchema' in kwargs:
            input_schema = kwargs['inputSchema']
        if input_schema is None:
            raise TypeError("Missing 'input_schema' argument")
        if name_prefix is None and 'namePrefix' in kwargs:
            name_prefix = kwargs['namePrefix']
        if name_prefix is None:
            raise TypeError("Missing 'name_prefix' argument")
        if in_app_stream_names is None and 'inAppStreamNames' in kwargs:
            in_app_stream_names = kwargs['inAppStreamNames']
        if input_id is None and 'inputId' in kwargs:
            input_id = kwargs['inputId']
        if input_parallelism is None and 'inputParallelism' in kwargs:
            input_parallelism = kwargs['inputParallelism']
        if input_processing_configuration is None and 'inputProcessingConfiguration' in kwargs:
            input_processing_configuration = kwargs['inputProcessingConfiguration']
        if input_starting_position_configurations is None and 'inputStartingPositionConfigurations' in kwargs:
            input_starting_position_configurations = kwargs['inputStartingPositionConfigurations']
        if kinesis_firehose_input is None and 'kinesisFirehoseInput' in kwargs:
            kinesis_firehose_input = kwargs['kinesisFirehoseInput']
        if kinesis_streams_input is None and 'kinesisStreamsInput' in kwargs:
            kinesis_streams_input = kwargs['kinesisStreamsInput']

        _setter("input_schema", input_schema)
        _setter("name_prefix", name_prefix)
        if in_app_stream_names is not None:
            _setter("in_app_stream_names", in_app_stream_names)
        if input_id is not None:
            _setter("input_id", input_id)
        if input_parallelism is not None:
            _setter("input_parallelism", input_parallelism)
        if input_processing_configuration is not None:
            _setter("input_processing_configuration", input_processing_configuration)
        if input_starting_position_configurations is not None:
            _setter("input_starting_position_configurations", input_starting_position_configurations)
        if kinesis_firehose_input is not None:
            _setter("kinesis_firehose_input", kinesis_firehose_input)
        if kinesis_streams_input is not None:
            _setter("kinesis_streams_input", kinesis_streams_input)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema':
        """
        Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> str:
        """
        The name prefix to use when creating an in-application stream.
        """
        return pulumi.get(self, "name_prefix")

    @property
    @pulumi.getter(name="inAppStreamNames")
    def in_app_stream_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_app_stream_names")

    @property
    @pulumi.getter(name="inputId")
    def input_id(self) -> Optional[str]:
        return pulumi.get(self, "input_id")

    @property
    @pulumi.getter(name="inputParallelism")
    def input_parallelism(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism']:
        """
        Describes the number of in-application streams to create.
        """
        return pulumi.get(self, "input_parallelism")

    @property
    @pulumi.getter(name="inputProcessingConfiguration")
    def input_processing_configuration(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration']:
        """
        The input processing configuration for the input.
        An input processor transforms records as they are received from the stream, before the application's SQL code executes.
        """
        return pulumi.get(self, "input_processing_configuration")

    @property
    @pulumi.getter(name="inputStartingPositionConfigurations")
    def input_starting_position_configurations(self) -> Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration']]:
        """
        The point at which the application starts processing records from the streaming source.
        """
        return pulumi.get(self, "input_starting_position_configurations")

    @property
    @pulumi.getter(name="kinesisFirehoseInput")
    def kinesis_firehose_input(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput']:
        """
        If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        """
        return pulumi.get(self, "kinesis_firehose_input")

    @property
    @pulumi.getter(name="kinesisStreamsInput")
    def kinesis_streams_input(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput']:
        """
        If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "kinesis_streams_input")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None):
        """
        :param int count: The number of in-application streams to create.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of in-application streams to create.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLambdaProcessor":
            suggest = "input_lambda_processor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_lambda_processor: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor'):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorArgs' input_lambda_processor: Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_lambda_processor=input_lambda_processor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_lambda_processor: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_lambda_processor is None and 'inputLambdaProcessor' in kwargs:
            input_lambda_processor = kwargs['inputLambdaProcessor']
        if input_lambda_processor is None:
            raise TypeError("Missing 'input_lambda_processor' argument")

        _setter("input_lambda_processor", input_lambda_processor)

    @property
    @pulumi.getter(name="inputLambdaProcessor")
    def input_lambda_processor(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor':
        """
        Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
        """
        return pulumi.get(self, "input_lambda_processor")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the Lambda function that operates on records in the stream.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the Lambda function that operates on records in the stream.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordColumns":
            suggest = "record_columns"
        elif key == "recordFormat":
            suggest = "record_format"
        elif key == "recordEncoding":
            suggest = "record_encoding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_columns: Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn'],
                 record_format: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat',
                 record_encoding: Optional[str] = None):
        """
        :param Sequence['ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumnArgs'] record_columns: Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatArgs' record_format: Specifies the format of the records on the streaming source.
        :param str record_encoding: Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_columns=record_columns,
            record_format=record_format,
            record_encoding=record_encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_columns: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn']] = None,
             record_format: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat'] = None,
             record_encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_columns is None and 'recordColumns' in kwargs:
            record_columns = kwargs['recordColumns']
        if record_columns is None:
            raise TypeError("Missing 'record_columns' argument")
        if record_format is None and 'recordFormat' in kwargs:
            record_format = kwargs['recordFormat']
        if record_format is None:
            raise TypeError("Missing 'record_format' argument")
        if record_encoding is None and 'recordEncoding' in kwargs:
            record_encoding = kwargs['recordEncoding']

        _setter("record_columns", record_columns)
        _setter("record_format", record_format)
        if record_encoding is not None:
            _setter("record_encoding", record_encoding)

    @property
    @pulumi.getter(name="recordColumns")
    def record_columns(self) -> Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn']:
        """
        Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
        """
        return pulumi.get(self, "record_columns")

    @property
    @pulumi.getter(name="recordFormat")
    def record_format(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat':
        """
        Specifies the format of the records on the streaming source.
        """
        return pulumi.get(self, "record_format")

    @property
    @pulumi.getter(name="recordEncoding")
    def record_encoding(self) -> Optional[str]:
        """
        Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
        """
        return pulumi.get(self, "record_encoding")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlType":
            suggest = "sql_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 sql_type: str,
                 mapping: Optional[str] = None):
        """
        :param str name: The name of the column that is created in the in-application input stream or reference table.
        :param str sql_type: The type of column created in the in-application input stream or reference table.
        :param str mapping: A reference to the data element in the streaming input or the reference data source.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            sql_type=sql_type,
            mapping=mapping,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             sql_type: Optional[str] = None,
             mapping: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if sql_type is None and 'sqlType' in kwargs:
            sql_type = kwargs['sqlType']
        if sql_type is None:
            raise TypeError("Missing 'sql_type' argument")

        _setter("name", name)
        _setter("sql_type", sql_type)
        if mapping is not None:
            _setter("mapping", mapping)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column that is created in the in-application input stream or reference table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sqlType")
    def sql_type(self) -> str:
        """
        The type of column created in the in-application input stream or reference table.
        """
        return pulumi.get(self, "sql_type")

    @property
    @pulumi.getter
    def mapping(self) -> Optional[str]:
        """
        A reference to the data element in the streaming input or the reference data source.
        """
        return pulumi.get(self, "mapping")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingParameters":
            suggest = "mapping_parameters"
        elif key == "recordFormatType":
            suggest = "record_format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_parameters: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters',
                 record_format_type: str):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersArgs' mapping_parameters: Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        :param str record_format_type: The type of record format. Valid values: `CSV`, `JSON`.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mapping_parameters=mapping_parameters,
            record_format_type=record_format_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters'] = None,
             record_format_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mapping_parameters is None and 'mappingParameters' in kwargs:
            mapping_parameters = kwargs['mappingParameters']
        if mapping_parameters is None:
            raise TypeError("Missing 'mapping_parameters' argument")
        if record_format_type is None and 'recordFormatType' in kwargs:
            record_format_type = kwargs['recordFormatType']
        if record_format_type is None:
            raise TypeError("Missing 'record_format_type' argument")

        _setter("mapping_parameters", mapping_parameters)
        _setter("record_format_type", record_format_type)

    @property
    @pulumi.getter(name="mappingParameters")
    def mapping_parameters(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters':
        """
        Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        """
        return pulumi.get(self, "mapping_parameters")

    @property
    @pulumi.getter(name="recordFormatType")
    def record_format_type(self) -> str:
        """
        The type of record format. Valid values: `CSV`, `JSON`.
        """
        return pulumi.get(self, "record_format_type")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvMappingParameters":
            suggest = "csv_mapping_parameters"
        elif key == "jsonMappingParameters":
            suggest = "json_mapping_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters'] = None,
                 json_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters'] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersArgs' csv_mapping_parameters: Provides additional mapping information when the record format uses delimiters (for example, CSV).
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersArgs' json_mapping_parameters: Provides additional mapping information when JSON is the record format on the streaming source.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            csv_mapping_parameters=csv_mapping_parameters,
            json_mapping_parameters=json_mapping_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             csv_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters'] = None,
             json_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if csv_mapping_parameters is None and 'csvMappingParameters' in kwargs:
            csv_mapping_parameters = kwargs['csvMappingParameters']
        if json_mapping_parameters is None and 'jsonMappingParameters' in kwargs:
            json_mapping_parameters = kwargs['jsonMappingParameters']

        if csv_mapping_parameters is not None:
            _setter("csv_mapping_parameters", csv_mapping_parameters)
        if json_mapping_parameters is not None:
            _setter("json_mapping_parameters", json_mapping_parameters)

    @property
    @pulumi.getter(name="csvMappingParameters")
    def csv_mapping_parameters(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters']:
        """
        Provides additional mapping information when the record format uses delimiters (for example, CSV).
        """
        return pulumi.get(self, "csv_mapping_parameters")

    @property
    @pulumi.getter(name="jsonMappingParameters")
    def json_mapping_parameters(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters']:
        """
        Provides additional mapping information when JSON is the record format on the streaming source.
        """
        return pulumi.get(self, "json_mapping_parameters")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordColumnDelimiter":
            suggest = "record_column_delimiter"
        elif key == "recordRowDelimiter":
            suggest = "record_row_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_column_delimiter: str,
                 record_row_delimiter: str):
        """
        :param str record_column_delimiter: The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
        :param str record_row_delimiter: The row delimiter. For example, in a CSV format, `\\n` is the typical row delimiter.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_column_delimiter=record_column_delimiter,
            record_row_delimiter=record_row_delimiter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_column_delimiter: Optional[str] = None,
             record_row_delimiter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_column_delimiter is None and 'recordColumnDelimiter' in kwargs:
            record_column_delimiter = kwargs['recordColumnDelimiter']
        if record_column_delimiter is None:
            raise TypeError("Missing 'record_column_delimiter' argument")
        if record_row_delimiter is None and 'recordRowDelimiter' in kwargs:
            record_row_delimiter = kwargs['recordRowDelimiter']
        if record_row_delimiter is None:
            raise TypeError("Missing 'record_row_delimiter' argument")

        _setter("record_column_delimiter", record_column_delimiter)
        _setter("record_row_delimiter", record_row_delimiter)

    @property
    @pulumi.getter(name="recordColumnDelimiter")
    def record_column_delimiter(self) -> str:
        """
        The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
        """
        return pulumi.get(self, "record_column_delimiter")

    @property
    @pulumi.getter(name="recordRowDelimiter")
    def record_row_delimiter(self) -> str:
        """
        The row delimiter. For example, in a CSV format, `\\n` is the typical row delimiter.
        """
        return pulumi.get(self, "record_row_delimiter")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordRowPath":
            suggest = "record_row_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_row_path: str):
        """
        :param str record_row_path: The path to the top-level parent that contains the records.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_row_path=record_row_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_row_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_row_path is None and 'recordRowPath' in kwargs:
            record_row_path = kwargs['recordRowPath']
        if record_row_path is None:
            raise TypeError("Missing 'record_row_path' argument")

        _setter("record_row_path", record_row_path)

    @property
    @pulumi.getter(name="recordRowPath")
    def record_row_path(self) -> str:
        """
        The path to the top-level parent that contains the records.
        """
        return pulumi.get(self, "record_row_path")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputStartingPosition":
            suggest = "input_starting_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_starting_position: Optional[str] = None):
        """
        :param str input_starting_position: The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_starting_position=input_starting_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_starting_position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_starting_position is None and 'inputStartingPosition' in kwargs:
            input_starting_position = kwargs['inputStartingPosition']

        if input_starting_position is not None:
            _setter("input_starting_position", input_starting_position)

    @property
    @pulumi.getter(name="inputStartingPosition")
    def input_starting_position(self) -> Optional[str]:
        """
        The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
        """
        return pulumi.get(self, "input_starting_position")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the delivery stream.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the delivery stream.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the input Kinesis data stream to read.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the input Kinesis data stream to read.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSchema":
            suggest = "destination_schema"
        elif key == "kinesisFirehoseOutput":
            suggest = "kinesis_firehose_output"
        elif key == "kinesisStreamsOutput":
            suggest = "kinesis_streams_output"
        elif key == "lambdaOutput":
            suggest = "lambda_output"
        elif key == "outputId":
            suggest = "output_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_schema: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema',
                 name: str,
                 kinesis_firehose_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput'] = None,
                 kinesis_streams_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput'] = None,
                 lambda_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput'] = None,
                 output_id: Optional[str] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaArgs' destination_schema: Describes the data format when records are written to the destination.
        :param str name: The name of the in-application stream.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputArgs' kinesis_firehose_output: Identifies a Kinesis Data Firehose delivery stream as the destination.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputArgs' kinesis_streams_output: Identifies a Kinesis data stream as the destination.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputArgs' lambda_output: Identifies a Lambda function as the destination.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_schema=destination_schema,
            name=name,
            kinesis_firehose_output=kinesis_firehose_output,
            kinesis_streams_output=kinesis_streams_output,
            lambda_output=lambda_output,
            output_id=output_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_schema: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema'] = None,
             name: Optional[str] = None,
             kinesis_firehose_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput'] = None,
             kinesis_streams_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput'] = None,
             lambda_output: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput'] = None,
             output_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_schema is None and 'destinationSchema' in kwargs:
            destination_schema = kwargs['destinationSchema']
        if destination_schema is None:
            raise TypeError("Missing 'destination_schema' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if kinesis_firehose_output is None and 'kinesisFirehoseOutput' in kwargs:
            kinesis_firehose_output = kwargs['kinesisFirehoseOutput']
        if kinesis_streams_output is None and 'kinesisStreamsOutput' in kwargs:
            kinesis_streams_output = kwargs['kinesisStreamsOutput']
        if lambda_output is None and 'lambdaOutput' in kwargs:
            lambda_output = kwargs['lambdaOutput']
        if output_id is None and 'outputId' in kwargs:
            output_id = kwargs['outputId']

        _setter("destination_schema", destination_schema)
        _setter("name", name)
        if kinesis_firehose_output is not None:
            _setter("kinesis_firehose_output", kinesis_firehose_output)
        if kinesis_streams_output is not None:
            _setter("kinesis_streams_output", kinesis_streams_output)
        if lambda_output is not None:
            _setter("lambda_output", lambda_output)
        if output_id is not None:
            _setter("output_id", output_id)

    @property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema':
        """
        Describes the data format when records are written to the destination.
        """
        return pulumi.get(self, "destination_schema")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the in-application stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="kinesisFirehoseOutput")
    def kinesis_firehose_output(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput']:
        """
        Identifies a Kinesis Data Firehose delivery stream as the destination.
        """
        return pulumi.get(self, "kinesis_firehose_output")

    @property
    @pulumi.getter(name="kinesisStreamsOutput")
    def kinesis_streams_output(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput']:
        """
        Identifies a Kinesis data stream as the destination.
        """
        return pulumi.get(self, "kinesis_streams_output")

    @property
    @pulumi.getter(name="lambdaOutput")
    def lambda_output(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput']:
        """
        Identifies a Lambda function as the destination.
        """
        return pulumi.get(self, "lambda_output")

    @property
    @pulumi.getter(name="outputId")
    def output_id(self) -> Optional[str]:
        return pulumi.get(self, "output_id")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordFormatType":
            suggest = "record_format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_format_type: str):
        """
        :param str record_format_type: Specifies the format of the records on the output stream. Valid values: `CSV`, `JSON`.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_format_type=record_format_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_format_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_format_type is None and 'recordFormatType' in kwargs:
            record_format_type = kwargs['recordFormatType']
        if record_format_type is None:
            raise TypeError("Missing 'record_format_type' argument")

        _setter("record_format_type", record_format_type)

    @property
    @pulumi.getter(name="recordFormatType")
    def record_format_type(self) -> str:
        """
        Specifies the format of the records on the output stream. Valid values: `CSV`, `JSON`.
        """
        return pulumi.get(self, "record_format_type")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the destination delivery stream to write to.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the destination delivery stream to write to.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the destination Kinesis data stream to write to.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the destination Kinesis data stream to write to.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str):
        """
        :param str resource_arn: The ARN of the destination Lambda function to write to.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The ARN of the destination Lambda function to write to.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceSchema":
            suggest = "reference_schema"
        elif key == "s3ReferenceDataSource":
            suggest = "s3_reference_data_source"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "referenceId":
            suggest = "reference_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_schema: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema',
                 s3_reference_data_source: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource',
                 table_name: str,
                 reference_id: Optional[str] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaArgs' reference_schema: Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceArgs' s3_reference_data_source: Identifies the S3 bucket and object that contains the reference data.
        :param str table_name: The name of the in-application table to create.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_schema=reference_schema,
            s3_reference_data_source=s3_reference_data_source,
            table_name=table_name,
            reference_id=reference_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_schema: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema'] = None,
             s3_reference_data_source: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource'] = None,
             table_name: Optional[str] = None,
             reference_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_schema is None and 'referenceSchema' in kwargs:
            reference_schema = kwargs['referenceSchema']
        if reference_schema is None:
            raise TypeError("Missing 'reference_schema' argument")
        if s3_reference_data_source is None and 's3ReferenceDataSource' in kwargs:
            s3_reference_data_source = kwargs['s3ReferenceDataSource']
        if s3_reference_data_source is None:
            raise TypeError("Missing 's3_reference_data_source' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if reference_id is None and 'referenceId' in kwargs:
            reference_id = kwargs['referenceId']

        _setter("reference_schema", reference_schema)
        _setter("s3_reference_data_source", s3_reference_data_source)
        _setter("table_name", table_name)
        if reference_id is not None:
            _setter("reference_id", reference_id)

    @property
    @pulumi.getter(name="referenceSchema")
    def reference_schema(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema':
        """
        Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        """
        return pulumi.get(self, "reference_schema")

    @property
    @pulumi.getter(name="s3ReferenceDataSource")
    def s3_reference_data_source(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource':
        """
        Identifies the S3 bucket and object that contains the reference data.
        """
        return pulumi.get(self, "s3_reference_data_source")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the in-application table to create.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> Optional[str]:
        return pulumi.get(self, "reference_id")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordColumns":
            suggest = "record_columns"
        elif key == "recordFormat":
            suggest = "record_format"
        elif key == "recordEncoding":
            suggest = "record_encoding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_columns: Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn'],
                 record_format: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat',
                 record_encoding: Optional[str] = None):
        """
        :param Sequence['ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumnArgs'] record_columns: Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatArgs' record_format: Specifies the format of the records on the streaming source.
        :param str record_encoding: Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
               
               The `s3_reference_data_source` object supports the following:
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_columns=record_columns,
            record_format=record_format,
            record_encoding=record_encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_columns: Optional[Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn']] = None,
             record_format: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat'] = None,
             record_encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_columns is None and 'recordColumns' in kwargs:
            record_columns = kwargs['recordColumns']
        if record_columns is None:
            raise TypeError("Missing 'record_columns' argument")
        if record_format is None and 'recordFormat' in kwargs:
            record_format = kwargs['recordFormat']
        if record_format is None:
            raise TypeError("Missing 'record_format' argument")
        if record_encoding is None and 'recordEncoding' in kwargs:
            record_encoding = kwargs['recordEncoding']

        _setter("record_columns", record_columns)
        _setter("record_format", record_format)
        if record_encoding is not None:
            _setter("record_encoding", record_encoding)

    @property
    @pulumi.getter(name="recordColumns")
    def record_columns(self) -> Sequence['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn']:
        """
        Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
        """
        return pulumi.get(self, "record_columns")

    @property
    @pulumi.getter(name="recordFormat")
    def record_format(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat':
        """
        Specifies the format of the records on the streaming source.
        """
        return pulumi.get(self, "record_format")

    @property
    @pulumi.getter(name="recordEncoding")
    def record_encoding(self) -> Optional[str]:
        """
        Specifies the encoding of the records in the streaming source. For example, `UTF-8`.

        The `s3_reference_data_source` object supports the following:
        """
        return pulumi.get(self, "record_encoding")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlType":
            suggest = "sql_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 sql_type: str,
                 mapping: Optional[str] = None):
        """
        :param str name: The name of the column that is created in the in-application input stream or reference table.
        :param str sql_type: The type of column created in the in-application input stream or reference table.
        :param str mapping: A reference to the data element in the streaming input or the reference data source.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            sql_type=sql_type,
            mapping=mapping,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             sql_type: Optional[str] = None,
             mapping: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if sql_type is None and 'sqlType' in kwargs:
            sql_type = kwargs['sqlType']
        if sql_type is None:
            raise TypeError("Missing 'sql_type' argument")

        _setter("name", name)
        _setter("sql_type", sql_type)
        if mapping is not None:
            _setter("mapping", mapping)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column that is created in the in-application input stream or reference table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sqlType")
    def sql_type(self) -> str:
        """
        The type of column created in the in-application input stream or reference table.
        """
        return pulumi.get(self, "sql_type")

    @property
    @pulumi.getter
    def mapping(self) -> Optional[str]:
        """
        A reference to the data element in the streaming input or the reference data source.
        """
        return pulumi.get(self, "mapping")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingParameters":
            suggest = "mapping_parameters"
        elif key == "recordFormatType":
            suggest = "record_format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_parameters: 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters',
                 record_format_type: str):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersArgs' mapping_parameters: Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        :param str record_format_type: The type of record format. Valid values: `CSV`, `JSON`.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mapping_parameters=mapping_parameters,
            record_format_type=record_format_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters'] = None,
             record_format_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mapping_parameters is None and 'mappingParameters' in kwargs:
            mapping_parameters = kwargs['mappingParameters']
        if mapping_parameters is None:
            raise TypeError("Missing 'mapping_parameters' argument")
        if record_format_type is None and 'recordFormatType' in kwargs:
            record_format_type = kwargs['recordFormatType']
        if record_format_type is None:
            raise TypeError("Missing 'record_format_type' argument")

        _setter("mapping_parameters", mapping_parameters)
        _setter("record_format_type", record_format_type)

    @property
    @pulumi.getter(name="mappingParameters")
    def mapping_parameters(self) -> 'outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters':
        """
        Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        """
        return pulumi.get(self, "mapping_parameters")

    @property
    @pulumi.getter(name="recordFormatType")
    def record_format_type(self) -> str:
        """
        The type of record format. Valid values: `CSV`, `JSON`.
        """
        return pulumi.get(self, "record_format_type")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvMappingParameters":
            suggest = "csv_mapping_parameters"
        elif key == "jsonMappingParameters":
            suggest = "json_mapping_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters'] = None,
                 json_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters'] = None):
        """
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersArgs' csv_mapping_parameters: Provides additional mapping information when the record format uses delimiters (for example, CSV).
        :param 'ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersArgs' json_mapping_parameters: Provides additional mapping information when JSON is the record format on the streaming source.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            csv_mapping_parameters=csv_mapping_parameters,
            json_mapping_parameters=json_mapping_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             csv_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters'] = None,
             json_mapping_parameters: Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if csv_mapping_parameters is None and 'csvMappingParameters' in kwargs:
            csv_mapping_parameters = kwargs['csvMappingParameters']
        if json_mapping_parameters is None and 'jsonMappingParameters' in kwargs:
            json_mapping_parameters = kwargs['jsonMappingParameters']

        if csv_mapping_parameters is not None:
            _setter("csv_mapping_parameters", csv_mapping_parameters)
        if json_mapping_parameters is not None:
            _setter("json_mapping_parameters", json_mapping_parameters)

    @property
    @pulumi.getter(name="csvMappingParameters")
    def csv_mapping_parameters(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters']:
        """
        Provides additional mapping information when the record format uses delimiters (for example, CSV).
        """
        return pulumi.get(self, "csv_mapping_parameters")

    @property
    @pulumi.getter(name="jsonMappingParameters")
    def json_mapping_parameters(self) -> Optional['outputs.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters']:
        """
        Provides additional mapping information when JSON is the record format on the streaming source.
        """
        return pulumi.get(self, "json_mapping_parameters")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordColumnDelimiter":
            suggest = "record_column_delimiter"
        elif key == "recordRowDelimiter":
            suggest = "record_row_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_column_delimiter: str,
                 record_row_delimiter: str):
        """
        :param str record_column_delimiter: The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
        :param str record_row_delimiter: The row delimiter. For example, in a CSV format, `\\n` is the typical row delimiter.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_column_delimiter=record_column_delimiter,
            record_row_delimiter=record_row_delimiter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_column_delimiter: Optional[str] = None,
             record_row_delimiter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_column_delimiter is None and 'recordColumnDelimiter' in kwargs:
            record_column_delimiter = kwargs['recordColumnDelimiter']
        if record_column_delimiter is None:
            raise TypeError("Missing 'record_column_delimiter' argument")
        if record_row_delimiter is None and 'recordRowDelimiter' in kwargs:
            record_row_delimiter = kwargs['recordRowDelimiter']
        if record_row_delimiter is None:
            raise TypeError("Missing 'record_row_delimiter' argument")

        _setter("record_column_delimiter", record_column_delimiter)
        _setter("record_row_delimiter", record_row_delimiter)

    @property
    @pulumi.getter(name="recordColumnDelimiter")
    def record_column_delimiter(self) -> str:
        """
        The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
        """
        return pulumi.get(self, "record_column_delimiter")

    @property
    @pulumi.getter(name="recordRowDelimiter")
    def record_row_delimiter(self) -> str:
        """
        The row delimiter. For example, in a CSV format, `\\n` is the typical row delimiter.
        """
        return pulumi.get(self, "record_row_delimiter")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordRowPath":
            suggest = "record_row_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_row_path: str):
        """
        :param str record_row_path: The path to the top-level parent that contains the records.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            record_row_path=record_row_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             record_row_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if record_row_path is None and 'recordRowPath' in kwargs:
            record_row_path = kwargs['recordRowPath']
        if record_row_path is None:
            raise TypeError("Missing 'record_row_path' argument")

        _setter("record_row_path", record_row_path)

    @property
    @pulumi.getter(name="recordRowPath")
    def record_row_path(self) -> str:
        """
        The path to the top-level parent that contains the records.
        """
        return pulumi.get(self, "record_row_path")


@pulumi.output_type
class ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "fileKey":
            suggest = "file_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: str,
                 file_key: str):
        """
        :param str bucket_arn: The ARN for the S3 bucket containing the application code.
        :param str file_key: The file key for the object containing the application code.
        """
        ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_arn=bucket_arn,
            file_key=file_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_arn: Optional[str] = None,
             file_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_arn is None and 'bucketArn' in kwargs:
            bucket_arn = kwargs['bucketArn']
        if bucket_arn is None:
            raise TypeError("Missing 'bucket_arn' argument")
        if file_key is None and 'fileKey' in kwargs:
            file_key = kwargs['fileKey']
        if file_key is None:
            raise TypeError("Missing 'file_key' argument")

        _setter("bucket_arn", bucket_arn)
        _setter("file_key", file_key)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> str:
        """
        The ARN for the S3 bucket containing the application code.
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="fileKey")
    def file_key(self) -> str:
        """
        The file key for the object containing the application code.
        """
        return pulumi.get(self, "file_key")


@pulumi.output_type
class ApplicationApplicationConfigurationVpcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcConfigurationId":
            suggest = "vpc_configuration_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationApplicationConfigurationVpcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationApplicationConfigurationVpcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationApplicationConfigurationVpcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[str],
                 subnet_ids: Sequence[str],
                 vpc_configuration_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param Sequence[str] security_group_ids: The Security Group IDs used by the VPC configuration.
        :param Sequence[str] subnet_ids: The Subnet IDs used by the VPC configuration.
        """
        ApplicationApplicationConfigurationVpcConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_configuration_id=vpc_configuration_id,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_group_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_configuration_id: Optional[str] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_configuration_id is None and 'vpcConfigurationId' in kwargs:
            vpc_configuration_id = kwargs['vpcConfigurationId']
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("security_group_ids", security_group_ids)
        _setter("subnet_ids", subnet_ids)
        if vpc_configuration_id is not None:
            _setter("vpc_configuration_id", vpc_configuration_id)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        The Security Group IDs used by the VPC configuration.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The Subnet IDs used by the VPC configuration.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcConfigurationId")
    def vpc_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_configuration_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ApplicationCloudwatchLoggingOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logStreamArn":
            suggest = "log_stream_arn"
        elif key == "cloudwatchLoggingOptionId":
            suggest = "cloudwatch_logging_option_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationCloudwatchLoggingOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationCloudwatchLoggingOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationCloudwatchLoggingOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_stream_arn: str,
                 cloudwatch_logging_option_id: Optional[str] = None):
        """
        :param str log_stream_arn: The ARN of the CloudWatch log stream to receive application messages.
        """
        ApplicationCloudwatchLoggingOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_stream_arn=log_stream_arn,
            cloudwatch_logging_option_id=cloudwatch_logging_option_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_stream_arn: Optional[str] = None,
             cloudwatch_logging_option_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_stream_arn is None and 'logStreamArn' in kwargs:
            log_stream_arn = kwargs['logStreamArn']
        if log_stream_arn is None:
            raise TypeError("Missing 'log_stream_arn' argument")
        if cloudwatch_logging_option_id is None and 'cloudwatchLoggingOptionId' in kwargs:
            cloudwatch_logging_option_id = kwargs['cloudwatchLoggingOptionId']

        _setter("log_stream_arn", log_stream_arn)
        if cloudwatch_logging_option_id is not None:
            _setter("cloudwatch_logging_option_id", cloudwatch_logging_option_id)

    @property
    @pulumi.getter(name="logStreamArn")
    def log_stream_arn(self) -> str:
        """
        The ARN of the CloudWatch log stream to receive application messages.
        """
        return pulumi.get(self, "log_stream_arn")

    @property
    @pulumi.getter(name="cloudwatchLoggingOptionId")
    def cloudwatch_logging_option_id(self) -> Optional[str]:
        return pulumi.get(self, "cloudwatch_logging_option_id")


