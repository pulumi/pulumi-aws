# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'GlobalTableReplicaArgs',
    'TableAttributeArgs',
    'TableGlobalSecondaryIndexArgs',
    'TableImportTableArgs',
    'TableImportTableInputFormatOptionsArgs',
    'TableImportTableInputFormatOptionsCsvArgs',
    'TableImportTableS3BucketSourceArgs',
    'TableLocalSecondaryIndexArgs',
    'TablePointInTimeRecoveryArgs',
    'TableReplicaArgs',
    'TableServerSideEncryptionArgs',
    'TableTtlArgs',
    'GetTableServerSideEncryptionArgs',
]

@pulumi.input_type
class GlobalTableReplicaArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] region_name: AWS region name of replica DynamoDB TableE.g., `us-east-1`
        """
        GlobalTableReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")

        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        AWS region name of replica DynamoDB TableE.g., `us-east-1`
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)


@pulumi.input_type
class TableAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the attribute
        :param pulumi.Input[str] type: Attribute type. Valid values are `S` (string), `N` (number), `B` (binary).
        """
        TableAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Attribute type. Valid values are `S` (string), `N` (number), `B` (binary).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 hash_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 projection_type: pulumi.Input[str],
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 range_key: Optional[pulumi.Input[str]] = None,
                 read_capacity: Optional[pulumi.Input[int]] = None,
                 write_capacity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] hash_key: Name of the hash key in the index; must be defined as an attribute in the resource.
        :param pulumi.Input[str] name: Name of the index.
        :param pulumi.Input[str] projection_type: One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hash_key and sort_key attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `non_key_attributes` in addition to the attributes that that`KEYS_ONLY` project.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_key_attributes: Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        :param pulumi.Input[str] range_key: Name of the range key; must be defined
        :param pulumi.Input[int] read_capacity: Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
        :param pulumi.Input[int] write_capacity: Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
        """
        TableGlobalSecondaryIndexArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hash_key=hash_key,
            name=name,
            projection_type=projection_type,
            non_key_attributes=non_key_attributes,
            range_key=range_key,
            read_capacity=read_capacity,
            write_capacity=write_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hash_key: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             projection_type: Optional[pulumi.Input[str]] = None,
             non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             range_key: Optional[pulumi.Input[str]] = None,
             read_capacity: Optional[pulumi.Input[int]] = None,
             write_capacity: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hash_key is None and 'hashKey' in kwargs:
            hash_key = kwargs['hashKey']
        if hash_key is None:
            raise TypeError("Missing 'hash_key' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if projection_type is None and 'projectionType' in kwargs:
            projection_type = kwargs['projectionType']
        if projection_type is None:
            raise TypeError("Missing 'projection_type' argument")
        if non_key_attributes is None and 'nonKeyAttributes' in kwargs:
            non_key_attributes = kwargs['nonKeyAttributes']
        if range_key is None and 'rangeKey' in kwargs:
            range_key = kwargs['rangeKey']
        if read_capacity is None and 'readCapacity' in kwargs:
            read_capacity = kwargs['readCapacity']
        if write_capacity is None and 'writeCapacity' in kwargs:
            write_capacity = kwargs['writeCapacity']

        _setter("hash_key", hash_key)
        _setter("name", name)
        _setter("projection_type", projection_type)
        if non_key_attributes is not None:
            _setter("non_key_attributes", non_key_attributes)
        if range_key is not None:
            _setter("range_key", range_key)
        if read_capacity is not None:
            _setter("read_capacity", read_capacity)
        if write_capacity is not None:
            _setter("write_capacity", write_capacity)

    @property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> pulumi.Input[str]:
        """
        Name of the hash key in the index; must be defined as an attribute in the resource.
        """
        return pulumi.get(self, "hash_key")

    @hash_key.setter
    def hash_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> pulumi.Input[str]:
        """
        One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hash_key and sort_key attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `non_key_attributes` in addition to the attributes that that`KEYS_ONLY` project.
        """
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "projection_type", value)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the range key; must be defined
        """
        return pulumi.get(self, "range_key")

    @range_key.setter
    def range_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key", value)

    @property
    @pulumi.getter(name="readCapacity")
    def read_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
        """
        return pulumi.get(self, "read_capacity")

    @read_capacity.setter
    def read_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_capacity", value)

    @property
    @pulumi.getter(name="writeCapacity")
    def write_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
        """
        return pulumi.get(self, "write_capacity")

    @write_capacity.setter
    def write_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "write_capacity", value)


@pulumi.input_type
class TableImportTableArgs:
    def __init__(__self__, *,
                 input_format: pulumi.Input[str],
                 s3_bucket_source: pulumi.Input['TableImportTableS3BucketSourceArgs'],
                 input_compression_type: Optional[pulumi.Input[str]] = None,
                 input_format_options: Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']] = None):
        """
        :param pulumi.Input[str] input_format: The format of the source data. Valid values are `CSV`, `DYNAMODB_JSON` and `ION`.
        :param pulumi.Input['TableImportTableS3BucketSourceArgs'] s3_bucket_source: Values for the S3 bucket the source file is imported from. See below.
        :param pulumi.Input[str] input_compression_type: Type of compression to be used on the input coming from the imported table. Valid values are `GZIP`, `ZSTD` and `NONE`.
        :param pulumi.Input['TableImportTableInputFormatOptionsArgs'] input_format_options: Describe the format options for the data that was imported into the target table. There is one value, `csv`. See below.
        """
        TableImportTableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_format=input_format,
            s3_bucket_source=s3_bucket_source,
            input_compression_type=input_compression_type,
            input_format_options=input_format_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_format: Optional[pulumi.Input[str]] = None,
             s3_bucket_source: Optional[pulumi.Input['TableImportTableS3BucketSourceArgs']] = None,
             input_compression_type: Optional[pulumi.Input[str]] = None,
             input_format_options: Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_format is None and 'inputFormat' in kwargs:
            input_format = kwargs['inputFormat']
        if input_format is None:
            raise TypeError("Missing 'input_format' argument")
        if s3_bucket_source is None and 's3BucketSource' in kwargs:
            s3_bucket_source = kwargs['s3BucketSource']
        if s3_bucket_source is None:
            raise TypeError("Missing 's3_bucket_source' argument")
        if input_compression_type is None and 'inputCompressionType' in kwargs:
            input_compression_type = kwargs['inputCompressionType']
        if input_format_options is None and 'inputFormatOptions' in kwargs:
            input_format_options = kwargs['inputFormatOptions']

        _setter("input_format", input_format)
        _setter("s3_bucket_source", s3_bucket_source)
        if input_compression_type is not None:
            _setter("input_compression_type", input_compression_type)
        if input_format_options is not None:
            _setter("input_format_options", input_format_options)

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> pulumi.Input[str]:
        """
        The format of the source data. Valid values are `CSV`, `DYNAMODB_JSON` and `ION`.
        """
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_format", value)

    @property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> pulumi.Input['TableImportTableS3BucketSourceArgs']:
        """
        Values for the S3 bucket the source file is imported from. See below.
        """
        return pulumi.get(self, "s3_bucket_source")

    @s3_bucket_source.setter
    def s3_bucket_source(self, value: pulumi.Input['TableImportTableS3BucketSourceArgs']):
        pulumi.set(self, "s3_bucket_source", value)

    @property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of compression to be used on the input coming from the imported table. Valid values are `GZIP`, `ZSTD` and `NONE`.
        """
        return pulumi.get(self, "input_compression_type")

    @input_compression_type.setter
    def input_compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_compression_type", value)

    @property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']]:
        """
        Describe the format options for the data that was imported into the target table. There is one value, `csv`. See below.
        """
        return pulumi.get(self, "input_format_options")

    @input_format_options.setter
    def input_format_options(self, value: Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']]):
        pulumi.set(self, "input_format_options", value)


@pulumi.input_type
class TableImportTableInputFormatOptionsArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']] = None):
        """
        :param pulumi.Input['TableImportTableInputFormatOptionsCsvArgs'] csv: This block contains the processing options for the CSV file being imported:
        """
        TableImportTableInputFormatOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            csv=csv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             csv: Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if csv is not None:
            _setter("csv", csv)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']]:
        """
        This block contains the processing options for the CSV file being imported:
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']]):
        pulumi.set(self, "csv", value)


@pulumi.input_type
class TableImportTableInputFormatOptionsCsvArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 header_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The delimiter used for separating items in the CSV file being imported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] header_lists: List of the headers used to specify a common header for all source CSV files being imported.
        """
        TableImportTableInputFormatOptionsCsvArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delimiter=delimiter,
            header_lists=header_lists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delimiter: Optional[pulumi.Input[str]] = None,
             header_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if header_lists is None and 'headerLists' in kwargs:
            header_lists = kwargs['headerLists']

        if delimiter is not None:
            _setter("delimiter", delimiter)
        if header_lists is not None:
            _setter("header_lists", header_lists)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter used for separating items in the CSV file being imported.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="headerLists")
    def header_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the headers used to specify a common header for all source CSV files being imported.
        """
        return pulumi.get(self, "header_lists")

    @header_lists.setter
    def header_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "header_lists", value)


@pulumi.input_type
class TableImportTableS3BucketSourceArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 bucket_owner: Optional[pulumi.Input[str]] = None,
                 key_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The S3 bucket that is being imported from.
        :param pulumi.Input[str] bucket_owner: The account number of the S3 bucket that is being imported from.
        :param pulumi.Input[str] key_prefix: The key prefix shared by all S3 Objects that are being imported.
        """
        TableImportTableS3BucketSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            bucket_owner=bucket_owner,
            key_prefix=key_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[pulumi.Input[str]] = None,
             bucket_owner: Optional[pulumi.Input[str]] = None,
             key_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if bucket_owner is None and 'bucketOwner' in kwargs:
            bucket_owner = kwargs['bucketOwner']
        if key_prefix is None and 'keyPrefix' in kwargs:
            key_prefix = kwargs['keyPrefix']

        _setter("bucket", bucket)
        if bucket_owner is not None:
            _setter("bucket_owner", bucket_owner)
        if key_prefix is not None:
            _setter("key_prefix", key_prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The S3 bucket that is being imported from.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[pulumi.Input[str]]:
        """
        The account number of the S3 bucket that is being imported from.
        """
        return pulumi.get(self, "bucket_owner")

    @bucket_owner.setter
    def bucket_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_owner", value)

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The key prefix shared by all S3 Objects that are being imported.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_prefix", value)


@pulumi.input_type
class TableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 projection_type: pulumi.Input[str],
                 range_key: pulumi.Input[str],
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Name of the index
        :param pulumi.Input[str] projection_type: One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hash_key and sort_key attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `non_key_attributes` in addition to the attributes that that`KEYS_ONLY` project.
        :param pulumi.Input[str] range_key: Name of the range key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_key_attributes: Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        TableLocalSecondaryIndexArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            projection_type=projection_type,
            range_key=range_key,
            non_key_attributes=non_key_attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             projection_type: Optional[pulumi.Input[str]] = None,
             range_key: Optional[pulumi.Input[str]] = None,
             non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if projection_type is None and 'projectionType' in kwargs:
            projection_type = kwargs['projectionType']
        if projection_type is None:
            raise TypeError("Missing 'projection_type' argument")
        if range_key is None and 'rangeKey' in kwargs:
            range_key = kwargs['rangeKey']
        if range_key is None:
            raise TypeError("Missing 'range_key' argument")
        if non_key_attributes is None and 'nonKeyAttributes' in kwargs:
            non_key_attributes = kwargs['nonKeyAttributes']

        _setter("name", name)
        _setter("projection_type", projection_type)
        _setter("range_key", range_key)
        if non_key_attributes is not None:
            _setter("non_key_attributes", non_key_attributes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the index
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> pulumi.Input[str]:
        """
        One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hash_key and sort_key attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `non_key_attributes` in addition to the attributes that that`KEYS_ONLY` project.
        """
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "projection_type", value)

    @property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> pulumi.Input[str]:
        """
        Name of the range key.
        """
        return pulumi.get(self, "range_key")

    @range_key.setter
    def range_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_key", value)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)


@pulumi.input_type
class TablePointInTimeRecoveryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the `point_in_time_recovery` block is not provided, this defaults to `false`.
        """
        TablePointInTimeRecoveryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the `point_in_time_recovery` block is not provided, this defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class TableReplicaArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[str],
                 arn: Optional[pulumi.Input[str]] = None,
                 kms_key_arn: Optional[pulumi.Input[str]] = None,
                 point_in_time_recovery: Optional[pulumi.Input[bool]] = None,
                 propagate_tags: Optional[pulumi.Input[bool]] = None,
                 stream_arn: Optional[pulumi.Input[str]] = None,
                 stream_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region_name: Region name of the replica.
        :param pulumi.Input[str] arn: ARN of the table
        :param pulumi.Input[str] kms_key_arn: ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
        :param pulumi.Input[bool] point_in_time_recovery: Whether to enable Point In Time Recovery for the replica. Default is `false`.
        :param pulumi.Input[bool] propagate_tags: Whether to propagate the global table's tags to a replica. Default is `false`. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from `true` to `false` on a subsequent `apply` means replica tags are left as they were, unmanaged, not deleted.
        :param pulumi.Input[str] stream_arn: ARN of the Table Stream. Only available when `stream_enabled = true`
        :param pulumi.Input[str] stream_label: Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when `stream_enabled = true`.
        """
        TableReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_name=region_name,
            arn=arn,
            kms_key_arn=kms_key_arn,
            point_in_time_recovery=point_in_time_recovery,
            propagate_tags=propagate_tags,
            stream_arn=stream_arn,
            stream_label=stream_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_name: Optional[pulumi.Input[str]] = None,
             arn: Optional[pulumi.Input[str]] = None,
             kms_key_arn: Optional[pulumi.Input[str]] = None,
             point_in_time_recovery: Optional[pulumi.Input[bool]] = None,
             propagate_tags: Optional[pulumi.Input[bool]] = None,
             stream_arn: Optional[pulumi.Input[str]] = None,
             stream_label: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']
        if point_in_time_recovery is None and 'pointInTimeRecovery' in kwargs:
            point_in_time_recovery = kwargs['pointInTimeRecovery']
        if propagate_tags is None and 'propagateTags' in kwargs:
            propagate_tags = kwargs['propagateTags']
        if stream_arn is None and 'streamArn' in kwargs:
            stream_arn = kwargs['streamArn']
        if stream_label is None and 'streamLabel' in kwargs:
            stream_label = kwargs['streamLabel']

        _setter("region_name", region_name)
        if arn is not None:
            _setter("arn", arn)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)
        if point_in_time_recovery is not None:
            _setter("point_in_time_recovery", point_in_time_recovery)
        if propagate_tags is not None:
            _setter("propagate_tags", propagate_tags)
        if stream_arn is not None:
            _setter("stream_arn", stream_arn)
        if stream_label is not None:
            _setter("stream_label", stream_label)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        Region name of the replica.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the table
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)

    @property
    @pulumi.getter(name="pointInTimeRecovery")
    def point_in_time_recovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable Point In Time Recovery for the replica. Default is `false`.
        """
        return pulumi.get(self, "point_in_time_recovery")

    @point_in_time_recovery.setter
    def point_in_time_recovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time_recovery", value)

    @property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to propagate the global table's tags to a replica. Default is `false`. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from `true` to `false` on a subsequent `apply` means replica tags are left as they were, unmanaged, not deleted.
        """
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "propagate_tags", value)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the Table Stream. Only available when `stream_enabled = true`
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_arn", value)

    @property
    @pulumi.getter(name="streamLabel")
    def stream_label(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when `stream_enabled = true`.
        """
        return pulumi.get(self, "stream_label")

    @stream_label.setter
    def stream_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_label", value)


@pulumi.input_type
class TableServerSideEncryptionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If `enabled` is `false` then server-side encryption is set to AWS-_owned_ key (shown as `DEFAULT` in the AWS console). Potentially confusingly, if `enabled` is `true` and no `kms_key_arn` is specified then server-side encryption is set to the _default_ KMS-_managed_ key (shown as `KMS` in the AWS console). The [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html) explains the difference between AWS-_owned_ and KMS-_managed_ keys.
        :param pulumi.Input[str] kms_key_arn: ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
        """
        TableServerSideEncryptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kms_key_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']

        _setter("enabled", enabled)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If `enabled` is `false` then server-side encryption is set to AWS-_owned_ key (shown as `DEFAULT` in the AWS console). Potentially confusingly, if `enabled` is `true` and no `kms_key_arn` is specified then server-side encryption is set to the _default_ KMS-_managed_ key (shown as `KMS` in the AWS console). The [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html) explains the difference between AWS-_owned_ and KMS-_managed_ keys.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


@pulumi.input_type
class TableTtlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] attribute_name: Name of the table attribute to store the TTL timestamp in.
        :param pulumi.Input[bool] enabled: Whether TTL is enabled.
        """
        TableTtlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_name=attribute_name,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_name: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attribute_name is None and 'attributeName' in kwargs:
            attribute_name = kwargs['attributeName']
        if attribute_name is None:
            raise TypeError("Missing 'attribute_name' argument")

        _setter("attribute_name", attribute_name)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        Name of the table attribute to store the TTL timestamp in.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether TTL is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class GetTableServerSideEncryptionArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 kms_key_arn: str):
        GetTableServerSideEncryptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             kms_key_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']
        if kms_key_arn is None:
            raise TypeError("Missing 'kms_key_arn' argument")

        _setter("enabled", enabled)
        _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> str:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: str):
        pulumi.set(self, "kms_key_arn", value)


