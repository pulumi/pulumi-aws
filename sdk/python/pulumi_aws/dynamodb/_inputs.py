# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GlobalSecondaryIndexKeySchemaArgs',
    'GlobalSecondaryIndexKeySchemaArgsDict',
    'GlobalSecondaryIndexOnDemandThroughputArgs',
    'GlobalSecondaryIndexOnDemandThroughputArgsDict',
    'GlobalSecondaryIndexProjectionArgs',
    'GlobalSecondaryIndexProjectionArgsDict',
    'GlobalSecondaryIndexProvisionedThroughputArgs',
    'GlobalSecondaryIndexProvisionedThroughputArgsDict',
    'GlobalSecondaryIndexTimeoutsArgs',
    'GlobalSecondaryIndexTimeoutsArgsDict',
    'GlobalSecondaryIndexWarmThroughputArgs',
    'GlobalSecondaryIndexWarmThroughputArgsDict',
    'GlobalTableReplicaArgs',
    'GlobalTableReplicaArgsDict',
    'TableAttributeArgs',
    'TableAttributeArgsDict',
    'TableExportIncrementalExportSpecificationArgs',
    'TableExportIncrementalExportSpecificationArgsDict',
    'TableGlobalSecondaryIndexArgs',
    'TableGlobalSecondaryIndexArgsDict',
    'TableGlobalSecondaryIndexOnDemandThroughputArgs',
    'TableGlobalSecondaryIndexOnDemandThroughputArgsDict',
    'TableGlobalSecondaryIndexWarmThroughputArgs',
    'TableGlobalSecondaryIndexWarmThroughputArgsDict',
    'TableGlobalTableWitnessArgs',
    'TableGlobalTableWitnessArgsDict',
    'TableImportTableArgs',
    'TableImportTableArgsDict',
    'TableImportTableInputFormatOptionsArgs',
    'TableImportTableInputFormatOptionsArgsDict',
    'TableImportTableInputFormatOptionsCsvArgs',
    'TableImportTableInputFormatOptionsCsvArgsDict',
    'TableImportTableS3BucketSourceArgs',
    'TableImportTableS3BucketSourceArgsDict',
    'TableLocalSecondaryIndexArgs',
    'TableLocalSecondaryIndexArgsDict',
    'TableOnDemandThroughputArgs',
    'TableOnDemandThroughputArgsDict',
    'TablePointInTimeRecoveryArgs',
    'TablePointInTimeRecoveryArgsDict',
    'TableReplicaArgs',
    'TableReplicaArgsDict',
    'TableServerSideEncryptionArgs',
    'TableServerSideEncryptionArgsDict',
    'TableTtlArgs',
    'TableTtlArgsDict',
    'TableWarmThroughputArgs',
    'TableWarmThroughputArgsDict',
    'GetTableServerSideEncryptionArgs',
    'GetTableServerSideEncryptionArgsDict',
]

MYPY = False

if not MYPY:
    class GlobalSecondaryIndexKeySchemaArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        attribute_type: pulumi.Input[_builtins.str]
        key_type: pulumi.Input[_builtins.str]
elif False:
    GlobalSecondaryIndexKeySchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexKeySchemaArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_type: pulumi.Input[_builtins.str],
                 key_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)
        pulumi.set(__self__, "key_type", key_type)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_type", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_type", value)


if not MYPY:
    class GlobalSecondaryIndexOnDemandThroughputArgsDict(TypedDict):
        max_read_request_units: NotRequired[pulumi.Input[_builtins.int]]
        max_write_request_units: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    GlobalSecondaryIndexOnDemandThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexOnDemandThroughputArgs:
    def __init__(__self__, *,
                 max_read_request_units: Optional[pulumi.Input[_builtins.int]] = None,
                 max_write_request_units: Optional[pulumi.Input[_builtins.int]] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_read_request_units")

    @max_read_request_units.setter
    def max_read_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_read_request_units", value)

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_write_request_units")

    @max_write_request_units.setter
    def max_write_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_write_request_units", value)


if not MYPY:
    class GlobalSecondaryIndexProjectionArgsDict(TypedDict):
        projection_type: pulumi.Input[_builtins.str]
        non_key_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    GlobalSecondaryIndexProjectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexProjectionArgs:
    def __init__(__self__, *,
                 projection_type: pulumi.Input[_builtins.str],
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "projection_type", projection_type)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "projection_type", value)

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_key_attributes", value)


if not MYPY:
    class GlobalSecondaryIndexProvisionedThroughputArgsDict(TypedDict):
        read_capacity_units: NotRequired[pulumi.Input[_builtins.int]]
        write_capacity_units: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    GlobalSecondaryIndexProvisionedThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexProvisionedThroughputArgs:
    def __init__(__self__, *,
                 read_capacity_units: Optional[pulumi.Input[_builtins.int]] = None,
                 write_capacity_units: Optional[pulumi.Input[_builtins.int]] = None):
        if read_capacity_units is not None:
            pulumi.set(__self__, "read_capacity_units", read_capacity_units)
        if write_capacity_units is not None:
            pulumi.set(__self__, "write_capacity_units", write_capacity_units)

    @_builtins.property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "read_capacity_units")

    @read_capacity_units.setter
    def read_capacity_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_capacity_units", value)

    @_builtins.property
    @pulumi.getter(name="writeCapacityUnits")
    def write_capacity_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "write_capacity_units")

    @write_capacity_units.setter
    def write_capacity_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_capacity_units", value)


if not MYPY:
    class GlobalSecondaryIndexTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GlobalSecondaryIndexTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GlobalSecondaryIndexWarmThroughputArgsDict(TypedDict):
        read_units_per_second: pulumi.Input[_builtins.int]
        write_units_per_second: pulumi.Input[_builtins.int]
elif False:
    GlobalSecondaryIndexWarmThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalSecondaryIndexWarmThroughputArgs:
    def __init__(__self__, *,
                 read_units_per_second: pulumi.Input[_builtins.int],
                 write_units_per_second: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "read_units_per_second")

    @read_units_per_second.setter
    def read_units_per_second(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "read_units_per_second", value)

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "write_units_per_second")

    @write_units_per_second.setter
    def write_units_per_second(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "write_units_per_second", value)


if not MYPY:
    class GlobalTableReplicaArgsDict(TypedDict):
        region_name: pulumi.Input[_builtins.str]
elif False:
    GlobalTableReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalTableReplicaArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_name", value)


if not MYPY:
    class TableAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    TableAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TableExportIncrementalExportSpecificationArgsDict(TypedDict):
        export_from_time: NotRequired[pulumi.Input[_builtins.str]]
        export_to_time: NotRequired[pulumi.Input[_builtins.str]]
        export_view_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TableExportIncrementalExportSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExportIncrementalExportSpecificationArgs:
    def __init__(__self__, *,
                 export_from_time: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_time: Optional[pulumi.Input[_builtins.str]] = None,
                 export_view_type: Optional[pulumi.Input[_builtins.str]] = None):
        if export_from_time is not None:
            pulumi.set(__self__, "export_from_time", export_from_time)
        if export_to_time is not None:
            pulumi.set(__self__, "export_to_time", export_to_time)
        if export_view_type is not None:
            pulumi.set(__self__, "export_view_type", export_view_type)

    @_builtins.property
    @pulumi.getter(name="exportFromTime")
    def export_from_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_from_time")

    @export_from_time.setter
    def export_from_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_from_time", value)

    @_builtins.property
    @pulumi.getter(name="exportToTime")
    def export_to_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_time")

    @export_to_time.setter
    def export_to_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_time", value)

    @_builtins.property
    @pulumi.getter(name="exportViewType")
    def export_view_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_view_type")

    @export_view_type.setter
    def export_view_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_view_type", value)


if not MYPY:
    class TableGlobalSecondaryIndexArgsDict(TypedDict):
        hash_key: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        projection_type: pulumi.Input[_builtins.str]
        non_key_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        on_demand_throughput: NotRequired[pulumi.Input['TableGlobalSecondaryIndexOnDemandThroughputArgsDict']]
        range_key: NotRequired[pulumi.Input[_builtins.str]]
        read_capacity: NotRequired[pulumi.Input[_builtins.int]]
        warm_throughput: NotRequired[pulumi.Input['TableGlobalSecondaryIndexWarmThroughputArgsDict']]
        write_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TableGlobalSecondaryIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 hash_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 projection_type: pulumi.Input[_builtins.str],
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 on_demand_throughput: Optional[pulumi.Input['TableGlobalSecondaryIndexOnDemandThroughputArgs']] = None,
                 range_key: Optional[pulumi.Input[_builtins.str]] = None,
                 read_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 warm_throughput: Optional[pulumi.Input['TableGlobalSecondaryIndexWarmThroughputArgs']] = None,
                 write_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "hash_key", hash_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if on_demand_throughput is not None:
            pulumi.set(__self__, "on_demand_throughput", on_demand_throughput)
        if range_key is not None:
            pulumi.set(__self__, "range_key", range_key)
        if read_capacity is not None:
            pulumi.set(__self__, "read_capacity", read_capacity)
        if warm_throughput is not None:
            pulumi.set(__self__, "warm_throughput", warm_throughput)
        if write_capacity is not None:
            pulumi.set(__self__, "write_capacity", write_capacity)

    @_builtins.property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hash_key")

    @hash_key.setter
    def hash_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hash_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "projection_type", value)

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @_builtins.property
    @pulumi.getter(name="onDemandThroughput")
    def on_demand_throughput(self) -> Optional[pulumi.Input['TableGlobalSecondaryIndexOnDemandThroughputArgs']]:
        return pulumi.get(self, "on_demand_throughput")

    @on_demand_throughput.setter
    def on_demand_throughput(self, value: Optional[pulumi.Input['TableGlobalSecondaryIndexOnDemandThroughputArgs']]):
        pulumi.set(self, "on_demand_throughput", value)

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key")

    @range_key.setter
    def range_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key", value)

    @_builtins.property
    @pulumi.getter(name="readCapacity")
    def read_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "read_capacity")

    @read_capacity.setter
    def read_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_capacity", value)

    @_builtins.property
    @pulumi.getter(name="warmThroughput")
    def warm_throughput(self) -> Optional[pulumi.Input['TableGlobalSecondaryIndexWarmThroughputArgs']]:
        return pulumi.get(self, "warm_throughput")

    @warm_throughput.setter
    def warm_throughput(self, value: Optional[pulumi.Input['TableGlobalSecondaryIndexWarmThroughputArgs']]):
        pulumi.set(self, "warm_throughput", value)

    @_builtins.property
    @pulumi.getter(name="writeCapacity")
    def write_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "write_capacity")

    @write_capacity.setter
    def write_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_capacity", value)


if not MYPY:
    class TableGlobalSecondaryIndexOnDemandThroughputArgsDict(TypedDict):
        max_read_request_units: NotRequired[pulumi.Input[_builtins.int]]
        max_write_request_units: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TableGlobalSecondaryIndexOnDemandThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableGlobalSecondaryIndexOnDemandThroughputArgs:
    def __init__(__self__, *,
                 max_read_request_units: Optional[pulumi.Input[_builtins.int]] = None,
                 max_write_request_units: Optional[pulumi.Input[_builtins.int]] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_read_request_units")

    @max_read_request_units.setter
    def max_read_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_read_request_units", value)

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_write_request_units")

    @max_write_request_units.setter
    def max_write_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_write_request_units", value)


if not MYPY:
    class TableGlobalSecondaryIndexWarmThroughputArgsDict(TypedDict):
        read_units_per_second: NotRequired[pulumi.Input[_builtins.int]]
        write_units_per_second: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TableGlobalSecondaryIndexWarmThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableGlobalSecondaryIndexWarmThroughputArgs:
    def __init__(__self__, *,
                 read_units_per_second: Optional[pulumi.Input[_builtins.int]] = None,
                 write_units_per_second: Optional[pulumi.Input[_builtins.int]] = None):
        if read_units_per_second is not None:
            pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        if write_units_per_second is not None:
            pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "read_units_per_second")

    @read_units_per_second.setter
    def read_units_per_second(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_units_per_second", value)

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "write_units_per_second")

    @write_units_per_second.setter
    def write_units_per_second(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_units_per_second", value)


if not MYPY:
    class TableGlobalTableWitnessArgsDict(TypedDict):
        region_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TableGlobalTableWitnessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableGlobalTableWitnessArgs:
    def __init__(__self__, *,
                 region_name: Optional[pulumi.Input[_builtins.str]] = None):
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region_name", value)


if not MYPY:
    class TableImportTableArgsDict(TypedDict):
        input_format: pulumi.Input[_builtins.str]
        s3_bucket_source: pulumi.Input['TableImportTableS3BucketSourceArgsDict']
        input_compression_type: NotRequired[pulumi.Input[_builtins.str]]
        input_format_options: NotRequired[pulumi.Input['TableImportTableInputFormatOptionsArgsDict']]
elif False:
    TableImportTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableImportTableArgs:
    def __init__(__self__, *,
                 input_format: pulumi.Input[_builtins.str],
                 s3_bucket_source: pulumi.Input['TableImportTableS3BucketSourceArgs'],
                 input_compression_type: Optional[pulumi.Input[_builtins.str]] = None,
                 input_format_options: Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']] = None):
        pulumi.set(__self__, "input_format", input_format)
        pulumi.set(__self__, "s3_bucket_source", s3_bucket_source)
        if input_compression_type is not None:
            pulumi.set(__self__, "input_compression_type", input_compression_type)
        if input_format_options is not None:
            pulumi.set(__self__, "input_format_options", input_format_options)

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_format", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> pulumi.Input['TableImportTableS3BucketSourceArgs']:
        return pulumi.get(self, "s3_bucket_source")

    @s3_bucket_source.setter
    def s3_bucket_source(self, value: pulumi.Input['TableImportTableS3BucketSourceArgs']):
        pulumi.set(self, "s3_bucket_source", value)

    @_builtins.property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "input_compression_type")

    @input_compression_type.setter
    def input_compression_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_compression_type", value)

    @_builtins.property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']]:
        return pulumi.get(self, "input_format_options")

    @input_format_options.setter
    def input_format_options(self, value: Optional[pulumi.Input['TableImportTableInputFormatOptionsArgs']]):
        pulumi.set(self, "input_format_options", value)


if not MYPY:
    class TableImportTableInputFormatOptionsArgsDict(TypedDict):
        csv: NotRequired[pulumi.Input['TableImportTableInputFormatOptionsCsvArgsDict']]
elif False:
    TableImportTableInputFormatOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableImportTableInputFormatOptionsArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']] = None):
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['TableImportTableInputFormatOptionsCsvArgs']]):
        pulumi.set(self, "csv", value)


if not MYPY:
    class TableImportTableInputFormatOptionsCsvArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        header_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    TableImportTableInputFormatOptionsCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableImportTableInputFormatOptionsCsvArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 header_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_lists is not None:
            pulumi.set(__self__, "header_lists", header_lists)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="headerLists")
    def header_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header_lists")

    @header_lists.setter
    def header_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header_lists", value)


if not MYPY:
    class TableImportTableS3BucketSourceArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        bucket_owner: NotRequired[pulumi.Input[_builtins.str]]
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TableImportTableS3BucketSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableImportTableS3BucketSourceArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 bucket_owner: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket", bucket)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_owner")

    @bucket_owner.setter
    def bucket_owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)


if not MYPY:
    class TableLocalSecondaryIndexArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        projection_type: pulumi.Input[_builtins.str]
        range_key: pulumi.Input[_builtins.str]
        non_key_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    TableLocalSecondaryIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 projection_type: pulumi.Input[_builtins.str],
                 range_key: pulumi.Input[_builtins.str],
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        pulumi.set(__self__, "range_key", range_key)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "projection_type", value)

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "range_key")

    @range_key.setter
    def range_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "range_key", value)

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_key_attributes", value)


if not MYPY:
    class TableOnDemandThroughputArgsDict(TypedDict):
        max_read_request_units: NotRequired[pulumi.Input[_builtins.int]]
        max_write_request_units: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TableOnDemandThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableOnDemandThroughputArgs:
    def __init__(__self__, *,
                 max_read_request_units: Optional[pulumi.Input[_builtins.int]] = None,
                 max_write_request_units: Optional[pulumi.Input[_builtins.int]] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_read_request_units")

    @max_read_request_units.setter
    def max_read_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_read_request_units", value)

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_write_request_units")

    @max_write_request_units.setter
    def max_write_request_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_write_request_units", value)


if not MYPY:
    class TablePointInTimeRecoveryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        recovery_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TablePointInTimeRecoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TablePointInTimeRecoveryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 recovery_period_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if recovery_period_in_days is not None:
            pulumi.set(__self__, "recovery_period_in_days", recovery_period_in_days)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="recoveryPeriodInDays")
    def recovery_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "recovery_period_in_days")

    @recovery_period_in_days.setter
    def recovery_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recovery_period_in_days", value)


if not MYPY:
    class TableReplicaArgsDict(TypedDict):
        region_name: pulumi.Input[_builtins.str]
        arn: NotRequired[pulumi.Input[_builtins.str]]
        consistency_mode: NotRequired[pulumi.Input[_builtins.str]]
        deletion_protection_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        point_in_time_recovery: NotRequired[pulumi.Input[_builtins.bool]]
        propagate_tags: NotRequired[pulumi.Input[_builtins.bool]]
        stream_arn: NotRequired[pulumi.Input[_builtins.str]]
        stream_label: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TableReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableReplicaArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[_builtins.str],
                 arn: Optional[pulumi.Input[_builtins.str]] = None,
                 consistency_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 deletion_protection_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 point_in_time_recovery: Optional[pulumi.Input[_builtins.bool]] = None,
                 propagate_tags: Optional[pulumi.Input[_builtins.bool]] = None,
                 stream_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_label: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "region_name", region_name)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if consistency_mode is not None:
            pulumi.set(__self__, "consistency_mode", consistency_mode)
        if deletion_protection_enabled is not None:
            pulumi.set(__self__, "deletion_protection_enabled", deletion_protection_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if point_in_time_recovery is not None:
            pulumi.set(__self__, "point_in_time_recovery", point_in_time_recovery)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)
        if stream_label is not None:
            pulumi.set(__self__, "stream_label", stream_label)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_name", value)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="consistencyMode")
    def consistency_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "consistency_mode")

    @consistency_mode.setter
    def consistency_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consistency_mode", value)

    @_builtins.property
    @pulumi.getter(name="deletionProtectionEnabled")
    def deletion_protection_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "deletion_protection_enabled")

    @deletion_protection_enabled.setter
    def deletion_protection_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deletion_protection_enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="pointInTimeRecovery")
    def point_in_time_recovery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "point_in_time_recovery")

    @point_in_time_recovery.setter
    def point_in_time_recovery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "point_in_time_recovery", value)

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "propagate_tags", value)

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_arn", value)

    @_builtins.property
    @pulumi.getter(name="streamLabel")
    def stream_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "stream_label")

    @stream_label.setter
    def stream_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_label", value)


if not MYPY:
    class TableServerSideEncryptionArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TableServerSideEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableServerSideEncryptionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class TableTtlArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TableTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTtlArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TableWarmThroughputArgsDict(TypedDict):
        read_units_per_second: NotRequired[pulumi.Input[_builtins.int]]
        write_units_per_second: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TableWarmThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableWarmThroughputArgs:
    def __init__(__self__, *,
                 read_units_per_second: Optional[pulumi.Input[_builtins.int]] = None,
                 write_units_per_second: Optional[pulumi.Input[_builtins.int]] = None):
        if read_units_per_second is not None:
            pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        if write_units_per_second is not None:
            pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "read_units_per_second")

    @read_units_per_second.setter
    def read_units_per_second(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_units_per_second", value)

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "write_units_per_second")

    @write_units_per_second.setter
    def write_units_per_second(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_units_per_second", value)


if not MYPY:
    class GetTableServerSideEncryptionArgsDict(TypedDict):
        enabled: _builtins.bool
        kms_key_arn: _builtins.str
elif False:
    GetTableServerSideEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableServerSideEncryptionArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kms_key_arn: _builtins.str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: _builtins.str):
        pulumi.set(self, "kms_key_arn", value)


