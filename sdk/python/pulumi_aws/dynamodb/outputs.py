# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GlobalSecondaryIndexKeySchema',
    'GlobalSecondaryIndexOnDemandThroughput',
    'GlobalSecondaryIndexProjection',
    'GlobalSecondaryIndexProvisionedThroughput',
    'GlobalSecondaryIndexTimeouts',
    'GlobalSecondaryIndexWarmThroughput',
    'GlobalTableReplica',
    'TableAttribute',
    'TableExportIncrementalExportSpecification',
    'TableGlobalSecondaryIndex',
    'TableGlobalSecondaryIndexOnDemandThroughput',
    'TableGlobalSecondaryIndexWarmThroughput',
    'TableGlobalTableWitness',
    'TableImportTable',
    'TableImportTableInputFormatOptions',
    'TableImportTableInputFormatOptionsCsv',
    'TableImportTableS3BucketSource',
    'TableLocalSecondaryIndex',
    'TableOnDemandThroughput',
    'TablePointInTimeRecovery',
    'TableReplica',
    'TableServerSideEncryption',
    'TableTtl',
    'TableWarmThroughput',
    'GetTableAttributeResult',
    'GetTableGlobalSecondaryIndexResult',
    'GetTableGlobalSecondaryIndexOnDemandThroughputResult',
    'GetTableGlobalSecondaryIndexWarmThroughputResult',
    'GetTableLocalSecondaryIndexResult',
    'GetTableOnDemandThroughputResult',
    'GetTablePointInTimeRecoveryResult',
    'GetTableReplicaResult',
    'GetTableServerSideEncryptionResult',
    'GetTableTtlResult',
    'GetTableWarmThroughputResult',
]

@pulumi.output_type
class GlobalSecondaryIndexKeySchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeType":
            suggest = "attribute_type"
        elif key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexKeySchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexKeySchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexKeySchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: _builtins.str,
                 attribute_type: _builtins.str,
                 key_type: _builtins.str):
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)
        pulumi.set(__self__, "key_type", key_type)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> _builtins.str:
        return pulumi.get(self, "attribute_name")

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> _builtins.str:
        return pulumi.get(self, "attribute_type")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> _builtins.str:
        return pulumi.get(self, "key_type")


@pulumi.output_type
class GlobalSecondaryIndexOnDemandThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReadRequestUnits":
            suggest = "max_read_request_units"
        elif key == "maxWriteRequestUnits":
            suggest = "max_write_request_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexOnDemandThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexOnDemandThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexOnDemandThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_read_request_units: Optional[_builtins.int] = None,
                 max_write_request_units: Optional[_builtins.int] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_read_request_units")

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_write_request_units")


@pulumi.output_type
class GlobalSecondaryIndexProjection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectionType":
            suggest = "projection_type"
        elif key == "nonKeyAttributes":
            suggest = "non_key_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexProjection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexProjection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexProjection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 projection_type: _builtins.str,
                 non_key_attributes: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "projection_type", projection_type)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> _builtins.str:
        return pulumi.get(self, "projection_type")

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "non_key_attributes")


@pulumi.output_type
class GlobalSecondaryIndexProvisionedThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readCapacityUnits":
            suggest = "read_capacity_units"
        elif key == "writeCapacityUnits":
            suggest = "write_capacity_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexProvisionedThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexProvisionedThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexProvisionedThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_capacity_units: Optional[_builtins.int] = None,
                 write_capacity_units: Optional[_builtins.int] = None):
        if read_capacity_units is not None:
            pulumi.set(__self__, "read_capacity_units", read_capacity_units)
        if write_capacity_units is not None:
            pulumi.set(__self__, "write_capacity_units", write_capacity_units)

    @_builtins.property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "read_capacity_units")

    @_builtins.property
    @pulumi.getter(name="writeCapacityUnits")
    def write_capacity_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "write_capacity_units")


@pulumi.output_type
class GlobalSecondaryIndexTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GlobalSecondaryIndexWarmThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readUnitsPerSecond":
            suggest = "read_units_per_second"
        elif key == "writeUnitsPerSecond":
            suggest = "write_units_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexWarmThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexWarmThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexWarmThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_units_per_second: _builtins.int,
                 write_units_per_second: _builtins.int):
        pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "read_units_per_second")

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "write_units_per_second")


@pulumi.output_type
class GlobalTableReplica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalTableReplica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalTableReplica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalTableReplica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class TableAttribute(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class TableExportIncrementalExportSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportFromTime":
            suggest = "export_from_time"
        elif key == "exportToTime":
            suggest = "export_to_time"
        elif key == "exportViewType":
            suggest = "export_view_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableExportIncrementalExportSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableExportIncrementalExportSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableExportIncrementalExportSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_from_time: Optional[_builtins.str] = None,
                 export_to_time: Optional[_builtins.str] = None,
                 export_view_type: Optional[_builtins.str] = None):
        if export_from_time is not None:
            pulumi.set(__self__, "export_from_time", export_from_time)
        if export_to_time is not None:
            pulumi.set(__self__, "export_to_time", export_to_time)
        if export_view_type is not None:
            pulumi.set(__self__, "export_view_type", export_view_type)

    @_builtins.property
    @pulumi.getter(name="exportFromTime")
    def export_from_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_from_time")

    @_builtins.property
    @pulumi.getter(name="exportToTime")
    def export_to_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_to_time")

    @_builtins.property
    @pulumi.getter(name="exportViewType")
    def export_view_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_view_type")


@pulumi.output_type
class TableGlobalSecondaryIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKey":
            suggest = "hash_key"
        elif key == "projectionType":
            suggest = "projection_type"
        elif key == "nonKeyAttributes":
            suggest = "non_key_attributes"
        elif key == "onDemandThroughput":
            suggest = "on_demand_throughput"
        elif key == "rangeKey":
            suggest = "range_key"
        elif key == "readCapacity":
            suggest = "read_capacity"
        elif key == "warmThroughput":
            suggest = "warm_throughput"
        elif key == "writeCapacity":
            suggest = "write_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableGlobalSecondaryIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableGlobalSecondaryIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableGlobalSecondaryIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key: _builtins.str,
                 name: _builtins.str,
                 projection_type: _builtins.str,
                 non_key_attributes: Optional[Sequence[_builtins.str]] = None,
                 on_demand_throughput: Optional['outputs.TableGlobalSecondaryIndexOnDemandThroughput'] = None,
                 range_key: Optional[_builtins.str] = None,
                 read_capacity: Optional[_builtins.int] = None,
                 warm_throughput: Optional['outputs.TableGlobalSecondaryIndexWarmThroughput'] = None,
                 write_capacity: Optional[_builtins.int] = None):
        pulumi.set(__self__, "hash_key", hash_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if on_demand_throughput is not None:
            pulumi.set(__self__, "on_demand_throughput", on_demand_throughput)
        if range_key is not None:
            pulumi.set(__self__, "range_key", range_key)
        if read_capacity is not None:
            pulumi.set(__self__, "read_capacity", read_capacity)
        if warm_throughput is not None:
            pulumi.set(__self__, "warm_throughput", warm_throughput)
        if write_capacity is not None:
            pulumi.set(__self__, "write_capacity", write_capacity)

    @_builtins.property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> _builtins.str:
        return pulumi.get(self, "hash_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> _builtins.str:
        return pulumi.get(self, "projection_type")

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "non_key_attributes")

    @_builtins.property
    @pulumi.getter(name="onDemandThroughput")
    def on_demand_throughput(self) -> Optional['outputs.TableGlobalSecondaryIndexOnDemandThroughput']:
        return pulumi.get(self, "on_demand_throughput")

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key")

    @_builtins.property
    @pulumi.getter(name="readCapacity")
    def read_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "read_capacity")

    @_builtins.property
    @pulumi.getter(name="warmThroughput")
    def warm_throughput(self) -> Optional['outputs.TableGlobalSecondaryIndexWarmThroughput']:
        return pulumi.get(self, "warm_throughput")

    @_builtins.property
    @pulumi.getter(name="writeCapacity")
    def write_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "write_capacity")


@pulumi.output_type
class TableGlobalSecondaryIndexOnDemandThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReadRequestUnits":
            suggest = "max_read_request_units"
        elif key == "maxWriteRequestUnits":
            suggest = "max_write_request_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableGlobalSecondaryIndexOnDemandThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableGlobalSecondaryIndexOnDemandThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableGlobalSecondaryIndexOnDemandThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_read_request_units: Optional[_builtins.int] = None,
                 max_write_request_units: Optional[_builtins.int] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_read_request_units")

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_write_request_units")


@pulumi.output_type
class TableGlobalSecondaryIndexWarmThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readUnitsPerSecond":
            suggest = "read_units_per_second"
        elif key == "writeUnitsPerSecond":
            suggest = "write_units_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableGlobalSecondaryIndexWarmThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableGlobalSecondaryIndexWarmThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableGlobalSecondaryIndexWarmThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_units_per_second: Optional[_builtins.int] = None,
                 write_units_per_second: Optional[_builtins.int] = None):
        if read_units_per_second is not None:
            pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        if write_units_per_second is not None:
            pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "read_units_per_second")

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "write_units_per_second")


@pulumi.output_type
class TableGlobalTableWitness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableGlobalTableWitness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableGlobalTableWitness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableGlobalTableWitness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: Optional[_builtins.str] = None):
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class TableImportTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputFormat":
            suggest = "input_format"
        elif key == "s3BucketSource":
            suggest = "s3_bucket_source"
        elif key == "inputCompressionType":
            suggest = "input_compression_type"
        elif key == "inputFormatOptions":
            suggest = "input_format_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableImportTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableImportTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableImportTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_format: _builtins.str,
                 s3_bucket_source: 'outputs.TableImportTableS3BucketSource',
                 input_compression_type: Optional[_builtins.str] = None,
                 input_format_options: Optional['outputs.TableImportTableInputFormatOptions'] = None):
        pulumi.set(__self__, "input_format", input_format)
        pulumi.set(__self__, "s3_bucket_source", s3_bucket_source)
        if input_compression_type is not None:
            pulumi.set(__self__, "input_compression_type", input_compression_type)
        if input_format_options is not None:
            pulumi.set(__self__, "input_format_options", input_format_options)

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> _builtins.str:
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> 'outputs.TableImportTableS3BucketSource':
        return pulumi.get(self, "s3_bucket_source")

    @_builtins.property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "input_compression_type")

    @_builtins.property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional['outputs.TableImportTableInputFormatOptions']:
        return pulumi.get(self, "input_format_options")


@pulumi.output_type
class TableImportTableInputFormatOptions(dict):
    def __init__(__self__, *,
                 csv: Optional['outputs.TableImportTableInputFormatOptionsCsv'] = None):
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional['outputs.TableImportTableInputFormatOptionsCsv']:
        return pulumi.get(self, "csv")


@pulumi.output_type
class TableImportTableInputFormatOptionsCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerLists":
            suggest = "header_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableImportTableInputFormatOptionsCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableImportTableInputFormatOptionsCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableImportTableInputFormatOptionsCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None,
                 header_lists: Optional[Sequence[_builtins.str]] = None):
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_lists is not None:
            pulumi.set(__self__, "header_lists", header_lists)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="headerLists")
    def header_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "header_lists")


@pulumi.output_type
class TableImportTableS3BucketSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwner":
            suggest = "bucket_owner"
        elif key == "keyPrefix":
            suggest = "key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableImportTableS3BucketSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableImportTableS3BucketSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableImportTableS3BucketSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 bucket_owner: Optional[_builtins.str] = None,
                 key_prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket", bucket)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner")

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_prefix")


@pulumi.output_type
class TableLocalSecondaryIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectionType":
            suggest = "projection_type"
        elif key == "rangeKey":
            suggest = "range_key"
        elif key == "nonKeyAttributes":
            suggest = "non_key_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableLocalSecondaryIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableLocalSecondaryIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableLocalSecondaryIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 projection_type: _builtins.str,
                 range_key: _builtins.str,
                 non_key_attributes: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        pulumi.set(__self__, "range_key", range_key)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> _builtins.str:
        return pulumi.get(self, "projection_type")

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> _builtins.str:
        return pulumi.get(self, "range_key")

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "non_key_attributes")


@pulumi.output_type
class TableOnDemandThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReadRequestUnits":
            suggest = "max_read_request_units"
        elif key == "maxWriteRequestUnits":
            suggest = "max_write_request_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableOnDemandThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableOnDemandThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableOnDemandThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_read_request_units: Optional[_builtins.int] = None,
                 max_write_request_units: Optional[_builtins.int] = None):
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_read_request_units")

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_write_request_units")


@pulumi.output_type
class TablePointInTimeRecovery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryPeriodInDays":
            suggest = "recovery_period_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TablePointInTimeRecovery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TablePointInTimeRecovery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TablePointInTimeRecovery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 recovery_period_in_days: Optional[_builtins.int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if recovery_period_in_days is not None:
            pulumi.set(__self__, "recovery_period_in_days", recovery_period_in_days)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="recoveryPeriodInDays")
    def recovery_period_in_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "recovery_period_in_days")


@pulumi.output_type
class TableReplica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "consistencyMode":
            suggest = "consistency_mode"
        elif key == "deletionProtectionEnabled":
            suggest = "deletion_protection_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"
        elif key == "pointInTimeRecovery":
            suggest = "point_in_time_recovery"
        elif key == "propagateTags":
            suggest = "propagate_tags"
        elif key == "streamArn":
            suggest = "stream_arn"
        elif key == "streamLabel":
            suggest = "stream_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableReplica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableReplica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableReplica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str,
                 arn: Optional[_builtins.str] = None,
                 consistency_mode: Optional[_builtins.str] = None,
                 deletion_protection_enabled: Optional[_builtins.bool] = None,
                 kms_key_arn: Optional[_builtins.str] = None,
                 point_in_time_recovery: Optional[_builtins.bool] = None,
                 propagate_tags: Optional[_builtins.bool] = None,
                 stream_arn: Optional[_builtins.str] = None,
                 stream_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "region_name", region_name)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if consistency_mode is not None:
            pulumi.set(__self__, "consistency_mode", consistency_mode)
        if deletion_protection_enabled is not None:
            pulumi.set(__self__, "deletion_protection_enabled", deletion_protection_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if point_in_time_recovery is not None:
            pulumi.set(__self__, "point_in_time_recovery", point_in_time_recovery)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)
        if stream_label is not None:
            pulumi.set(__self__, "stream_label", stream_label)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="consistencyMode")
    def consistency_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "consistency_mode")

    @_builtins.property
    @pulumi.getter(name="deletionProtectionEnabled")
    def deletion_protection_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "deletion_protection_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_arn")

    @_builtins.property
    @pulumi.getter(name="pointInTimeRecovery")
    def point_in_time_recovery(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "propagate_tags")

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stream_arn")

    @_builtins.property
    @pulumi.getter(name="streamLabel")
    def stream_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stream_label")


@pulumi.output_type
class TableServerSideEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableServerSideEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableServerSideEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableServerSideEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kms_key_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class TableTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attribute_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TableWarmThroughput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readUnitsPerSecond":
            suggest = "read_units_per_second"
        elif key == "writeUnitsPerSecond":
            suggest = "write_units_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableWarmThroughput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableWarmThroughput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableWarmThroughput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_units_per_second: Optional[_builtins.int] = None,
                 write_units_per_second: Optional[_builtins.int] = None):
        if read_units_per_second is not None:
            pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        if write_units_per_second is not None:
            pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "read_units_per_second")

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "write_units_per_second")


@pulumi.output_type
class GetTableAttributeResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTableGlobalSecondaryIndexResult(dict):
    def __init__(__self__, *,
                 hash_key: _builtins.str,
                 name: _builtins.str,
                 non_key_attributes: Sequence[_builtins.str],
                 on_demand_throughputs: Sequence['outputs.GetTableGlobalSecondaryIndexOnDemandThroughputResult'],
                 projection_type: _builtins.str,
                 range_key: _builtins.str,
                 read_capacity: _builtins.int,
                 warm_throughputs: Sequence['outputs.GetTableGlobalSecondaryIndexWarmThroughputResult'],
                 write_capacity: _builtins.int):
        pulumi.set(__self__, "hash_key", hash_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        pulumi.set(__self__, "on_demand_throughputs", on_demand_throughputs)
        pulumi.set(__self__, "projection_type", projection_type)
        pulumi.set(__self__, "range_key", range_key)
        pulumi.set(__self__, "read_capacity", read_capacity)
        pulumi.set(__self__, "warm_throughputs", warm_throughputs)
        pulumi.set(__self__, "write_capacity", write_capacity)

    @_builtins.property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> _builtins.str:
        return pulumi.get(self, "hash_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "non_key_attributes")

    @_builtins.property
    @pulumi.getter(name="onDemandThroughputs")
    def on_demand_throughputs(self) -> Sequence['outputs.GetTableGlobalSecondaryIndexOnDemandThroughputResult']:
        return pulumi.get(self, "on_demand_throughputs")

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> _builtins.str:
        return pulumi.get(self, "projection_type")

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> _builtins.str:
        return pulumi.get(self, "range_key")

    @_builtins.property
    @pulumi.getter(name="readCapacity")
    def read_capacity(self) -> _builtins.int:
        return pulumi.get(self, "read_capacity")

    @_builtins.property
    @pulumi.getter(name="warmThroughputs")
    def warm_throughputs(self) -> Sequence['outputs.GetTableGlobalSecondaryIndexWarmThroughputResult']:
        return pulumi.get(self, "warm_throughputs")

    @_builtins.property
    @pulumi.getter(name="writeCapacity")
    def write_capacity(self) -> _builtins.int:
        return pulumi.get(self, "write_capacity")


@pulumi.output_type
class GetTableGlobalSecondaryIndexOnDemandThroughputResult(dict):
    def __init__(__self__, *,
                 max_read_request_units: _builtins.int,
                 max_write_request_units: _builtins.int):
        pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> _builtins.int:
        return pulumi.get(self, "max_read_request_units")

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> _builtins.int:
        return pulumi.get(self, "max_write_request_units")


@pulumi.output_type
class GetTableGlobalSecondaryIndexWarmThroughputResult(dict):
    def __init__(__self__, *,
                 read_units_per_second: _builtins.int,
                 write_units_per_second: _builtins.int):
        pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "read_units_per_second")

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "write_units_per_second")


@pulumi.output_type
class GetTableLocalSecondaryIndexResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 non_key_attributes: Sequence[_builtins.str],
                 projection_type: _builtins.str,
                 range_key: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        pulumi.set(__self__, "projection_type", projection_type)
        pulumi.set(__self__, "range_key", range_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "non_key_attributes")

    @_builtins.property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> _builtins.str:
        return pulumi.get(self, "projection_type")

    @_builtins.property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> _builtins.str:
        return pulumi.get(self, "range_key")


@pulumi.output_type
class GetTableOnDemandThroughputResult(dict):
    def __init__(__self__, *,
                 max_read_request_units: _builtins.int,
                 max_write_request_units: _builtins.int):
        pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @_builtins.property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> _builtins.int:
        return pulumi.get(self, "max_read_request_units")

    @_builtins.property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> _builtins.int:
        return pulumi.get(self, "max_write_request_units")


@pulumi.output_type
class GetTablePointInTimeRecoveryResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 recovery_period_in_days: _builtins.int):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "recovery_period_in_days", recovery_period_in_days)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="recoveryPeriodInDays")
    def recovery_period_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_period_in_days")


@pulumi.output_type
class GetTableReplicaResult(dict):
    def __init__(__self__, *,
                 kms_key_arn: _builtins.str,
                 region_name: _builtins.str):
        pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_arn")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetTableServerSideEncryptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kms_key_arn: _builtins.str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class GetTableTtlResult(dict):
    def __init__(__self__, *,
                 attribute_name: _builtins.str,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> _builtins.str:
        return pulumi.get(self, "attribute_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetTableWarmThroughputResult(dict):
    def __init__(__self__, *,
                 read_units_per_second: _builtins.int,
                 write_units_per_second: _builtins.int):
        pulumi.set(__self__, "read_units_per_second", read_units_per_second)
        pulumi.set(__self__, "write_units_per_second", write_units_per_second)

    @_builtins.property
    @pulumi.getter(name="readUnitsPerSecond")
    def read_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "read_units_per_second")

    @_builtins.property
    @pulumi.getter(name="writeUnitsPerSecond")
    def write_units_per_second(self) -> _builtins.int:
        return pulumi.get(self, "write_units_per_second")


