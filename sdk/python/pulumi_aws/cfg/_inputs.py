# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConfigurationAggregatorAccountAggregationSourceArgs',
    'ConfigurationAggregatorAccountAggregationSourceArgsDict',
    'ConfigurationAggregatorOrganizationAggregationSourceArgs',
    'ConfigurationAggregatorOrganizationAggregationSourceArgsDict',
    'ConformancePackInputParameterArgs',
    'ConformancePackInputParameterArgsDict',
    'DeliveryChannelSnapshotDeliveryPropertiesArgs',
    'DeliveryChannelSnapshotDeliveryPropertiesArgsDict',
    'OrganizationConformancePackInputParameterArgs',
    'OrganizationConformancePackInputParameterArgsDict',
    'RecorderRecordingGroupArgs',
    'RecorderRecordingGroupArgsDict',
    'RecorderRecordingGroupExclusionByResourceTypeArgs',
    'RecorderRecordingGroupExclusionByResourceTypeArgsDict',
    'RecorderRecordingGroupRecordingStrategyArgs',
    'RecorderRecordingGroupRecordingStrategyArgsDict',
    'RecorderRecordingModeArgs',
    'RecorderRecordingModeArgsDict',
    'RecorderRecordingModeRecordingModeOverrideArgs',
    'RecorderRecordingModeRecordingModeOverrideArgsDict',
    'RemediationConfigurationExecutionControlsArgs',
    'RemediationConfigurationExecutionControlsArgsDict',
    'RemediationConfigurationExecutionControlsSsmControlsArgs',
    'RemediationConfigurationExecutionControlsSsmControlsArgsDict',
    'RemediationConfigurationParameterArgs',
    'RemediationConfigurationParameterArgsDict',
    'RuleEvaluationModeArgs',
    'RuleEvaluationModeArgsDict',
    'RuleScopeArgs',
    'RuleScopeArgsDict',
    'RuleSourceArgs',
    'RuleSourceArgsDict',
    'RuleSourceCustomPolicyDetailsArgs',
    'RuleSourceCustomPolicyDetailsArgsDict',
    'RuleSourceSourceDetailArgs',
    'RuleSourceSourceDetailArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigurationAggregatorAccountAggregationSourceArgsDict(TypedDict):
        account_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        all_regions: NotRequired[pulumi.Input[_builtins.bool]]
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfigurationAggregatorAccountAggregationSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationAggregatorAccountAggregationSourceArgs:
    def __init__(__self__, *,
                 account_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 all_regions: Optional[pulumi.Input[_builtins.bool]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "account_ids", account_ids)
        if all_regions is not None:
            pulumi.set(__self__, "all_regions", all_regions)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="allRegions")
    def all_regions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "all_regions")

    @all_regions.setter
    def all_regions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_regions", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regions", value)


if not MYPY:
    class ConfigurationAggregatorOrganizationAggregationSourceArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        all_regions: NotRequired[pulumi.Input[_builtins.bool]]
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfigurationAggregatorOrganizationAggregationSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationAggregatorOrganizationAggregationSourceArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 all_regions: Optional[pulumi.Input[_builtins.bool]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if all_regions is not None:
            pulumi.set(__self__, "all_regions", all_regions)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="allRegions")
    def all_regions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "all_regions")

    @all_regions.setter
    def all_regions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_regions", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regions", value)


if not MYPY:
    class ConformancePackInputParameterArgsDict(TypedDict):
        parameter_name: pulumi.Input[_builtins.str]
        parameter_value: pulumi.Input[_builtins.str]
elif False:
    ConformancePackInputParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConformancePackInputParameterArgs:
    def __init__(__self__, *,
                 parameter_name: pulumi.Input[_builtins.str],
                 parameter_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "parameter_name", parameter_name)
        pulumi.set(__self__, "parameter_value", parameter_value)

    @_builtins.property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "parameter_name")

    @parameter_name.setter
    def parameter_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parameter_name", value)

    @_builtins.property
    @pulumi.getter(name="parameterValue")
    def parameter_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "parameter_value")

    @parameter_value.setter
    def parameter_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parameter_value", value)


if not MYPY:
    class DeliveryChannelSnapshotDeliveryPropertiesArgsDict(TypedDict):
        delivery_frequency: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeliveryChannelSnapshotDeliveryPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryChannelSnapshotDeliveryPropertiesArgs:
    def __init__(__self__, *,
                 delivery_frequency: Optional[pulumi.Input[_builtins.str]] = None):
        if delivery_frequency is not None:
            pulumi.set(__self__, "delivery_frequency", delivery_frequency)

    @_builtins.property
    @pulumi.getter(name="deliveryFrequency")
    def delivery_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delivery_frequency")

    @delivery_frequency.setter
    def delivery_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delivery_frequency", value)


if not MYPY:
    class OrganizationConformancePackInputParameterArgsDict(TypedDict):
        parameter_name: pulumi.Input[_builtins.str]
        parameter_value: pulumi.Input[_builtins.str]
elif False:
    OrganizationConformancePackInputParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationConformancePackInputParameterArgs:
    def __init__(__self__, *,
                 parameter_name: pulumi.Input[_builtins.str],
                 parameter_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "parameter_name", parameter_name)
        pulumi.set(__self__, "parameter_value", parameter_value)

    @_builtins.property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "parameter_name")

    @parameter_name.setter
    def parameter_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parameter_name", value)

    @_builtins.property
    @pulumi.getter(name="parameterValue")
    def parameter_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "parameter_value")

    @parameter_value.setter
    def parameter_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parameter_value", value)


if not MYPY:
    class RecorderRecordingGroupArgsDict(TypedDict):
        all_supported: NotRequired[pulumi.Input[_builtins.bool]]
        exclusion_by_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupExclusionByResourceTypeArgsDict']]]]
        include_global_resource_types: NotRequired[pulumi.Input[_builtins.bool]]
        recording_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupRecordingStrategyArgsDict']]]]
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RecorderRecordingGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecorderRecordingGroupArgs:
    def __init__(__self__, *,
                 all_supported: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclusion_by_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupExclusionByResourceTypeArgs']]]] = None,
                 include_global_resource_types: Optional[pulumi.Input[_builtins.bool]] = None,
                 recording_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupRecordingStrategyArgs']]]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all_supported is not None:
            pulumi.set(__self__, "all_supported", all_supported)
        if exclusion_by_resource_types is not None:
            pulumi.set(__self__, "exclusion_by_resource_types", exclusion_by_resource_types)
        if include_global_resource_types is not None:
            pulumi.set(__self__, "include_global_resource_types", include_global_resource_types)
        if recording_strategies is not None:
            pulumi.set(__self__, "recording_strategies", recording_strategies)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @_builtins.property
    @pulumi.getter(name="allSupported")
    def all_supported(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "all_supported")

    @all_supported.setter
    def all_supported(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_supported", value)

    @_builtins.property
    @pulumi.getter(name="exclusionByResourceTypes")
    def exclusion_by_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupExclusionByResourceTypeArgs']]]]:
        return pulumi.get(self, "exclusion_by_resource_types")

    @exclusion_by_resource_types.setter
    def exclusion_by_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupExclusionByResourceTypeArgs']]]]):
        pulumi.set(self, "exclusion_by_resource_types", value)

    @_builtins.property
    @pulumi.getter(name="includeGlobalResourceTypes")
    def include_global_resource_types(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_global_resource_types")

    @include_global_resource_types.setter
    def include_global_resource_types(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_global_resource_types", value)

    @_builtins.property
    @pulumi.getter(name="recordingStrategies")
    def recording_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupRecordingStrategyArgs']]]]:
        return pulumi.get(self, "recording_strategies")

    @recording_strategies.setter
    def recording_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecorderRecordingGroupRecordingStrategyArgs']]]]):
        pulumi.set(self, "recording_strategies", value)

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_types", value)


if not MYPY:
    class RecorderRecordingGroupExclusionByResourceTypeArgsDict(TypedDict):
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RecorderRecordingGroupExclusionByResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecorderRecordingGroupExclusionByResourceTypeArgs:
    def __init__(__self__, *,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_types", value)


if not MYPY:
    class RecorderRecordingGroupRecordingStrategyArgsDict(TypedDict):
        use_only: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecorderRecordingGroupRecordingStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecorderRecordingGroupRecordingStrategyArgs:
    def __init__(__self__, *,
                 use_only: Optional[pulumi.Input[_builtins.str]] = None):
        if use_only is not None:
            pulumi.set(__self__, "use_only", use_only)

    @_builtins.property
    @pulumi.getter(name="useOnly")
    def use_only(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "use_only")

    @use_only.setter
    def use_only(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use_only", value)


if not MYPY:
    class RecorderRecordingModeArgsDict(TypedDict):
        recording_frequency: NotRequired[pulumi.Input[_builtins.str]]
        recording_mode_override: NotRequired[pulumi.Input['RecorderRecordingModeRecordingModeOverrideArgsDict']]
elif False:
    RecorderRecordingModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecorderRecordingModeArgs:
    def __init__(__self__, *,
                 recording_frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 recording_mode_override: Optional[pulumi.Input['RecorderRecordingModeRecordingModeOverrideArgs']] = None):
        if recording_frequency is not None:
            pulumi.set(__self__, "recording_frequency", recording_frequency)
        if recording_mode_override is not None:
            pulumi.set(__self__, "recording_mode_override", recording_mode_override)

    @_builtins.property
    @pulumi.getter(name="recordingFrequency")
    def recording_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recording_frequency")

    @recording_frequency.setter
    def recording_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recording_frequency", value)

    @_builtins.property
    @pulumi.getter(name="recordingModeOverride")
    def recording_mode_override(self) -> Optional[pulumi.Input['RecorderRecordingModeRecordingModeOverrideArgs']]:
        return pulumi.get(self, "recording_mode_override")

    @recording_mode_override.setter
    def recording_mode_override(self, value: Optional[pulumi.Input['RecorderRecordingModeRecordingModeOverrideArgs']]):
        pulumi.set(self, "recording_mode_override", value)


if not MYPY:
    class RecorderRecordingModeRecordingModeOverrideArgsDict(TypedDict):
        recording_frequency: pulumi.Input[_builtins.str]
        resource_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RecorderRecordingModeRecordingModeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecorderRecordingModeRecordingModeOverrideArgs:
    def __init__(__self__, *,
                 recording_frequency: pulumi.Input[_builtins.str],
                 resource_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "recording_frequency", recording_frequency)
        pulumi.set(__self__, "resource_types", resource_types)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="recordingFrequency")
    def recording_frequency(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "recording_frequency")

    @recording_frequency.setter
    def recording_frequency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "recording_frequency", value)

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resource_types", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class RemediationConfigurationExecutionControlsArgsDict(TypedDict):
        ssm_controls: NotRequired[pulumi.Input['RemediationConfigurationExecutionControlsSsmControlsArgsDict']]
elif False:
    RemediationConfigurationExecutionControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationConfigurationExecutionControlsArgs:
    def __init__(__self__, *,
                 ssm_controls: Optional[pulumi.Input['RemediationConfigurationExecutionControlsSsmControlsArgs']] = None):
        if ssm_controls is not None:
            pulumi.set(__self__, "ssm_controls", ssm_controls)

    @_builtins.property
    @pulumi.getter(name="ssmControls")
    def ssm_controls(self) -> Optional[pulumi.Input['RemediationConfigurationExecutionControlsSsmControlsArgs']]:
        return pulumi.get(self, "ssm_controls")

    @ssm_controls.setter
    def ssm_controls(self, value: Optional[pulumi.Input['RemediationConfigurationExecutionControlsSsmControlsArgs']]):
        pulumi.set(self, "ssm_controls", value)


if not MYPY:
    class RemediationConfigurationExecutionControlsSsmControlsArgsDict(TypedDict):
        concurrent_execution_rate_percentage: NotRequired[pulumi.Input[_builtins.int]]
        error_percentage: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    RemediationConfigurationExecutionControlsSsmControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationConfigurationExecutionControlsSsmControlsArgs:
    def __init__(__self__, *,
                 concurrent_execution_rate_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 error_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        if concurrent_execution_rate_percentage is not None:
            pulumi.set(__self__, "concurrent_execution_rate_percentage", concurrent_execution_rate_percentage)
        if error_percentage is not None:
            pulumi.set(__self__, "error_percentage", error_percentage)

    @_builtins.property
    @pulumi.getter(name="concurrentExecutionRatePercentage")
    def concurrent_execution_rate_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "concurrent_execution_rate_percentage")

    @concurrent_execution_rate_percentage.setter
    def concurrent_execution_rate_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concurrent_execution_rate_percentage", value)

    @_builtins.property
    @pulumi.getter(name="errorPercentage")
    def error_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "error_percentage")

    @error_percentage.setter
    def error_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "error_percentage", value)


if not MYPY:
    class RemediationConfigurationParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        resource_value: NotRequired[pulumi.Input[_builtins.str]]
        static_value: NotRequired[pulumi.Input[_builtins.str]]
        static_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RemediationConfigurationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationConfigurationParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 resource_value: Optional[pulumi.Input[_builtins.str]] = None,
                 static_value: Optional[pulumi.Input[_builtins.str]] = None,
                 static_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "name", name)
        if resource_value is not None:
            pulumi.set(__self__, "resource_value", resource_value)
        if static_value is not None:
            pulumi.set(__self__, "static_value", static_value)
        if static_values is not None:
            pulumi.set(__self__, "static_values", static_values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceValue")
    def resource_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_value")

    @resource_value.setter
    def resource_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_value", value)

    @_builtins.property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "static_value")

    @static_value.setter
    def static_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_value", value)

    @_builtins.property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "static_values")

    @static_values.setter
    def static_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "static_values", value)


if not MYPY:
    class RuleEvaluationModeArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleEvaluationModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEvaluationModeArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class RuleScopeArgsDict(TypedDict):
        compliance_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        compliance_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        tag_key: NotRequired[pulumi.Input[_builtins.str]]
        tag_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleScopeArgs:
    def __init__(__self__, *,
                 compliance_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tag_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_value: Optional[pulumi.Input[_builtins.str]] = None):
        if compliance_resource_id is not None:
            pulumi.set(__self__, "compliance_resource_id", compliance_resource_id)
        if compliance_resource_types is not None:
            pulumi.set(__self__, "compliance_resource_types", compliance_resource_types)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="complianceResourceId")
    def compliance_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "compliance_resource_id")

    @compliance_resource_id.setter
    def compliance_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compliance_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="complianceResourceTypes")
    def compliance_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "compliance_resource_types")

    @compliance_resource_types.setter
    def compliance_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "compliance_resource_types", value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class RuleSourceArgsDict(TypedDict):
        owner: pulumi.Input[_builtins.str]
        custom_policy_details: NotRequired[pulumi.Input['RuleSourceCustomPolicyDetailsArgsDict']]
        source_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleSourceSourceDetailArgsDict']]]]
        source_identifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSourceArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[_builtins.str],
                 custom_policy_details: Optional[pulumi.Input['RuleSourceCustomPolicyDetailsArgs']] = None,
                 source_details: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSourceSourceDetailArgs']]]] = None,
                 source_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "owner", owner)
        if custom_policy_details is not None:
            pulumi.set(__self__, "custom_policy_details", custom_policy_details)
        if source_details is not None:
            pulumi.set(__self__, "source_details", source_details)
        if source_identifier is not None:
            pulumi.set(__self__, "source_identifier", source_identifier)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter(name="customPolicyDetails")
    def custom_policy_details(self) -> Optional[pulumi.Input['RuleSourceCustomPolicyDetailsArgs']]:
        return pulumi.get(self, "custom_policy_details")

    @custom_policy_details.setter
    def custom_policy_details(self, value: Optional[pulumi.Input['RuleSourceCustomPolicyDetailsArgs']]):
        pulumi.set(self, "custom_policy_details", value)

    @_builtins.property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleSourceSourceDetailArgs']]]]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSourceSourceDetailArgs']]]]):
        pulumi.set(self, "source_details", value)

    @_builtins.property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_identifier")

    @source_identifier.setter
    def source_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_identifier", value)


if not MYPY:
    class RuleSourceCustomPolicyDetailsArgsDict(TypedDict):
        policy_runtime: pulumi.Input[_builtins.str]
        policy_text: pulumi.Input[_builtins.str]
        enable_debug_log_delivery: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    RuleSourceCustomPolicyDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSourceCustomPolicyDetailsArgs:
    def __init__(__self__, *,
                 policy_runtime: pulumi.Input[_builtins.str],
                 policy_text: pulumi.Input[_builtins.str],
                 enable_debug_log_delivery: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "policy_runtime", policy_runtime)
        pulumi.set(__self__, "policy_text", policy_text)
        if enable_debug_log_delivery is not None:
            pulumi.set(__self__, "enable_debug_log_delivery", enable_debug_log_delivery)

    @_builtins.property
    @pulumi.getter(name="policyRuntime")
    def policy_runtime(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "policy_runtime")

    @policy_runtime.setter
    def policy_runtime(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_runtime", value)

    @_builtins.property
    @pulumi.getter(name="policyText")
    def policy_text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "policy_text")

    @policy_text.setter
    def policy_text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_text", value)

    @_builtins.property
    @pulumi.getter(name="enableDebugLogDelivery")
    def enable_debug_log_delivery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_debug_log_delivery")

    @enable_debug_log_delivery.setter
    def enable_debug_log_delivery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_debug_log_delivery", value)


if not MYPY:
    class RuleSourceSourceDetailArgsDict(TypedDict):
        event_source: NotRequired[pulumi.Input[_builtins.str]]
        maximum_execution_frequency: NotRequired[pulumi.Input[_builtins.str]]
        message_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleSourceSourceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSourceSourceDetailArgs:
    def __init__(__self__, *,
                 event_source: Optional[pulumi.Input[_builtins.str]] = None,
                 maximum_execution_frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None):
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if maximum_execution_frequency is not None:
            pulumi.set(__self__, "maximum_execution_frequency", maximum_execution_frequency)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="maximumExecutionFrequency")
    def maximum_execution_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "maximum_execution_frequency")

    @maximum_execution_frequency.setter
    def maximum_execution_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_execution_frequency", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)


