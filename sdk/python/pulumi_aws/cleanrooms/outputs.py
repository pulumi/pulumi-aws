# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CollaborationDataEncryptionMetadata',
    'CollaborationMember',
    'ConfiguredTableTableReference',
]

@pulumi.output_type
class CollaborationDataEncryptionMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowClearText":
            suggest = "allow_clear_text"
        elif key == "allowDuplicates":
            suggest = "allow_duplicates"
        elif key == "allowJoinsOnColumnsWithDifferentNames":
            suggest = "allow_joins_on_columns_with_different_names"
        elif key == "preserveNulls":
            suggest = "preserve_nulls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationDataEncryptionMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_clear_text: bool,
                 allow_duplicates: bool,
                 allow_joins_on_columns_with_different_names: bool,
                 preserve_nulls: bool):
        CollaborationDataEncryptionMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_clear_text=allow_clear_text,
            allow_duplicates=allow_duplicates,
            allow_joins_on_columns_with_different_names=allow_joins_on_columns_with_different_names,
            preserve_nulls=preserve_nulls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_clear_text: Optional[bool] = None,
             allow_duplicates: Optional[bool] = None,
             allow_joins_on_columns_with_different_names: Optional[bool] = None,
             preserve_nulls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_clear_text is None and 'allowClearText' in kwargs:
            allow_clear_text = kwargs['allowClearText']
        if allow_clear_text is None:
            raise TypeError("Missing 'allow_clear_text' argument")
        if allow_duplicates is None and 'allowDuplicates' in kwargs:
            allow_duplicates = kwargs['allowDuplicates']
        if allow_duplicates is None:
            raise TypeError("Missing 'allow_duplicates' argument")
        if allow_joins_on_columns_with_different_names is None and 'allowJoinsOnColumnsWithDifferentNames' in kwargs:
            allow_joins_on_columns_with_different_names = kwargs['allowJoinsOnColumnsWithDifferentNames']
        if allow_joins_on_columns_with_different_names is None:
            raise TypeError("Missing 'allow_joins_on_columns_with_different_names' argument")
        if preserve_nulls is None and 'preserveNulls' in kwargs:
            preserve_nulls = kwargs['preserveNulls']
        if preserve_nulls is None:
            raise TypeError("Missing 'preserve_nulls' argument")

        _setter("allow_clear_text", allow_clear_text)
        _setter("allow_duplicates", allow_duplicates)
        _setter("allow_joins_on_columns_with_different_names", allow_joins_on_columns_with_different_names)
        _setter("preserve_nulls", preserve_nulls)

    @property
    @pulumi.getter(name="allowClearText")
    def allow_clear_text(self) -> bool:
        return pulumi.get(self, "allow_clear_text")

    @property
    @pulumi.getter(name="allowDuplicates")
    def allow_duplicates(self) -> bool:
        return pulumi.get(self, "allow_duplicates")

    @property
    @pulumi.getter(name="allowJoinsOnColumnsWithDifferentNames")
    def allow_joins_on_columns_with_different_names(self) -> bool:
        return pulumi.get(self, "allow_joins_on_columns_with_different_names")

    @property
    @pulumi.getter(name="preserveNulls")
    def preserve_nulls(self) -> bool:
        return pulumi.get(self, "preserve_nulls")


@pulumi.output_type
class CollaborationMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "memberAbilities":
            suggest = "member_abilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 display_name: str,
                 member_abilities: Sequence[str],
                 status: Optional[str] = None):
        CollaborationMember._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            display_name=display_name,
            member_abilities=member_abilities,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             display_name: Optional[str] = None,
             member_abilities: Optional[Sequence[str]] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if member_abilities is None and 'memberAbilities' in kwargs:
            member_abilities = kwargs['memberAbilities']
        if member_abilities is None:
            raise TypeError("Missing 'member_abilities' argument")

        _setter("account_id", account_id)
        _setter("display_name", display_name)
        _setter("member_abilities", member_abilities)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="memberAbilities")
    def member_abilities(self) -> Sequence[str]:
        return pulumi.get(self, "member_abilities")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class ConfiguredTableTableReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableTableReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableTableReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableTableReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 table_name: str):
        ConfiguredTableTableReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             table_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("database_name", database_name)
        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")


