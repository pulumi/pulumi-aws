# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CertificateDomainValidationOptionArgs',
    'ContainerServiceDeploymentVersionContainerArgs',
    'ContainerServiceDeploymentVersionPublicEndpointArgs',
    'ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs',
    'ContainerServicePrivateRegistryAccessArgs',
    'ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs',
    'ContainerServicePublicDomainNamesArgs',
    'ContainerServicePublicDomainNamesCertificateArgs',
    'DistributionCacheBehaviorArgs',
    'DistributionCacheBehaviorSettingsArgs',
    'DistributionCacheBehaviorSettingsForwardedCookiesArgs',
    'DistributionCacheBehaviorSettingsForwardedHeadersArgs',
    'DistributionCacheBehaviorSettingsForwardedQueryStringsArgs',
    'DistributionDefaultCacheBehaviorArgs',
    'DistributionLocationArgs',
    'DistributionOriginArgs',
    'InstanceAddOnArgs',
    'InstancePublicPortsPortInfoArgs',
    'LbCertificateDomainValidationRecordArgs',
]

@pulumi.input_type
class CertificateDomainValidationOptionArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 resource_record_name: Optional[pulumi.Input[str]] = None,
                 resource_record_type: Optional[pulumi.Input[str]] = None,
                 resource_record_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain_name: A domain name for which the certificate should be issued.
        """
        CertificateDomainValidationOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            resource_record_name=resource_record_name,
            resource_record_type=resource_record_type,
            resource_record_value=resource_record_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[pulumi.Input[str]] = None,
             resource_record_name: Optional[pulumi.Input[str]] = None,
             resource_record_type: Optional[pulumi.Input[str]] = None,
             resource_record_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if resource_record_name is None and 'resourceRecordName' in kwargs:
            resource_record_name = kwargs['resourceRecordName']
        if resource_record_type is None and 'resourceRecordType' in kwargs:
            resource_record_type = kwargs['resourceRecordType']
        if resource_record_value is None and 'resourceRecordValue' in kwargs:
            resource_record_value = kwargs['resourceRecordValue']

        if domain_name is not None:
            _setter("domain_name", domain_name)
        if resource_record_name is not None:
            _setter("resource_record_name", resource_record_name)
        if resource_record_type is not None:
            _setter("resource_record_type", resource_record_type)
        if resource_record_value is not None:
            _setter("resource_record_value", resource_record_value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        A domain name for which the certificate should be issued.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="resourceRecordName")
    def resource_record_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_name")

    @resource_record_name.setter
    def resource_record_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_name", value)

    @property
    @pulumi.getter(name="resourceRecordType")
    def resource_record_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_type")

    @resource_record_type.setter
    def resource_record_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_type", value)

    @property
    @pulumi.getter(name="resourceRecordValue")
    def resource_record_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_value")

    @resource_record_value.setter
    def resource_record_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_value", value)


@pulumi.input_type
class ContainerServiceDeploymentVersionContainerArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[str],
                 image: pulumi.Input[str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environment: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] container_name: The name for the container.
        :param pulumi.Input[str] image: The name of the image used for the container. Container images sourced from your Lightsail container service, that are registered and stored on your service, start with a colon (`:`). For example, `:container-service-1.mystaticwebsite.1`. Container images sourced from a public registry like Docker Hub don't start with a colon. For example, `nginx:latest` or `nginx`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: The launch command for the container. A list of string.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment: A key-value map of the environment variables of the container.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] ports: A key-value map of the open firewall ports of the container. Valid values: `HTTP`, `HTTPS`, `TCP`, `UDP`.
        """
        ContainerServiceDeploymentVersionContainerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_name=container_name,
            image=image,
            commands=commands,
            environment=environment,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_name: Optional[pulumi.Input[str]] = None,
             image: Optional[pulumi.Input[str]] = None,
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             environment: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             ports: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if image is None:
            raise TypeError("Missing 'image' argument")

        _setter("container_name", container_name)
        _setter("image", image)
        if commands is not None:
            _setter("commands", commands)
        if environment is not None:
            _setter("environment", environment)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[str]:
        """
        The name for the container.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The name of the image used for the container. Container images sourced from your Lightsail container service, that are registered and stored on your service, start with a colon (`:`). For example, `:container-service-1.mystaticwebsite.1`. Container images sourced from a public registry like Docker Hub don't start with a colon. For example, `nginx:latest` or `nginx`.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The launch command for the container. A list of string.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A key-value map of the environment variables of the container.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A key-value map of the open firewall ports of the container. Valid values: `HTTP`, `HTTPS`, `TCP`, `UDP`.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


@pulumi.input_type
class ContainerServiceDeploymentVersionPublicEndpointArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[str],
                 container_port: pulumi.Input[int],
                 health_check: pulumi.Input['ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs']):
        """
        :param pulumi.Input[str] container_name: The name of the container for the endpoint.
        :param pulumi.Input[int] container_port: The port of the container to which traffic is forwarded to.
        :param pulumi.Input['ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs'] health_check: A configuration block that describes the health check configuration of the container. Detailed below.
        """
        ContainerServiceDeploymentVersionPublicEndpointArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_name=container_name,
            container_port=container_port,
            health_check=health_check,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_name: Optional[pulumi.Input[str]] = None,
             container_port: Optional[pulumi.Input[int]] = None,
             health_check: Optional[pulumi.Input['ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if container_port is None and 'containerPort' in kwargs:
            container_port = kwargs['containerPort']
        if container_port is None:
            raise TypeError("Missing 'container_port' argument")
        if health_check is None and 'healthCheck' in kwargs:
            health_check = kwargs['healthCheck']
        if health_check is None:
            raise TypeError("Missing 'health_check' argument")

        _setter("container_name", container_name)
        _setter("container_port", container_port)
        _setter("health_check", health_check)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[str]:
        """
        The name of the container for the endpoint.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[int]:
        """
        The port of the container to which traffic is forwarded to.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "container_port", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> pulumi.Input['ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs']:
        """
        A configuration block that describes the health check configuration of the container. Detailed below.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: pulumi.Input['ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs']):
        pulumi.set(self, "health_check", value)


@pulumi.input_type
class ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs:
    def __init__(__self__, *,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 interval_seconds: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 success_codes: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] healthy_threshold: The number of consecutive health checks successes required before moving the container to the Healthy state. Defaults to 2.
        :param pulumi.Input[int] interval_seconds: The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. Defaults to 5.
        :param pulumi.Input[str] path: The path on the container on which to perform the health check. Defaults to "/".
        :param pulumi.Input[str] success_codes: The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. Defaults to "200-499".
        :param pulumi.Input[int] timeout_seconds: The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. Defaults to 2.
        :param pulumi.Input[int] unhealthy_threshold: The number of consecutive health checks failures required before moving the container to the Unhealthy state. Defaults to 2.
        """
        ContainerServiceDeploymentVersionPublicEndpointHealthCheckArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy_threshold=healthy_threshold,
            interval_seconds=interval_seconds,
            path=path,
            success_codes=success_codes,
            timeout_seconds=timeout_seconds,
            unhealthy_threshold=unhealthy_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy_threshold: Optional[pulumi.Input[int]] = None,
             interval_seconds: Optional[pulumi.Input[int]] = None,
             path: Optional[pulumi.Input[str]] = None,
             success_codes: Optional[pulumi.Input[str]] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             unhealthy_threshold: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if interval_seconds is None and 'intervalSeconds' in kwargs:
            interval_seconds = kwargs['intervalSeconds']
        if success_codes is None and 'successCodes' in kwargs:
            success_codes = kwargs['successCodes']
        if timeout_seconds is None and 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']

        if healthy_threshold is not None:
            _setter("healthy_threshold", healthy_threshold)
        if interval_seconds is not None:
            _setter("interval_seconds", interval_seconds)
        if path is not None:
            _setter("path", path)
        if success_codes is not None:
            _setter("success_codes", success_codes)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)
        if unhealthy_threshold is not None:
            _setter("unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of consecutive health checks successes required before moving the container to the Healthy state. Defaults to 2.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. Defaults to 5.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path on the container on which to perform the health check. Defaults to "/".
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. Defaults to "200-499".
        """
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success_codes", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. Defaults to 2.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of consecutive health checks failures required before moving the container to the Unhealthy state. Defaults to 2.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


@pulumi.input_type
class ContainerServicePrivateRegistryAccessArgs:
    def __init__(__self__, *,
                 ecr_image_puller_role: Optional[pulumi.Input['ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs']] = None):
        """
        :param pulumi.Input['ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs'] ecr_image_puller_role: Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
        """
        ContainerServicePrivateRegistryAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ecr_image_puller_role=ecr_image_puller_role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ecr_image_puller_role: Optional[pulumi.Input['ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ecr_image_puller_role is None and 'ecrImagePullerRole' in kwargs:
            ecr_image_puller_role = kwargs['ecrImagePullerRole']

        if ecr_image_puller_role is not None:
            _setter("ecr_image_puller_role", ecr_image_puller_role)

    @property
    @pulumi.getter(name="ecrImagePullerRole")
    def ecr_image_puller_role(self) -> Optional[pulumi.Input['ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs']]:
        """
        Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
        """
        return pulumi.get(self, "ecr_image_puller_role")

    @ecr_image_puller_role.setter
    def ecr_image_puller_role(self, value: Optional[pulumi.Input['ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs']]):
        pulumi.set(self, "ecr_image_puller_role", value)


@pulumi.input_type
class ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs:
    def __init__(__self__, *,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 principal_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_active: A Boolean value that indicates whether to activate the role. The default is `false`.
        :param pulumi.Input[str] principal_arn: The principal ARN of the container service. The principal ARN can be used to create a trust
               relationship between your standard AWS account and your Lightsail container service. This allows you to give your
               service permission to access resources in your standard AWS account.
        """
        ContainerServicePrivateRegistryAccessEcrImagePullerRoleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_active=is_active,
            principal_arn=principal_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_active: Optional[pulumi.Input[bool]] = None,
             principal_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_active is None and 'isActive' in kwargs:
            is_active = kwargs['isActive']
        if principal_arn is None and 'principalArn' in kwargs:
            principal_arn = kwargs['principalArn']

        if is_active is not None:
            _setter("is_active", is_active)
        if principal_arn is not None:
            _setter("principal_arn", principal_arn)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean value that indicates whether to activate the role. The default is `false`.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="principalArn")
    def principal_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The principal ARN of the container service. The principal ARN can be used to create a trust
        relationship between your standard AWS account and your Lightsail container service. This allows you to give your
        service permission to access resources in your standard AWS account.
        """
        return pulumi.get(self, "principal_arn")

    @principal_arn.setter
    def principal_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_arn", value)


@pulumi.input_type
class ContainerServicePublicDomainNamesArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['ContainerServicePublicDomainNamesCertificateArgs']]]):
        ContainerServicePublicDomainNamesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerServicePublicDomainNamesCertificateArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")

        _setter("certificates", certificates)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['ContainerServicePublicDomainNamesCertificateArgs']]]:
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['ContainerServicePublicDomainNamesCertificateArgs']]]):
        pulumi.set(self, "certificates", value)


@pulumi.input_type
class ContainerServicePublicDomainNamesCertificateArgs:
    def __init__(__self__, *,
                 certificate_name: pulumi.Input[str],
                 domain_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        ContainerServicePublicDomainNamesCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_name=certificate_name,
            domain_names=domain_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_name: Optional[pulumi.Input[str]] = None,
             domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_name is None and 'certificateName' in kwargs:
            certificate_name = kwargs['certificateName']
        if certificate_name is None:
            raise TypeError("Missing 'certificate_name' argument")
        if domain_names is None and 'domainNames' in kwargs:
            domain_names = kwargs['domainNames']
        if domain_names is None:
            raise TypeError("Missing 'domain_names' argument")

        _setter("certificate_name", certificate_name)
        _setter("domain_names", domain_names)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "domain_names", value)


@pulumi.input_type
class DistributionCacheBehaviorArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: The cache behavior for the specified path.
        :param pulumi.Input[str] path: The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/\\*), and file types (\\*.html, \\*jpg, \\*js). Directories and file paths are case-sensitive.
        """
        DistributionCacheBehaviorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            behavior=behavior,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             behavior: Optional[pulumi.Input[str]] = None,
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if behavior is None:
            raise TypeError("Missing 'behavior' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("behavior", behavior)
        _setter("path", path)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The cache behavior for the specified path.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/\\*), and file types (\\*.html, \\*jpg, \\*js). Directories and file paths are case-sensitive.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class DistributionCacheBehaviorSettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[str]] = None,
                 cached_http_methods: Optional[pulumi.Input[str]] = None,
                 default_ttl: Optional[pulumi.Input[int]] = None,
                 forwarded_cookies: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedCookiesArgs']] = None,
                 forwarded_headers: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedHeadersArgs']] = None,
                 forwarded_query_strings: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedQueryStringsArgs']] = None,
                 maximum_ttl: Optional[pulumi.Input[int]] = None,
                 minimum_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] allowed_http_methods: The HTTP methods that are processed and forwarded to the distribution's origin.
        :param pulumi.Input[str] cached_http_methods: The HTTP method responses that are cached by your distribution.
        :param pulumi.Input[int] default_ttl: The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
        :param pulumi.Input['DistributionCacheBehaviorSettingsForwardedCookiesArgs'] forwarded_cookies: An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded. Detailed below
        :param pulumi.Input['DistributionCacheBehaviorSettingsForwardedHeadersArgs'] forwarded_headers: An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded. Detailed below
        :param pulumi.Input['DistributionCacheBehaviorSettingsForwardedQueryStringsArgs'] forwarded_query_strings: An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded. Detailed below
        :param pulumi.Input[int] maximum_ttl: The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
        :param pulumi.Input[int] minimum_ttl: The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
        """
        DistributionCacheBehaviorSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_http_methods=allowed_http_methods,
            cached_http_methods=cached_http_methods,
            default_ttl=default_ttl,
            forwarded_cookies=forwarded_cookies,
            forwarded_headers=forwarded_headers,
            forwarded_query_strings=forwarded_query_strings,
            maximum_ttl=maximum_ttl,
            minimum_ttl=minimum_ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_http_methods: Optional[pulumi.Input[str]] = None,
             cached_http_methods: Optional[pulumi.Input[str]] = None,
             default_ttl: Optional[pulumi.Input[int]] = None,
             forwarded_cookies: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedCookiesArgs']] = None,
             forwarded_headers: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedHeadersArgs']] = None,
             forwarded_query_strings: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedQueryStringsArgs']] = None,
             maximum_ttl: Optional[pulumi.Input[int]] = None,
             minimum_ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_http_methods is None and 'allowedHttpMethods' in kwargs:
            allowed_http_methods = kwargs['allowedHttpMethods']
        if cached_http_methods is None and 'cachedHttpMethods' in kwargs:
            cached_http_methods = kwargs['cachedHttpMethods']
        if default_ttl is None and 'defaultTtl' in kwargs:
            default_ttl = kwargs['defaultTtl']
        if forwarded_cookies is None and 'forwardedCookies' in kwargs:
            forwarded_cookies = kwargs['forwardedCookies']
        if forwarded_headers is None and 'forwardedHeaders' in kwargs:
            forwarded_headers = kwargs['forwardedHeaders']
        if forwarded_query_strings is None and 'forwardedQueryStrings' in kwargs:
            forwarded_query_strings = kwargs['forwardedQueryStrings']
        if maximum_ttl is None and 'maximumTtl' in kwargs:
            maximum_ttl = kwargs['maximumTtl']
        if minimum_ttl is None and 'minimumTtl' in kwargs:
            minimum_ttl = kwargs['minimumTtl']

        if allowed_http_methods is not None:
            _setter("allowed_http_methods", allowed_http_methods)
        if cached_http_methods is not None:
            _setter("cached_http_methods", cached_http_methods)
        if default_ttl is not None:
            _setter("default_ttl", default_ttl)
        if forwarded_cookies is not None:
            _setter("forwarded_cookies", forwarded_cookies)
        if forwarded_headers is not None:
            _setter("forwarded_headers", forwarded_headers)
        if forwarded_query_strings is not None:
            _setter("forwarded_query_strings", forwarded_query_strings)
        if maximum_ttl is not None:
            _setter("maximum_ttl", maximum_ttl)
        if minimum_ttl is not None:
            _setter("minimum_ttl", minimum_ttl)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP methods that are processed and forwarded to the distribution's origin.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="cachedHttpMethods")
    def cached_http_methods(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method responses that are cached by your distribution.
        """
        return pulumi.get(self, "cached_http_methods")

    @cached_http_methods.setter
    def cached_http_methods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cached_http_methods", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="forwardedCookies")
    def forwarded_cookies(self) -> Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedCookiesArgs']]:
        """
        An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded. Detailed below
        """
        return pulumi.get(self, "forwarded_cookies")

    @forwarded_cookies.setter
    def forwarded_cookies(self, value: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedCookiesArgs']]):
        pulumi.set(self, "forwarded_cookies", value)

    @property
    @pulumi.getter(name="forwardedHeaders")
    def forwarded_headers(self) -> Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedHeadersArgs']]:
        """
        An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded. Detailed below
        """
        return pulumi.get(self, "forwarded_headers")

    @forwarded_headers.setter
    def forwarded_headers(self, value: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedHeadersArgs']]):
        pulumi.set(self, "forwarded_headers", value)

    @property
    @pulumi.getter(name="forwardedQueryStrings")
    def forwarded_query_strings(self) -> Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedQueryStringsArgs']]:
        """
        An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded. Detailed below
        """
        return pulumi.get(self, "forwarded_query_strings")

    @forwarded_query_strings.setter
    def forwarded_query_strings(self, value: Optional[pulumi.Input['DistributionCacheBehaviorSettingsForwardedQueryStringsArgs']]):
        pulumi.set(self, "forwarded_query_strings", value)

    @property
    @pulumi.getter(name="maximumTtl")
    def maximum_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
        """
        return pulumi.get(self, "maximum_ttl")

    @maximum_ttl.setter
    def maximum_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_ttl", value)

    @property
    @pulumi.getter(name="minimumTtl")
    def minimum_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
        """
        return pulumi.get(self, "minimum_ttl")

    @minimum_ttl.setter
    def minimum_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_ttl", value)


@pulumi.input_type
class DistributionCacheBehaviorSettingsForwardedCookiesArgs:
    def __init__(__self__, *,
                 cookies_allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 option: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cookies_allow_lists: The specific cookies to forward to your distribution's origin.
        :param pulumi.Input[str] option: Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
        """
        DistributionCacheBehaviorSettingsForwardedCookiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookies_allow_lists=cookies_allow_lists,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookies_allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             option: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cookies_allow_lists is None and 'cookiesAllowLists' in kwargs:
            cookies_allow_lists = kwargs['cookiesAllowLists']

        if cookies_allow_lists is not None:
            _setter("cookies_allow_lists", cookies_allow_lists)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter(name="cookiesAllowLists")
    def cookies_allow_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The specific cookies to forward to your distribution's origin.
        """
        return pulumi.get(self, "cookies_allow_lists")

    @cookies_allow_lists.setter
    def cookies_allow_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cookies_allow_lists", value)

    @property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "option", value)


@pulumi.input_type
class DistributionCacheBehaviorSettingsForwardedHeadersArgs:
    def __init__(__self__, *,
                 headers_allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 option: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers_allow_lists: The specific headers to forward to your distribution's origin.
        :param pulumi.Input[str] option: The headers that you want your distribution to forward to your origin and base caching on.
        """
        DistributionCacheBehaviorSettingsForwardedHeadersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers_allow_lists=headers_allow_lists,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers_allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             option: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if headers_allow_lists is None and 'headersAllowLists' in kwargs:
            headers_allow_lists = kwargs['headersAllowLists']

        if headers_allow_lists is not None:
            _setter("headers_allow_lists", headers_allow_lists)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter(name="headersAllowLists")
    def headers_allow_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The specific headers to forward to your distribution's origin.
        """
        return pulumi.get(self, "headers_allow_lists")

    @headers_allow_lists.setter
    def headers_allow_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers_allow_lists", value)

    @property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input[str]]:
        """
        The headers that you want your distribution to forward to your origin and base caching on.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "option", value)


@pulumi.input_type
class DistributionCacheBehaviorSettingsForwardedQueryStringsArgs:
    def __init__(__self__, *,
                 option: Optional[pulumi.Input[bool]] = None,
                 query_strings_allowed_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] option: Indicates whether the distribution forwards and caches based on query strings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_strings_allowed_lists: The specific query strings that the distribution forwards to the origin.
        """
        DistributionCacheBehaviorSettingsForwardedQueryStringsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            option=option,
            query_strings_allowed_lists=query_strings_allowed_lists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             option: Optional[pulumi.Input[bool]] = None,
             query_strings_allowed_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_strings_allowed_lists is None and 'queryStringsAllowedLists' in kwargs:
            query_strings_allowed_lists = kwargs['queryStringsAllowedLists']

        if option is not None:
            _setter("option", option)
        if query_strings_allowed_lists is not None:
            _setter("query_strings_allowed_lists", query_strings_allowed_lists)

    @property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the distribution forwards and caches based on query strings.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter(name="queryStringsAllowedLists")
    def query_strings_allowed_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The specific query strings that the distribution forwards to the origin.
        """
        return pulumi.get(self, "query_strings_allowed_lists")

    @query_strings_allowed_lists.setter
    def query_strings_allowed_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_strings_allowed_lists", value)


@pulumi.input_type
class DistributionDefaultCacheBehaviorArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: The cache behavior of the distribution. Valid values: `cache` and `dont-cache`.
        """
        DistributionDefaultCacheBehaviorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            behavior=behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             behavior: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if behavior is None:
            raise TypeError("Missing 'behavior' argument")

        _setter("behavior", behavior)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The cache behavior of the distribution. Valid values: `cache` and `dont-cache`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)


@pulumi.input_type
class DistributionLocationArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 region_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] availability_zone: The Availability Zone. Follows the format us-east-2a (case-sensitive).
        :param pulumi.Input[str] region_name: The AWS Region name of the origin resource.
        """
        DistributionLocationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[pulumi.Input[str]] = None,
             region_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")

        _setter("availability_zone", availability_zone)
        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        The Availability Zone. Follows the format us-east-2a (case-sensitive).
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        The AWS Region name of the origin resource.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)


@pulumi.input_type
class DistributionOriginArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 region_name: pulumi.Input[str],
                 protocol_policy: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the origin resource. Your origin can be an instance with an attached static IP, a bucket, or a load balancer that has at least one instance attached to it.
        :param pulumi.Input[str] region_name: The AWS Region name of the origin resource.
        :param pulumi.Input[str] protocol_policy: The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
        :param pulumi.Input[str] resource_type: The resource type of the origin resource (e.g., Instance).
        """
        DistributionOriginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            region_name=region_name,
            protocol_policy=protocol_policy,
            resource_type=resource_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             region_name: Optional[pulumi.Input[str]] = None,
             protocol_policy: Optional[pulumi.Input[str]] = None,
             resource_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")
        if protocol_policy is None and 'protocolPolicy' in kwargs:
            protocol_policy = kwargs['protocolPolicy']
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']

        _setter("name", name)
        _setter("region_name", region_name)
        if protocol_policy is not None:
            _setter("protocol_policy", protocol_policy)
        if resource_type is not None:
            _setter("resource_type", resource_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the origin resource. Your origin can be an instance with an attached static IP, a bucket, or a load balancer that has at least one instance attached to it.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        The AWS Region name of the origin resource.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="protocolPolicy")
    def protocol_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
        """
        return pulumi.get(self, "protocol_policy")

    @protocol_policy.setter
    def protocol_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_policy", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The resource type of the origin resource (e.g., Instance).
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


@pulumi.input_type
class InstanceAddOnArgs:
    def __init__(__self__, *,
                 snapshot_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] snapshot_time: The daily time when an automatic snapshot will be created. Must be in HH:00 format, and in an hourly increment and specified in Coordinated Universal Time (UTC). The snapshot will be automatically created between the time specified and up to 45 minutes after.
        :param pulumi.Input[str] status: The status of the add on. Valid Values: `Enabled`, `Disabled`.
        :param pulumi.Input[str] type: The add-on type. There is currently only one valid type `AutoSnapshot`.
        """
        InstanceAddOnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            snapshot_time=snapshot_time,
            status=status,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             snapshot_time: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshot_time is None and 'snapshotTime' in kwargs:
            snapshot_time = kwargs['snapshotTime']
        if snapshot_time is None:
            raise TypeError("Missing 'snapshot_time' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("snapshot_time", snapshot_time)
        _setter("status", status)
        _setter("type", type)

    @property
    @pulumi.getter(name="snapshotTime")
    def snapshot_time(self) -> pulumi.Input[str]:
        """
        The daily time when an automatic snapshot will be created. Must be in HH:00 format, and in an hourly increment and specified in Coordinated Universal Time (UTC). The snapshot will be automatically created between the time specified and up to 45 minutes after.
        """
        return pulumi.get(self, "snapshot_time")

    @snapshot_time.setter
    def snapshot_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "snapshot_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        The status of the add on. Valid Values: `Enabled`, `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The add-on type. There is currently only one valid type `AutoSnapshot`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class InstancePublicPortsPortInfoArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[int],
                 cidr_list_aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] from_port: First port in a range of open ports on an instance.
        :param pulumi.Input[str] protocol: IP protocol name. Valid values are `tcp`, `all`, `udp`, and `icmp`.
        :param pulumi.Input[int] to_port: Last port in a range of open ports on an instance.
               
               The following arguments are optional:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_list_aliases: Set of CIDR aliases that define access for a preconfigured range of IP addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidrs: Set of CIDR blocks.
        """
        InstancePublicPortsPortInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            protocol=protocol,
            to_port=to_port,
            cidr_list_aliases=cidr_list_aliases,
            cidrs=cidrs,
            ipv6_cidrs=ipv6_cidrs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[pulumi.Input[int]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             to_port: Optional[pulumi.Input[int]] = None,
             cidr_list_aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ipv6_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_list_aliases is None and 'cidrListAliases' in kwargs:
            cidr_list_aliases = kwargs['cidrListAliases']
        if ipv6_cidrs is None and 'ipv6Cidrs' in kwargs:
            ipv6_cidrs = kwargs['ipv6Cidrs']

        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("to_port", to_port)
        if cidr_list_aliases is not None:
            _setter("cidr_list_aliases", cidr_list_aliases)
        if cidrs is not None:
            _setter("cidrs", cidrs)
        if ipv6_cidrs is not None:
            _setter("ipv6_cidrs", ipv6_cidrs)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        First port in a range of open ports on an instance.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        IP protocol name. Valid values are `tcp`, `all`, `udp`, and `icmp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        Last port in a range of open ports on an instance.

        The following arguments are optional:
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrListAliases")
    def cidr_list_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of CIDR aliases that define access for a preconfigured range of IP addresses.
        """
        return pulumi.get(self, "cidr_list_aliases")

    @cidr_list_aliases.setter
    def cidr_list_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_list_aliases", value)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of CIDR blocks.
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidrs", value)

    @property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ipv6_cidrs")

    @ipv6_cidrs.setter
    def ipv6_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_cidrs", value)


@pulumi.input_type
class LbCertificateDomainValidationRecordArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 resource_record_name: Optional[pulumi.Input[str]] = None,
                 resource_record_type: Optional[pulumi.Input[str]] = None,
                 resource_record_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain_name: The domain name (e.g., example.com) for your SSL/TLS certificate.
        """
        LbCertificateDomainValidationRecordArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            resource_record_name=resource_record_name,
            resource_record_type=resource_record_type,
            resource_record_value=resource_record_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[pulumi.Input[str]] = None,
             resource_record_name: Optional[pulumi.Input[str]] = None,
             resource_record_type: Optional[pulumi.Input[str]] = None,
             resource_record_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if resource_record_name is None and 'resourceRecordName' in kwargs:
            resource_record_name = kwargs['resourceRecordName']
        if resource_record_type is None and 'resourceRecordType' in kwargs:
            resource_record_type = kwargs['resourceRecordType']
        if resource_record_value is None and 'resourceRecordValue' in kwargs:
            resource_record_value = kwargs['resourceRecordValue']

        if domain_name is not None:
            _setter("domain_name", domain_name)
        if resource_record_name is not None:
            _setter("resource_record_name", resource_record_name)
        if resource_record_type is not None:
            _setter("resource_record_type", resource_record_type)
        if resource_record_value is not None:
            _setter("resource_record_value", resource_record_value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name (e.g., example.com) for your SSL/TLS certificate.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="resourceRecordName")
    def resource_record_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_name")

    @resource_record_name.setter
    def resource_record_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_name", value)

    @property
    @pulumi.getter(name="resourceRecordType")
    def resource_record_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_type")

    @resource_record_type.setter
    def resource_record_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_type", value)

    @property
    @pulumi.getter(name="resourceRecordValue")
    def resource_record_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_record_value")

    @resource_record_value.setter
    def resource_record_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_record_value", value)


