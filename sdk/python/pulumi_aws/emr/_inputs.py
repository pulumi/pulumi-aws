# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRangeArgs',
    'BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRangeArgsDict',
    'ClusterAutoTerminationPolicyArgs',
    'ClusterAutoTerminationPolicyArgsDict',
    'ClusterBootstrapActionArgs',
    'ClusterBootstrapActionArgsDict',
    'ClusterCoreInstanceFleetArgs',
    'ClusterCoreInstanceFleetArgsDict',
    'ClusterCoreInstanceFleetInstanceTypeConfigArgs',
    'ClusterCoreInstanceFleetInstanceTypeConfigArgsDict',
    'ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs',
    'ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgsDict',
    'ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs',
    'ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgsDict',
    'ClusterCoreInstanceFleetLaunchSpecificationsArgs',
    'ClusterCoreInstanceFleetLaunchSpecificationsArgsDict',
    'ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs',
    'ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict',
    'ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs',
    'ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict',
    'ClusterCoreInstanceGroupArgs',
    'ClusterCoreInstanceGroupArgsDict',
    'ClusterCoreInstanceGroupEbsConfigArgs',
    'ClusterCoreInstanceGroupEbsConfigArgsDict',
    'ClusterEc2AttributesArgs',
    'ClusterEc2AttributesArgsDict',
    'ClusterKerberosAttributesArgs',
    'ClusterKerberosAttributesArgsDict',
    'ClusterMasterInstanceFleetArgs',
    'ClusterMasterInstanceFleetArgsDict',
    'ClusterMasterInstanceFleetInstanceTypeConfigArgs',
    'ClusterMasterInstanceFleetInstanceTypeConfigArgsDict',
    'ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs',
    'ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgsDict',
    'ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs',
    'ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgsDict',
    'ClusterMasterInstanceFleetLaunchSpecificationsArgs',
    'ClusterMasterInstanceFleetLaunchSpecificationsArgsDict',
    'ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs',
    'ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict',
    'ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs',
    'ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict',
    'ClusterMasterInstanceGroupArgs',
    'ClusterMasterInstanceGroupArgsDict',
    'ClusterMasterInstanceGroupEbsConfigArgs',
    'ClusterMasterInstanceGroupEbsConfigArgsDict',
    'ClusterPlacementGroupConfigArgs',
    'ClusterPlacementGroupConfigArgsDict',
    'ClusterStepArgs',
    'ClusterStepArgsDict',
    'ClusterStepHadoopJarStepArgs',
    'ClusterStepHadoopJarStepArgsDict',
    'InstanceFleetInstanceTypeConfigArgs',
    'InstanceFleetInstanceTypeConfigArgsDict',
    'InstanceFleetInstanceTypeConfigConfigurationArgs',
    'InstanceFleetInstanceTypeConfigConfigurationArgsDict',
    'InstanceFleetInstanceTypeConfigEbsConfigArgs',
    'InstanceFleetInstanceTypeConfigEbsConfigArgsDict',
    'InstanceFleetLaunchSpecificationsArgs',
    'InstanceFleetLaunchSpecificationsArgsDict',
    'InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs',
    'InstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict',
    'InstanceFleetLaunchSpecificationsSpotSpecificationArgs',
    'InstanceFleetLaunchSpecificationsSpotSpecificationArgsDict',
    'InstanceGroupEbsConfigArgs',
    'InstanceGroupEbsConfigArgsDict',
    'ManagedScalingPolicyComputeLimitArgs',
    'ManagedScalingPolicyComputeLimitArgsDict',
    'GetReleaseLabelsFiltersArgs',
    'GetReleaseLabelsFiltersArgsDict',
]

MYPY = False

if not MYPY:
    class BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRangeArgsDict(TypedDict):
        max_range: pulumi.Input[_builtins.int]
        min_range: pulumi.Input[_builtins.int]
elif False:
    BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRangeArgs:
    def __init__(__self__, *,
                 max_range: pulumi.Input[_builtins.int],
                 min_range: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "max_range", max_range)
        pulumi.set(__self__, "min_range", min_range)

    @_builtins.property
    @pulumi.getter(name="maxRange")
    def max_range(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_range")

    @max_range.setter
    def max_range(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_range", value)

    @_builtins.property
    @pulumi.getter(name="minRange")
    def min_range(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min_range")

    @min_range.setter
    def min_range(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_range", value)


if not MYPY:
    class ClusterAutoTerminationPolicyArgsDict(TypedDict):
        idle_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterAutoTerminationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoTerminationPolicyArgs:
    def __init__(__self__, *,
                 idle_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout", value)


if not MYPY:
    class ClusterBootstrapActionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterBootstrapActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBootstrapActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if args is not None:
            pulumi.set(__self__, "args", args)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)


if not MYPY:
    class ClusterCoreInstanceFleetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        instance_type_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigArgsDict']]]]
        launch_specifications: NotRequired[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsArgsDict']]
        name: NotRequired[pulumi.Input[_builtins.str]]
        provisioned_on_demand_capacity: NotRequired[pulumi.Input[_builtins.int]]
        provisioned_spot_capacity: NotRequired[pulumi.Input[_builtins.int]]
        target_on_demand_capacity: NotRequired[pulumi.Input[_builtins.int]]
        target_spot_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCoreInstanceFleetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_type_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigArgs']]]] = None,
                 launch_specifications: Optional[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 provisioned_on_demand_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 provisioned_spot_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 target_on_demand_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 target_spot_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_type_configs is not None:
            pulumi.set(__self__, "instance_type_configs", instance_type_configs)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provisioned_on_demand_capacity is not None:
            pulumi.set(__self__, "provisioned_on_demand_capacity", provisioned_on_demand_capacity)
        if provisioned_spot_capacity is not None:
            pulumi.set(__self__, "provisioned_spot_capacity", provisioned_spot_capacity)
        if target_on_demand_capacity is not None:
            pulumi.set(__self__, "target_on_demand_capacity", target_on_demand_capacity)
        if target_spot_capacity is not None:
            pulumi.set(__self__, "target_spot_capacity", target_spot_capacity)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="instanceTypeConfigs")
    def instance_type_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigArgs']]]]:
        return pulumi.get(self, "instance_type_configs")

    @instance_type_configs.setter
    def instance_type_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigArgs']]]]):
        pulumi.set(self, "instance_type_configs", value)

    @_builtins.property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsArgs']]:
        return pulumi.get(self, "launch_specifications")

    @launch_specifications.setter
    def launch_specifications(self, value: Optional[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsArgs']]):
        pulumi.set(self, "launch_specifications", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="provisionedOnDemandCapacity")
    def provisioned_on_demand_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "provisioned_on_demand_capacity")

    @provisioned_on_demand_capacity.setter
    def provisioned_on_demand_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "provisioned_on_demand_capacity", value)

    @_builtins.property
    @pulumi.getter(name="provisionedSpotCapacity")
    def provisioned_spot_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "provisioned_spot_capacity")

    @provisioned_spot_capacity.setter
    def provisioned_spot_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "provisioned_spot_capacity", value)

    @_builtins.property
    @pulumi.getter(name="targetOnDemandCapacity")
    def target_on_demand_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "target_on_demand_capacity")

    @target_on_demand_capacity.setter
    def target_on_demand_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_on_demand_capacity", value)

    @_builtins.property
    @pulumi.getter(name="targetSpotCapacity")
    def target_spot_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "target_spot_capacity")

    @target_spot_capacity.setter
    def target_spot_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_spot_capacity", value)


if not MYPY:
    class ClusterCoreInstanceFleetInstanceTypeConfigArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        bid_price: NotRequired[pulumi.Input[_builtins.str]]
        bid_price_as_percentage_of_on_demand_price: NotRequired[pulumi.Input[_builtins.float]]
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgsDict']]]]
        ebs_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgsDict']]]]
        weighted_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCoreInstanceFleetInstanceTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetInstanceTypeConfigArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 bid_price: Optional[pulumi.Input[_builtins.str]] = None,
                 bid_price_as_percentage_of_on_demand_price: Optional[pulumi.Input[_builtins.float]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs']]]] = None,
                 ebs_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs']]]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "instance_type", instance_type)
        if bid_price is not None:
            pulumi.set(__self__, "bid_price", bid_price)
        if bid_price_as_percentage_of_on_demand_price is not None:
            pulumi.set(__self__, "bid_price_as_percentage_of_on_demand_price", bid_price_as_percentage_of_on_demand_price)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ebs_configs is not None:
            pulumi.set(__self__, "ebs_configs", ebs_configs)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bid_price")

    @bid_price.setter
    def bid_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bid_price", value)

    @_builtins.property
    @pulumi.getter(name="bidPriceAsPercentageOfOnDemandPrice")
    def bid_price_as_percentage_of_on_demand_price(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "bid_price_as_percentage_of_on_demand_price")

    @bid_price_as_percentage_of_on_demand_price.setter
    def bid_price_as_percentage_of_on_demand_price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "bid_price_as_percentage_of_on_demand_price", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs']]]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter(name="ebsConfigs")
    def ebs_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs']]]]:
        return pulumi.get(self, "ebs_configs")

    @ebs_configs.setter
    def ebs_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs']]]]):
        pulumi.set(self, "ebs_configs", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgsDict(TypedDict):
        classification: NotRequired[pulumi.Input[_builtins.str]]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs:
    def __init__(__self__, *,
                 classification: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class ClusterCoreInstanceFleetLaunchSpecificationsArgsDict(TypedDict):
        on_demand_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict']]]]
        spot_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict']]]]
elif False:
    ClusterCoreInstanceFleetLaunchSpecificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetLaunchSpecificationsArgs:
    def __init__(__self__, *,
                 on_demand_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]] = None,
                 spot_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]] = None):
        if on_demand_specifications is not None:
            pulumi.set(__self__, "on_demand_specifications", on_demand_specifications)
        if spot_specifications is not None:
            pulumi.set(__self__, "spot_specifications", spot_specifications)

    @_builtins.property
    @pulumi.getter(name="onDemandSpecifications")
    def on_demand_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]:
        return pulumi.get(self, "on_demand_specifications")

    @on_demand_specifications.setter
    def on_demand_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]):
        pulumi.set(self, "on_demand_specifications", value)

    @_builtins.property
    @pulumi.getter(name="spotSpecifications")
    def spot_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]:
        return pulumi.get(self, "spot_specifications")

    @spot_specifications.setter
    def spot_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]):
        pulumi.set(self, "spot_specifications", value)


if not MYPY:
    class ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
elif False:
    ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)


if not MYPY:
    class ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
        timeout_action: pulumi.Input[_builtins.str]
        timeout_duration_minutes: pulumi.Input[_builtins.int]
        block_duration_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str],
                 timeout_action: pulumi.Input[_builtins.str],
                 timeout_duration_minutes: pulumi.Input[_builtins.int],
                 block_duration_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        pulumi.set(__self__, "timeout_action", timeout_action)
        pulumi.set(__self__, "timeout_duration_minutes", timeout_duration_minutes)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDurationMinutes")
    def timeout_duration_minutes(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "timeout_duration_minutes")

    @timeout_duration_minutes.setter
    def timeout_duration_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_duration_minutes", value)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_duration_minutes", value)


if not MYPY:
    class ClusterCoreInstanceGroupArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        autoscaling_policy: NotRequired[pulumi.Input[_builtins.str]]
        bid_price: NotRequired[pulumi.Input[_builtins.str]]
        ebs_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceGroupEbsConfigArgsDict']]]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterCoreInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceGroupArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 autoscaling_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 bid_price: Optional[pulumi.Input[_builtins.str]] = None,
                 ebs_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceGroupEbsConfigArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "instance_type", instance_type)
        if autoscaling_policy is not None:
            pulumi.set(__self__, "autoscaling_policy", autoscaling_policy)
        if bid_price is not None:
            pulumi.set(__self__, "bid_price", bid_price)
        if ebs_configs is not None:
            pulumi.set(__self__, "ebs_configs", ebs_configs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="autoscalingPolicy")
    def autoscaling_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "autoscaling_policy")

    @autoscaling_policy.setter
    def autoscaling_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autoscaling_policy", value)

    @_builtins.property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bid_price")

    @bid_price.setter
    def bid_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bid_price", value)

    @_builtins.property
    @pulumi.getter(name="ebsConfigs")
    def ebs_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceGroupEbsConfigArgs']]]]:
        return pulumi.get(self, "ebs_configs")

    @ebs_configs.setter
    def ebs_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterCoreInstanceGroupEbsConfigArgs']]]]):
        pulumi.set(self, "ebs_configs", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterCoreInstanceGroupEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCoreInstanceGroupEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCoreInstanceGroupEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class ClusterEc2AttributesArgsDict(TypedDict):
        instance_profile: pulumi.Input[_builtins.str]
        additional_master_security_groups: NotRequired[pulumi.Input[_builtins.str]]
        additional_slave_security_groups: NotRequired[pulumi.Input[_builtins.str]]
        emr_managed_master_security_group: NotRequired[pulumi.Input[_builtins.str]]
        emr_managed_slave_security_group: NotRequired[pulumi.Input[_builtins.str]]
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        service_access_security_group: NotRequired[pulumi.Input[_builtins.str]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterEc2AttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEc2AttributesArgs:
    def __init__(__self__, *,
                 instance_profile: pulumi.Input[_builtins.str],
                 additional_master_security_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 additional_slave_security_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 emr_managed_master_security_group: Optional[pulumi.Input[_builtins.str]] = None,
                 emr_managed_slave_security_group: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service_access_security_group: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "instance_profile", instance_profile)
        if additional_master_security_groups is not None:
            pulumi.set(__self__, "additional_master_security_groups", additional_master_security_groups)
        if additional_slave_security_groups is not None:
            pulumi.set(__self__, "additional_slave_security_groups", additional_slave_security_groups)
        if emr_managed_master_security_group is not None:
            pulumi.set(__self__, "emr_managed_master_security_group", emr_managed_master_security_group)
        if emr_managed_slave_security_group is not None:
            pulumi.set(__self__, "emr_managed_slave_security_group", emr_managed_slave_security_group)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if service_access_security_group is not None:
            pulumi.set(__self__, "service_access_security_group", service_access_security_group)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="instanceProfile")
    def instance_profile(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_profile")

    @instance_profile.setter
    def instance_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="additionalMasterSecurityGroups")
    def additional_master_security_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "additional_master_security_groups")

    @additional_master_security_groups.setter
    def additional_master_security_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_master_security_groups", value)

    @_builtins.property
    @pulumi.getter(name="additionalSlaveSecurityGroups")
    def additional_slave_security_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "additional_slave_security_groups")

    @additional_slave_security_groups.setter
    def additional_slave_security_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_slave_security_groups", value)

    @_builtins.property
    @pulumi.getter(name="emrManagedMasterSecurityGroup")
    def emr_managed_master_security_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "emr_managed_master_security_group")

    @emr_managed_master_security_group.setter
    def emr_managed_master_security_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emr_managed_master_security_group", value)

    @_builtins.property
    @pulumi.getter(name="emrManagedSlaveSecurityGroup")
    def emr_managed_slave_security_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "emr_managed_slave_security_group")

    @emr_managed_slave_security_group.setter
    def emr_managed_slave_security_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emr_managed_slave_security_group", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccessSecurityGroup")
    def service_access_security_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "service_access_security_group")

    @service_access_security_group.setter
    def service_access_security_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_access_security_group", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class ClusterKerberosAttributesArgsDict(TypedDict):
        kdc_admin_password: pulumi.Input[_builtins.str]
        realm: pulumi.Input[_builtins.str]
        ad_domain_join_password: NotRequired[pulumi.Input[_builtins.str]]
        ad_domain_join_user: NotRequired[pulumi.Input[_builtins.str]]
        cross_realm_trust_principal_password: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterKerberosAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKerberosAttributesArgs:
    def __init__(__self__, *,
                 kdc_admin_password: pulumi.Input[_builtins.str],
                 realm: pulumi.Input[_builtins.str],
                 ad_domain_join_password: Optional[pulumi.Input[_builtins.str]] = None,
                 ad_domain_join_user: Optional[pulumi.Input[_builtins.str]] = None,
                 cross_realm_trust_principal_password: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "kdc_admin_password", kdc_admin_password)
        pulumi.set(__self__, "realm", realm)
        if ad_domain_join_password is not None:
            pulumi.set(__self__, "ad_domain_join_password", ad_domain_join_password)
        if ad_domain_join_user is not None:
            pulumi.set(__self__, "ad_domain_join_user", ad_domain_join_user)
        if cross_realm_trust_principal_password is not None:
            pulumi.set(__self__, "cross_realm_trust_principal_password", cross_realm_trust_principal_password)

    @_builtins.property
    @pulumi.getter(name="kdcAdminPassword")
    def kdc_admin_password(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "kdc_admin_password")

    @kdc_admin_password.setter
    def kdc_admin_password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kdc_admin_password", value)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "realm", value)

    @_builtins.property
    @pulumi.getter(name="adDomainJoinPassword")
    def ad_domain_join_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ad_domain_join_password")

    @ad_domain_join_password.setter
    def ad_domain_join_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ad_domain_join_password", value)

    @_builtins.property
    @pulumi.getter(name="adDomainJoinUser")
    def ad_domain_join_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ad_domain_join_user")

    @ad_domain_join_user.setter
    def ad_domain_join_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ad_domain_join_user", value)

    @_builtins.property
    @pulumi.getter(name="crossRealmTrustPrincipalPassword")
    def cross_realm_trust_principal_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cross_realm_trust_principal_password")

    @cross_realm_trust_principal_password.setter
    def cross_realm_trust_principal_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_realm_trust_principal_password", value)


if not MYPY:
    class ClusterMasterInstanceFleetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        instance_type_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigArgsDict']]]]
        launch_specifications: NotRequired[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsArgsDict']]
        name: NotRequired[pulumi.Input[_builtins.str]]
        provisioned_on_demand_capacity: NotRequired[pulumi.Input[_builtins.int]]
        provisioned_spot_capacity: NotRequired[pulumi.Input[_builtins.int]]
        target_on_demand_capacity: NotRequired[pulumi.Input[_builtins.int]]
        target_spot_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterMasterInstanceFleetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_type_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigArgs']]]] = None,
                 launch_specifications: Optional[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 provisioned_on_demand_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 provisioned_spot_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 target_on_demand_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 target_spot_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_type_configs is not None:
            pulumi.set(__self__, "instance_type_configs", instance_type_configs)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provisioned_on_demand_capacity is not None:
            pulumi.set(__self__, "provisioned_on_demand_capacity", provisioned_on_demand_capacity)
        if provisioned_spot_capacity is not None:
            pulumi.set(__self__, "provisioned_spot_capacity", provisioned_spot_capacity)
        if target_on_demand_capacity is not None:
            pulumi.set(__self__, "target_on_demand_capacity", target_on_demand_capacity)
        if target_spot_capacity is not None:
            pulumi.set(__self__, "target_spot_capacity", target_spot_capacity)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="instanceTypeConfigs")
    def instance_type_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigArgs']]]]:
        return pulumi.get(self, "instance_type_configs")

    @instance_type_configs.setter
    def instance_type_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigArgs']]]]):
        pulumi.set(self, "instance_type_configs", value)

    @_builtins.property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsArgs']]:
        return pulumi.get(self, "launch_specifications")

    @launch_specifications.setter
    def launch_specifications(self, value: Optional[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsArgs']]):
        pulumi.set(self, "launch_specifications", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="provisionedOnDemandCapacity")
    def provisioned_on_demand_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "provisioned_on_demand_capacity")

    @provisioned_on_demand_capacity.setter
    def provisioned_on_demand_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "provisioned_on_demand_capacity", value)

    @_builtins.property
    @pulumi.getter(name="provisionedSpotCapacity")
    def provisioned_spot_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "provisioned_spot_capacity")

    @provisioned_spot_capacity.setter
    def provisioned_spot_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "provisioned_spot_capacity", value)

    @_builtins.property
    @pulumi.getter(name="targetOnDemandCapacity")
    def target_on_demand_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "target_on_demand_capacity")

    @target_on_demand_capacity.setter
    def target_on_demand_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_on_demand_capacity", value)

    @_builtins.property
    @pulumi.getter(name="targetSpotCapacity")
    def target_spot_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "target_spot_capacity")

    @target_spot_capacity.setter
    def target_spot_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_spot_capacity", value)


if not MYPY:
    class ClusterMasterInstanceFleetInstanceTypeConfigArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        bid_price: NotRequired[pulumi.Input[_builtins.str]]
        bid_price_as_percentage_of_on_demand_price: NotRequired[pulumi.Input[_builtins.float]]
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgsDict']]]]
        ebs_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgsDict']]]]
        weighted_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterMasterInstanceFleetInstanceTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetInstanceTypeConfigArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 bid_price: Optional[pulumi.Input[_builtins.str]] = None,
                 bid_price_as_percentage_of_on_demand_price: Optional[pulumi.Input[_builtins.float]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs']]]] = None,
                 ebs_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs']]]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "instance_type", instance_type)
        if bid_price is not None:
            pulumi.set(__self__, "bid_price", bid_price)
        if bid_price_as_percentage_of_on_demand_price is not None:
            pulumi.set(__self__, "bid_price_as_percentage_of_on_demand_price", bid_price_as_percentage_of_on_demand_price)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ebs_configs is not None:
            pulumi.set(__self__, "ebs_configs", ebs_configs)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bid_price")

    @bid_price.setter
    def bid_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bid_price", value)

    @_builtins.property
    @pulumi.getter(name="bidPriceAsPercentageOfOnDemandPrice")
    def bid_price_as_percentage_of_on_demand_price(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "bid_price_as_percentage_of_on_demand_price")

    @bid_price_as_percentage_of_on_demand_price.setter
    def bid_price_as_percentage_of_on_demand_price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "bid_price_as_percentage_of_on_demand_price", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs']]]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter(name="ebsConfigs")
    def ebs_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs']]]]:
        return pulumi.get(self, "ebs_configs")

    @ebs_configs.setter
    def ebs_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs']]]]):
        pulumi.set(self, "ebs_configs", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgsDict(TypedDict):
        classification: NotRequired[pulumi.Input[_builtins.str]]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs:
    def __init__(__self__, *,
                 classification: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class ClusterMasterInstanceFleetLaunchSpecificationsArgsDict(TypedDict):
        on_demand_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict']]]]
        spot_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict']]]]
elif False:
    ClusterMasterInstanceFleetLaunchSpecificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetLaunchSpecificationsArgs:
    def __init__(__self__, *,
                 on_demand_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]] = None,
                 spot_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]] = None):
        if on_demand_specifications is not None:
            pulumi.set(__self__, "on_demand_specifications", on_demand_specifications)
        if spot_specifications is not None:
            pulumi.set(__self__, "spot_specifications", spot_specifications)

    @_builtins.property
    @pulumi.getter(name="onDemandSpecifications")
    def on_demand_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]:
        return pulumi.get(self, "on_demand_specifications")

    @on_demand_specifications.setter
    def on_demand_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]):
        pulumi.set(self, "on_demand_specifications", value)

    @_builtins.property
    @pulumi.getter(name="spotSpecifications")
    def spot_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]:
        return pulumi.get(self, "spot_specifications")

    @spot_specifications.setter
    def spot_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]):
        pulumi.set(self, "spot_specifications", value)


if not MYPY:
    class ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
elif False:
    ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)


if not MYPY:
    class ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
        timeout_action: pulumi.Input[_builtins.str]
        timeout_duration_minutes: pulumi.Input[_builtins.int]
        block_duration_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str],
                 timeout_action: pulumi.Input[_builtins.str],
                 timeout_duration_minutes: pulumi.Input[_builtins.int],
                 block_duration_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        pulumi.set(__self__, "timeout_action", timeout_action)
        pulumi.set(__self__, "timeout_duration_minutes", timeout_duration_minutes)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDurationMinutes")
    def timeout_duration_minutes(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "timeout_duration_minutes")

    @timeout_duration_minutes.setter
    def timeout_duration_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_duration_minutes", value)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_duration_minutes", value)


if not MYPY:
    class ClusterMasterInstanceGroupArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        bid_price: NotRequired[pulumi.Input[_builtins.str]]
        ebs_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceGroupEbsConfigArgsDict']]]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterMasterInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceGroupArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 bid_price: Optional[pulumi.Input[_builtins.str]] = None,
                 ebs_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceGroupEbsConfigArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "instance_type", instance_type)
        if bid_price is not None:
            pulumi.set(__self__, "bid_price", bid_price)
        if ebs_configs is not None:
            pulumi.set(__self__, "ebs_configs", ebs_configs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bid_price")

    @bid_price.setter
    def bid_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bid_price", value)

    @_builtins.property
    @pulumi.getter(name="ebsConfigs")
    def ebs_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceGroupEbsConfigArgs']]]]:
        return pulumi.get(self, "ebs_configs")

    @ebs_configs.setter
    def ebs_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterMasterInstanceGroupEbsConfigArgs']]]]):
        pulumi.set(self, "ebs_configs", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterMasterInstanceGroupEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterMasterInstanceGroupEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterInstanceGroupEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class ClusterPlacementGroupConfigArgsDict(TypedDict):
        instance_role: pulumi.Input[_builtins.str]
        placement_strategy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterPlacementGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPlacementGroupConfigArgs:
    def __init__(__self__, *,
                 instance_role: pulumi.Input[_builtins.str],
                 placement_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "instance_role", instance_role)
        if placement_strategy is not None:
            pulumi.set(__self__, "placement_strategy", placement_strategy)

    @_builtins.property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_role")

    @instance_role.setter
    def instance_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_role", value)

    @_builtins.property
    @pulumi.getter(name="placementStrategy")
    def placement_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "placement_strategy")

    @placement_strategy.setter
    def placement_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement_strategy", value)


if not MYPY:
    class ClusterStepArgsDict(TypedDict):
        action_on_failure: pulumi.Input[_builtins.str]
        hadoop_jar_step: pulumi.Input['ClusterStepHadoopJarStepArgsDict']
        name: pulumi.Input[_builtins.str]
elif False:
    ClusterStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterStepArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[_builtins.str],
                 hadoop_jar_step: pulumi.Input['ClusterStepHadoopJarStepArgs'],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        pulumi.set(__self__, "hadoop_jar_step", hadoop_jar_step)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="hadoopJarStep")
    def hadoop_jar_step(self) -> pulumi.Input['ClusterStepHadoopJarStepArgs']:
        return pulumi.get(self, "hadoop_jar_step")

    @hadoop_jar_step.setter
    def hadoop_jar_step(self, value: pulumi.Input['ClusterStepHadoopJarStepArgs']):
        pulumi.set(self, "hadoop_jar_step", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterStepHadoopJarStepArgsDict(TypedDict):
        jar: pulumi.Input[_builtins.str]
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        main_class: NotRequired[pulumi.Input[_builtins.str]]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ClusterStepHadoopJarStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterStepHadoopJarStepArgs:
    def __init__(__self__, *,
                 jar: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 main_class: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "jar", jar)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def jar(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "jar", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "main_class")

    @main_class.setter
    def main_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "main_class", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class InstanceFleetInstanceTypeConfigArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        bid_price: NotRequired[pulumi.Input[_builtins.str]]
        bid_price_as_percentage_of_on_demand_price: NotRequired[pulumi.Input[_builtins.float]]
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigConfigurationArgsDict']]]]
        ebs_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigEbsConfigArgsDict']]]]
        weighted_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceFleetInstanceTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetInstanceTypeConfigArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 bid_price: Optional[pulumi.Input[_builtins.str]] = None,
                 bid_price_as_percentage_of_on_demand_price: Optional[pulumi.Input[_builtins.float]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigConfigurationArgs']]]] = None,
                 ebs_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigEbsConfigArgs']]]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "instance_type", instance_type)
        if bid_price is not None:
            pulumi.set(__self__, "bid_price", bid_price)
        if bid_price_as_percentage_of_on_demand_price is not None:
            pulumi.set(__self__, "bid_price_as_percentage_of_on_demand_price", bid_price_as_percentage_of_on_demand_price)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ebs_configs is not None:
            pulumi.set(__self__, "ebs_configs", ebs_configs)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bid_price")

    @bid_price.setter
    def bid_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bid_price", value)

    @_builtins.property
    @pulumi.getter(name="bidPriceAsPercentageOfOnDemandPrice")
    def bid_price_as_percentage_of_on_demand_price(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "bid_price_as_percentage_of_on_demand_price")

    @bid_price_as_percentage_of_on_demand_price.setter
    def bid_price_as_percentage_of_on_demand_price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "bid_price_as_percentage_of_on_demand_price", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigConfigurationArgs']]]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter(name="ebsConfigs")
    def ebs_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigEbsConfigArgs']]]]:
        return pulumi.get(self, "ebs_configs")

    @ebs_configs.setter
    def ebs_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetInstanceTypeConfigEbsConfigArgs']]]]):
        pulumi.set(self, "ebs_configs", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class InstanceFleetInstanceTypeConfigConfigurationArgsDict(TypedDict):
        classification: NotRequired[pulumi.Input[_builtins.str]]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    InstanceFleetInstanceTypeConfigConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetInstanceTypeConfigConfigurationArgs:
    def __init__(__self__, *,
                 classification: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class InstanceFleetInstanceTypeConfigEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceFleetInstanceTypeConfigEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetInstanceTypeConfigEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class InstanceFleetLaunchSpecificationsArgsDict(TypedDict):
        on_demand_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict']]]]
        spot_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsSpotSpecificationArgsDict']]]]
elif False:
    InstanceFleetLaunchSpecificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetLaunchSpecificationsArgs:
    def __init__(__self__, *,
                 on_demand_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]] = None,
                 spot_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]] = None):
        if on_demand_specifications is not None:
            pulumi.set(__self__, "on_demand_specifications", on_demand_specifications)
        if spot_specifications is not None:
            pulumi.set(__self__, "spot_specifications", spot_specifications)

    @_builtins.property
    @pulumi.getter(name="onDemandSpecifications")
    def on_demand_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]:
        return pulumi.get(self, "on_demand_specifications")

    @on_demand_specifications.setter
    def on_demand_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs']]]]):
        pulumi.set(self, "on_demand_specifications", value)

    @_builtins.property
    @pulumi.getter(name="spotSpecifications")
    def spot_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]:
        return pulumi.get(self, "spot_specifications")

    @spot_specifications.setter
    def spot_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceFleetLaunchSpecificationsSpotSpecificationArgs']]]]):
        pulumi.set(self, "spot_specifications", value)


if not MYPY:
    class InstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
elif False:
    InstanceFleetLaunchSpecificationsOnDemandSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)


if not MYPY:
    class InstanceFleetLaunchSpecificationsSpotSpecificationArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[_builtins.str]
        timeout_action: pulumi.Input[_builtins.str]
        timeout_duration_minutes: pulumi.Input[_builtins.int]
        block_duration_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceFleetLaunchSpecificationsSpotSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFleetLaunchSpecificationsSpotSpecificationArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[_builtins.str],
                 timeout_action: pulumi.Input[_builtins.str],
                 timeout_duration_minutes: pulumi.Input[_builtins.int],
                 block_duration_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        pulumi.set(__self__, "timeout_action", timeout_action)
        pulumi.set(__self__, "timeout_duration_minutes", timeout_duration_minutes)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDurationMinutes")
    def timeout_duration_minutes(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "timeout_duration_minutes")

    @timeout_duration_minutes.setter
    def timeout_duration_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_duration_minutes", value)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_duration_minutes", value)


if not MYPY:
    class InstanceGroupEbsConfigArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        volumes_per_instance: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceGroupEbsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceGroupEbsConfigArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class ManagedScalingPolicyComputeLimitArgsDict(TypedDict):
        maximum_capacity_units: pulumi.Input[_builtins.int]
        minimum_capacity_units: pulumi.Input[_builtins.int]
        unit_type: pulumi.Input[_builtins.str]
        maximum_core_capacity_units: NotRequired[pulumi.Input[_builtins.int]]
        maximum_ondemand_capacity_units: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ManagedScalingPolicyComputeLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedScalingPolicyComputeLimitArgs:
    def __init__(__self__, *,
                 maximum_capacity_units: pulumi.Input[_builtins.int],
                 minimum_capacity_units: pulumi.Input[_builtins.int],
                 unit_type: pulumi.Input[_builtins.str],
                 maximum_core_capacity_units: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_ondemand_capacity_units: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "maximum_capacity_units", maximum_capacity_units)
        pulumi.set(__self__, "minimum_capacity_units", minimum_capacity_units)
        pulumi.set(__self__, "unit_type", unit_type)
        if maximum_core_capacity_units is not None:
            pulumi.set(__self__, "maximum_core_capacity_units", maximum_core_capacity_units)
        if maximum_ondemand_capacity_units is not None:
            pulumi.set(__self__, "maximum_ondemand_capacity_units", maximum_ondemand_capacity_units)

    @_builtins.property
    @pulumi.getter(name="maximumCapacityUnits")
    def maximum_capacity_units(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_capacity_units")

    @maximum_capacity_units.setter
    def maximum_capacity_units(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_capacity_units", value)

    @_builtins.property
    @pulumi.getter(name="minimumCapacityUnits")
    def minimum_capacity_units(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minimum_capacity_units")

    @minimum_capacity_units.setter
    def minimum_capacity_units(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_capacity_units", value)

    @_builtins.property
    @pulumi.getter(name="unitType")
    def unit_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "unit_type")

    @unit_type.setter
    def unit_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit_type", value)

    @_builtins.property
    @pulumi.getter(name="maximumCoreCapacityUnits")
    def maximum_core_capacity_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_core_capacity_units")

    @maximum_core_capacity_units.setter
    def maximum_core_capacity_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_core_capacity_units", value)

    @_builtins.property
    @pulumi.getter(name="maximumOndemandCapacityUnits")
    def maximum_ondemand_capacity_units(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_ondemand_capacity_units")

    @maximum_ondemand_capacity_units.setter
    def maximum_ondemand_capacity_units(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_ondemand_capacity_units", value)


if not MYPY:
    class GetReleaseLabelsFiltersArgsDict(TypedDict):
        application: NotRequired[_builtins.str]
        prefix: NotRequired[_builtins.str]
elif False:
    GetReleaseLabelsFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseLabelsFiltersArgs:
    def __init__(__self__, *,
                 application: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        if application is not None:
            pulumi.set(__self__, "application", application)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def application(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: Optional[_builtins.str]):
        pulumi.set(self, "application", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "prefix", value)


