# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DomainSingleSignOnArgs',
    'DomainSingleSignOnArgsDict',
    'DomainTimeoutsArgs',
    'DomainTimeoutsArgsDict',
    'EnvironmentProfileUserParameterArgs',
    'EnvironmentProfileUserParameterArgsDict',
    'FormTypeImportArgs',
    'FormTypeImportArgsDict',
    'FormTypeModelArgs',
    'FormTypeModelArgsDict',
    'FormTypeTimeoutsArgs',
    'FormTypeTimeoutsArgsDict',
    'GlossaryTermTermRelationsArgs',
    'GlossaryTermTermRelationsArgsDict',
    'GlossaryTermTimeoutsArgs',
    'GlossaryTermTimeoutsArgsDict',
    'ProjectFailureReasonArgs',
    'ProjectFailureReasonArgsDict',
    'ProjectTimeoutsArgs',
    'ProjectTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class DomainSingleSignOnArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        user_assignment: NotRequired[pulumi.Input[str]]
elif False:
    DomainSingleSignOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSingleSignOnArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 user_assignment: Optional[pulumi.Input[str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assignment is not None:
            pulumi.set(__self__, "user_assignment", user_assignment)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignment")
    def user_assignment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_assignment")

    @user_assignment.setter
    def user_assignment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assignment", value)


if not MYPY:
    class DomainTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    DomainTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class EnvironmentProfileUserParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the environment profile parameter.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the environment profile parameter.
        """
elif False:
    EnvironmentProfileUserParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentProfileUserParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the environment profile parameter.
        :param pulumi.Input[str] value: Value of the environment profile parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the environment profile parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the environment profile parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FormTypeImportArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the form type. Must be the name of the structure in smithy document.
        """
        revision: pulumi.Input[str]
        """
        Revision of the Form Type.
        """
elif False:
    FormTypeImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FormTypeImportArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 revision: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the form type. Must be the name of the structure in smithy document.
        :param pulumi.Input[str] revision: Revision of the Form Type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the form type. Must be the name of the structure in smithy document.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def revision(self) -> pulumi.Input[str]:
        """
        Revision of the Form Type.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[str]):
        pulumi.set(self, "revision", value)


if not MYPY:
    class FormTypeModelArgsDict(TypedDict):
        smithy: pulumi.Input[str]
        """
        Smithy document that indicates the model of the API. Must be between the lengths 1 and 100,000 and be encoded as a smithy document.

        The following arguments are optional:
        """
elif False:
    FormTypeModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FormTypeModelArgs:
    def __init__(__self__, *,
                 smithy: pulumi.Input[str]):
        """
        :param pulumi.Input[str] smithy: Smithy document that indicates the model of the API. Must be between the lengths 1 and 100,000 and be encoded as a smithy document.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "smithy", smithy)

    @property
    @pulumi.getter
    def smithy(self) -> pulumi.Input[str]:
        """
        Smithy document that indicates the model of the API. Must be between the lengths 1 and 100,000 and be encoded as a smithy document.

        The following arguments are optional:
        """
        return pulumi.get(self, "smithy")

    @smithy.setter
    def smithy(self, value: pulumi.Input[str]):
        pulumi.set(self, "smithy", value)


if not MYPY:
    class FormTypeTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    FormTypeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FormTypeTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class GlossaryTermTermRelationsArgsDict(TypedDict):
        classifies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        String array that calssifies the term relations.
        """
        is_as: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GlossaryTermTermRelationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlossaryTermTermRelationsArgs:
    def __init__(__self__, *,
                 classifies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_as: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] classifies: String array that calssifies the term relations.
        """
        if classifies is not None:
            pulumi.set(__self__, "classifies", classifies)
        if is_as is not None:
            pulumi.set(__self__, "is_as", is_as)

    @property
    @pulumi.getter
    def classifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        String array that calssifies the term relations.
        """
        return pulumi.get(self, "classifies")

    @classifies.setter
    def classifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "classifies", value)

    @property
    @pulumi.getter(name="isAs")
    def is_as(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "is_as")

    @is_as.setter
    def is_as(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "is_as", value)


if not MYPY:
    class GlossaryTermTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GlossaryTermTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlossaryTermTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class ProjectFailureReasonArgsDict(TypedDict):
        code: pulumi.Input[str]
        message: pulumi.Input[str]
elif False:
    ProjectFailureReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectFailureReasonArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[str],
                 message: pulumi.Input[str]):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> pulumi.Input[str]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[str]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[str]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[str]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ProjectTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ProjectTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


