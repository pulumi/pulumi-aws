# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DataRepositoryAssociationS3',
    'DataRepositoryAssociationS3AutoExportPolicy',
    'DataRepositoryAssociationS3AutoImportPolicy',
    'FileCacheDataRepositoryAssociation',
    'FileCacheDataRepositoryAssociationNf',
    'FileCacheLustreConfiguration',
    'FileCacheLustreConfigurationLogConfiguration',
    'FileCacheLustreConfigurationMetadataConfiguration',
    'LustreFileSystemDataReadCacheConfiguration',
    'LustreFileSystemLogConfiguration',
    'LustreFileSystemMetadataConfiguration',
    'LustreFileSystemRootSquashConfiguration',
    'OntapFileSystemDiskIopsConfiguration',
    'OntapFileSystemEndpoint',
    'OntapFileSystemEndpointIntercluster',
    'OntapFileSystemEndpointManagement',
    'OntapStorageVirtualMachineActiveDirectoryConfiguration',
    'OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration',
    'OntapStorageVirtualMachineEndpoint',
    'OntapStorageVirtualMachineEndpointIscsi',
    'OntapStorageVirtualMachineEndpointManagement',
    'OntapStorageVirtualMachineEndpointNf',
    'OntapStorageVirtualMachineEndpointSmb',
    'OntapVolumeAggregateConfiguration',
    'OntapVolumeSnaplockConfiguration',
    'OntapVolumeSnaplockConfigurationAutocommitPeriod',
    'OntapVolumeSnaplockConfigurationRetentionPeriod',
    'OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention',
    'OntapVolumeTieringPolicy',
    'OpenZfsFileSystemDiskIopsConfiguration',
    'OpenZfsFileSystemReadCacheConfiguration',
    'OpenZfsFileSystemRootVolumeConfiguration',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExports',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration',
    'OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota',
    'OpenZfsVolumeNfsExports',
    'OpenZfsVolumeNfsExportsClientConfiguration',
    'OpenZfsVolumeOriginSnapshot',
    'OpenZfsVolumeUserAndGroupQuota',
    'S3AccessPointAttachmentOpenzfsConfiguration',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser',
    'S3AccessPointAttachmentS3AccessPoint',
    'S3AccessPointAttachmentS3AccessPointVpcConfiguration',
    'S3AccessPointAttachmentTimeouts',
    'WindowsFileSystemAuditLogConfiguration',
    'WindowsFileSystemDiskIopsConfiguration',
    'WindowsFileSystemSelfManagedActiveDirectory',
    'GetOntapFileSystemDiskIopsConfigurationResult',
    'GetOntapFileSystemEndpointResult',
    'GetOntapFileSystemEndpointInterclusterResult',
    'GetOntapFileSystemEndpointManagementResult',
    'GetOntapStorageVirtualMachineActiveDirectoryConfigurationResult',
    'GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationResult',
    'GetOntapStorageVirtualMachineEndpointResult',
    'GetOntapStorageVirtualMachineEndpointIscsiResult',
    'GetOntapStorageVirtualMachineEndpointManagementResult',
    'GetOntapStorageVirtualMachineEndpointNfResult',
    'GetOntapStorageVirtualMachineEndpointSmbResult',
    'GetOntapStorageVirtualMachineFilterResult',
    'GetOntapStorageVirtualMachineLifecycleTransitionReasonResult',
    'GetOntapStorageVirtualMachinesFilterResult',
    'GetOpenZfsSnapshotFilterResult',
    'GetWindowsFileSystemAuditLogConfigurationResult',
    'GetWindowsFileSystemDiskIopsConfigurationResult',
]

@pulumi.output_type
class DataRepositoryAssociationS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoExportPolicy":
            suggest = "auto_export_policy"
        elif key == "autoImportPolicy":
            suggest = "auto_import_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataRepositoryAssociationS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataRepositoryAssociationS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataRepositoryAssociationS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_export_policy: Optional['outputs.DataRepositoryAssociationS3AutoExportPolicy'] = None,
                 auto_import_policy: Optional['outputs.DataRepositoryAssociationS3AutoImportPolicy'] = None):
        if auto_export_policy is not None:
            pulumi.set(__self__, "auto_export_policy", auto_export_policy)
        if auto_import_policy is not None:
            pulumi.set(__self__, "auto_import_policy", auto_import_policy)

    @_builtins.property
    @pulumi.getter(name="autoExportPolicy")
    def auto_export_policy(self) -> Optional['outputs.DataRepositoryAssociationS3AutoExportPolicy']:
        return pulumi.get(self, "auto_export_policy")

    @_builtins.property
    @pulumi.getter(name="autoImportPolicy")
    def auto_import_policy(self) -> Optional['outputs.DataRepositoryAssociationS3AutoImportPolicy']:
        return pulumi.get(self, "auto_import_policy")


@pulumi.output_type
class DataRepositoryAssociationS3AutoExportPolicy(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence[_builtins.str]] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "events")


@pulumi.output_type
class DataRepositoryAssociationS3AutoImportPolicy(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence[_builtins.str]] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "events")


@pulumi.output_type
class FileCacheDataRepositoryAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataRepositoryPath":
            suggest = "data_repository_path"
        elif key == "fileCachePath":
            suggest = "file_cache_path"
        elif key == "associationId":
            suggest = "association_id"
        elif key == "dataRepositorySubdirectories":
            suggest = "data_repository_subdirectories"
        elif key == "fileCacheId":
            suggest = "file_cache_id"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "fileSystemPath":
            suggest = "file_system_path"
        elif key == "importedFileChunkSize":
            suggest = "imported_file_chunk_size"
        elif key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileCacheDataRepositoryAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileCacheDataRepositoryAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileCacheDataRepositoryAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_repository_path: _builtins.str,
                 file_cache_path: _builtins.str,
                 association_id: Optional[_builtins.str] = None,
                 data_repository_subdirectories: Optional[Sequence[_builtins.str]] = None,
                 file_cache_id: Optional[_builtins.str] = None,
                 file_system_id: Optional[_builtins.str] = None,
                 file_system_path: Optional[_builtins.str] = None,
                 imported_file_chunk_size: Optional[_builtins.int] = None,
                 nfs: Optional[Sequence['outputs.FileCacheDataRepositoryAssociationNf']] = None,
                 resource_arn: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "data_repository_path", data_repository_path)
        pulumi.set(__self__, "file_cache_path", file_cache_path)
        if association_id is not None:
            pulumi.set(__self__, "association_id", association_id)
        if data_repository_subdirectories is not None:
            pulumi.set(__self__, "data_repository_subdirectories", data_repository_subdirectories)
        if file_cache_id is not None:
            pulumi.set(__self__, "file_cache_id", file_cache_id)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if file_system_path is not None:
            pulumi.set(__self__, "file_system_path", file_system_path)
        if imported_file_chunk_size is not None:
            pulumi.set(__self__, "imported_file_chunk_size", imported_file_chunk_size)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="dataRepositoryPath")
    def data_repository_path(self) -> _builtins.str:
        return pulumi.get(self, "data_repository_path")

    @_builtins.property
    @pulumi.getter(name="fileCachePath")
    def file_cache_path(self) -> _builtins.str:
        return pulumi.get(self, "file_cache_path")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="dataRepositorySubdirectories")
    def data_repository_subdirectories(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "data_repository_subdirectories")

    @_builtins.property
    @pulumi.getter(name="fileCacheId")
    def file_cache_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_cache_id")

    @_builtins.property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_system_id")

    @_builtins.property
    @pulumi.getter(name="fileSystemPath")
    def file_system_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_system_path")

    @_builtins.property
    @pulumi.getter(name="importedFileChunkSize")
    def imported_file_chunk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "imported_file_chunk_size")

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Optional[Sequence['outputs.FileCacheDataRepositoryAssociationNf']]:
        return pulumi.get(self, "nfs")

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_arn")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class FileCacheDataRepositoryAssociationNf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsIps":
            suggest = "dns_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileCacheDataRepositoryAssociationNf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileCacheDataRepositoryAssociationNf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileCacheDataRepositoryAssociationNf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 dns_ips: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "version", version)
        if dns_ips is not None:
            pulumi.set(__self__, "dns_ips", dns_ips)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dns_ips")


@pulumi.output_type
class FileCacheLustreConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentType":
            suggest = "deployment_type"
        elif key == "metadataConfigurations":
            suggest = "metadata_configurations"
        elif key == "perUnitStorageThroughput":
            suggest = "per_unit_storage_throughput"
        elif key == "logConfigurations":
            suggest = "log_configurations"
        elif key == "mountName":
            suggest = "mount_name"
        elif key == "weeklyMaintenanceStartTime":
            suggest = "weekly_maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileCacheLustreConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileCacheLustreConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileCacheLustreConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_type: _builtins.str,
                 metadata_configurations: Sequence['outputs.FileCacheLustreConfigurationMetadataConfiguration'],
                 per_unit_storage_throughput: _builtins.int,
                 log_configurations: Optional[Sequence['outputs.FileCacheLustreConfigurationLogConfiguration']] = None,
                 mount_name: Optional[_builtins.str] = None,
                 weekly_maintenance_start_time: Optional[_builtins.str] = None):
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "metadata_configurations", metadata_configurations)
        pulumi.set(__self__, "per_unit_storage_throughput", per_unit_storage_throughput)
        if log_configurations is not None:
            pulumi.set(__self__, "log_configurations", log_configurations)
        if mount_name is not None:
            pulumi.set(__self__, "mount_name", mount_name)
        if weekly_maintenance_start_time is not None:
            pulumi.set(__self__, "weekly_maintenance_start_time", weekly_maintenance_start_time)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> _builtins.str:
        return pulumi.get(self, "deployment_type")

    @_builtins.property
    @pulumi.getter(name="metadataConfigurations")
    def metadata_configurations(self) -> Sequence['outputs.FileCacheLustreConfigurationMetadataConfiguration']:
        return pulumi.get(self, "metadata_configurations")

    @_builtins.property
    @pulumi.getter(name="perUnitStorageThroughput")
    def per_unit_storage_throughput(self) -> _builtins.int:
        return pulumi.get(self, "per_unit_storage_throughput")

    @_builtins.property
    @pulumi.getter(name="logConfigurations")
    def log_configurations(self) -> Optional[Sequence['outputs.FileCacheLustreConfigurationLogConfiguration']]:
        return pulumi.get(self, "log_configurations")

    @_builtins.property
    @pulumi.getter(name="mountName")
    def mount_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_name")

    @_builtins.property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "weekly_maintenance_start_time")


@pulumi.output_type
class FileCacheLustreConfigurationLogConfiguration(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "level")


@pulumi.output_type
class FileCacheLustreConfigurationMetadataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCapacity":
            suggest = "storage_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileCacheLustreConfigurationMetadataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileCacheLustreConfigurationMetadataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileCacheLustreConfigurationMetadataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_capacity: _builtins.int):
        pulumi.set(__self__, "storage_capacity", storage_capacity)

    @_builtins.property
    @pulumi.getter(name="storageCapacity")
    def storage_capacity(self) -> _builtins.int:
        return pulumi.get(self, "storage_capacity")


@pulumi.output_type
class LustreFileSystemDataReadCacheConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizingMode":
            suggest = "sizing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LustreFileSystemDataReadCacheConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LustreFileSystemDataReadCacheConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LustreFileSystemDataReadCacheConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sizing_mode: _builtins.str,
                 size: Optional[_builtins.int] = None):
        pulumi.set(__self__, "sizing_mode", sizing_mode)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="sizingMode")
    def sizing_mode(self) -> _builtins.str:
        return pulumi.get(self, "sizing_mode")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")


@pulumi.output_type
class LustreFileSystemLogConfiguration(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "level")


@pulumi.output_type
class LustreFileSystemMetadataConfiguration(dict):
    def __init__(__self__, *,
                 iops: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class LustreFileSystemRootSquashConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noSquashNids":
            suggest = "no_squash_nids"
        elif key == "rootSquash":
            suggest = "root_squash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LustreFileSystemRootSquashConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LustreFileSystemRootSquashConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LustreFileSystemRootSquashConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_squash_nids: Optional[Sequence[_builtins.str]] = None,
                 root_squash: Optional[_builtins.str] = None):
        if no_squash_nids is not None:
            pulumi.set(__self__, "no_squash_nids", no_squash_nids)
        if root_squash is not None:
            pulumi.set(__self__, "root_squash", root_squash)

    @_builtins.property
    @pulumi.getter(name="noSquashNids")
    def no_squash_nids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "no_squash_nids")

    @_builtins.property
    @pulumi.getter(name="rootSquash")
    def root_squash(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "root_squash")


@pulumi.output_type
class OntapFileSystemDiskIopsConfiguration(dict):
    def __init__(__self__, *,
                 iops: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class OntapFileSystemEndpoint(dict):
    def __init__(__self__, *,
                 interclusters: Optional[Sequence['outputs.OntapFileSystemEndpointIntercluster']] = None,
                 managements: Optional[Sequence['outputs.OntapFileSystemEndpointManagement']] = None):
        if interclusters is not None:
            pulumi.set(__self__, "interclusters", interclusters)
        if managements is not None:
            pulumi.set(__self__, "managements", managements)

    @_builtins.property
    @pulumi.getter
    def interclusters(self) -> Optional[Sequence['outputs.OntapFileSystemEndpointIntercluster']]:
        return pulumi.get(self, "interclusters")

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Optional[Sequence['outputs.OntapFileSystemEndpointManagement']]:
        return pulumi.get(self, "managements")


@pulumi.output_type
class OntapFileSystemEndpointIntercluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapFileSystemEndpointIntercluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapFileSystemEndpointIntercluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapFileSystemEndpointIntercluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapFileSystemEndpointManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapFileSystemEndpointManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapFileSystemEndpointManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapFileSystemEndpointManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapStorageVirtualMachineActiveDirectoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "netbiosName":
            suggest = "netbios_name"
        elif key == "selfManagedActiveDirectoryConfiguration":
            suggest = "self_managed_active_directory_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineActiveDirectoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineActiveDirectoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineActiveDirectoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 netbios_name: Optional[_builtins.str] = None,
                 self_managed_active_directory_configuration: Optional['outputs.OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration'] = None):
        if netbios_name is not None:
            pulumi.set(__self__, "netbios_name", netbios_name)
        if self_managed_active_directory_configuration is not None:
            pulumi.set(__self__, "self_managed_active_directory_configuration", self_managed_active_directory_configuration)

    @_builtins.property
    @pulumi.getter(name="netbiosName")
    def netbios_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netbios_name")

    @_builtins.property
    @pulumi.getter(name="selfManagedActiveDirectoryConfiguration")
    def self_managed_active_directory_configuration(self) -> Optional['outputs.OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration']:
        return pulumi.get(self, "self_managed_active_directory_configuration")


@pulumi.output_type
class OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsIps":
            suggest = "dns_ips"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "fileSystemAdministratorsGroup":
            suggest = "file_system_administrators_group"
        elif key == "organizationalUnitDistinguishedName":
            suggest = "organizational_unit_distinguished_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_ips: Sequence[_builtins.str],
                 domain_name: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str,
                 file_system_administrators_group: Optional[_builtins.str] = None,
                 organizational_unit_distinguished_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "dns_ips", dns_ips)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if file_system_administrators_group is not None:
            pulumi.set(__self__, "file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_ips")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_system_administrators_group")

    @_builtins.property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "organizational_unit_distinguished_name")


@pulumi.output_type
class OntapStorageVirtualMachineEndpoint(dict):
    def __init__(__self__, *,
                 iscsis: Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointIscsi']] = None,
                 managements: Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointManagement']] = None,
                 nfs: Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointNf']] = None,
                 smbs: Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointSmb']] = None):
        if iscsis is not None:
            pulumi.set(__self__, "iscsis", iscsis)
        if managements is not None:
            pulumi.set(__self__, "managements", managements)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if smbs is not None:
            pulumi.set(__self__, "smbs", smbs)

    @_builtins.property
    @pulumi.getter
    def iscsis(self) -> Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointIscsi']]:
        return pulumi.get(self, "iscsis")

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointManagement']]:
        return pulumi.get(self, "managements")

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointNf']]:
        return pulumi.get(self, "nfs")

    @_builtins.property
    @pulumi.getter
    def smbs(self) -> Optional[Sequence['outputs.OntapStorageVirtualMachineEndpointSmb']]:
        return pulumi.get(self, "smbs")


@pulumi.output_type
class OntapStorageVirtualMachineEndpointIscsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineEndpointIscsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineEndpointIscsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineEndpointIscsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapStorageVirtualMachineEndpointManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineEndpointManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineEndpointManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineEndpointManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapStorageVirtualMachineEndpointNf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineEndpointNf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineEndpointNf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineEndpointNf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapStorageVirtualMachineEndpointSmb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapStorageVirtualMachineEndpointSmb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapStorageVirtualMachineEndpointSmb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapStorageVirtualMachineEndpointSmb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 ip_addresses: Optional[Sequence[_builtins.str]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OntapVolumeAggregateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "constituentsPerAggregate":
            suggest = "constituents_per_aggregate"
        elif key == "totalConstituents":
            suggest = "total_constituents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapVolumeAggregateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapVolumeAggregateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapVolumeAggregateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregates: Optional[Sequence[_builtins.str]] = None,
                 constituents_per_aggregate: Optional[_builtins.int] = None,
                 total_constituents: Optional[_builtins.int] = None):
        if aggregates is not None:
            pulumi.set(__self__, "aggregates", aggregates)
        if constituents_per_aggregate is not None:
            pulumi.set(__self__, "constituents_per_aggregate", constituents_per_aggregate)
        if total_constituents is not None:
            pulumi.set(__self__, "total_constituents", total_constituents)

    @_builtins.property
    @pulumi.getter
    def aggregates(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "aggregates")

    @_builtins.property
    @pulumi.getter(name="constituentsPerAggregate")
    def constituents_per_aggregate(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "constituents_per_aggregate")

    @_builtins.property
    @pulumi.getter(name="totalConstituents")
    def total_constituents(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_constituents")


@pulumi.output_type
class OntapVolumeSnaplockConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snaplockType":
            suggest = "snaplock_type"
        elif key == "auditLogVolume":
            suggest = "audit_log_volume"
        elif key == "autocommitPeriod":
            suggest = "autocommit_period"
        elif key == "privilegedDelete":
            suggest = "privileged_delete"
        elif key == "retentionPeriod":
            suggest = "retention_period"
        elif key == "volumeAppendModeEnabled":
            suggest = "volume_append_mode_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapVolumeSnaplockConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapVolumeSnaplockConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapVolumeSnaplockConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snaplock_type: _builtins.str,
                 audit_log_volume: Optional[_builtins.bool] = None,
                 autocommit_period: Optional['outputs.OntapVolumeSnaplockConfigurationAutocommitPeriod'] = None,
                 privileged_delete: Optional[_builtins.str] = None,
                 retention_period: Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriod'] = None,
                 volume_append_mode_enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "snaplock_type", snaplock_type)
        if audit_log_volume is not None:
            pulumi.set(__self__, "audit_log_volume", audit_log_volume)
        if autocommit_period is not None:
            pulumi.set(__self__, "autocommit_period", autocommit_period)
        if privileged_delete is not None:
            pulumi.set(__self__, "privileged_delete", privileged_delete)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)
        if volume_append_mode_enabled is not None:
            pulumi.set(__self__, "volume_append_mode_enabled", volume_append_mode_enabled)

    @_builtins.property
    @pulumi.getter(name="snaplockType")
    def snaplock_type(self) -> _builtins.str:
        return pulumi.get(self, "snaplock_type")

    @_builtins.property
    @pulumi.getter(name="auditLogVolume")
    def audit_log_volume(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "audit_log_volume")

    @_builtins.property
    @pulumi.getter(name="autocommitPeriod")
    def autocommit_period(self) -> Optional['outputs.OntapVolumeSnaplockConfigurationAutocommitPeriod']:
        return pulumi.get(self, "autocommit_period")

    @_builtins.property
    @pulumi.getter(name="privilegedDelete")
    def privileged_delete(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "privileged_delete")

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriod']:
        return pulumi.get(self, "retention_period")

    @_builtins.property
    @pulumi.getter(name="volumeAppendModeEnabled")
    def volume_append_mode_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "volume_append_mode_enabled")


@pulumi.output_type
class OntapVolumeSnaplockConfigurationAutocommitPeriod(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OntapVolumeSnaplockConfigurationRetentionPeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"
        elif key == "maximumRetention":
            suggest = "maximum_retention"
        elif key == "minimumRetention":
            suggest = "minimum_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapVolumeSnaplockConfigurationRetentionPeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapVolumeSnaplockConfigurationRetentionPeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapVolumeSnaplockConfigurationRetentionPeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention'] = None,
                 maximum_retention: Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention'] = None,
                 minimum_retention: Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention'] = None):
        if default_retention is not None:
            pulumi.set(__self__, "default_retention", default_retention)
        if maximum_retention is not None:
            pulumi.set(__self__, "maximum_retention", maximum_retention)
        if minimum_retention is not None:
            pulumi.set(__self__, "minimum_retention", minimum_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention']:
        return pulumi.get(self, "default_retention")

    @_builtins.property
    @pulumi.getter(name="maximumRetention")
    def maximum_retention(self) -> Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention']:
        return pulumi.get(self, "maximum_retention")

    @_builtins.property
    @pulumi.getter(name="minimumRetention")
    def minimum_retention(self) -> Optional['outputs.OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention']:
        return pulumi.get(self, "minimum_retention")


@pulumi.output_type
class OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OntapVolumeTieringPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coolingPeriod":
            suggest = "cooling_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OntapVolumeTieringPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OntapVolumeTieringPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OntapVolumeTieringPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cooling_period: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        if cooling_period is not None:
            pulumi.set(__self__, "cooling_period", cooling_period)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="coolingPeriod")
    def cooling_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cooling_period")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class OpenZfsFileSystemDiskIopsConfiguration(dict):
    def __init__(__self__, *,
                 iops: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class OpenZfsFileSystemReadCacheConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizingMode":
            suggest = "sizing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsFileSystemReadCacheConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsFileSystemReadCacheConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsFileSystemReadCacheConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None,
                 sizing_mode: Optional[_builtins.str] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)
        if sizing_mode is not None:
            pulumi.set(__self__, "sizing_mode", sizing_mode)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizingMode")
    def sizing_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sizing_mode")


@pulumi.output_type
class OpenZfsFileSystemRootVolumeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyTagsToSnapshots":
            suggest = "copy_tags_to_snapshots"
        elif key == "dataCompressionType":
            suggest = "data_compression_type"
        elif key == "nfsExports":
            suggest = "nfs_exports"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "recordSizeKib":
            suggest = "record_size_kib"
        elif key == "userAndGroupQuotas":
            suggest = "user_and_group_quotas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsFileSystemRootVolumeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsFileSystemRootVolumeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsFileSystemRootVolumeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_tags_to_snapshots: Optional[_builtins.bool] = None,
                 data_compression_type: Optional[_builtins.str] = None,
                 nfs_exports: Optional['outputs.OpenZfsFileSystemRootVolumeConfigurationNfsExports'] = None,
                 read_only: Optional[_builtins.bool] = None,
                 record_size_kib: Optional[_builtins.int] = None,
                 user_and_group_quotas: Optional[Sequence['outputs.OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota']] = None):
        if copy_tags_to_snapshots is not None:
            pulumi.set(__self__, "copy_tags_to_snapshots", copy_tags_to_snapshots)
        if data_compression_type is not None:
            pulumi.set(__self__, "data_compression_type", data_compression_type)
        if nfs_exports is not None:
            pulumi.set(__self__, "nfs_exports", nfs_exports)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if record_size_kib is not None:
            pulumi.set(__self__, "record_size_kib", record_size_kib)
        if user_and_group_quotas is not None:
            pulumi.set(__self__, "user_and_group_quotas", user_and_group_quotas)

    @_builtins.property
    @pulumi.getter(name="copyTagsToSnapshots")
    def copy_tags_to_snapshots(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "copy_tags_to_snapshots")

    @_builtins.property
    @pulumi.getter(name="dataCompressionType")
    def data_compression_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_compression_type")

    @_builtins.property
    @pulumi.getter(name="nfsExports")
    def nfs_exports(self) -> Optional['outputs.OpenZfsFileSystemRootVolumeConfigurationNfsExports']:
        return pulumi.get(self, "nfs_exports")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter(name="recordSizeKib")
    def record_size_kib(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "record_size_kib")

    @_builtins.property
    @pulumi.getter(name="userAndGroupQuotas")
    def user_and_group_quotas(self) -> Optional[Sequence['outputs.OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota']]:
        return pulumi.get(self, "user_and_group_quotas")


@pulumi.output_type
class OpenZfsFileSystemRootVolumeConfigurationNfsExports(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientConfigurations":
            suggest = "client_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsFileSystemRootVolumeConfigurationNfsExports. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsFileSystemRootVolumeConfigurationNfsExports.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsFileSystemRootVolumeConfigurationNfsExports.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_configurations: Sequence['outputs.OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration']):
        pulumi.set(__self__, "client_configurations", client_configurations)

    @_builtins.property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> Sequence['outputs.OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration']:
        return pulumi.get(self, "client_configurations")


@pulumi.output_type
class OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration(dict):
    def __init__(__self__, *,
                 clients: _builtins.str,
                 options: Sequence[_builtins.str]):
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> _builtins.str:
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "options")


@pulumi.output_type
class OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCapacityQuotaGib":
            suggest = "storage_capacity_quota_gib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.int,
                 storage_capacity_quota_gib: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "storage_capacity_quota_gib", storage_capacity_quota_gib)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="storageCapacityQuotaGib")
    def storage_capacity_quota_gib(self) -> _builtins.int:
        return pulumi.get(self, "storage_capacity_quota_gib")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OpenZfsVolumeNfsExports(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientConfigurations":
            suggest = "client_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsVolumeNfsExports. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsVolumeNfsExports.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsVolumeNfsExports.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_configurations: Sequence['outputs.OpenZfsVolumeNfsExportsClientConfiguration']):
        pulumi.set(__self__, "client_configurations", client_configurations)

    @_builtins.property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> Sequence['outputs.OpenZfsVolumeNfsExportsClientConfiguration']:
        return pulumi.get(self, "client_configurations")


@pulumi.output_type
class OpenZfsVolumeNfsExportsClientConfiguration(dict):
    def __init__(__self__, *,
                 clients: _builtins.str,
                 options: Sequence[_builtins.str]):
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> _builtins.str:
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "options")


@pulumi.output_type
class OpenZfsVolumeOriginSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyStrategy":
            suggest = "copy_strategy"
        elif key == "snapshotArn":
            suggest = "snapshot_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsVolumeOriginSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsVolumeOriginSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsVolumeOriginSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_strategy: _builtins.str,
                 snapshot_arn: _builtins.str):
        pulumi.set(__self__, "copy_strategy", copy_strategy)
        pulumi.set(__self__, "snapshot_arn", snapshot_arn)

    @_builtins.property
    @pulumi.getter(name="copyStrategy")
    def copy_strategy(self) -> _builtins.str:
        return pulumi.get(self, "copy_strategy")

    @_builtins.property
    @pulumi.getter(name="snapshotArn")
    def snapshot_arn(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_arn")


@pulumi.output_type
class OpenZfsVolumeUserAndGroupQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCapacityQuotaGib":
            suggest = "storage_capacity_quota_gib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenZfsVolumeUserAndGroupQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenZfsVolumeUserAndGroupQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenZfsVolumeUserAndGroupQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.int,
                 storage_capacity_quota_gib: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "storage_capacity_quota_gib", storage_capacity_quota_gib)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="storageCapacityQuotaGib")
    def storage_capacity_quota_gib(self) -> _builtins.int:
        return pulumi.get(self, "storage_capacity_quota_gib")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class S3AccessPointAttachmentOpenzfsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "fileSystemIdentity":
            suggest = "file_system_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointAttachmentOpenzfsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointAttachmentOpenzfsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointAttachmentOpenzfsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_id: _builtins.str,
                 file_system_identity: Optional['outputs.S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity'] = None):
        pulumi.set(__self__, "volume_id", volume_id)
        if file_system_identity is not None:
            pulumi.set(__self__, "file_system_identity", file_system_identity)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="fileSystemIdentity")
    def file_system_identity(self) -> Optional['outputs.S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity']:
        return pulumi.get(self, "file_system_identity")


@pulumi.output_type
class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "posixUser":
            suggest = "posix_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 posix_user: Optional['outputs.S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser'] = None):
        pulumi.set(__self__, "type", type)
        if posix_user is not None:
            pulumi.set(__self__, "posix_user", posix_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="posixUser")
    def posix_user(self) -> Optional['outputs.S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser']:
        return pulumi.get(self, "posix_user")


@pulumi.output_type
class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryGids":
            suggest = "secondary_gids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gid: _builtins.int,
                 uid: _builtins.int,
                 secondary_gids: Optional[Sequence[_builtins.int]] = None):
        pulumi.set(__self__, "gid", gid)
        pulumi.set(__self__, "uid", uid)
        if secondary_gids is not None:
            pulumi.set(__self__, "secondary_gids", secondary_gids)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> _builtins.int:
        return pulumi.get(self, "gid")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.int:
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="secondaryGids")
    def secondary_gids(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "secondary_gids")


@pulumi.output_type
class S3AccessPointAttachmentS3AccessPoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcConfiguration":
            suggest = "vpc_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointAttachmentS3AccessPoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointAttachmentS3AccessPoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointAttachmentS3AccessPoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: Optional[_builtins.str] = None,
                 vpc_configuration: Optional['outputs.S3AccessPointAttachmentS3AccessPointVpcConfiguration'] = None):
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional['outputs.S3AccessPointAttachmentS3AccessPointVpcConfiguration']:
        return pulumi.get(self, "vpc_configuration")


@pulumi.output_type
class S3AccessPointAttachmentS3AccessPointVpcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointAttachmentS3AccessPointVpcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointAttachmentS3AccessPointVpcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointAttachmentS3AccessPointVpcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_id: Optional[_builtins.str] = None):
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class S3AccessPointAttachmentTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class WindowsFileSystemAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogDestination":
            suggest = "audit_log_destination"
        elif key == "fileAccessAuditLogLevel":
            suggest = "file_access_audit_log_level"
        elif key == "fileShareAccessAuditLogLevel":
            suggest = "file_share_access_audit_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFileSystemAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFileSystemAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFileSystemAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log_destination: Optional[_builtins.str] = None,
                 file_access_audit_log_level: Optional[_builtins.str] = None,
                 file_share_access_audit_log_level: Optional[_builtins.str] = None):
        if audit_log_destination is not None:
            pulumi.set(__self__, "audit_log_destination", audit_log_destination)
        if file_access_audit_log_level is not None:
            pulumi.set(__self__, "file_access_audit_log_level", file_access_audit_log_level)
        if file_share_access_audit_log_level is not None:
            pulumi.set(__self__, "file_share_access_audit_log_level", file_share_access_audit_log_level)

    @_builtins.property
    @pulumi.getter(name="auditLogDestination")
    def audit_log_destination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "audit_log_destination")

    @_builtins.property
    @pulumi.getter(name="fileAccessAuditLogLevel")
    def file_access_audit_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_access_audit_log_level")

    @_builtins.property
    @pulumi.getter(name="fileShareAccessAuditLogLevel")
    def file_share_access_audit_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_share_access_audit_log_level")


@pulumi.output_type
class WindowsFileSystemDiskIopsConfiguration(dict):
    def __init__(__self__, *,
                 iops: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class WindowsFileSystemSelfManagedActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsIps":
            suggest = "dns_ips"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "fileSystemAdministratorsGroup":
            suggest = "file_system_administrators_group"
        elif key == "organizationalUnitDistinguishedName":
            suggest = "organizational_unit_distinguished_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFileSystemSelfManagedActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFileSystemSelfManagedActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFileSystemSelfManagedActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_ips: Sequence[_builtins.str],
                 domain_name: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str,
                 file_system_administrators_group: Optional[_builtins.str] = None,
                 organizational_unit_distinguished_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "dns_ips", dns_ips)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if file_system_administrators_group is not None:
            pulumi.set(__self__, "file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_ips")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_system_administrators_group")

    @_builtins.property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "organizational_unit_distinguished_name")


@pulumi.output_type
class GetOntapFileSystemDiskIopsConfigurationResult(dict):
    def __init__(__self__, *,
                 iops: _builtins.int,
                 mode: _builtins.str):
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetOntapFileSystemEndpointResult(dict):
    def __init__(__self__, *,
                 interclusters: Sequence['outputs.GetOntapFileSystemEndpointInterclusterResult'],
                 managements: Sequence['outputs.GetOntapFileSystemEndpointManagementResult']):
        pulumi.set(__self__, "interclusters", interclusters)
        pulumi.set(__self__, "managements", managements)

    @_builtins.property
    @pulumi.getter
    def interclusters(self) -> Sequence['outputs.GetOntapFileSystemEndpointInterclusterResult']:
        return pulumi.get(self, "interclusters")

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Sequence['outputs.GetOntapFileSystemEndpointManagementResult']:
        return pulumi.get(self, "managements")


@pulumi.output_type
class GetOntapFileSystemEndpointInterclusterResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapFileSystemEndpointManagementResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapStorageVirtualMachineActiveDirectoryConfigurationResult(dict):
    def __init__(__self__, *,
                 netbios_name: _builtins.str,
                 self_managed_active_directory_configurations: Sequence['outputs.GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationResult']):
        pulumi.set(__self__, "netbios_name", netbios_name)
        pulumi.set(__self__, "self_managed_active_directory_configurations", self_managed_active_directory_configurations)

    @_builtins.property
    @pulumi.getter(name="netbiosName")
    def netbios_name(self) -> _builtins.str:
        return pulumi.get(self, "netbios_name")

    @_builtins.property
    @pulumi.getter(name="selfManagedActiveDirectoryConfigurations")
    def self_managed_active_directory_configurations(self) -> Sequence['outputs.GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationResult']:
        return pulumi.get(self, "self_managed_active_directory_configurations")


@pulumi.output_type
class GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationResult(dict):
    def __init__(__self__, *,
                 dns_ips: Sequence[_builtins.str],
                 domain_name: _builtins.str,
                 file_system_administrators_group: _builtins.str,
                 organizational_unit_distinguished_name: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "dns_ips", dns_ips)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "file_system_administrators_group", file_system_administrators_group)
        pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_ips")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> _builtins.str:
        return pulumi.get(self, "file_system_administrators_group")

    @_builtins.property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> _builtins.str:
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetOntapStorageVirtualMachineEndpointResult(dict):
    def __init__(__self__, *,
                 iscsis: Sequence['outputs.GetOntapStorageVirtualMachineEndpointIscsiResult'],
                 managements: Sequence['outputs.GetOntapStorageVirtualMachineEndpointManagementResult'],
                 nfs: Sequence['outputs.GetOntapStorageVirtualMachineEndpointNfResult'],
                 smbs: Sequence['outputs.GetOntapStorageVirtualMachineEndpointSmbResult']):
        pulumi.set(__self__, "iscsis", iscsis)
        pulumi.set(__self__, "managements", managements)
        pulumi.set(__self__, "nfs", nfs)
        pulumi.set(__self__, "smbs", smbs)

    @_builtins.property
    @pulumi.getter
    def iscsis(self) -> Sequence['outputs.GetOntapStorageVirtualMachineEndpointIscsiResult']:
        return pulumi.get(self, "iscsis")

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Sequence['outputs.GetOntapStorageVirtualMachineEndpointManagementResult']:
        return pulumi.get(self, "managements")

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Sequence['outputs.GetOntapStorageVirtualMachineEndpointNfResult']:
        return pulumi.get(self, "nfs")

    @_builtins.property
    @pulumi.getter
    def smbs(self) -> Sequence['outputs.GetOntapStorageVirtualMachineEndpointSmbResult']:
        return pulumi.get(self, "smbs")


@pulumi.output_type
class GetOntapStorageVirtualMachineEndpointIscsiResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapStorageVirtualMachineEndpointManagementResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapStorageVirtualMachineEndpointNfResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapStorageVirtualMachineEndpointSmbResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetOntapStorageVirtualMachineFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOntapStorageVirtualMachineLifecycleTransitionReasonResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str):
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        return pulumi.get(self, "message")


@pulumi.output_type
class GetOntapStorageVirtualMachinesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOpenZfsSnapshotFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetWindowsFileSystemAuditLogConfigurationResult(dict):
    def __init__(__self__, *,
                 audit_log_destination: _builtins.str,
                 file_access_audit_log_level: _builtins.str,
                 file_share_access_audit_log_level: _builtins.str):
        pulumi.set(__self__, "audit_log_destination", audit_log_destination)
        pulumi.set(__self__, "file_access_audit_log_level", file_access_audit_log_level)
        pulumi.set(__self__, "file_share_access_audit_log_level", file_share_access_audit_log_level)

    @_builtins.property
    @pulumi.getter(name="auditLogDestination")
    def audit_log_destination(self) -> _builtins.str:
        return pulumi.get(self, "audit_log_destination")

    @_builtins.property
    @pulumi.getter(name="fileAccessAuditLogLevel")
    def file_access_audit_log_level(self) -> _builtins.str:
        return pulumi.get(self, "file_access_audit_log_level")

    @_builtins.property
    @pulumi.getter(name="fileShareAccessAuditLogLevel")
    def file_share_access_audit_log_level(self) -> _builtins.str:
        return pulumi.get(self, "file_share_access_audit_log_level")


@pulumi.output_type
class GetWindowsFileSystemDiskIopsConfigurationResult(dict):
    def __init__(__self__, *,
                 iops: _builtins.int,
                 mode: _builtins.str):
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


