# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DataRepositoryAssociationS3Args',
    'DataRepositoryAssociationS3ArgsDict',
    'DataRepositoryAssociationS3AutoExportPolicyArgs',
    'DataRepositoryAssociationS3AutoExportPolicyArgsDict',
    'DataRepositoryAssociationS3AutoImportPolicyArgs',
    'DataRepositoryAssociationS3AutoImportPolicyArgsDict',
    'FileCacheDataRepositoryAssociationArgs',
    'FileCacheDataRepositoryAssociationArgsDict',
    'FileCacheDataRepositoryAssociationNfArgs',
    'FileCacheDataRepositoryAssociationNfArgsDict',
    'FileCacheLustreConfigurationArgs',
    'FileCacheLustreConfigurationArgsDict',
    'FileCacheLustreConfigurationLogConfigurationArgs',
    'FileCacheLustreConfigurationLogConfigurationArgsDict',
    'FileCacheLustreConfigurationMetadataConfigurationArgs',
    'FileCacheLustreConfigurationMetadataConfigurationArgsDict',
    'LustreFileSystemDataReadCacheConfigurationArgs',
    'LustreFileSystemDataReadCacheConfigurationArgsDict',
    'LustreFileSystemLogConfigurationArgs',
    'LustreFileSystemLogConfigurationArgsDict',
    'LustreFileSystemMetadataConfigurationArgs',
    'LustreFileSystemMetadataConfigurationArgsDict',
    'LustreFileSystemRootSquashConfigurationArgs',
    'LustreFileSystemRootSquashConfigurationArgsDict',
    'OntapFileSystemDiskIopsConfigurationArgs',
    'OntapFileSystemDiskIopsConfigurationArgsDict',
    'OntapFileSystemEndpointArgs',
    'OntapFileSystemEndpointArgsDict',
    'OntapFileSystemEndpointInterclusterArgs',
    'OntapFileSystemEndpointInterclusterArgsDict',
    'OntapFileSystemEndpointManagementArgs',
    'OntapFileSystemEndpointManagementArgsDict',
    'OntapStorageVirtualMachineActiveDirectoryConfigurationArgs',
    'OntapStorageVirtualMachineActiveDirectoryConfigurationArgsDict',
    'OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs',
    'OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgsDict',
    'OntapStorageVirtualMachineEndpointArgs',
    'OntapStorageVirtualMachineEndpointArgsDict',
    'OntapStorageVirtualMachineEndpointIscsiArgs',
    'OntapStorageVirtualMachineEndpointIscsiArgsDict',
    'OntapStorageVirtualMachineEndpointManagementArgs',
    'OntapStorageVirtualMachineEndpointManagementArgsDict',
    'OntapStorageVirtualMachineEndpointNfArgs',
    'OntapStorageVirtualMachineEndpointNfArgsDict',
    'OntapStorageVirtualMachineEndpointSmbArgs',
    'OntapStorageVirtualMachineEndpointSmbArgsDict',
    'OntapVolumeAggregateConfigurationArgs',
    'OntapVolumeAggregateConfigurationArgsDict',
    'OntapVolumeSnaplockConfigurationArgs',
    'OntapVolumeSnaplockConfigurationArgsDict',
    'OntapVolumeSnaplockConfigurationAutocommitPeriodArgs',
    'OntapVolumeSnaplockConfigurationAutocommitPeriodArgsDict',
    'OntapVolumeSnaplockConfigurationRetentionPeriodArgs',
    'OntapVolumeSnaplockConfigurationRetentionPeriodArgsDict',
    'OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgs',
    'OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgsDict',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgs',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgsDict',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgs',
    'OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgsDict',
    'OntapVolumeTieringPolicyArgs',
    'OntapVolumeTieringPolicyArgsDict',
    'OpenZfsFileSystemDiskIopsConfigurationArgs',
    'OpenZfsFileSystemDiskIopsConfigurationArgsDict',
    'OpenZfsFileSystemReadCacheConfigurationArgs',
    'OpenZfsFileSystemReadCacheConfigurationArgsDict',
    'OpenZfsFileSystemRootVolumeConfigurationArgs',
    'OpenZfsFileSystemRootVolumeConfigurationArgsDict',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgsDict',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs',
    'OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgsDict',
    'OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs',
    'OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgsDict',
    'OpenZfsVolumeNfsExportsArgs',
    'OpenZfsVolumeNfsExportsArgsDict',
    'OpenZfsVolumeNfsExportsClientConfigurationArgs',
    'OpenZfsVolumeNfsExportsClientConfigurationArgsDict',
    'OpenZfsVolumeOriginSnapshotArgs',
    'OpenZfsVolumeOriginSnapshotArgsDict',
    'OpenZfsVolumeUserAndGroupQuotaArgs',
    'OpenZfsVolumeUserAndGroupQuotaArgsDict',
    'S3AccessPointAttachmentOpenzfsConfigurationArgs',
    'S3AccessPointAttachmentOpenzfsConfigurationArgsDict',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgs',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgsDict',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgs',
    'S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgsDict',
    'S3AccessPointAttachmentS3AccessPointArgs',
    'S3AccessPointAttachmentS3AccessPointArgsDict',
    'S3AccessPointAttachmentS3AccessPointVpcConfigurationArgs',
    'S3AccessPointAttachmentS3AccessPointVpcConfigurationArgsDict',
    'S3AccessPointAttachmentTimeoutsArgs',
    'S3AccessPointAttachmentTimeoutsArgsDict',
    'WindowsFileSystemAuditLogConfigurationArgs',
    'WindowsFileSystemAuditLogConfigurationArgsDict',
    'WindowsFileSystemDiskIopsConfigurationArgs',
    'WindowsFileSystemDiskIopsConfigurationArgsDict',
    'WindowsFileSystemSelfManagedActiveDirectoryArgs',
    'WindowsFileSystemSelfManagedActiveDirectoryArgsDict',
    'GetOntapStorageVirtualMachineFilterArgs',
    'GetOntapStorageVirtualMachineFilterArgsDict',
    'GetOntapStorageVirtualMachinesFilterArgs',
    'GetOntapStorageVirtualMachinesFilterArgsDict',
    'GetOpenZfsSnapshotFilterArgs',
    'GetOpenZfsSnapshotFilterArgsDict',
]

MYPY = False

if not MYPY:
    class DataRepositoryAssociationS3ArgsDict(TypedDict):
        auto_export_policy: NotRequired[pulumi.Input['DataRepositoryAssociationS3AutoExportPolicyArgsDict']]
        auto_import_policy: NotRequired[pulumi.Input['DataRepositoryAssociationS3AutoImportPolicyArgsDict']]
elif False:
    DataRepositoryAssociationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataRepositoryAssociationS3Args:
    def __init__(__self__, *,
                 auto_export_policy: Optional[pulumi.Input['DataRepositoryAssociationS3AutoExportPolicyArgs']] = None,
                 auto_import_policy: Optional[pulumi.Input['DataRepositoryAssociationS3AutoImportPolicyArgs']] = None):
        if auto_export_policy is not None:
            pulumi.set(__self__, "auto_export_policy", auto_export_policy)
        if auto_import_policy is not None:
            pulumi.set(__self__, "auto_import_policy", auto_import_policy)

    @_builtins.property
    @pulumi.getter(name="autoExportPolicy")
    def auto_export_policy(self) -> Optional[pulumi.Input['DataRepositoryAssociationS3AutoExportPolicyArgs']]:
        return pulumi.get(self, "auto_export_policy")

    @auto_export_policy.setter
    def auto_export_policy(self, value: Optional[pulumi.Input['DataRepositoryAssociationS3AutoExportPolicyArgs']]):
        pulumi.set(self, "auto_export_policy", value)

    @_builtins.property
    @pulumi.getter(name="autoImportPolicy")
    def auto_import_policy(self) -> Optional[pulumi.Input['DataRepositoryAssociationS3AutoImportPolicyArgs']]:
        return pulumi.get(self, "auto_import_policy")

    @auto_import_policy.setter
    def auto_import_policy(self, value: Optional[pulumi.Input['DataRepositoryAssociationS3AutoImportPolicyArgs']]):
        pulumi.set(self, "auto_import_policy", value)


if not MYPY:
    class DataRepositoryAssociationS3AutoExportPolicyArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DataRepositoryAssociationS3AutoExportPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataRepositoryAssociationS3AutoExportPolicyArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)


if not MYPY:
    class DataRepositoryAssociationS3AutoImportPolicyArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DataRepositoryAssociationS3AutoImportPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataRepositoryAssociationS3AutoImportPolicyArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)


if not MYPY:
    class FileCacheDataRepositoryAssociationArgsDict(TypedDict):
        data_repository_path: pulumi.Input[_builtins.str]
        file_cache_path: pulumi.Input[_builtins.str]
        association_id: NotRequired[pulumi.Input[_builtins.str]]
        data_repository_subdirectories: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        file_cache_id: NotRequired[pulumi.Input[_builtins.str]]
        file_system_id: NotRequired[pulumi.Input[_builtins.str]]
        file_system_path: NotRequired[pulumi.Input[_builtins.str]]
        imported_file_chunk_size: NotRequired[pulumi.Input[_builtins.int]]
        nfs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FileCacheDataRepositoryAssociationNfArgsDict']]]]
        resource_arn: NotRequired[pulumi.Input[_builtins.str]]
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    FileCacheDataRepositoryAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileCacheDataRepositoryAssociationArgs:
    def __init__(__self__, *,
                 data_repository_path: pulumi.Input[_builtins.str],
                 file_cache_path: pulumi.Input[_builtins.str],
                 association_id: Optional[pulumi.Input[_builtins.str]] = None,
                 data_repository_subdirectories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 file_cache_id: Optional[pulumi.Input[_builtins.str]] = None,
                 file_system_id: Optional[pulumi.Input[_builtins.str]] = None,
                 file_system_path: Optional[pulumi.Input[_builtins.str]] = None,
                 imported_file_chunk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 nfs: Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheDataRepositoryAssociationNfArgs']]]] = None,
                 resource_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "data_repository_path", data_repository_path)
        pulumi.set(__self__, "file_cache_path", file_cache_path)
        if association_id is not None:
            pulumi.set(__self__, "association_id", association_id)
        if data_repository_subdirectories is not None:
            pulumi.set(__self__, "data_repository_subdirectories", data_repository_subdirectories)
        if file_cache_id is not None:
            pulumi.set(__self__, "file_cache_id", file_cache_id)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if file_system_path is not None:
            pulumi.set(__self__, "file_system_path", file_system_path)
        if imported_file_chunk_size is not None:
            pulumi.set(__self__, "imported_file_chunk_size", imported_file_chunk_size)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="dataRepositoryPath")
    def data_repository_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_repository_path")

    @data_repository_path.setter
    def data_repository_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_repository_path", value)

    @_builtins.property
    @pulumi.getter(name="fileCachePath")
    def file_cache_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_cache_path")

    @file_cache_path.setter
    def file_cache_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_cache_path", value)

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "association_id")

    @association_id.setter
    def association_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "association_id", value)

    @_builtins.property
    @pulumi.getter(name="dataRepositorySubdirectories")
    def data_repository_subdirectories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "data_repository_subdirectories")

    @data_repository_subdirectories.setter
    def data_repository_subdirectories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_repository_subdirectories", value)

    @_builtins.property
    @pulumi.getter(name="fileCacheId")
    def file_cache_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_cache_id")

    @file_cache_id.setter
    def file_cache_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_cache_id", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_id", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemPath")
    def file_system_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_system_path")

    @file_system_path.setter
    def file_system_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_path", value)

    @_builtins.property
    @pulumi.getter(name="importedFileChunkSize")
    def imported_file_chunk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "imported_file_chunk_size")

    @imported_file_chunk_size.setter
    def imported_file_chunk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "imported_file_chunk_size", value)

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheDataRepositoryAssociationNfArgs']]]]:
        return pulumi.get(self, "nfs")

    @nfs.setter
    def nfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheDataRepositoryAssociationNfArgs']]]]):
        pulumi.set(self, "nfs", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FileCacheDataRepositoryAssociationNfArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        dns_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    FileCacheDataRepositoryAssociationNfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileCacheDataRepositoryAssociationNfArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 dns_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "version", version)
        if dns_ips is not None:
            pulumi.set(__self__, "dns_ips", dns_ips)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dns_ips")

    @dns_ips.setter
    def dns_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_ips", value)


if not MYPY:
    class FileCacheLustreConfigurationArgsDict(TypedDict):
        deployment_type: pulumi.Input[_builtins.str]
        metadata_configurations: pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationMetadataConfigurationArgsDict']]]
        per_unit_storage_throughput: pulumi.Input[_builtins.int]
        log_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationLogConfigurationArgsDict']]]]
        mount_name: NotRequired[pulumi.Input[_builtins.str]]
        weekly_maintenance_start_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FileCacheLustreConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileCacheLustreConfigurationArgs:
    def __init__(__self__, *,
                 deployment_type: pulumi.Input[_builtins.str],
                 metadata_configurations: pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationMetadataConfigurationArgs']]],
                 per_unit_storage_throughput: pulumi.Input[_builtins.int],
                 log_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationLogConfigurationArgs']]]] = None,
                 mount_name: Optional[pulumi.Input[_builtins.str]] = None,
                 weekly_maintenance_start_time: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "metadata_configurations", metadata_configurations)
        pulumi.set(__self__, "per_unit_storage_throughput", per_unit_storage_throughput)
        if log_configurations is not None:
            pulumi.set(__self__, "log_configurations", log_configurations)
        if mount_name is not None:
            pulumi.set(__self__, "mount_name", mount_name)
        if weekly_maintenance_start_time is not None:
            pulumi.set(__self__, "weekly_maintenance_start_time", weekly_maintenance_start_time)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_type", value)

    @_builtins.property
    @pulumi.getter(name="metadataConfigurations")
    def metadata_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationMetadataConfigurationArgs']]]:
        return pulumi.get(self, "metadata_configurations")

    @metadata_configurations.setter
    def metadata_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationMetadataConfigurationArgs']]]):
        pulumi.set(self, "metadata_configurations", value)

    @_builtins.property
    @pulumi.getter(name="perUnitStorageThroughput")
    def per_unit_storage_throughput(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "per_unit_storage_throughput")

    @per_unit_storage_throughput.setter
    def per_unit_storage_throughput(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "per_unit_storage_throughput", value)

    @_builtins.property
    @pulumi.getter(name="logConfigurations")
    def log_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationLogConfigurationArgs']]]]:
        return pulumi.get(self, "log_configurations")

    @log_configurations.setter
    def log_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FileCacheLustreConfigurationLogConfigurationArgs']]]]):
        pulumi.set(self, "log_configurations", value)

    @_builtins.property
    @pulumi.getter(name="mountName")
    def mount_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mount_name")

    @mount_name.setter
    def mount_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_name", value)

    @_builtins.property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "weekly_maintenance_start_time")

    @weekly_maintenance_start_time.setter
    def weekly_maintenance_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "weekly_maintenance_start_time", value)


if not MYPY:
    class FileCacheLustreConfigurationLogConfigurationArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FileCacheLustreConfigurationLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileCacheLustreConfigurationLogConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class FileCacheLustreConfigurationMetadataConfigurationArgsDict(TypedDict):
        storage_capacity: pulumi.Input[_builtins.int]
elif False:
    FileCacheLustreConfigurationMetadataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileCacheLustreConfigurationMetadataConfigurationArgs:
    def __init__(__self__, *,
                 storage_capacity: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "storage_capacity", storage_capacity)

    @_builtins.property
    @pulumi.getter(name="storageCapacity")
    def storage_capacity(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "storage_capacity")

    @storage_capacity.setter
    def storage_capacity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_capacity", value)


if not MYPY:
    class LustreFileSystemDataReadCacheConfigurationArgsDict(TypedDict):
        sizing_mode: pulumi.Input[_builtins.str]
        size: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    LustreFileSystemDataReadCacheConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LustreFileSystemDataReadCacheConfigurationArgs:
    def __init__(__self__, *,
                 sizing_mode: pulumi.Input[_builtins.str],
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "sizing_mode", sizing_mode)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="sizingMode")
    def sizing_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sizing_mode")

    @sizing_mode.setter
    def sizing_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sizing_mode", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class LustreFileSystemLogConfigurationArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LustreFileSystemLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LustreFileSystemLogConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class LustreFileSystemMetadataConfigurationArgsDict(TypedDict):
        iops: NotRequired[pulumi.Input[_builtins.int]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LustreFileSystemMetadataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LustreFileSystemMetadataConfigurationArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class LustreFileSystemRootSquashConfigurationArgsDict(TypedDict):
        no_squash_nids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        root_squash: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LustreFileSystemRootSquashConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LustreFileSystemRootSquashConfigurationArgs:
    def __init__(__self__, *,
                 no_squash_nids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 root_squash: Optional[pulumi.Input[_builtins.str]] = None):
        if no_squash_nids is not None:
            pulumi.set(__self__, "no_squash_nids", no_squash_nids)
        if root_squash is not None:
            pulumi.set(__self__, "root_squash", root_squash)

    @_builtins.property
    @pulumi.getter(name="noSquashNids")
    def no_squash_nids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "no_squash_nids")

    @no_squash_nids.setter
    def no_squash_nids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "no_squash_nids", value)

    @_builtins.property
    @pulumi.getter(name="rootSquash")
    def root_squash(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "root_squash")

    @root_squash.setter
    def root_squash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_squash", value)


if not MYPY:
    class OntapFileSystemDiskIopsConfigurationArgsDict(TypedDict):
        iops: NotRequired[pulumi.Input[_builtins.int]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OntapFileSystemDiskIopsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapFileSystemDiskIopsConfigurationArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class OntapFileSystemEndpointArgsDict(TypedDict):
        interclusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointInterclusterArgsDict']]]]
        managements: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointManagementArgsDict']]]]
elif False:
    OntapFileSystemEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapFileSystemEndpointArgs:
    def __init__(__self__, *,
                 interclusters: Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointInterclusterArgs']]]] = None,
                 managements: Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointManagementArgs']]]] = None):
        if interclusters is not None:
            pulumi.set(__self__, "interclusters", interclusters)
        if managements is not None:
            pulumi.set(__self__, "managements", managements)

    @_builtins.property
    @pulumi.getter
    def interclusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointInterclusterArgs']]]]:
        return pulumi.get(self, "interclusters")

    @interclusters.setter
    def interclusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointInterclusterArgs']]]]):
        pulumi.set(self, "interclusters", value)

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointManagementArgs']]]]:
        return pulumi.get(self, "managements")

    @managements.setter
    def managements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapFileSystemEndpointManagementArgs']]]]):
        pulumi.set(self, "managements", value)


if not MYPY:
    class OntapFileSystemEndpointInterclusterArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapFileSystemEndpointInterclusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapFileSystemEndpointInterclusterArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapFileSystemEndpointManagementArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapFileSystemEndpointManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapFileSystemEndpointManagementArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapStorageVirtualMachineActiveDirectoryConfigurationArgsDict(TypedDict):
        netbios_name: NotRequired[pulumi.Input[_builtins.str]]
        self_managed_active_directory_configuration: NotRequired[pulumi.Input['OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgsDict']]
elif False:
    OntapStorageVirtualMachineActiveDirectoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineActiveDirectoryConfigurationArgs:
    def __init__(__self__, *,
                 netbios_name: Optional[pulumi.Input[_builtins.str]] = None,
                 self_managed_active_directory_configuration: Optional[pulumi.Input['OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs']] = None):
        if netbios_name is not None:
            pulumi.set(__self__, "netbios_name", netbios_name)
        if self_managed_active_directory_configuration is not None:
            pulumi.set(__self__, "self_managed_active_directory_configuration", self_managed_active_directory_configuration)

    @_builtins.property
    @pulumi.getter(name="netbiosName")
    def netbios_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "netbios_name")

    @netbios_name.setter
    def netbios_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "netbios_name", value)

    @_builtins.property
    @pulumi.getter(name="selfManagedActiveDirectoryConfiguration")
    def self_managed_active_directory_configuration(self) -> Optional[pulumi.Input['OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs']]:
        return pulumi.get(self, "self_managed_active_directory_configuration")

    @self_managed_active_directory_configuration.setter
    def self_managed_active_directory_configuration(self, value: Optional[pulumi.Input['OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs']]):
        pulumi.set(self, "self_managed_active_directory_configuration", value)


if not MYPY:
    class OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgsDict(TypedDict):
        dns_ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        domain_name: pulumi.Input[_builtins.str]
        password: pulumi.Input[_builtins.str]
        username: pulumi.Input[_builtins.str]
        file_system_administrators_group: NotRequired[pulumi.Input[_builtins.str]]
        organizational_unit_distinguished_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs:
    def __init__(__self__, *,
                 dns_ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 domain_name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 file_system_administrators_group: Optional[pulumi.Input[_builtins.str]] = None,
                 organizational_unit_distinguished_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "dns_ips", dns_ips)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if file_system_administrators_group is not None:
            pulumi.set(__self__, "file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "dns_ips")

    @dns_ips.setter
    def dns_ips(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "dns_ips", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_system_administrators_group")

    @file_system_administrators_group.setter
    def file_system_administrators_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_administrators_group", value)

    @_builtins.property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @organizational_unit_distinguished_name.setter
    def organizational_unit_distinguished_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organizational_unit_distinguished_name", value)


if not MYPY:
    class OntapStorageVirtualMachineEndpointArgsDict(TypedDict):
        iscsis: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointIscsiArgsDict']]]]
        managements: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointManagementArgsDict']]]]
        nfs: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointNfArgsDict']]]]
        smbs: NotRequired[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointSmbArgsDict']]]]
elif False:
    OntapStorageVirtualMachineEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineEndpointArgs:
    def __init__(__self__, *,
                 iscsis: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointIscsiArgs']]]] = None,
                 managements: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointManagementArgs']]]] = None,
                 nfs: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointNfArgs']]]] = None,
                 smbs: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointSmbArgs']]]] = None):
        if iscsis is not None:
            pulumi.set(__self__, "iscsis", iscsis)
        if managements is not None:
            pulumi.set(__self__, "managements", managements)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if smbs is not None:
            pulumi.set(__self__, "smbs", smbs)

    @_builtins.property
    @pulumi.getter
    def iscsis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointIscsiArgs']]]]:
        return pulumi.get(self, "iscsis")

    @iscsis.setter
    def iscsis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointIscsiArgs']]]]):
        pulumi.set(self, "iscsis", value)

    @_builtins.property
    @pulumi.getter
    def managements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointManagementArgs']]]]:
        return pulumi.get(self, "managements")

    @managements.setter
    def managements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointManagementArgs']]]]):
        pulumi.set(self, "managements", value)

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointNfArgs']]]]:
        return pulumi.get(self, "nfs")

    @nfs.setter
    def nfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointNfArgs']]]]):
        pulumi.set(self, "nfs", value)

    @_builtins.property
    @pulumi.getter
    def smbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointSmbArgs']]]]:
        return pulumi.get(self, "smbs")

    @smbs.setter
    def smbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OntapStorageVirtualMachineEndpointSmbArgs']]]]):
        pulumi.set(self, "smbs", value)


if not MYPY:
    class OntapStorageVirtualMachineEndpointIscsiArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapStorageVirtualMachineEndpointIscsiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineEndpointIscsiArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapStorageVirtualMachineEndpointManagementArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapStorageVirtualMachineEndpointManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineEndpointManagementArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapStorageVirtualMachineEndpointNfArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapStorageVirtualMachineEndpointNfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineEndpointNfArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapStorageVirtualMachineEndpointSmbArgsDict(TypedDict):
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OntapStorageVirtualMachineEndpointSmbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapStorageVirtualMachineEndpointSmbArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OntapVolumeAggregateConfigurationArgsDict(TypedDict):
        aggregates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        constituents_per_aggregate: NotRequired[pulumi.Input[_builtins.int]]
        total_constituents: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OntapVolumeAggregateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeAggregateConfigurationArgs:
    def __init__(__self__, *,
                 aggregates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 constituents_per_aggregate: Optional[pulumi.Input[_builtins.int]] = None,
                 total_constituents: Optional[pulumi.Input[_builtins.int]] = None):
        if aggregates is not None:
            pulumi.set(__self__, "aggregates", aggregates)
        if constituents_per_aggregate is not None:
            pulumi.set(__self__, "constituents_per_aggregate", constituents_per_aggregate)
        if total_constituents is not None:
            pulumi.set(__self__, "total_constituents", total_constituents)

    @_builtins.property
    @pulumi.getter
    def aggregates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "aggregates")

    @aggregates.setter
    def aggregates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "aggregates", value)

    @_builtins.property
    @pulumi.getter(name="constituentsPerAggregate")
    def constituents_per_aggregate(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "constituents_per_aggregate")

    @constituents_per_aggregate.setter
    def constituents_per_aggregate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "constituents_per_aggregate", value)

    @_builtins.property
    @pulumi.getter(name="totalConstituents")
    def total_constituents(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "total_constituents")

    @total_constituents.setter
    def total_constituents(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_constituents", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationArgsDict(TypedDict):
        snaplock_type: pulumi.Input[_builtins.str]
        audit_log_volume: NotRequired[pulumi.Input[_builtins.bool]]
        autocommit_period: NotRequired[pulumi.Input['OntapVolumeSnaplockConfigurationAutocommitPeriodArgsDict']]
        privileged_delete: NotRequired[pulumi.Input[_builtins.str]]
        retention_period: NotRequired[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodArgsDict']]
        volume_append_mode_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    OntapVolumeSnaplockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationArgs:
    def __init__(__self__, *,
                 snaplock_type: pulumi.Input[_builtins.str],
                 audit_log_volume: Optional[pulumi.Input[_builtins.bool]] = None,
                 autocommit_period: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationAutocommitPeriodArgs']] = None,
                 privileged_delete: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_period: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodArgs']] = None,
                 volume_append_mode_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "snaplock_type", snaplock_type)
        if audit_log_volume is not None:
            pulumi.set(__self__, "audit_log_volume", audit_log_volume)
        if autocommit_period is not None:
            pulumi.set(__self__, "autocommit_period", autocommit_period)
        if privileged_delete is not None:
            pulumi.set(__self__, "privileged_delete", privileged_delete)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)
        if volume_append_mode_enabled is not None:
            pulumi.set(__self__, "volume_append_mode_enabled", volume_append_mode_enabled)

    @_builtins.property
    @pulumi.getter(name="snaplockType")
    def snaplock_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "snaplock_type")

    @snaplock_type.setter
    def snaplock_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "snaplock_type", value)

    @_builtins.property
    @pulumi.getter(name="auditLogVolume")
    def audit_log_volume(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "audit_log_volume")

    @audit_log_volume.setter
    def audit_log_volume(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_log_volume", value)

    @_builtins.property
    @pulumi.getter(name="autocommitPeriod")
    def autocommit_period(self) -> Optional[pulumi.Input['OntapVolumeSnaplockConfigurationAutocommitPeriodArgs']]:
        return pulumi.get(self, "autocommit_period")

    @autocommit_period.setter
    def autocommit_period(self, value: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationAutocommitPeriodArgs']]):
        pulumi.set(self, "autocommit_period", value)

    @_builtins.property
    @pulumi.getter(name="privilegedDelete")
    def privileged_delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "privileged_delete")

    @privileged_delete.setter
    def privileged_delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "privileged_delete", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodArgs']]:
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodArgs']]):
        pulumi.set(self, "retention_period", value)

    @_builtins.property
    @pulumi.getter(name="volumeAppendModeEnabled")
    def volume_append_mode_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "volume_append_mode_enabled")

    @volume_append_mode_enabled.setter
    def volume_append_mode_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "volume_append_mode_enabled", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationAutocommitPeriodArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OntapVolumeSnaplockConfigurationAutocommitPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationAutocommitPeriodArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationRetentionPeriodArgsDict(TypedDict):
        default_retention: NotRequired[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgsDict']]
        maximum_retention: NotRequired[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgsDict']]
        minimum_retention: NotRequired[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgsDict']]
elif False:
    OntapVolumeSnaplockConfigurationRetentionPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationRetentionPeriodArgs:
    def __init__(__self__, *,
                 default_retention: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgs']] = None,
                 maximum_retention: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgs']] = None,
                 minimum_retention: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgs']] = None):
        if default_retention is not None:
            pulumi.set(__self__, "default_retention", default_retention)
        if maximum_retention is not None:
            pulumi.set(__self__, "maximum_retention", maximum_retention)
        if minimum_retention is not None:
            pulumi.set(__self__, "minimum_retention", minimum_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgs']]:
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgs']]):
        pulumi.set(self, "default_retention", value)

    @_builtins.property
    @pulumi.getter(name="maximumRetention")
    def maximum_retention(self) -> Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgs']]:
        return pulumi.get(self, "maximum_retention")

    @maximum_retention.setter
    def maximum_retention(self, value: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgs']]):
        pulumi.set(self, "maximum_retention", value)

    @_builtins.property
    @pulumi.getter(name="minimumRetention")
    def minimum_retention(self) -> Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgs']]:
        return pulumi.get(self, "minimum_retention")

    @minimum_retention.setter
    def minimum_retention(self, value: Optional[pulumi.Input['OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgs']]):
        pulumi.set(self, "minimum_retention", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetentionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetentionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetentionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OntapVolumeTieringPolicyArgsDict(TypedDict):
        cooling_period: NotRequired[pulumi.Input[_builtins.int]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OntapVolumeTieringPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OntapVolumeTieringPolicyArgs:
    def __init__(__self__, *,
                 cooling_period: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if cooling_period is not None:
            pulumi.set(__self__, "cooling_period", cooling_period)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="coolingPeriod")
    def cooling_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cooling_period")

    @cooling_period.setter
    def cooling_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cooling_period", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OpenZfsFileSystemDiskIopsConfigurationArgsDict(TypedDict):
        iops: NotRequired[pulumi.Input[_builtins.int]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OpenZfsFileSystemDiskIopsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemDiskIopsConfigurationArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class OpenZfsFileSystemReadCacheConfigurationArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.int]]
        sizing_mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OpenZfsFileSystemReadCacheConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemReadCacheConfigurationArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 sizing_mode: Optional[pulumi.Input[_builtins.str]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)
        if sizing_mode is not None:
            pulumi.set(__self__, "sizing_mode", sizing_mode)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sizingMode")
    def sizing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sizing_mode")

    @sizing_mode.setter
    def sizing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sizing_mode", value)


if not MYPY:
    class OpenZfsFileSystemRootVolumeConfigurationArgsDict(TypedDict):
        copy_tags_to_snapshots: NotRequired[pulumi.Input[_builtins.bool]]
        data_compression_type: NotRequired[pulumi.Input[_builtins.str]]
        nfs_exports: NotRequired[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgsDict']]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        record_size_kib: NotRequired[pulumi.Input[_builtins.int]]
        user_and_group_quotas: NotRequired[pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgsDict']]]]
elif False:
    OpenZfsFileSystemRootVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemRootVolumeConfigurationArgs:
    def __init__(__self__, *,
                 copy_tags_to_snapshots: Optional[pulumi.Input[_builtins.bool]] = None,
                 data_compression_type: Optional[pulumi.Input[_builtins.str]] = None,
                 nfs_exports: Optional[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs']] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 record_size_kib: Optional[pulumi.Input[_builtins.int]] = None,
                 user_and_group_quotas: Optional[pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs']]]] = None):
        if copy_tags_to_snapshots is not None:
            pulumi.set(__self__, "copy_tags_to_snapshots", copy_tags_to_snapshots)
        if data_compression_type is not None:
            pulumi.set(__self__, "data_compression_type", data_compression_type)
        if nfs_exports is not None:
            pulumi.set(__self__, "nfs_exports", nfs_exports)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if record_size_kib is not None:
            pulumi.set(__self__, "record_size_kib", record_size_kib)
        if user_and_group_quotas is not None:
            pulumi.set(__self__, "user_and_group_quotas", user_and_group_quotas)

    @_builtins.property
    @pulumi.getter(name="copyTagsToSnapshots")
    def copy_tags_to_snapshots(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "copy_tags_to_snapshots")

    @copy_tags_to_snapshots.setter
    def copy_tags_to_snapshots(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "copy_tags_to_snapshots", value)

    @_builtins.property
    @pulumi.getter(name="dataCompressionType")
    def data_compression_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_compression_type")

    @data_compression_type.setter
    def data_compression_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_compression_type", value)

    @_builtins.property
    @pulumi.getter(name="nfsExports")
    def nfs_exports(self) -> Optional[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs']]:
        return pulumi.get(self, "nfs_exports")

    @nfs_exports.setter
    def nfs_exports(self, value: Optional[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs']]):
        pulumi.set(self, "nfs_exports", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="recordSizeKib")
    def record_size_kib(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "record_size_kib")

    @record_size_kib.setter
    def record_size_kib(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "record_size_kib", value)

    @_builtins.property
    @pulumi.getter(name="userAndGroupQuotas")
    def user_and_group_quotas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs']]]]:
        return pulumi.get(self, "user_and_group_quotas")

    @user_and_group_quotas.setter
    def user_and_group_quotas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs']]]]):
        pulumi.set(self, "user_and_group_quotas", value)


if not MYPY:
    class OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgsDict(TypedDict):
        client_configurations: pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgsDict']]]
elif False:
    OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs:
    def __init__(__self__, *,
                 client_configurations: pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs']]]):
        pulumi.set(__self__, "client_configurations", client_configurations)

    @_builtins.property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs']]]:
        return pulumi.get(self, "client_configurations")

    @client_configurations.setter
    def client_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs']]]):
        pulumi.set(self, "client_configurations", value)


if not MYPY:
    class OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgsDict(TypedDict):
        clients: pulumi.Input[_builtins.str]
        options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input[_builtins.str],
                 options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "clients", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        storage_capacity_quota_gib: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 storage_capacity_quota_gib: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "storage_capacity_quota_gib", storage_capacity_quota_gib)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="storageCapacityQuotaGib")
    def storage_capacity_quota_gib(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "storage_capacity_quota_gib")

    @storage_capacity_quota_gib.setter
    def storage_capacity_quota_gib(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_capacity_quota_gib", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OpenZfsVolumeNfsExportsArgsDict(TypedDict):
        client_configurations: pulumi.Input[Sequence[pulumi.Input['OpenZfsVolumeNfsExportsClientConfigurationArgsDict']]]
elif False:
    OpenZfsVolumeNfsExportsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsVolumeNfsExportsArgs:
    def __init__(__self__, *,
                 client_configurations: pulumi.Input[Sequence[pulumi.Input['OpenZfsVolumeNfsExportsClientConfigurationArgs']]]):
        pulumi.set(__self__, "client_configurations", client_configurations)

    @_builtins.property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['OpenZfsVolumeNfsExportsClientConfigurationArgs']]]:
        return pulumi.get(self, "client_configurations")

    @client_configurations.setter
    def client_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['OpenZfsVolumeNfsExportsClientConfigurationArgs']]]):
        pulumi.set(self, "client_configurations", value)


if not MYPY:
    class OpenZfsVolumeNfsExportsClientConfigurationArgsDict(TypedDict):
        clients: pulumi.Input[_builtins.str]
        options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    OpenZfsVolumeNfsExportsClientConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsVolumeNfsExportsClientConfigurationArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input[_builtins.str],
                 options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "clients", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class OpenZfsVolumeOriginSnapshotArgsDict(TypedDict):
        copy_strategy: pulumi.Input[_builtins.str]
        snapshot_arn: pulumi.Input[_builtins.str]
elif False:
    OpenZfsVolumeOriginSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsVolumeOriginSnapshotArgs:
    def __init__(__self__, *,
                 copy_strategy: pulumi.Input[_builtins.str],
                 snapshot_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "copy_strategy", copy_strategy)
        pulumi.set(__self__, "snapshot_arn", snapshot_arn)

    @_builtins.property
    @pulumi.getter(name="copyStrategy")
    def copy_strategy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "copy_strategy")

    @copy_strategy.setter
    def copy_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "copy_strategy", value)

    @_builtins.property
    @pulumi.getter(name="snapshotArn")
    def snapshot_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "snapshot_arn")

    @snapshot_arn.setter
    def snapshot_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "snapshot_arn", value)


if not MYPY:
    class OpenZfsVolumeUserAndGroupQuotaArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        storage_capacity_quota_gib: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    OpenZfsVolumeUserAndGroupQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenZfsVolumeUserAndGroupQuotaArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 storage_capacity_quota_gib: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "storage_capacity_quota_gib", storage_capacity_quota_gib)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="storageCapacityQuotaGib")
    def storage_capacity_quota_gib(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "storage_capacity_quota_gib")

    @storage_capacity_quota_gib.setter
    def storage_capacity_quota_gib(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_capacity_quota_gib", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class S3AccessPointAttachmentOpenzfsConfigurationArgsDict(TypedDict):
        volume_id: pulumi.Input[_builtins.str]
        file_system_identity: NotRequired[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgsDict']]
elif False:
    S3AccessPointAttachmentOpenzfsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentOpenzfsConfigurationArgs:
    def __init__(__self__, *,
                 volume_id: pulumi.Input[_builtins.str],
                 file_system_identity: Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgs']] = None):
        pulumi.set(__self__, "volume_id", volume_id)
        if file_system_identity is not None:
            pulumi.set(__self__, "file_system_identity", file_system_identity)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_id", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemIdentity")
    def file_system_identity(self) -> Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgs']]:
        return pulumi.get(self, "file_system_identity")

    @file_system_identity.setter
    def file_system_identity(self, value: Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgs']]):
        pulumi.set(self, "file_system_identity", value)


if not MYPY:
    class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        posix_user: NotRequired[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgsDict']]
elif False:
    S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 posix_user: Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgs']] = None):
        pulumi.set(__self__, "type", type)
        if posix_user is not None:
            pulumi.set(__self__, "posix_user", posix_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="posixUser")
    def posix_user(self) -> Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgs']]:
        return pulumi.get(self, "posix_user")

    @posix_user.setter
    def posix_user(self, value: Optional[pulumi.Input['S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgs']]):
        pulumi.set(self, "posix_user", value)


if not MYPY:
    class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgsDict(TypedDict):
        gid: pulumi.Input[_builtins.int]
        uid: pulumi.Input[_builtins.int]
        secondary_gids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentOpenzfsConfigurationFileSystemIdentityPosixUserArgs:
    def __init__(__self__, *,
                 gid: pulumi.Input[_builtins.int],
                 uid: pulumi.Input[_builtins.int],
                 secondary_gids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        pulumi.set(__self__, "gid", gid)
        pulumi.set(__self__, "uid", uid)
        if secondary_gids is not None:
            pulumi.set(__self__, "secondary_gids", secondary_gids)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "gid", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter(name="secondaryGids")
    def secondary_gids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "secondary_gids")

    @secondary_gids.setter
    def secondary_gids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "secondary_gids", value)


if not MYPY:
    class S3AccessPointAttachmentS3AccessPointArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        vpc_configuration: NotRequired[pulumi.Input['S3AccessPointAttachmentS3AccessPointVpcConfigurationArgsDict']]
elif False:
    S3AccessPointAttachmentS3AccessPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentS3AccessPointArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_configuration: Optional[pulumi.Input['S3AccessPointAttachmentS3AccessPointVpcConfigurationArgs']] = None):
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional[pulumi.Input['S3AccessPointAttachmentS3AccessPointVpcConfigurationArgs']]:
        return pulumi.get(self, "vpc_configuration")

    @vpc_configuration.setter
    def vpc_configuration(self, value: Optional[pulumi.Input['S3AccessPointAttachmentS3AccessPointVpcConfigurationArgs']]):
        pulumi.set(self, "vpc_configuration", value)


if not MYPY:
    class S3AccessPointAttachmentS3AccessPointVpcConfigurationArgsDict(TypedDict):
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    S3AccessPointAttachmentS3AccessPointVpcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentS3AccessPointVpcConfigurationArgs:
    def __init__(__self__, *,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class S3AccessPointAttachmentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    S3AccessPointAttachmentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AccessPointAttachmentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class WindowsFileSystemAuditLogConfigurationArgsDict(TypedDict):
        audit_log_destination: NotRequired[pulumi.Input[_builtins.str]]
        file_access_audit_log_level: NotRequired[pulumi.Input[_builtins.str]]
        file_share_access_audit_log_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WindowsFileSystemAuditLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFileSystemAuditLogConfigurationArgs:
    def __init__(__self__, *,
                 audit_log_destination: Optional[pulumi.Input[_builtins.str]] = None,
                 file_access_audit_log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 file_share_access_audit_log_level: Optional[pulumi.Input[_builtins.str]] = None):
        if audit_log_destination is not None:
            pulumi.set(__self__, "audit_log_destination", audit_log_destination)
        if file_access_audit_log_level is not None:
            pulumi.set(__self__, "file_access_audit_log_level", file_access_audit_log_level)
        if file_share_access_audit_log_level is not None:
            pulumi.set(__self__, "file_share_access_audit_log_level", file_share_access_audit_log_level)

    @_builtins.property
    @pulumi.getter(name="auditLogDestination")
    def audit_log_destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "audit_log_destination")

    @audit_log_destination.setter
    def audit_log_destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_log_destination", value)

    @_builtins.property
    @pulumi.getter(name="fileAccessAuditLogLevel")
    def file_access_audit_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_access_audit_log_level")

    @file_access_audit_log_level.setter
    def file_access_audit_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_access_audit_log_level", value)

    @_builtins.property
    @pulumi.getter(name="fileShareAccessAuditLogLevel")
    def file_share_access_audit_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_share_access_audit_log_level")

    @file_share_access_audit_log_level.setter
    def file_share_access_audit_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_share_access_audit_log_level", value)


if not MYPY:
    class WindowsFileSystemDiskIopsConfigurationArgsDict(TypedDict):
        iops: NotRequired[pulumi.Input[_builtins.int]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WindowsFileSystemDiskIopsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFileSystemDiskIopsConfigurationArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class WindowsFileSystemSelfManagedActiveDirectoryArgsDict(TypedDict):
        dns_ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        domain_name: pulumi.Input[_builtins.str]
        password: pulumi.Input[_builtins.str]
        username: pulumi.Input[_builtins.str]
        file_system_administrators_group: NotRequired[pulumi.Input[_builtins.str]]
        organizational_unit_distinguished_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WindowsFileSystemSelfManagedActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFileSystemSelfManagedActiveDirectoryArgs:
    def __init__(__self__, *,
                 dns_ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 domain_name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 file_system_administrators_group: Optional[pulumi.Input[_builtins.str]] = None,
                 organizational_unit_distinguished_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "dns_ips", dns_ips)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if file_system_administrators_group is not None:
            pulumi.set(__self__, "file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)

    @_builtins.property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "dns_ips")

    @dns_ips.setter
    def dns_ips(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "dns_ips", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_system_administrators_group")

    @file_system_administrators_group.setter
    def file_system_administrators_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_administrators_group", value)

    @_builtins.property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @organizational_unit_distinguished_name.setter
    def organizational_unit_distinguished_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organizational_unit_distinguished_name", value)


if not MYPY:
    class GetOntapStorageVirtualMachineFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetOntapStorageVirtualMachineFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOntapStorageVirtualMachineFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetOntapStorageVirtualMachinesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetOntapStorageVirtualMachinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOntapStorageVirtualMachinesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetOpenZfsSnapshotFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetOpenZfsSnapshotFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOpenZfsSnapshotFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


