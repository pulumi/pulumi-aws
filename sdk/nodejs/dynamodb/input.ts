// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface GlobalTableReplica {
    /**
     * AWS region name of replica DynamoDB TableE.g., `us-east-1`
     */
    regionName: pulumi.Input<string>;
}
export interface TableAttribute {
    /**
     * Name of the attribute
     */
    name: pulumi.Input<string>;
    /**
     * Attribute type. Valid values are `S` (string), `N` (number), `B` (binary).
     */
    type: pulumi.Input<string>;
}
export interface TableGlobalSecondaryIndex {
    /**
     * Name of the hash key in the index; must be defined as an attribute in the resource.
     */
    hashKey: pulumi.Input<string>;
    /**
     * Name of the index.
     */
    name: pulumi.Input<string>;
    /**
     * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
     */
    nonKeyAttributes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
     */
    projectionType: pulumi.Input<string>;
    /**
     * Name of the range key; must be defined
     */
    rangeKey?: pulumi.Input<string>;
    /**
     * Number of read units for this index. Must be set if billingMode is set to PROVISIONED.
     */
    readCapacity?: pulumi.Input<number>;
    /**
     * Number of write units for this index. Must be set if billingMode is set to PROVISIONED.
     */
    writeCapacity?: pulumi.Input<number>;
}
export interface TableImportTable {
    /**
     * Type of compression to be used on the input coming from the imported table.
     * Valid values are `GZIP`, `ZSTD` and `NONE`.
     */
    inputCompressionType?: pulumi.Input<string>;
    /**
     * The format of the source data.
     * Valid values are `CSV`, `DYNAMODB_JSON`, and `ION`.
     */
    inputFormat: pulumi.Input<string>;
    /**
     * Describe the format options for the data that was imported into the target table.
     * There is one value, `csv`.
     * See below.
     */
    inputFormatOptions?: pulumi.Input<inputs.TableImportTableInputFormatOptions>;
    /**
     * Values for the S3 bucket the source file is imported from.
     * See below.
     */
    s3BucketSource: pulumi.Input<inputs.TableImportTableS3BucketSource>;
}
export interface TableImportTableInputFormatOptions {
    /**
     * This block contains the processing options for the CSV file being imported:
     */
    csv?: pulumi.Input<inputs.TableImportTableInputFormatOptionsCsv>;
}
export interface TableImportTableInputFormatOptionsCsv {
    /**
     * The delimiter used for separating items in the CSV file being imported.
     */
    delimiter?: pulumi.Input<string>;
    /**
     * List of the headers used to specify a common header for all source CSV files being imported.
     */
    headerLists?: pulumi.Input<pulumi.Input<string>[]>;
}
export interface TableImportTableS3BucketSource {
    /**
     * The S3 bucket that is being imported from.
     */
    bucket: pulumi.Input<string>;
    /**
     * The account number of the S3 bucket that is being imported from.
     */
    bucketOwner?: pulumi.Input<string>;
    /**
     * The key prefix shared by all S3 Objects that are being imported.
     */
    keyPrefix?: pulumi.Input<string>;
}
export interface TableLocalSecondaryIndex {
    /**
     * Name of the index
     */
    name: pulumi.Input<string>;
    /**
     * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
     */
    nonKeyAttributes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
     */
    projectionType: pulumi.Input<string>;
    /**
     * Name of the range key.
     */
    rangeKey: pulumi.Input<string>;
}
export interface TablePointInTimeRecovery {
    /**
     * Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the `pointInTimeRecovery` block is not provided, this defaults to `false`.
     */
    enabled: pulumi.Input<boolean>;
}
export interface TableReplica {
    /**
     * ARN of the table
     */
    arn?: pulumi.Input<string>;
    /**
     * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
     */
    kmsKeyArn?: pulumi.Input<string>;
    /**
     * Whether to enable Point In Time Recovery for the replica. Default is `false`.
     */
    pointInTimeRecovery?: pulumi.Input<boolean>;
    /**
     * Whether to propagate the global table's tags to a replica. Default is `false`. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from `true` to `false` on a subsequent `apply` means replica tags are left as they were, unmanaged, not deleted.
     */
    propagateTags?: pulumi.Input<boolean>;
    /**
     * Region name of the replica.
     */
    regionName: pulumi.Input<string>;
    /**
     * ARN of the Table Stream. Only available when `streamEnabled = true`
     */
    streamArn?: pulumi.Input<string>;
    /**
     * Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when `streamEnabled = true`.
     */
    streamLabel?: pulumi.Input<string>;
}
export interface TableServerSideEncryption {
    /**
     * Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If `enabled` is `false` then server-side encryption is set to AWS-_owned_ key (shown as `DEFAULT` in the AWS console). Potentially confusingly, if `enabled` is `true` and no `kmsKeyArn` is specified then server-side encryption is set to the _default_ KMS-_managed_ key (shown as `KMS` in the AWS console). The [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html) explains the difference between AWS-_owned_ and KMS-_managed_ keys.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
     */
    kmsKeyArn?: pulumi.Input<string>;
}
export interface TableTtl {
    /**
     * Name of the table attribute to store the TTL timestamp in.
     */
    attributeName: pulumi.Input<string>;
    /**
     * Whether TTL is enabled.
     */
    enabled?: pulumi.Input<boolean>;
}
export interface GetTableServerSideEncryption {
    enabled?: boolean;
    kmsKeyArn?: string;
}
export interface GetTableServerSideEncryptionArgs {
    enabled?: pulumi.Input<boolean>;
    kmsKeyArn?: pulumi.Input<string>;
}
