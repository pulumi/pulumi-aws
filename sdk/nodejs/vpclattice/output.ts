// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface ListenerDefaultAction {
    fixedResponse?: outputs.ListenerDefaultActionFixedResponse;
    /**
     * Route requests to one or more target groups. See Forward blocks below.
     *
     * > **NOTE:** You must specify exactly one of the following argument blocks: `fixedResponse` or `forward`.
     */
    forwards?: outputs.ListenerDefaultActionForward[];
}
export interface ListenerDefaultActionFixedResponse {
    /**
     * Custom HTTP status code to return, e.g. a 404 response code. See [Listeners](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html) in the AWS documentation for a list of supported codes.
     */
    statusCode: number;
}
export interface ListenerDefaultActionForward {
    /**
     * One or more target group blocks.
     */
    targetGroups?: outputs.ListenerDefaultActionForwardTargetGroup[];
}
export interface ListenerDefaultActionForwardTargetGroup {
    targetGroupIdentifier?: string;
    weight?: number;
}
export interface ListenerRuleAction {
    /**
     * Describes the rule action that returns a custom HTTP response.
     */
    fixedResponse?: outputs.ListenerRuleActionFixedResponse;
    /**
     * The forward action. Traffic that matches the rule is forwarded to the specified target groups.
     */
    forward?: outputs.ListenerRuleActionForward;
}
export interface ListenerRuleActionFixedResponse {
    /**
     * The HTTP response code.
     */
    statusCode: number;
}
export interface ListenerRuleActionForward {
    /**
     * The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
     *
     * The default value is 1 with maximum number of 2. If only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
     */
    targetGroups: outputs.ListenerRuleActionForwardTargetGroup[];
}
export interface ListenerRuleActionForwardTargetGroup {
    targetGroupIdentifier: string;
    weight?: number;
}
export interface ListenerRuleMatch {
    /**
     * The HTTP criteria that a rule must match.
     */
    httpMatch?: outputs.ListenerRuleMatchHttpMatch;
}
export interface ListenerRuleMatchHttpMatch {
    /**
     * The header matches. Matches incoming requests with rule based on request header value before applying rule action.
     */
    headerMatches?: outputs.ListenerRuleMatchHttpMatchHeaderMatch[];
    /**
     * The HTTP method type.
     */
    method?: string;
    /**
     * The path match.
     */
    pathMatch?: outputs.ListenerRuleMatchHttpMatchPathMatch;
}
export interface ListenerRuleMatchHttpMatchHeaderMatch {
    /**
     * Indicates whether the match is case sensitive. Defaults to false.
     */
    caseSensitive?: boolean;
    /**
     * The header match type.
     */
    match: outputs.ListenerRuleMatchHttpMatchHeaderMatchMatch;
    /**
     * The name of the header.
     */
    name: string;
}
export interface ListenerRuleMatchHttpMatchHeaderMatchMatch {
    /**
     * Specifies a contains type match.
     */
    contains?: string;
    /**
     * Specifies an exact type match.
     */
    exact?: string;
    /**
     * Specifies a prefix type match. Matches the value with the prefix.
     */
    prefix?: string;
}
export interface ListenerRuleMatchHttpMatchPathMatch {
    /**
     * Indicates whether the match is case sensitive. Defaults to false.
     */
    caseSensitive?: boolean;
    /**
     * The header match type.
     */
    match: outputs.ListenerRuleMatchHttpMatchPathMatchMatch;
}
export interface ListenerRuleMatchHttpMatchPathMatchMatch {
    /**
     * Specifies an exact type match.
     */
    exact?: string;
    /**
     * Specifies a prefix type match. Matches the value with the prefix.
     */
    prefix?: string;
}
export interface ServiceDnsEntry {
    domainName: string;
    hostedZoneId: string;
}
export interface ServiceNetworkServiceAssociationDnsEntry {
    /**
     * The domain name of the service.
     */
    domainName: string;
    /**
     * The ID of the hosted zone.
     */
    hostedZoneId: string;
}
export interface TargetGroupAttachmentTarget {
    /**
     * The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
     */
    id: string;
    /**
     * This port is used for routing traffic to the target, and defaults to the target group port. However, you can override the default and specify a custom port.
     */
    port: number;
}
export interface TargetGroupConfig {
    /**
     * The health check configuration.
     */
    healthCheck?: outputs.TargetGroupConfigHealthCheck;
    /**
     * The type of IP address used for the target group. Valid values: `IPV4` | `IPV6`.
     */
    ipAddressType: string;
    /**
     * The version of the event structure that the Lambda function receives. Supported only if `type` is `LAMBDA`. Valid Values are `V1` | `V2`.
     */
    lambdaEventStructureVersion: string;
    /**
     * The port on which the targets are listening.
     */
    port: number;
    /**
     * The protocol to use for routing traffic to the targets. Valid Values are `HTTP` | `HTTPS`.
     */
    protocol: string;
    /**
     * The protocol version. Valid Values are `HTTP1` | `HTTP2` | `GRPC`. Default value is `HTTP1`.
     */
    protocolVersion: string;
    /**
     * The ID of the VPC.
     */
    vpcIdentifier?: string;
}
export interface TargetGroupConfigHealthCheck {
    /**
     * Indicates whether health checking is enabled. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
     */
    healthCheckIntervalSeconds?: number;
    /**
     * The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
     * * `healthyThresholdCount ` - (Optional) The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
     */
    healthCheckTimeoutSeconds?: number;
    healthyThresholdCount?: number;
    /**
     * The codes to use when checking for a successful response from a target. These are called _Success codes_ in the console.
     */
    matcher?: outputs.TargetGroupConfigHealthCheckMatcher;
    /**
     * The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is `/`. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
     */
    path?: string;
    /**
     * The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
     */
    port: number;
    /**
     * The protocol used when performing health checks on targets. The possible protocols are `HTTP` and `HTTPS`.
     */
    protocol: string;
    /**
     * The protocol version used when performing health checks on targets. The possible protocol versions are `HTTP1` and `HTTP2`. The default is `HTTP1`.
     */
    protocolVersion?: string;
    /**
     * The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
     */
    unhealthyThresholdCount?: number;
}
export interface TargetGroupConfigHealthCheckMatcher {
    /**
     * The HTTP codes to use when checking for a successful response from a target.
     */
    value?: string;
}
export interface GetListenerDefaultAction {
    fixedResponses: outputs.GetListenerDefaultActionFixedResponse[];
    forwards: outputs.GetListenerDefaultActionForward[];
}
export interface GetListenerDefaultActionFixedResponse {
    statusCode: number;
}
export interface GetListenerDefaultActionForward {
    targetGroups: outputs.GetListenerDefaultActionForwardTargetGroup[];
}
export interface GetListenerDefaultActionForwardTargetGroup {
    targetGroupIdentifier: string;
    weight: number;
}
export interface GetServiceDnsEntry {
    domainName: string;
    hostedZoneId: string;
}
