// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface ChannelCdiInputSpecification {
    /**
     * Maximum CDI input resolution.
     */
    resolution: string;
}
export interface ChannelDestination {
    /**
     * User-specified id. Ths is used in an output group or an output.
     */
    id: string;
    /**
     * Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
     */
    mediaPackageSettings?: outputs.ChannelDestinationMediaPackageSetting[];
    /**
     * Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
     */
    multiplexSettings?: outputs.ChannelDestinationMultiplexSettings;
    /**
     * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
     */
    settings?: outputs.ChannelDestinationSetting[];
}
export interface ChannelDestinationMediaPackageSetting {
    /**
     * ID of the channel in MediaPackage that is the destination for this output group.
     */
    channelId: string;
}
export interface ChannelDestinationMultiplexSettings {
    /**
     * The ID of the Multiplex that the encoder is providing output to.
     */
    multiplexId: string;
    /**
     * The program name of the Multiplex program that the encoder is providing output to.
     */
    programName: string;
}
export interface ChannelDestinationSetting {
    /**
     * Key used to extract the password from EC2 Parameter store.
     */
    passwordParam?: string;
    /**
     * Stream name RTMP destinations (URLs of type rtmp://)
     */
    streamName?: string;
    /**
     * A URL specifying a destination.
     */
    url?: string;
    /**
     * Username for destination.
     */
    username?: string;
}
export interface ChannelEncoderSettings {
    /**
     * Audio descriptions for the channel. See Audio Descriptions for more details.
     */
    audioDescriptions?: outputs.ChannelEncoderSettingsAudioDescription[];
    /**
     * Settings for ad avail blanking. See Avail Blanking for more details.
     */
    availBlanking: outputs.ChannelEncoderSettingsAvailBlanking;
    /**
     * Caption Descriptions. See Caption Descriptions for more details.
     */
    captionDescriptions: outputs.ChannelEncoderSettingsCaptionDescription[];
    /**
     * Configuration settings that apply to the event as a whole. See Global Configuration for more details.
     */
    globalConfiguration?: outputs.ChannelEncoderSettingsGlobalConfiguration;
    /**
     * Settings for motion graphics. See Motion Graphics Configuration for more details.
     */
    motionGraphicsConfiguration?: outputs.ChannelEncoderSettingsMotionGraphicsConfiguration;
    /**
     * Nielsen configuration settings. See Nielsen Configuration for more details.
     */
    nielsenConfiguration?: outputs.ChannelEncoderSettingsNielsenConfiguration;
    /**
     * Output groups for the channel. See Output Groups for more details.
     */
    outputGroups: outputs.ChannelEncoderSettingsOutputGroup[];
    /**
     * Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
     */
    timecodeConfig: outputs.ChannelEncoderSettingsTimecodeConfig;
    /**
     * Video Descriptions. See Video Descriptions for more details.
     */
    videoDescriptions: outputs.ChannelEncoderSettingsVideoDescription[];
}
export interface ChannelEncoderSettingsAudioDescription {
    /**
     * Advanced audio normalization settings. See Audio Normalization Settings for more details.
     */
    audioNormalizationSettings?: outputs.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings;
    /**
     * The name of the audio selector used as the source for this AudioDescription.
     */
    audioSelectorName: string;
    /**
     * Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
     */
    audioType: string;
    /**
     * Determined how audio type is determined.
     */
    audioTypeControl: string;
    /**
     * Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
     */
    audioWatermarkSettings?: outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings;
    /**
     * Audio codec settings. See Audio Codec Settings for more details.
     */
    codecSettings: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettings;
    languageCode: string;
    languageCodeControl: string;
    /**
     * The name of this audio description.
     */
    name: string;
    remixSettings?: outputs.ChannelEncoderSettingsAudioDescriptionRemixSettings;
    streamName: string;
}
export interface ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings {
    /**
     * Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
     */
    algorithm: string;
    /**
     * Algorithm control for the audio description.
     */
    algorithmControl: string;
    /**
     * Target LKFS (loudness) to adjust volume to.
     */
    targetLkfs: number;
}
export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings {
    nielsenWatermarksSettings: outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings;
}
export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings {
    nielsenCbetSettings: outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings;
    nielsenDistributionType: string;
    nielsenNaesIiNwSettings: outputs.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting[];
}
export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings {
    cbetCheckDigitString: string;
    /**
     * Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
     */
    cbetStepaside: string;
    /**
     * CBET source ID to use in the watermark.
     */
    csid: string;
}
export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting {
    checkDigitString: string;
    /**
     * The Nielsen Source ID to include in the watermark.
     */
    sid: number;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettings {
    aacSettings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings;
    ac3Settings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings;
    eac3AtmosSettings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings;
    eac3Settings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings;
    mp2Settings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings;
    passThroughSettings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings;
    wavSettings?: outputs.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings {
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    /**
     * Mono, Stereo, or 5.1 channel layout.
     */
    codingMode: string;
    /**
     * Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
     */
    inputType: string;
    /**
     * AAC profile.
     */
    profile: string;
    /**
     * The rate control mode.
     */
    rateControlMode: string;
    /**
     * Sets LATM/LOAS AAC output for raw containers.
     */
    rawFormat: string;
    /**
     * Sample rate in Hz.
     */
    sampleRate: number;
    /**
     * Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
     */
    spec: string;
    /**
     * VBR Quality Level - Only used if rateControlMode is VBR.
     */
    vbrQuality: string;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings {
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    /**
     * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
     */
    bitstreamMode: string;
    /**
     * Dolby Digital coding mode.
     */
    codingMode: string;
    /**
     * Sets the dialnorm of the output.
     */
    dialnorm: number;
    /**
     * If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
     */
    drcProfile: string;
    /**
     * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
     */
    lfeFilter: string;
    /**
     * Metadata control.
     */
    metadataControl: string;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings {
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    /**
     * Dolby Digital Plus with Dolby Atmos coding mode.
     */
    codingMode: string;
    /**
     * Sets the dialnorm for the output.
     */
    dialnorm: number;
    /**
     * Sets the Dolby dynamic range compression profile.
     */
    drcLine: string;
    /**
     * Sets the profile for heavy Dolby dynamic range compression.
     */
    drcRf: string;
    /**
     * Height dimensional trim.
     */
    heightTrim: number;
    /**
     * Surround dimensional trim.
     */
    surroundTrim: number;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings {
    /**
     * Sets the attenuation control.
     */
    attenuationControl: string;
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    /**
     * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
     */
    bitstreamMode: string;
    /**
     * Dolby Digital Plus coding mode.
     */
    codingMode: string;
    dcFilter: string;
    dialnorm: number;
    drcLine: string;
    drcRf: string;
    lfeControl: string;
    lfeFilter: string;
    loRoCenterMixLevel: number;
    loRoSurroundMixLevel: number;
    ltRtCenterMixLevel: number;
    ltRtSurroundMixLevel: number;
    metadataControl: string;
    passthroughControl: string;
    phaseControl: string;
    stereoDownmix: string;
    surroundExMode: string;
    surroundMode: string;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings {
    bitrate: number;
    codingMode: string;
    sampleRate: number;
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings {
}
export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings {
    bitDepth: number;
    codingMode: string;
    sampleRate: number;
}
export interface ChannelEncoderSettingsAudioDescriptionRemixSettings {
    channelMappings: outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping[];
    channelsIn: number;
    channelsOut: number;
}
export interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping {
    inputChannelLevels: outputs.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel[];
    outputChannel: number;
}
export interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel {
    gain: number;
    inputChannel: number;
}
export interface ChannelEncoderSettingsAvailBlanking {
    /**
     * Blanking image to be used. See Avail Blanking Image for more details.
     */
    availBlankingImage?: outputs.ChannelEncoderSettingsAvailBlankingAvailBlankingImage;
    /**
     * When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
     */
    state: string;
}
export interface ChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    /**
     * Key used to extract the password from EC2 Parameter store.
     */
    passwordParam: string;
    /**
     * Path to a file accessible to the live stream.
     */
    uri: string;
    /**
     * . Username to be used.
     */
    username: string;
}
export interface ChannelEncoderSettingsCaptionDescription {
    /**
     * Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
     */
    accessibility?: string;
    /**
     * Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
     */
    captionSelectorName: string;
    /**
     * Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
     */
    destinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettings;
    /**
     * ISO 639-2 three-digit code.
     */
    languageCode?: string;
    /**
     * Human readable information to indicate captions available for players (eg. English, or Spanish).
     */
    languageDescription?: string;
    /**
     * Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
     */
    name: string;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettings {
    /**
     * ARIB Destination Settings.
     */
    aribDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings;
    /**
     * Burn In Destination Settings. See Burn In Destination Settings for more details.
     */
    burnInDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings;
    /**
     * DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
     */
    dvbSubDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings;
    /**
     * EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
     */
    ebuTtDDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings;
    /**
     * Embedded Destination Settings.
     */
    embeddedDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings;
    /**
     * Embedded Plus SCTE20 Destination Settings.
     */
    embeddedPlusScte20DestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings;
    /**
     * RTMP Caption Info Destination Settings.
     */
    rtmpCaptionInfoDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings;
    /**
     * SCTE20 Plus Embedded Destination Settings.
     */
    scte20PlusEmbeddedDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings;
    /**
     * SCTE27 Destination Settings.
     */
    scte27DestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings;
    /**
     * SMPTE TT Destination Settings.
     */
    smpteTtDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings;
    /**
     * Teletext Destination Settings.
     */
    teletextDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings;
    /**
     * TTML Destination Settings. See TTML Destination Settings for more details.
     */
    ttmlDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings;
    /**
     * WebVTT Destination Settings. See WebVTT Destination Settings for more details.
     */
    webvttDestinationSettings?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings {
    /**
     * If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
     */
    alignment?: string;
    /**
     * Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
     */
    backgroundColor?: string;
    /**
     * Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
     */
    backgroundOpacity?: number;
    /**
     * External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
     */
    font?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont;
    /**
     * Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    fontColor?: string;
    /**
     * Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
     */
    fontOpacity?: number;
    /**
     * Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
     */
    fontResolution?: number;
    /**
     * When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
     */
    fontSize?: string;
    /**
     * Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    outlineColor: string;
    /**
     * Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    outlineSize?: number;
    /**
     * Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
     */
    shadowColor?: string;
    /**
     * Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
     */
    shadowOpacity?: number;
    /**
     * Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
     */
    shadowXOffset?: number;
    /**
     * Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
     */
    shadowYOffset?: number;
    /**
     * Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
     */
    teletextGridControl: string;
    /**
     * Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
     */
    xPosition?: number;
    /**
     * Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
     */
    yPosition?: number;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont {
    /**
     * Key used to extract the password from EC2 Parameter store.
     */
    passwordParam: string;
    /**
     * Path to a file accessible to the live stream.
     */
    uri: string;
    /**
     * Username to be used.
     */
    username: string;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings {
    /**
     * If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    alignment?: string;
    /**
     * Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
     */
    backgroundColor?: string;
    /**
     * Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
     */
    backgroundOpacity?: number;
    /**
     * External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
     */
    font?: outputs.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont;
    /**
     * Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    fontColor?: string;
    /**
     * Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
     */
    fontOpacity?: number;
    /**
     * Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
     */
    fontResolution?: number;
    /**
     * When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
     */
    fontSize: string;
    /**
     * Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    outlineColor?: string;
    /**
     * Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    outlineSize?: number;
    /**
     * Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
     */
    shadowColor?: string;
    /**
     * Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
     */
    shadowOpacity?: number;
    /**
     * Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
     */
    shadowXOffset?: number;
    /**
     * Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
     */
    shadowYOffset?: number;
    /**
     * Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
     */
    teletextGridControl?: string;
    /**
     * Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    xPosition?: number;
    /**
     * Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
     */
    yPosition?: number;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont {
    /**
     * Key used to extract the password from EC2 Parameter store.
     */
    passwordParam: string;
    /**
     * Path to a file accessible to the live stream.
     */
    uri: string;
    /**
     * Username to be used.
     */
    username: string;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings {
    /**
     * Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
     */
    copyrightHolder?: string;
    /**
     * Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
     */
    fillLineGap?: string;
    /**
     * Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”.
     */
    fontFamily?: string;
    /**
     * Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information.
     */
    styleControl: string;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings {
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings {
    /**
     * This field is not currently supported and will not affect the output styling. Leave the default value.
     */
    styleControl: string;
}
export interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings {
    /**
     * Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\_STYLE\_DATA - Don’t pass through the style. The output captions will not contain any font styling information.
     */
    styleControl: string;
}
export interface ChannelEncoderSettingsGlobalConfiguration {
    /**
     * Value to set the initial audio gain for the Live Event.
     */
    initialAudioGain?: number;
    /**
     * Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
     */
    inputEndAction?: string;
    /**
     * Settings for system actions when input is lost. See Input Loss Behavior for more details.
     */
    inputLossBehavior?: outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehavior;
    /**
     * Indicates how MediaLive pipelines are synchronized. PIPELINE\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
     */
    outputLockingMode?: string;
    /**
     * Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
     */
    outputTimingSource?: string;
    /**
     * Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
     */
    supportLowFramerateInputs?: string;
}
export interface ChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    blackFrameMsec?: number;
    inputLossImageColor?: string;
    inputLossImageSlate?: outputs.ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate;
    inputLossImageType?: string;
    repeatFrameMsec?: number;
}
export interface ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    passwordParam: string;
    uri: string;
    username: string;
}
export interface ChannelEncoderSettingsMotionGraphicsConfiguration {
    /**
     * Motion Graphics Insertion.
     */
    motionGraphicsInsertion?: string;
    /**
     * Motion Graphics Settings. See Motion Graphics Settings for more details.
     */
    motionGraphicsSettings: outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings;
}
export interface ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings {
    /**
     * Html Motion Graphics Settings.
     */
    htmlMotionGraphicsSettings?: outputs.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings;
}
export interface ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings {
}
export interface ChannelEncoderSettingsNielsenConfiguration {
    /**
     * Enter the Distributor ID assigned to your organization by Nielsen.
     */
    distributorId?: string;
    /**
     * Enables Nielsen PCM to ID3 tagging.
     */
    nielsenPcmToId3Tagging?: string;
}
export interface ChannelEncoderSettingsOutputGroup {
    /**
     * Custom output group name defined by the user.
     */
    name?: string;
    /**
     * Settings associated with the output group. See Output Group Settings for more details.
     */
    outputGroupSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettings;
    /**
     * List of outputs. See Outputs for more details.
     */
    outputs: outputs.ChannelEncoderSettingsOutputGroupOutput[];
}
export interface ChannelEncoderSettingsOutputGroupOutput {
    /**
     * The names of the audio descriptions used as audio sources for the output.
     */
    audioDescriptionNames?: string[];
    /**
     * The names of the caption descriptions used as caption sources for the output.
     */
    captionDescriptionNames: string[];
    /**
     * The name used to identify an output.
     */
    outputName?: string;
    /**
     * Settings for output. See Output Settings for more details.
     */
    outputSettings: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettings;
    /**
     * The name of the video description used as video source for the output.
     */
    videoDescriptionName?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettings {
    /**
     * Archive group settings. See Archive Group Settings for more details.
     */
    archiveGroupSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting[];
    frameCaptureGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings;
    hlsGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings;
    /**
     * Media package group settings. See Media Package Group Settings for more details.
     */
    mediaPackageGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings;
    msSmoothGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings;
    multiplexGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings;
    /**
     * RTMP group settings. See RTMP Group Settings for more details.
     */
    rtmpGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings;
    udpGroupSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting {
    /**
     * Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
     */
    archiveCdnSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings;
    /**
     * A director and base filename where archive files should be written. See Destination for more details.
     */
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination;
    /**
     * Number of seconds to write to archive file before closing and starting a new one.
     */
    rolloverInterval?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings {
    /**
     * Archive S3 Settings. See Archive S3 Settings for more details.
     */
    archiveS3Settings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings {
    /**
     * Specify the canned ACL to apply to each S3 request.
     */
    cannedAcl?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings {
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination;
    frameCaptureCdnSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings {
    frameCaptureS3Settings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings {
    cannedAcl?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings {
    adMarkers: string[];
    baseUrlContent: string;
    baseUrlContent1: string;
    baseUrlManifest: string;
    baseUrlManifest1: string;
    captionLanguageMappings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping[];
    captionLanguageSetting: string;
    clientCache: string;
    codecSpecification: string;
    constantIv: string;
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination;
    directoryStructure: string;
    discontinuityTags: string;
    encryptionType: string;
    hlsCdnSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting[];
    hlsId3SegmentTagging: string;
    iframeOnlyPlaylists: string;
    incompleteSegmentBehavior: string;
    indexNSegments: number;
    inputLossAction: string;
    ivInManifest: string;
    ivSource: string;
    keepSegments: number;
    keyFormat: string;
    keyFormatVersions: string;
    keyProviderSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings;
    manifestCompression: string;
    manifestDurationFormat: string;
    minSegmentLength: number;
    mode: string;
    outputSelection: string;
    programDateTime: string;
    programDateTimeClock: string;
    programDateTimePeriod: number;
    redundantManifest: string;
    segmentLength: number;
    segmentsPerSubdirectory: number;
    streamInfResolution: string;
    timedMetadataId3Frame: string;
    timedMetadataId3Period: number;
    timestampDeltaMilliseconds: number;
    tsFileMode: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping {
    captionChannel: number;
    languageCode: string;
    languageDescription: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting {
    hlsAkamaiSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings;
    hlsBasicPutSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings;
    hlsMediaStoreSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings;
    hlsS3Settings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings;
    hlsWebdavSettings: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings {
    connectionRetryInterval?: number;
    filecacheDuration?: number;
    httpTransferMode: string;
    numRetries?: number;
    restartDelay?: number;
    salt: string;
    token: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings {
    connectionRetryInterval?: number;
    filecacheDuration?: number;
    numRetries?: number;
    restartDelay?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings {
    connectionRetryInterval?: number;
    filecacheDuration?: number;
    mediaStoreStorageClass: string;
    numRetries?: number;
    restartDelay?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings {
    cannedAcl?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings {
    connectionRetryInterval?: number;
    filecacheDuration?: number;
    httpTransferMode: string;
    numRetries?: number;
    restartDelay?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings {
    staticKeySettings?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting[];
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting {
    keyProviderServer?: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer;
    staticKeyValue: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer {
    passwordParam: string;
    uri: string;
    username: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings {
    /**
     * A director and base filename where archive files should be written. See Destination for more details.
     */
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings {
    acquisitionPointId: string;
    audioOnlyTimecodeControl: string;
    certificateMode: string;
    connectionRetryInterval: number;
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination;
    eventId: string;
    eventIdMode: string;
    eventStopBehavior: string;
    filecacheDuration?: number;
    fragmentLength: number;
    inputLossAction: string;
    numRetries?: number;
    restartDelay?: number;
    segmentationMode: string;
    sendDelayMs: number;
    sparseTrackType: string;
    streamManifestBehavior: string;
    timestampOffset: string;
    timestampOffsetMode: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings {
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings {
    /**
     * The ad marker type for this output group.
     */
    adMarkers?: string[];
    /**
     * Authentication scheme to use when connecting with CDN.
     */
    authenticationScheme: string;
    /**
     * Controls behavior when content cache fills up.
     */
    cacheFullBehavior: string;
    /**
     * Cache length in seconds, is used to calculate buffer size.
     */
    cacheLength: number;
    /**
     * Controls the types of data that passes to onCaptionInfo outputs.
     */
    captionData: string;
    /**
     * Controls the behavior of the RTMP group if input becomes unavailable.
     */
    inputLossAction: string;
    /**
     * Number of seconds to wait until a restart is initiated.
     */
    restartDelay?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings {
    /**
     * Specifies behavior of last resort when input video os lost.
     */
    inputLossAction: string;
    /**
     * Indicates ID3 frame that has the timecode.
     */
    timedMetadataId3Frame: string;
    timedMetadataId3Period: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettings {
    /**
     * Archive output settings. See Archive Output Settings for more details.
     */
    archiveOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings;
    frameCaptureOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings;
    hlsOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings;
    /**
     * Media package output settings. This can be set as an empty block.
     */
    mediaPackageOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings;
    msSmoothOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings;
    /**
     * Multiplex output settings. See Multiplex Output Settings for more details.
     */
    multiplexOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings;
    /**
     * RTMP output settings. See RTMP Output Settings for more details.
     */
    rtmpOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings;
    /**
     * UDP output settings. See UDP Output Settings for more details.
     */
    udpOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings {
    /**
     * Settings specific to the container type of the file. See Container Settings for more details.
     */
    containerSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings;
    /**
     * Output file extension.
     */
    extension?: string;
    /**
     * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
     */
    nameModifier?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings {
    /**
     * M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
     */
    m2tsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings;
    /**
     * Raw Settings. This can be set as an empty block.
     */
    rawSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings {
    absentInputAudioBehavior: string;
    arib?: string;
    aribCaptionsPid: string;
    aribCaptionsPidControl?: string;
    audioBufferModel?: string;
    audioFramesPerPes?: number;
    audioPids: string;
    audioStreamType?: string;
    bitrate?: number;
    bufferModel?: string;
    ccDescriptor?: string;
    dvbNitSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
    dvbSdtSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
    dvbSubPids: string;
    dvbTdtSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
    dvbTeletextPid: string;
    ebif?: string;
    ebpAudioInterval?: string;
    ebpLookaheadMs?: number;
    ebpPlacement?: string;
    ecmPid?: string;
    esRateInPes?: string;
    etvPlatformPid: string;
    etvSignalPid: string;
    fragmentTime?: number;
    klv?: string;
    klvDataPids: string;
    nielsenId3Behavior?: string;
    nullPacketBitrate?: number;
    patInterval?: number;
    pcrControl?: string;
    pcrPeriod?: number;
    pcrPid?: string;
    pmtInterval?: number;
    pmtPid: string;
    programNum?: number;
    rateMode?: string;
    scte27Pids: string;
    scte35Control?: string;
    scte35Pid: string;
    segmentationMarkers?: string;
    segmentationStyle?: string;
    segmentationTime?: number;
    timedMetadataBehavior?: string;
    timedMetadataPid: string;
    transportStreamId?: number;
    videoPid: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
    networkId: number;
    networkName: string;
    repInterval?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
    outputSdt?: string;
    repInterval?: number;
    serviceName?: string;
    serviceProviderName?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
    repInterval?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings {
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings {
    nameModifier: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings {
    h265PackagingType: string;
    hlsSettings: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings;
    nameModifier: string;
    segmentModifier: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings {
    audioOnlyHlsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings;
    fmp4HlsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings;
    frameCaptureHlsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings;
    standardHlsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings {
    audioGroupId: string;
    audioOnlyImage?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage;
    audioTrackType: string;
    segmentType: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage {
    passwordParam: string;
    uri: string;
    username: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings {
    audioRenditionSets: string;
    nielsenId3Behavior: string;
    timedMetadataBehavior: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings {
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings {
    audioRenditionSets: string;
    m3u8Settings: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings {
    audioFramesPerPes: number;
    audioPids: string;
    ecmPid: string;
    nielsenId3Behavior: string;
    patInterval: number;
    pcrControl: string;
    pcrPeriod: number;
    pcrPid: string;
    pmtInterval: number;
    pmtPid: string;
    programNum: number;
    scte35Behavior: string;
    scte35Pid: string;
    timedMetadataBehavior: string;
    timedMetadataPid: string;
    transportStreamId: number;
    videoPid: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings {
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings {
    h265PackagingType: string;
    nameModifier: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings {
    /**
     * Destination is a multiplex. See Destination for more details.
     */
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings {
    /**
     * Setting to allow self signed or verified RTMP certificates.
     */
    certificateMode: string;
    /**
     * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
     */
    connectionRetryInterval: number;
    /**
     * The RTMP endpoint excluding the stream name. See Destination for more details.
     */
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination;
    /**
     * Number of retry attempts.
     */
    numRetries: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings {
    /**
     * UDP output buffering in milliseconds.
     */
    bufferMsec: number;
    /**
     * UDP container settings. See Container Settings for more details.
     */
    containerSettings: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings;
    /**
     * Destination address and port number for RTP or UDP packets. See Destination for more details.
     */
    destination: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination;
    fecOutputSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings {
    /**
     * M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
     */
    m2tsSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings {
    absentInputAudioBehavior: string;
    arib?: string;
    aribCaptionsPid: string;
    aribCaptionsPidControl?: string;
    audioBufferModel?: string;
    audioFramesPerPes?: number;
    audioPids: string;
    audioStreamType?: string;
    bitrate?: number;
    bufferModel?: string;
    ccDescriptor?: string;
    dvbNitSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
    dvbSdtSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
    dvbSubPids: string;
    dvbTdtSettings?: outputs.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
    dvbTeletextPid: string;
    ebif?: string;
    ebpAudioInterval?: string;
    ebpLookaheadMs?: number;
    ebpPlacement?: string;
    ecmPid?: string;
    esRateInPes?: string;
    etvPlatformPid: string;
    etvSignalPid: string;
    fragmentTime?: number;
    klv?: string;
    klvDataPids: string;
    nielsenId3Behavior?: string;
    nullPacketBitrate?: number;
    patInterval?: number;
    pcrControl?: string;
    pcrPeriod?: number;
    pcrPid?: string;
    pmtInterval?: number;
    pmtPid: string;
    programNum?: number;
    rateMode?: string;
    scte27Pids: string;
    scte35Control?: string;
    scte35Pid: string;
    segmentationMarkers?: string;
    segmentationStyle?: string;
    segmentationTime?: number;
    timedMetadataBehavior?: string;
    timedMetadataPid: string;
    transportStreamId?: number;
    videoPid: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
    networkId: number;
    networkName: string;
    repInterval?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
    outputSdt?: string;
    repInterval?: number;
    serviceName?: string;
    serviceProviderName?: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
    repInterval?: number;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination {
    /**
     * Reference ID for the destination.
     */
    destinationRefId: string;
}
export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings {
    /**
     * The height of the FEC protection matrix.
     */
    columnDepth: number;
    /**
     * Enables column only or column and row based FEC.
     */
    includeFec: string;
    /**
     * The width of the FEC protection matrix.
     */
    rowLength: number;
}
export interface ChannelEncoderSettingsTimecodeConfig {
    /**
     * The source for the timecode that will be associated with the events outputs.
     */
    source: string;
    /**
     * Threshold in frames beyond which output timecode is resynchronized to the input timecode.
     */
    syncThreshold: number;
}
export interface ChannelEncoderSettingsVideoDescription {
    /**
     * The video codec settings. See Video Codec Settings for more details.
     */
    codecSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettings;
    /**
     * Output video height in pixels.
     */
    height: number;
    /**
     * The name of the video description.
     */
    name: string;
    /**
     * Indicate how to respond to the AFD values that might be in the input video.
     */
    respondToAfd: string;
    /**
     * Behavior on how to scale.
     */
    scalingBehavior: string;
    /**
     * Changes the strength of the anti-alias filter used for scaling.
     */
    sharpness: number;
    /**
     * Output video width in pixels.
     */
    width: number;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettings {
    frameCaptureSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings;
    h264Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings;
    h265Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings {
    /**
     * The frequency at which to capture frames for inclusion in the output.
     */
    captureInterval: number;
    /**
     * Unit for the frame capture interval.
     */
    captureIntervalUnits: string;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings {
    /**
     * Enables or disables adaptive quantization.
     */
    adaptiveQuantization: string;
    /**
     * Indicates that AFD values will be written into the output stream.
     */
    afdSignaling: string;
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    bufFillPct: number;
    /**
     * Size of buffer in bits.
     */
    bufSize: number;
    /**
     * Includes color space metadata in the output.
     */
    colorMetadata: string;
    /**
     * Entropy encoding mode.
     */
    entropyEncoding: string;
    /**
     * Filters to apply to an encode. See H264 Filter Settings for more details.
     */
    filterSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings;
    /**
     * Four bit AFD value to write on all frames of video in the output stream.
     */
    fixedAfd: string;
    flickerAq: string;
    /**
     * Controls whether coding is performed on a field basis or on a frame basis.
     */
    forceFieldPictures: string;
    /**
     * Indicates how the output video frame rate is specified.
     */
    framerateControl: string;
    /**
     * Framerate denominator.
     */
    framerateDenominator: number;
    /**
     * Framerate numerator.
     */
    framerateNumerator: number;
    /**
     * GOP-B reference.
     */
    gopBReference: string;
    /**
     * Frequency of closed GOPs.
     */
    gopClosedCadence: number;
    /**
     * Number of B-frames between reference frames.
     */
    gopNumBFrames: number;
    /**
     * GOP size in units of either frames of seconds per `gopSizeUnits`.
     */
    gopSize: number;
    /**
     * Indicates if the `gopSize` is specified in frames or seconds.
     */
    gopSizeUnits: string;
    /**
     * H264 level.
     */
    level: string;
    /**
     * Amount of lookahead.
     */
    lookAheadRateControl: string;
    /**
     * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     */
    maxBitrate: number;
    minIInterval: number;
    /**
     * Number of reference frames to use.
     */
    numRefFrames: number;
    /**
     * Indicates how the output pixel aspect ratio is specified.
     */
    parControl: string;
    /**
     * Pixel Aspect Ratio denominator.
     */
    parDenominator: number;
    /**
     * Pixel Aspect Ratio numerator.
     */
    parNumerator: number;
    /**
     * H264 profile.
     */
    profile: string;
    /**
     * Quality level.
     */
    qualityLevel: string;
    /**
     * Controls the target quality for the video encode.
     */
    qvbrQualityLevel: number;
    /**
     * Rate control mode.
     */
    rateControlMode: string;
    /**
     * Sets the scan type of the output.
     */
    scanType: string;
    /**
     * Scene change detection.
     */
    sceneChangeDetect: string;
    /**
     * Number of slices per picture.
     */
    slices: number;
    /**
     * Softness.
     */
    softness: number;
    /**
     * Makes adjustments within each frame based on spatial variation of content complexity.
     */
    spatialAq: string;
    /**
     * Subgop length.
     */
    subgopLength: string;
    /**
     * Produces a bitstream compliant with SMPTE RP-2027.
     */
    syntax: string;
    /**
     * Makes adjustments within each frame based on temporal variation of content complexity.
     */
    temporalAq: string;
    /**
     * Determines how timecodes should be inserted into the video elementary stream.
     */
    timecodeInsertion: string;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings {
    temporalFilterSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings {
    /**
     * Post filter sharpening.
     */
    postFilterSharpening?: string;
    /**
     * Filter strength.
     */
    strength?: string;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings {
    /**
     * Enables or disables adaptive quantization.
     */
    adaptiveQuantization: string;
    /**
     * Indicates that AFD values will be written into the output stream.
     */
    afdSignaling: string;
    /**
     * Whether or not EML should insert an Alternative Transfer Function SEI message.
     */
    alternativeTransferFunction: string;
    /**
     * Average bitrate in bits/second.
     */
    bitrate: number;
    /**
     * Size of buffer in bits.
     */
    bufSize?: number;
    /**
     * Includes color space metadata in the output.
     */
    colorMetadata: string;
    /**
     * Define the color metadata for the output. H265 Color Space Settings for more details.
     */
    colorSpaceSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings;
    /**
     * Filters to apply to an encode. See H265 Filter Settings for more details.
     */
    filterSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings;
    /**
     * Four bit AFD value to write on all frames of video in the output stream.
     */
    fixedAfd: string;
    flickerAq: string;
    /**
     * Framerate denominator.
     */
    framerateDenominator: number;
    /**
     * Framerate numerator.
     */
    framerateNumerator: number;
    /**
     * Frequency of closed GOPs.
     */
    gopClosedCadence?: number;
    /**
     * GOP size in units of either frames of seconds per `gopSizeUnits`.
     */
    gopSize?: number;
    /**
     * Indicates if the `gopSize` is specified in frames or seconds.
     */
    gopSizeUnits: string;
    /**
     * H265 level.
     */
    level: string;
    /**
     * Amount of lookahead.
     */
    lookAheadRateControl: string;
    /**
     * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     */
    maxBitrate?: number;
    minIInterval?: number;
    /**
     * Pixel Aspect Ratio denominator.
     */
    parDenominator?: number;
    /**
     * Pixel Aspect Ratio numerator.
     */
    parNumerator?: number;
    /**
     * H265 profile.
     */
    profile: string;
    /**
     * Controls the target quality for the video encode.
     */
    qvbrQualityLevel?: number;
    /**
     * Rate control mode.
     */
    rateControlMode: string;
    /**
     * Sets the scan type of the output.
     */
    scanType: string;
    /**
     * Scene change detection.
     */
    sceneChangeDetect: string;
    /**
     * Number of slices per picture.
     */
    slices?: number;
    /**
     * Set the H265 tier in the output.
     */
    tier: string;
    /**
     * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     */
    timecodeBurninSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings;
    /**
     * Determines how timecodes should be inserted into the video elementary stream.
     */
    timecodeInsertion: string;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings {
    colorSpacePassthroughSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings;
    dolbyVision81Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings;
    hdr10Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings;
    rec601Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings;
    rec709Settings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings {
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings {
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings {
    maxCll?: number;
    maxFall?: number;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings {
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings {
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings {
    temporalFilterSettings?: outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings {
    /**
     * Post filter sharpening.
     */
    postFilterSharpening?: string;
    /**
     * Filter strength.
     */
    strength?: string;
}
export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings {
    prefix: string;
    timecodeBurninFontSize: string;
    timecodeBurninPosition: string;
}
export interface ChannelInputAttachment {
    /**
     * User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
     */
    automaticInputFailoverSettings?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettings;
    /**
     * User-specified name for the attachment.
     */
    inputAttachmentName: string;
    /**
     * The ID of the input.
     */
    inputId: string;
    /**
     * Settings of an input. See Input Settings for more details.
     */
    inputSettings: outputs.ChannelInputAttachmentInputSettings;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettings {
    /**
     * This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\_preference for the failover pair is set to PRIMARY\_INPUT\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
     */
    errorClearTimeMsec?: number;
    /**
     * A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details.
     */
    failoverConditions?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition[];
    /**
     * Input preference when deciding which input to make active when a previously failed input has recovered.
     */
    inputPreference?: string;
    /**
     * The input ID of the secondary input in the automatic input failover pair.
     */
    secondaryInputId: string;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition {
    failoverConditionSettings?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings {
    /**
     * MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
     */
    audioSilenceSettings?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings;
    /**
     * MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
     */
    inputLossSettings?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings;
    /**
     * MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
     */
    videoBlackSettings?: outputs.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings {
    audioSelectorName: string;
    audioSilenceThresholdMsec?: number;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings {
    inputLossThresholdMsec?: number;
}
export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings {
    blackDetectThreshold?: number;
    videoBlackThresholdMsec?: number;
}
export interface ChannelInputAttachmentInputSettings {
    audioSelectors?: outputs.ChannelInputAttachmentInputSettingsAudioSelector[];
    captionSelectors?: outputs.ChannelInputAttachmentInputSettingsCaptionSelector[];
    /**
     * Enable or disable the deblock filter when filtering.
     */
    deblockFilter?: string;
    /**
     * Enable or disable the denoise filter when filtering.
     */
    denoiseFilter?: string;
    /**
     * Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
     */
    filterStrength?: number;
    /**
     * Turns on the filter for the input.
     */
    inputFilter: string;
    /**
     * Input settings. See Network Input Settings for more details.
     */
    networkInputSettings?: outputs.ChannelInputAttachmentInputSettingsNetworkInputSettings;
    /**
     * PID from which to read SCTE-35 messages.
     */
    scte35Pid?: number;
    /**
     * Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
     */
    smpte2038DataPreference?: string;
    /**
     * Loop input if it is a file.
     */
    sourceEndBehavior?: string;
    videoSelector?: outputs.ChannelInputAttachmentInputSettingsVideoSelector;
}
export interface ChannelInputAttachmentInputSettingsAudioSelector {
    /**
     * Name of the Channel.
     *
     * The following arguments are optional:
     */
    name: string;
    selectorSettings?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings {
    audioHlsRenditionSelection?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection;
    audioLanguageSelection?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection;
    audioPidSelection?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection;
    audioTrackSelection?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection {
    /**
     * Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
     */
    groupId: string;
    /**
     * Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
     */
    name: string;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection {
    /**
     * Selects a specific three-letter language code from within an audio source.
     */
    languageCode: string;
    /**
     * When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language.
     */
    languageSelectionPolicy?: string;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection {
    /**
     * Selects a specific PID from within a source.
     */
    pid: number;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection {
    /**
     * Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
     */
    dolbyEDecode?: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode;
    /**
     * Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
     */
    tracks: outputs.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack[];
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode {
    /**
     * Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
     */
    programSelection: string;
}
export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack {
    track: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelector {
    languageCode?: string;
    /**
     * Name of the Channel.
     *
     * The following arguments are optional:
     */
    name: string;
    selectorSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings {
    ancillarySourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings;
    aribSourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings;
    dvbSubSourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings;
    embeddedSourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings;
    scte20SourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings;
    scte27SourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings;
    teletextSourceSettings?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings {
    /**
     * Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
     */
    sourceAncillaryChannelNumber?: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings {
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings {
    /**
     * If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
     */
    ocrLanguage?: string;
    /**
     * When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
     */
    pid?: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings {
    /**
     * If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
     */
    convert608To708?: string;
    /**
     * Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
     */
    scte20Detection?: string;
    /**
     * Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
     */
    source608ChannelNumber?: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings {
    convert608To708?: string;
    source608ChannelNumber?: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings {
    ocrLanguage?: string;
    pid?: number;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings {
    /**
     * Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
     */
    outputRectangle?: outputs.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle;
    /**
     * Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix.
     */
    pageNumber?: string;
}
export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle {
    height: number;
    leftOffset: number;
    topOffset: number;
    width: number;
}
export interface ChannelInputAttachmentInputSettingsNetworkInputSettings {
    /**
     * Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
     */
    hlsInputSettings?: outputs.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings;
    /**
     * Check HTTPS server certificates.
     */
    serverValidation?: string;
}
export interface ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings {
    /**
     * The bitrate is specified in bits per second, as in an HLS manifest.
     */
    bandwidth?: number;
    /**
     * Buffer segments.
     */
    bufferSegments?: number;
    /**
     * The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
     */
    retries?: number;
    /**
     * The number of seconds between retries when an attempt to read a manifest or segment fails.
     */
    retryInterval?: number;
    scte35Source?: string;
}
export interface ChannelInputAttachmentInputSettingsVideoSelector {
    colorSpace?: string;
    colorSpaceUsage?: string;
}
export interface ChannelInputSpecification {
    codec: string;
    inputResolution: string;
    maximumBitrate: string;
}
export interface ChannelMaintenance {
    /**
     * The day of the week to use for maintenance.
     */
    maintenanceDay: string;
    /**
     * The hour maintenance will start.
     */
    maintenanceStartTime: string;
}
export interface ChannelVpc {
    availabilityZones: string[];
    networkInterfaceIds: string[];
    /**
     * List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
     */
    publicAddressAllocationIds: string[];
    /**
     * A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
     */
    securityGroupIds: string[];
    /**
     * A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
     */
    subnetIds: string[];
}
export interface InputDestination {
    /**
     * A unique name for the location the RTMP stream is being pushed to.
     */
    streamName: string;
}
export interface InputInputDevice {
    /**
     * The unique ID for the device.
     */
    id: string;
}
export interface InputMediaConnectFlow {
    /**
     * The ARN of the MediaConnect Flow
     */
    flowArn: string;
}
export interface InputSecurityGroupWhitelistRule {
    /**
     * The IPv4 CIDR that's whitelisted.
     */
    cidr: string;
}
export interface InputSource {
    /**
     * The key used to extract the password from EC2 Parameter store.
     */
    passwordParam: string;
    /**
     * The URL where the stream is pulled from.
     */
    url: string;
    /**
     * The username for the input source.
     */
    username: string;
}
export interface InputVpc {
    /**
     * A list of up to 5 EC2 VPC security group IDs to attach to the Input.
     */
    securityGroupIds?: string[];
    /**
     * A list of 2 VPC subnet IDs from the same VPC.
     */
    subnetIds: string[];
}
export interface MultiplexMultiplexSettings {
    /**
     * Maximum video buffer delay.
     */
    maximumVideoBufferDelayMilliseconds: number;
    /**
     * Transport stream bit rate.
     */
    transportStreamBitrate: number;
    /**
     * Unique ID for each multiplex.
     */
    transportStreamId: number;
    /**
     * Transport stream reserved bit rate.
     */
    transportStreamReservedBitrate: number;
}
export interface MultiplexProgramMultiplexProgramSettings {
    preferredChannelPipeline: string;
    programNumber: number;
    serviceDescriptor?: outputs.MultiplexProgramMultiplexProgramSettingsServiceDescriptor;
    videoSettings?: outputs.MultiplexProgramMultiplexProgramSettingsVideoSettings;
}
export interface MultiplexProgramMultiplexProgramSettingsServiceDescriptor {
    /**
     * Unique provider name.
     */
    providerName: string;
    /**
     * Unique service name.
     */
    serviceName: string;
}
export interface MultiplexProgramMultiplexProgramSettingsVideoSettings {
    /**
     * Constant bitrate value.
     */
    constantBitrate: number;
    /**
     * Statmux settings. See Statmux Settings for more details.
     */
    statmuxSettings?: outputs.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings;
}
export interface MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
    /**
     * Maximum bitrate.
     */
    maximumBitrate: number;
    /**
     * Minimum bitrate.
     */
    minimumBitrate: number;
    /**
     * Priority value.
     */
    priority: number;
}
export interface GetInputDestination {
    ip: string;
    port: string;
    url: string;
    vpcs: any[];
}
export interface GetInputInputDevice {
    /**
     * The ID of the Input.
     */
    id: string;
}
export interface GetInputMediaConnectFlow {
    flowArn: string;
}
export interface GetInputSource {
    passwordParam: string;
    url: string;
    username: string;
}
