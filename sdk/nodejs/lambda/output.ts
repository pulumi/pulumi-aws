// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";
import * as enums from "./enums";

export interface AliasRoutingConfig {
    /**
     * A map that defines the proportion of events that should be sent to different versions of a lambda function.
     */
    additionalVersionWeights?: {[key: string]: number};
}
export interface CodeSigningConfigAllowedPublishers {
    /**
     * The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
     */
    signingProfileVersionArns: string[];
}
export interface CodeSigningConfigPolicies {
    /**
     * Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
     */
    untrustedArtifactOnDeployment: string;
}
export interface EventSourceMappingAmazonManagedKafkaEventSourceConfig {
    /**
     * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
     */
    consumerGroupId: string;
}
export interface EventSourceMappingDestinationConfig {
    /**
     * The destination configuration for failed invocations. Detailed below.
     */
    onFailure?: outputs.EventSourceMappingDestinationConfigOnFailure;
}
export interface EventSourceMappingDestinationConfigOnFailure {
    destinationArn: string;
}
export interface EventSourceMappingDocumentDbEventSourceConfig {
    /**
     * The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
     */
    collectionName?: string;
    /**
     * The name of the database to consume within the DocumentDB cluster.
     */
    databaseName: string;
    /**
     * Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
     */
    fullDocument?: string;
}
export interface EventSourceMappingFilterCriteria {
    /**
     * A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
     */
    filters?: outputs.EventSourceMappingFilterCriteriaFilter[];
}
export interface EventSourceMappingFilterCriteriaFilter {
    pattern?: string;
}
export interface EventSourceMappingScalingConfig {
    /**
     * Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between `2` and `1000`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
     */
    maximumConcurrency?: number;
}
export interface EventSourceMappingSelfManagedEventSource {
    /**
     * A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
     */
    endpoints: {[key: string]: string};
}
export interface EventSourceMappingSelfManagedKafkaEventSourceConfig {
    /**
     * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
     */
    consumerGroupId: string;
}
export interface EventSourceMappingSourceAccessConfiguration {
    /**
     * The type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
     */
    type: string;
    /**
     * The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnetId` is the value you would find in an aws.ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `securityGroupId` is the value you would find in an aws.ec2.SecurityGroup resource's id attribute.
     */
    uri: string;
}
export interface FunctionDeadLetterConfig {
    /**
     * ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
     */
    targetArn: string;
}
export interface FunctionEnvironment {
    /**
     * Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
     */
    variables?: {[key: string]: string};
}
export interface FunctionEphemeralStorage {
    /**
     * The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeralStorage` value defaults to `512`MB and the maximum supported value is `10240`MB.
     */
    size: number;
}
export interface FunctionEventInvokeConfigDestinationConfig {
    /**
     * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
     */
    onFailure?: outputs.FunctionEventInvokeConfigDestinationConfigOnFailure;
    /**
     * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
     */
    onSuccess?: outputs.FunctionEventInvokeConfigDestinationConfigOnSuccess;
}
export interface FunctionEventInvokeConfigDestinationConfigOnFailure {
    destination: string;
}
export interface FunctionEventInvokeConfigDestinationConfigOnSuccess {
    destination: string;
}
export interface FunctionFileSystemConfig {
    /**
     * Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
     */
    arn: string;
    /**
     * Path where the function can access the file system, starting with /mnt/.
     */
    localMountPath: string;
}
export interface FunctionImageConfig {
    /**
     * Parameters that you want to pass in with `entryPoint`.
     */
    commands?: string[];
    /**
     * Entry point to your application, which is typically the location of the runtime executable.
     */
    entryPoints?: string[];
    /**
     * Working directory.
     */
    workingDirectory?: string;
}
export interface FunctionLoggingConfig {
    /**
     * for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
     */
    applicationLogLevel?: string;
    /**
     * select between `Text` and structured `JSON` format for your function's logs.
     */
    logFormat: string;
    /**
     * the CloudWatch log group your function sends logs to.
     */
    logGroup: string;
    /**
     * for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as `ERROR`, `DEBUG`, or `INFO`.
     */
    systemLogLevel?: string;
}
export interface FunctionSnapStart {
    /**
     * Conditions where snap start is enabled. Valid values are `PublishedVersions`.
     */
    applyOn: string;
    /**
     * Optimization status of the snap start configuration. Valid values are `On` and `Off`.
     */
    optimizationStatus: string;
}
export interface FunctionTracingConfig {
    /**
     * Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
     */
    mode: string;
}
export interface FunctionUrlCors {
    /**
     * Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
     */
    allowCredentials?: boolean;
    /**
     * The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
     */
    allowHeaders?: string[];
    /**
     * The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
     */
    allowMethods?: string[];
    /**
     * The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
     */
    allowOrigins?: string[];
    /**
     * The HTTP headers in your function response that you want to expose to origins that call the function URL.
     */
    exposeHeaders?: string[];
    /**
     * The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
     */
    maxAge?: number;
}
export interface FunctionVpcConfig {
    /**
     * Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is `false`.
     */
    ipv6AllowedForDualStack?: boolean;
    /**
     * List of security group IDs associated with the Lambda function.
     */
    securityGroupIds: string[];
    /**
     * List of subnet IDs associated with the Lambda function.
     */
    subnetIds: string[];
    /**
     * ID of the VPC.
     */
    vpcId: string;
}
export interface GetCodeSigningConfigAllowedPublisher {
    /**
     * The ARN for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
     */
    signingProfileVersionArns: string[];
}
export interface GetCodeSigningConfigPolicy {
    /**
     * Code signing configuration policy for deployment validation failure.
     */
    untrustedArtifactOnDeployment: string;
}
export interface GetFunctionDeadLetterConfig {
    targetArn: string;
}
export interface GetFunctionEnvironment {
    variables: {[key: string]: string};
}
export interface GetFunctionEphemeralStorage {
    size: number;
}
export interface GetFunctionFileSystemConfig {
    /**
     * Unqualified (no `:QUALIFIER` or `:VERSION` suffix) ARN identifying your Lambda Function. See also `qualifiedArn`.
     */
    arn: string;
    localMountPath: string;
}
export interface GetFunctionLoggingConfig {
    applicationLogLevel: string;
    logFormat: string;
    logGroup: string;
    systemLogLevel: string;
}
export interface GetFunctionTracingConfig {
    mode: string;
}
export interface GetFunctionUrlCor {
    allowCredentials: boolean;
    allowHeaders: string[];
    allowMethods: string[];
    allowOrigins: string[];
    exposeHeaders: string[];
    maxAge: number;
}
export interface GetFunctionVpcConfig {
    ipv6AllowedForDualStack: boolean;
    securityGroupIds: string[];
    subnetIds: string[];
    vpcId: string;
}
