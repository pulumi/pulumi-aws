// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface ApplicationAppSource {
    /**
     * Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    password?: pulumi.Input<string>;
    /**
     * For sources that are version-aware, the revision to use.
     */
    revision?: pulumi.Input<string>;
    /**
     * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    sshKey?: pulumi.Input<string>;
    /**
     * The type of source to use. For example, "archive".
     */
    type: pulumi.Input<string>;
    /**
     * The URL where the app resource can be found.
     */
    url?: pulumi.Input<string>;
    /**
     * Username to use when authenticating to the source.
     */
    username?: pulumi.Input<string>;
}
export interface ApplicationEnvironment {
    /**
     * Variable name.
     */
    key: pulumi.Input<string>;
    /**
     * Set visibility of the variable value to `true` or `false`.
     */
    secure?: pulumi.Input<boolean>;
    /**
     * Variable value.
     */
    value: pulumi.Input<string>;
}
export interface ApplicationSslConfiguration {
    /**
     * The contents of the certificate's domain.crt file.
     */
    certificate: pulumi.Input<string>;
    /**
     * Can be used to specify an intermediate certificate authority key or client authentication.
     */
    chain?: pulumi.Input<string>;
    /**
     * The private key; the contents of the certificate's domain.key file.
     */
    privateKey: pulumi.Input<string>;
}
export interface CustomLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    /**
     * A block the specifies how an opsworks logs look like. See Log Streams.
     */
    logStreams?: pulumi.Input<pulumi.Input<inputs.CustomLayerCloudwatchConfigurationLogStream>[]>;
}
export interface CustomLayerCloudwatchConfigurationLogStream {
    /**
     * Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
     */
    batchCount?: pulumi.Input<number>;
    /**
     * Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
     */
    batchSize?: pulumi.Input<number>;
    /**
     * Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
     */
    bufferDuration?: pulumi.Input<number>;
    /**
     * Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
     */
    datetimeFormat?: pulumi.Input<string>;
    /**
     * Specifies the encoding of the log file so that the file can be read correctly. The default is `utf8`.
     */
    encoding?: pulumi.Input<string>;
    /**
     * Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
     */
    file: pulumi.Input<string>;
    /**
     * Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
     */
    fileFingerprintLines?: pulumi.Input<string>;
    /**
     * Specifies where to start to read data (`startOfFile` or `endOfFile`). The default is `startOfFile`.
     */
    initialPosition?: pulumi.Input<string>;
    /**
     * Specifies the destination log group. A log group is created automatically if it doesn't already exist.
     */
    logGroupName: pulumi.Input<string>;
    /**
     * Specifies the pattern for identifying the start of a log message.
     */
    multilineStartPattern?: pulumi.Input<string>;
    /**
     * Specifies the time zone of log event time stamps.
     */
    timeZone?: pulumi.Input<string>;
}
export interface CustomLayerEbsVolume {
    /**
     * Encrypt the volume.
     */
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface CustomLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.CustomLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.CustomLayerLoadBasedAutoScalingUpscaling>;
}
export interface CustomLayerLoadBasedAutoScalingDownscaling {
    /**
     * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
     */
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
     */
    cpuThreshold?: pulumi.Input<number>;
    /**
     * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
     */
    ignoreMetricsTime?: pulumi.Input<number>;
    /**
     * The number of instances to add or remove when the load exceeds a threshold.
     */
    instanceCount?: pulumi.Input<number>;
    /**
     * The load threshold. A value of -1 disables the threshold.
     */
    loadThreshold?: pulumi.Input<number>;
    /**
     * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
     */
    memoryThreshold?: pulumi.Input<number>;
    /**
     * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
     */
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface CustomLayerLoadBasedAutoScalingUpscaling {
    /**
     * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
     */
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
     */
    cpuThreshold?: pulumi.Input<number>;
    /**
     * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
     */
    ignoreMetricsTime?: pulumi.Input<number>;
    /**
     * The number of instances to add or remove when the load exceeds a threshold.
     */
    instanceCount?: pulumi.Input<number>;
    /**
     * The load threshold. A value of -1 disables the threshold.
     */
    loadThreshold?: pulumi.Input<number>;
    /**
     * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
     */
    memoryThreshold?: pulumi.Input<number>;
    /**
     * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
     */
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface EcsClusterLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.EcsClusterLayerCloudwatchConfigurationLogStream>[]>;
}
export interface EcsClusterLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface EcsClusterLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface EcsClusterLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.EcsClusterLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.EcsClusterLayerLoadBasedAutoScalingUpscaling>;
}
export interface EcsClusterLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface EcsClusterLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface GangliaLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.GangliaLayerCloudwatchConfigurationLogStream>[]>;
}
export interface GangliaLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface GangliaLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface GangliaLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.GangliaLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.GangliaLayerLoadBasedAutoScalingUpscaling>;
}
export interface GangliaLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface GangliaLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface HaproxyLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.HaproxyLayerCloudwatchConfigurationLogStream>[]>;
}
export interface HaproxyLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface HaproxyLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface HaproxyLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.HaproxyLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.HaproxyLayerLoadBasedAutoScalingUpscaling>;
}
export interface HaproxyLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface HaproxyLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface InstanceEbsBlockDevice {
    deleteOnTermination?: pulumi.Input<boolean>;
    deviceName: pulumi.Input<string>;
    iops?: pulumi.Input<number>;
    snapshotId?: pulumi.Input<string>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}
export interface InstanceEphemeralBlockDevice {
    deviceName: pulumi.Input<string>;
    virtualName: pulumi.Input<string>;
}
export interface InstanceRootBlockDevice {
    deleteOnTermination?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}
export interface JavaAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.JavaAppLayerCloudwatchConfigurationLogStream>[]>;
}
export interface JavaAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface JavaAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface JavaAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.JavaAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.JavaAppLayerLoadBasedAutoScalingUpscaling>;
}
export interface JavaAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface JavaAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface MemcachedLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.MemcachedLayerCloudwatchConfigurationLogStream>[]>;
}
export interface MemcachedLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface MemcachedLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface MemcachedLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.MemcachedLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.MemcachedLayerLoadBasedAutoScalingUpscaling>;
}
export interface MemcachedLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface MemcachedLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface MysqlLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.MysqlLayerCloudwatchConfigurationLogStream>[]>;
}
export interface MysqlLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface MysqlLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface MysqlLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.MysqlLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.MysqlLayerLoadBasedAutoScalingUpscaling>;
}
export interface MysqlLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface MysqlLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface NodejsAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.NodejsAppLayerCloudwatchConfigurationLogStream>[]>;
}
export interface NodejsAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface NodejsAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface NodejsAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.NodejsAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.NodejsAppLayerLoadBasedAutoScalingUpscaling>;
}
export interface NodejsAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface NodejsAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface PhpAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.PhpAppLayerCloudwatchConfigurationLogStream>[]>;
}
export interface PhpAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface PhpAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface PhpAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.PhpAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.PhpAppLayerLoadBasedAutoScalingUpscaling>;
}
export interface PhpAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface PhpAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface RailsAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.RailsAppLayerCloudwatchConfigurationLogStream>[]>;
}
export interface RailsAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface RailsAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface RailsAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.RailsAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.RailsAppLayerLoadBasedAutoScalingUpscaling>;
}
export interface RailsAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface RailsAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface StackCustomCookbooksSource {
    /**
     * Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
     */
    password?: pulumi.Input<string>;
    /**
     * For sources that are version-aware, the revision to use.
     */
    revision?: pulumi.Input<string>;
    /**
     * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    sshKey?: pulumi.Input<string>;
    /**
     * The type of source to use. For example, "archive".
     */
    type: pulumi.Input<string>;
    /**
     * The URL where the cookbooks resource can be found.
     */
    url: pulumi.Input<string>;
    /**
     * Username to use when authenticating to the source.
     */
    username?: pulumi.Input<string>;
}
export interface StaticWebLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.StaticWebLayerCloudwatchConfigurationLogStream>[]>;
}
export interface StaticWebLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}
export interface StaticWebLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}
export interface StaticWebLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.StaticWebLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.StaticWebLayerLoadBasedAutoScalingUpscaling>;
}
export interface StaticWebLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
export interface StaticWebLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
