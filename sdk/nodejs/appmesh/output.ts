// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface GatewayRouteSpec {
    /**
     * Specification of a gRPC gateway route.
     */
    grpcRoute?: outputs.GatewayRouteSpecGrpcRoute;
    /**
     * Specification of an HTTP/2 gateway route.
     */
    http2Route?: outputs.GatewayRouteSpecHttp2Route;
    /**
     * Specification of an HTTP gateway route.
     */
    httpRoute?: outputs.GatewayRouteSpecHttpRoute;
    /**
     * Priority for the gateway route, between `0` and `1000`.
     */
    priority?: number;
}
export interface GatewayRouteSpecGrpcRoute {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.GatewayRouteSpecGrpcRouteAction;
    /**
     * Criteria for determining a request match.
     */
    match: outputs.GatewayRouteSpecGrpcRouteMatch;
}
export interface GatewayRouteSpecGrpcRouteAction {
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: outputs.GatewayRouteSpecGrpcRouteActionTarget;
}
export interface GatewayRouteSpecGrpcRouteActionTarget {
    /**
     * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
     */
    port?: number;
    /**
     * Virtual service gateway route target.
     */
    virtualService: outputs.GatewayRouteSpecGrpcRouteActionTargetVirtualService;
}
export interface GatewayRouteSpecGrpcRouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: string;
}
export interface GatewayRouteSpecGrpcRouteMatch {
    /**
     * The port number to match from the request.
     */
    port?: number;
    /**
     * Fully qualified domain name for the service to match from the request.
     */
    serviceName: string;
}
export interface GatewayRouteSpecHttp2Route {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.GatewayRouteSpecHttp2RouteAction;
    /**
     * Criteria for determining a request match.
     */
    match: outputs.GatewayRouteSpecHttp2RouteMatch;
}
export interface GatewayRouteSpecHttp2RouteAction {
    /**
     * Gateway route action to rewrite.
     */
    rewrite?: outputs.GatewayRouteSpecHttp2RouteActionRewrite;
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: outputs.GatewayRouteSpecHttp2RouteActionTarget;
}
export interface GatewayRouteSpecHttp2RouteActionRewrite {
    /**
     * Host name to rewrite.
     */
    hostname?: outputs.GatewayRouteSpecHttp2RouteActionRewriteHostname;
    /**
     * Exact path to rewrite.
     */
    path?: outputs.GatewayRouteSpecHttp2RouteActionRewritePath;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: outputs.GatewayRouteSpecHttp2RouteActionRewritePrefix;
}
export interface GatewayRouteSpecHttp2RouteActionRewriteHostname {
    /**
     * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultTargetHostname: string;
}
export interface GatewayRouteSpecHttp2RouteActionRewritePath {
    /**
     * The exact path to match on.
     */
    exact: string;
}
export interface GatewayRouteSpecHttp2RouteActionRewritePrefix {
    /**
     * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultPrefix?: string;
    /**
     * Value used to replace the incoming route prefix when rewritten.
     */
    value?: string;
}
export interface GatewayRouteSpecHttp2RouteActionTarget {
    /**
     * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
     */
    port?: number;
    /**
     * Virtual service gateway route target.
     */
    virtualService: outputs.GatewayRouteSpecHttp2RouteActionTargetVirtualService;
}
export interface GatewayRouteSpecHttp2RouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: string;
}
export interface GatewayRouteSpecHttp2RouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: outputs.GatewayRouteSpecHttp2RouteMatchHeader[];
    /**
     * Host name to match on.
     */
    hostname?: outputs.GatewayRouteSpecHttp2RouteMatchHostname;
    /**
     * Client request path to match on.
     */
    path?: outputs.GatewayRouteSpecHttp2RouteMatchPath;
    /**
     * The port number to match from the request.
     */
    port?: number;
    /**
     * Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
     */
    prefix?: string;
    /**
     * Client request query parameters to match on.
     */
    queryParameters?: outputs.GatewayRouteSpecHttp2RouteMatchQueryParameter[];
}
export interface GatewayRouteSpecHttp2RouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: boolean;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatch;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: string;
}
export interface GatewayRouteSpecHttp2RouteMatchHeaderMatch {
    /**
     * Header value sent by the client must match the specified value exactly.
     */
    exact?: string;
    /**
     * Header value sent by the client must begin with the specified characters.
     */
    prefix?: string;
    /**
     * Object that specifies the range of numbers that the header value sent by the client must be included in.
     */
    range?: outputs.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange;
    /**
     * Header value sent by the client must include the specified characters.
     */
    regex?: string;
    /**
     * Header value sent by the client must end with the specified characters.
     */
    suffix?: string;
}
export interface GatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: number;
    /**
     * Start of the range.
     */
    start: number;
}
export interface GatewayRouteSpecHttp2RouteMatchHostname {
    /**
     * Exact host name to match on.
     */
    exact?: string;
    /**
     * Specified ending characters of the host name to match on.
     */
    suffix?: string;
}
export interface GatewayRouteSpecHttp2RouteMatchPath {
    /**
     * The exact path to match on.
     */
    exact?: string;
    /**
     * The regex used to match the path.
     */
    regex?: string;
}
export interface GatewayRouteSpecHttp2RouteMatchQueryParameter {
    /**
     * The query parameter to match on.
     */
    match?: outputs.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch;
    /**
     * Name for the query parameter that will be matched on.
     */
    name: string;
}
export interface GatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
    /**
     * The exact query parameter to match on.
     */
    exact?: string;
}
export interface GatewayRouteSpecHttpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.GatewayRouteSpecHttpRouteAction;
    /**
     * Criteria for determining a request match.
     */
    match: outputs.GatewayRouteSpecHttpRouteMatch;
}
export interface GatewayRouteSpecHttpRouteAction {
    /**
     * Gateway route action to rewrite.
     */
    rewrite?: outputs.GatewayRouteSpecHttpRouteActionRewrite;
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: outputs.GatewayRouteSpecHttpRouteActionTarget;
}
export interface GatewayRouteSpecHttpRouteActionRewrite {
    /**
     * Host name to rewrite.
     */
    hostname?: outputs.GatewayRouteSpecHttpRouteActionRewriteHostname;
    /**
     * Exact path to rewrite.
     */
    path?: outputs.GatewayRouteSpecHttpRouteActionRewritePath;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: outputs.GatewayRouteSpecHttpRouteActionRewritePrefix;
}
export interface GatewayRouteSpecHttpRouteActionRewriteHostname {
    /**
     * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultTargetHostname: string;
}
export interface GatewayRouteSpecHttpRouteActionRewritePath {
    /**
     * The exact path to match on.
     */
    exact: string;
}
export interface GatewayRouteSpecHttpRouteActionRewritePrefix {
    /**
     * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultPrefix?: string;
    /**
     * Value used to replace the incoming route prefix when rewritten.
     */
    value?: string;
}
export interface GatewayRouteSpecHttpRouteActionTarget {
    /**
     * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
     */
    port?: number;
    /**
     * Virtual service gateway route target.
     */
    virtualService: outputs.GatewayRouteSpecHttpRouteActionTargetVirtualService;
}
export interface GatewayRouteSpecHttpRouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: string;
}
export interface GatewayRouteSpecHttpRouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: outputs.GatewayRouteSpecHttpRouteMatchHeader[];
    /**
     * Host name to match on.
     */
    hostname?: outputs.GatewayRouteSpecHttpRouteMatchHostname;
    /**
     * Client request path to match on.
     */
    path?: outputs.GatewayRouteSpecHttpRouteMatchPath;
    /**
     * The port number to match from the request.
     */
    port?: number;
    /**
     * Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
     */
    prefix?: string;
    /**
     * Client request query parameters to match on.
     */
    queryParameters?: outputs.GatewayRouteSpecHttpRouteMatchQueryParameter[];
}
export interface GatewayRouteSpecHttpRouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: boolean;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: outputs.GatewayRouteSpecHttpRouteMatchHeaderMatch;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: string;
}
export interface GatewayRouteSpecHttpRouteMatchHeaderMatch {
    /**
     * Header value sent by the client must match the specified value exactly.
     */
    exact?: string;
    /**
     * Header value sent by the client must begin with the specified characters.
     */
    prefix?: string;
    /**
     * Object that specifies the range of numbers that the header value sent by the client must be included in.
     */
    range?: outputs.GatewayRouteSpecHttpRouteMatchHeaderMatchRange;
    /**
     * Header value sent by the client must include the specified characters.
     */
    regex?: string;
    /**
     * Header value sent by the client must end with the specified characters.
     */
    suffix?: string;
}
export interface GatewayRouteSpecHttpRouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: number;
    /**
     * Start of the range.
     */
    start: number;
}
export interface GatewayRouteSpecHttpRouteMatchHostname {
    /**
     * Exact host name to match on.
     */
    exact?: string;
    /**
     * Specified ending characters of the host name to match on.
     */
    suffix?: string;
}
export interface GatewayRouteSpecHttpRouteMatchPath {
    /**
     * The exact path to match on.
     */
    exact?: string;
    /**
     * The regex used to match the path.
     */
    regex?: string;
}
export interface GatewayRouteSpecHttpRouteMatchQueryParameter {
    /**
     * The query parameter to match on.
     */
    match?: outputs.GatewayRouteSpecHttpRouteMatchQueryParameterMatch;
    /**
     * Name for the query parameter that will be matched on.
     */
    name: string;
}
export interface GatewayRouteSpecHttpRouteMatchQueryParameterMatch {
    /**
     * The exact query parameter to match on.
     */
    exact?: string;
}
export interface MeshSpec {
    /**
     * Egress filter rules for the service mesh.
     */
    egressFilter?: outputs.MeshSpecEgressFilter;
    /**
     * The service discovery information for the service mesh.
     */
    serviceDiscovery?: outputs.MeshSpecServiceDiscovery;
}
export interface MeshSpecEgressFilter {
    type?: string;
}
export interface MeshSpecServiceDiscovery {
    ipPreference?: string;
}
export interface RouteSpec {
    /**
     * GRPC routing information for the route.
     */
    grpcRoute?: outputs.RouteSpecGrpcRoute;
    /**
     * HTTP/2 routing information for the route.
     */
    http2Route?: outputs.RouteSpecHttp2Route;
    /**
     * HTTP routing information for the route.
     */
    httpRoute?: outputs.RouteSpecHttpRoute;
    /**
     * Priority for the route, between `0` and `1000`.
     * Routes are matched based on the specified value, where `0` is the highest priority.
     */
    priority?: number;
    /**
     * TCP routing information for the route.
     */
    tcpRoute?: outputs.RouteSpecTcpRoute;
}
export interface RouteSpecGrpcRoute {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.RouteSpecGrpcRouteAction;
    /**
     * Criteria for determining an gRPC request match.
     */
    match?: outputs.RouteSpecGrpcRouteMatch;
    /**
     * Retry policy.
     */
    retryPolicy?: outputs.RouteSpecGrpcRouteRetryPolicy;
    /**
     * Types of timeouts.
     */
    timeout?: outputs.RouteSpecGrpcRouteTimeout;
}
export interface RouteSpecGrpcRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: outputs.RouteSpecGrpcRouteActionWeightedTarget[];
}
export interface RouteSpecGrpcRouteActionWeightedTarget {
    /**
     * The targeted port of the weighted object.
     */
    port?: number;
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: string;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: number;
}
export interface RouteSpecGrpcRouteMatch {
    /**
     * Data to match from the gRPC request.
     */
    metadatas?: outputs.RouteSpecGrpcRouteMatchMetadata[];
    /**
     * Method name to match from the request. If you specify a name, you must also specify a `serviceName`.
     */
    methodName?: string;
    /**
     * The port number to match from the request.
     */
    port?: number;
    prefix?: string;
    /**
     * Fully qualified domain name for the service to match from the request.
     */
    serviceName?: string;
}
export interface RouteSpecGrpcRouteMatchMetadata {
    /**
     * If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
     */
    invert?: boolean;
    /**
     * Data to match from the request.
     */
    match?: outputs.RouteSpecGrpcRouteMatchMetadataMatch;
    /**
     * Name of the route. Must be between 1 and 50 characters in length.
     */
    name: string;
}
export interface RouteSpecGrpcRouteMatchMetadataMatch {
    /**
     * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
     */
    exact?: string;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     */
    prefix?: string;
    /**
     * Object that specifies the range of numbers that the value sent by the client must be included in.
     */
    range?: outputs.RouteSpecGrpcRouteMatchMetadataMatchRange;
    /**
     * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
     */
    regex?: string;
    /**
     * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
     */
    suffix?: string;
}
export interface RouteSpecGrpcRouteMatchMetadataMatchRange {
    /**
     * End of the range.
     */
    end: number;
    /**
     * Start of the range.
     */
    start: number;
}
export interface RouteSpecGrpcRouteRetryPolicy {
    /**
     * List of gRPC retry events.
     * Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
     */
    grpcRetryEvents?: string[];
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: string[];
    /**
     * Maximum number of retries.
     */
    maxRetries: number;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: outputs.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     */
    tcpRetryEvents?: string[];
}
export interface RouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Retry value.
     */
    value: number;
}
export interface RouteSpecGrpcRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.RouteSpecGrpcRouteTimeoutIdle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.RouteSpecGrpcRouteTimeoutPerRequest;
}
export interface RouteSpecGrpcRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecGrpcRouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecHttp2Route {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.RouteSpecHttp2RouteAction;
    /**
     * Criteria for determining an HTTP request match.
     */
    match: outputs.RouteSpecHttp2RouteMatch;
    /**
     * Retry policy.
     */
    retryPolicy?: outputs.RouteSpecHttp2RouteRetryPolicy;
    /**
     * Types of timeouts.
     */
    timeout?: outputs.RouteSpecHttp2RouteTimeout;
}
export interface RouteSpecHttp2RouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: outputs.RouteSpecHttp2RouteActionWeightedTarget[];
}
export interface RouteSpecHttp2RouteActionWeightedTarget {
    /**
     * The targeted port of the weighted object.
     */
    port?: number;
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: string;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: number;
}
export interface RouteSpecHttp2RouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: outputs.RouteSpecHttp2RouteMatchHeader[];
    /**
     * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
     */
    method?: string;
    /**
     * Client request path to match on.
     */
    path?: outputs.RouteSpecHttp2RouteMatchPath;
    /**
     * The port number to match from the request.
     */
    port?: number;
    /**
     * Path with which to match requests.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: string;
    /**
     * Client request query parameters to match on.
     */
    queryParameters?: outputs.RouteSpecHttp2RouteMatchQueryParameter[];
    /**
     * Client request header scheme to match on. Valid values: `http`, `https`.
     */
    scheme?: string;
}
export interface RouteSpecHttp2RouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: boolean;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: outputs.RouteSpecHttp2RouteMatchHeaderMatch;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: string;
}
export interface RouteSpecHttp2RouteMatchHeaderMatch {
    /**
     * Header value sent by the client must match the specified value exactly.
     */
    exact?: string;
    /**
     * Header value sent by the client must begin with the specified characters.
     */
    prefix?: string;
    /**
     * Object that specifies the range of numbers that the header value sent by the client must be included in.
     */
    range?: outputs.RouteSpecHttp2RouteMatchHeaderMatchRange;
    /**
     * Header value sent by the client must include the specified characters.
     */
    regex?: string;
    /**
     * Header value sent by the client must end with the specified characters.
     */
    suffix?: string;
}
export interface RouteSpecHttp2RouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: number;
    /**
     * Start of the range.
     */
    start: number;
}
export interface RouteSpecHttp2RouteMatchPath {
    /**
     * The exact path to match on.
     */
    exact?: string;
    /**
     * The regex used to match the path.
     */
    regex?: string;
}
export interface RouteSpecHttp2RouteMatchQueryParameter {
    /**
     * The query parameter to match on.
     */
    match?: outputs.RouteSpecHttp2RouteMatchQueryParameterMatch;
    /**
     * Name for the query parameter that will be matched on.
     */
    name: string;
}
export interface RouteSpecHttp2RouteMatchQueryParameterMatch {
    /**
     * The exact query parameter to match on.
     */
    exact?: string;
}
export interface RouteSpecHttp2RouteRetryPolicy {
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: string[];
    /**
     * Maximum number of retries.
     */
    maxRetries: number;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: outputs.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     *
     * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
     */
    tcpRetryEvents?: string[];
}
export interface RouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Retry value.
     */
    value: number;
}
export interface RouteSpecHttp2RouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.RouteSpecHttp2RouteTimeoutIdle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.RouteSpecHttp2RouteTimeoutPerRequest;
}
export interface RouteSpecHttp2RouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecHttp2RouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecHttpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.RouteSpecHttpRouteAction;
    /**
     * Criteria for determining an HTTP request match.
     */
    match: outputs.RouteSpecHttpRouteMatch;
    /**
     * Retry policy.
     */
    retryPolicy?: outputs.RouteSpecHttpRouteRetryPolicy;
    /**
     * Types of timeouts.
     */
    timeout?: outputs.RouteSpecHttpRouteTimeout;
}
export interface RouteSpecHttpRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: outputs.RouteSpecHttpRouteActionWeightedTarget[];
}
export interface RouteSpecHttpRouteActionWeightedTarget {
    /**
     * The targeted port of the weighted object.
     */
    port?: number;
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: string;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: number;
}
export interface RouteSpecHttpRouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: outputs.RouteSpecHttpRouteMatchHeader[];
    /**
     * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
     */
    method?: string;
    /**
     * Client request path to match on.
     */
    path?: outputs.RouteSpecHttpRouteMatchPath;
    /**
     * The port number to match from the request.
     */
    port?: number;
    /**
     * Path with which to match requests.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: string;
    /**
     * Client request query parameters to match on.
     */
    queryParameters?: outputs.RouteSpecHttpRouteMatchQueryParameter[];
    /**
     * Client request header scheme to match on. Valid values: `http`, `https`.
     */
    scheme?: string;
}
export interface RouteSpecHttpRouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: boolean;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: outputs.RouteSpecHttpRouteMatchHeaderMatch;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: string;
}
export interface RouteSpecHttpRouteMatchHeaderMatch {
    /**
     * Header value sent by the client must match the specified value exactly.
     */
    exact?: string;
    /**
     * Header value sent by the client must begin with the specified characters.
     */
    prefix?: string;
    /**
     * Object that specifies the range of numbers that the header value sent by the client must be included in.
     */
    range?: outputs.RouteSpecHttpRouteMatchHeaderMatchRange;
    /**
     * Header value sent by the client must include the specified characters.
     */
    regex?: string;
    /**
     * Header value sent by the client must end with the specified characters.
     */
    suffix?: string;
}
export interface RouteSpecHttpRouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: number;
    /**
     * Start of the range.
     */
    start: number;
}
export interface RouteSpecHttpRouteMatchPath {
    /**
     * The exact path to match on.
     */
    exact?: string;
    /**
     * The regex used to match the path.
     */
    regex?: string;
}
export interface RouteSpecHttpRouteMatchQueryParameter {
    /**
     * The query parameter to match on.
     */
    match?: outputs.RouteSpecHttpRouteMatchQueryParameterMatch;
    /**
     * Name for the query parameter that will be matched on.
     */
    name: string;
}
export interface RouteSpecHttpRouteMatchQueryParameterMatch {
    /**
     * The exact query parameter to match on.
     */
    exact?: string;
}
export interface RouteSpecHttpRouteRetryPolicy {
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: string[];
    /**
     * Maximum number of retries.
     */
    maxRetries: number;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: outputs.RouteSpecHttpRouteRetryPolicyPerRetryTimeout;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     *
     * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
     */
    tcpRetryEvents?: string[];
}
export interface RouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Retry value.
     */
    value: number;
}
export interface RouteSpecHttpRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.RouteSpecHttpRouteTimeoutIdle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.RouteSpecHttpRouteTimeoutPerRequest;
}
export interface RouteSpecHttpRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecHttpRouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface RouteSpecTcpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: outputs.RouteSpecTcpRouteAction;
    match?: outputs.RouteSpecTcpRouteMatch;
    /**
     * Types of timeouts.
     */
    timeout?: outputs.RouteSpecTcpRouteTimeout;
}
export interface RouteSpecTcpRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: outputs.RouteSpecTcpRouteActionWeightedTarget[];
}
export interface RouteSpecTcpRouteActionWeightedTarget {
    /**
     * The targeted port of the weighted object.
     */
    port?: number;
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: string;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: number;
}
export interface RouteSpecTcpRouteMatch {
    port?: number;
}
export interface RouteSpecTcpRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.RouteSpecTcpRouteTimeoutIdle;
}
export interface RouteSpecTcpRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualGatewaySpec {
    /**
     * Defaults for backends.
     */
    backendDefaults?: outputs.VirtualGatewaySpecBackendDefaults;
    /**
     * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
     */
    listeners: outputs.VirtualGatewaySpecListener[];
    /**
     * Inbound and outbound access logging information for the virtual gateway.
     */
    logging?: outputs.VirtualGatewaySpecLogging;
}
export interface VirtualGatewaySpecBackendDefaults {
    /**
     * Default client policy for virtual gateway backends.
     */
    clientPolicy?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicy;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTls;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: boolean;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: number[];
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
    /**
     * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: string;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    /**
     * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
     */
    subjectAlternativeNames?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
    /**
     * TLS validation context trust.
     */
    trust: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: string[];
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: string[];
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
}
export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualGatewaySpecListener {
    /**
     * Connection pool information for the listener.
     */
    connectionPool?: outputs.VirtualGatewaySpecListenerConnectionPool;
    /**
     * Health check information for the listener.
     */
    healthCheck?: outputs.VirtualGatewaySpecListenerHealthCheck;
    /**
     * Port mapping information for the listener.
     */
    portMapping: outputs.VirtualGatewaySpecListenerPortMapping;
    /**
     * Transport Layer Security (TLS) properties for the listener
     */
    tls?: outputs.VirtualGatewaySpecListenerTls;
}
export interface VirtualGatewaySpecListenerConnectionPool {
    /**
     * Connection pool information for gRPC listeners.
     */
    grpc?: outputs.VirtualGatewaySpecListenerConnectionPoolGrpc;
    /**
     * Connection pool information for HTTP listeners.
     */
    http?: outputs.VirtualGatewaySpecListenerConnectionPoolHttp;
    /**
     * Connection pool information for HTTP2 listeners.
     */
    http2?: outputs.VirtualGatewaySpecListenerConnectionPoolHttp2;
}
export interface VirtualGatewaySpecListenerConnectionPoolGrpc {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: number;
}
export interface VirtualGatewaySpecListenerConnectionPoolHttp2 {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: number;
}
export interface VirtualGatewaySpecListenerConnectionPoolHttp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: number;
    /**
     * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
     */
    maxPendingRequests?: number;
}
export interface VirtualGatewaySpecListenerHealthCheck {
    /**
     * Number of consecutive successful health checks that must occur before declaring listener healthy.
     */
    healthyThreshold: number;
    /**
     * Time period in milliseconds between each health check execution.
     */
    intervalMillis: number;
    /**
     * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
     */
    path?: string;
    /**
     * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
     */
    port: number;
    /**
     * Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
     */
    protocol: string;
    /**
     * Amount of time to wait when receiving a response from the health check, in milliseconds.
     */
    timeoutMillis: number;
    /**
     * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
     */
    unhealthyThreshold: number;
}
export interface VirtualGatewaySpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: number;
    /**
     * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: string;
}
export interface VirtualGatewaySpecListenerTls {
    /**
     * Listener's TLS certificate.
     */
    certificate: outputs.VirtualGatewaySpecListenerTlsCertificate;
    /**
     * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
     */
    mode: string;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation?: outputs.VirtualGatewaySpecListenerTlsValidation;
}
export interface VirtualGatewaySpecListenerTlsCertificate {
    /**
     * An AWS Certificate Manager (ACM) certificate.
     */
    acm?: outputs.VirtualGatewaySpecListenerTlsCertificateAcm;
    /**
     * Local file certificate.
     */
    file?: outputs.VirtualGatewaySpecListenerTlsCertificateFile;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualGatewaySpecListenerTlsCertificateSds;
}
export interface VirtualGatewaySpecListenerTlsCertificateAcm {
    /**
     * ARN for the certificate.
     */
    certificateArn: string;
}
export interface VirtualGatewaySpecListenerTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
    /**
     * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: string;
}
export interface VirtualGatewaySpecListenerTlsCertificateSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualGatewaySpecListenerTlsValidation {
    /**
     * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
     */
    subjectAlternativeNames?: outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames;
    /**
     * TLS validation context trust.
     */
    trust: outputs.VirtualGatewaySpecListenerTlsValidationTrust;
}
export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: outputs.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch;
}
export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: string[];
}
export interface VirtualGatewaySpecListenerTlsValidationTrust {
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: outputs.VirtualGatewaySpecListenerTlsValidationTrustFile;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualGatewaySpecListenerTlsValidationTrustSds;
}
export interface VirtualGatewaySpecListenerTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
}
export interface VirtualGatewaySpecListenerTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualGatewaySpecLogging {
    /**
     * Access log configuration for a virtual gateway.
     */
    accessLog?: outputs.VirtualGatewaySpecLoggingAccessLog;
}
export interface VirtualGatewaySpecLoggingAccessLog {
    /**
     * File object to send virtual gateway access logs to.
     */
    file?: outputs.VirtualGatewaySpecLoggingAccessLogFile;
}
export interface VirtualGatewaySpecLoggingAccessLogFile {
    /**
     * The specified format for the logs.
     */
    format?: outputs.VirtualGatewaySpecLoggingAccessLogFileFormat;
    /**
     * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
     */
    path: string;
}
export interface VirtualGatewaySpecLoggingAccessLogFileFormat {
    /**
     * The logging format for JSON.
     */
    jsons?: outputs.VirtualGatewaySpecLoggingAccessLogFileFormatJson[];
    /**
     * The logging format for text. Must be between 1 and 1000 characters in length.
     */
    text?: string;
}
export interface VirtualGatewaySpecLoggingAccessLogFileFormatJson {
    /**
     * The specified key for the JSON. Must be between 1 and 100 characters in length.
     */
    key: string;
    /**
     * The specified value for the JSON. Must be between 1 and 100 characters in length.
     */
    value: string;
}
export interface VirtualNodeSpec {
    /**
     * Defaults for backends.
     */
    backendDefaults?: outputs.VirtualNodeSpecBackendDefaults;
    /**
     * Backends to which the virtual node is expected to send outbound traffic.
     */
    backends?: outputs.VirtualNodeSpecBackend[];
    /**
     * Listeners from which the virtual node is expected to receive inbound traffic.
     */
    listeners?: outputs.VirtualNodeSpecListener[];
    /**
     * Inbound and outbound access logging information for the virtual node.
     */
    logging?: outputs.VirtualNodeSpecLogging;
    /**
     * Service discovery information for the virtual node.
     */
    serviceDiscovery?: outputs.VirtualNodeSpecServiceDiscovery;
}
export interface VirtualNodeSpecBackend {
    /**
     * Virtual service to use as a backend for a virtual node.
     */
    virtualService: outputs.VirtualNodeSpecBackendVirtualService;
}
export interface VirtualNodeSpecBackendDefaults {
    /**
     * Default client policy for virtual service backends. See above for details.
     */
    clientPolicy?: outputs.VirtualNodeSpecBackendDefaultsClientPolicy;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTls;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: boolean;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: number[];
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: string;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
    /**
     * TLS validation context trust.
     */
    trust: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: string[];
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: string[];
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
}
export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecBackendVirtualService {
    /**
     * Client policy for the backend.
     */
    clientPolicy?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicy;
    /**
     * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: string;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTls;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: boolean;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: number[];
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: string;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames;
    /**
     * TLS validation context trust.
     */
    trust: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: string[];
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: string[];
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
}
export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecListener {
    /**
     * Connection pool information for the listener.
     */
    connectionPool?: outputs.VirtualNodeSpecListenerConnectionPool;
    /**
     * Health check information for the listener.
     */
    healthCheck?: outputs.VirtualNodeSpecListenerHealthCheck;
    /**
     * Outlier detection information for the listener.
     */
    outlierDetection?: outputs.VirtualNodeSpecListenerOutlierDetection;
    /**
     * Port mapping information for the listener.
     */
    portMapping: outputs.VirtualNodeSpecListenerPortMapping;
    /**
     * Timeouts for different protocols.
     */
    timeout?: outputs.VirtualNodeSpecListenerTimeout;
    /**
     * Transport Layer Security (TLS) properties for the listener
     */
    tls?: outputs.VirtualNodeSpecListenerTls;
}
export interface VirtualNodeSpecListenerConnectionPool {
    /**
     * Connection pool information for gRPC listeners.
     */
    grpc?: outputs.VirtualNodeSpecListenerConnectionPoolGrpc;
    /**
     * Connection pool information for HTTP2 listeners.
     */
    http2s?: outputs.VirtualNodeSpecListenerConnectionPoolHttp2[];
    /**
     * Connection pool information for HTTP listeners.
     */
    https?: outputs.VirtualNodeSpecListenerConnectionPoolHttp[];
    /**
     * Connection pool information for TCP listeners.
     */
    tcps?: outputs.VirtualNodeSpecListenerConnectionPoolTcp[];
}
export interface VirtualNodeSpecListenerConnectionPoolGrpc {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: number;
}
export interface VirtualNodeSpecListenerConnectionPoolHttp2 {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: number;
}
export interface VirtualNodeSpecListenerConnectionPoolHttp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: number;
    /**
     * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
     */
    maxPendingRequests?: number;
}
export interface VirtualNodeSpecListenerConnectionPoolTcp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: number;
}
export interface VirtualNodeSpecListenerHealthCheck {
    /**
     * Number of consecutive successful health checks that must occur before declaring listener healthy.
     */
    healthyThreshold: number;
    /**
     * Time period in milliseconds between each health check execution.
     */
    intervalMillis: number;
    /**
     * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
     */
    path?: string;
    /**
     * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
     */
    port: number;
    /**
     * Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: string;
    /**
     * Amount of time to wait when receiving a response from the health check, in milliseconds.
     */
    timeoutMillis: number;
    /**
     * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
     */
    unhealthyThreshold: number;
}
export interface VirtualNodeSpecListenerOutlierDetection {
    /**
     * Base amount of time for which a host is ejected.
     */
    baseEjectionDuration: outputs.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration;
    /**
     * Time interval between ejection sweep analysis.
     */
    interval: outputs.VirtualNodeSpecListenerOutlierDetectionInterval;
    /**
     * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
     * Minimum value of `0`. Maximum value of `100`.
     */
    maxEjectionPercent: number;
    /**
     * Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
     */
    maxServerErrors: number;
}
export interface VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerOutlierDetectionInterval {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: number;
    /**
     * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: string;
}
export interface VirtualNodeSpecListenerTimeout {
    /**
     * Timeouts for gRPC listeners.
     */
    grpc?: outputs.VirtualNodeSpecListenerTimeoutGrpc;
    /**
     * Timeouts for HTTP listeners.
     */
    http?: outputs.VirtualNodeSpecListenerTimeoutHttp;
    /**
     * Timeouts for HTTP2 listeners.
     */
    http2?: outputs.VirtualNodeSpecListenerTimeoutHttp2;
    /**
     * Timeouts for TCP listeners.
     */
    tcp?: outputs.VirtualNodeSpecListenerTimeoutTcp;
}
export interface VirtualNodeSpecListenerTimeoutGrpc {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.VirtualNodeSpecListenerTimeoutGrpcIdle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.VirtualNodeSpecListenerTimeoutGrpcPerRequest;
}
export interface VirtualNodeSpecListenerTimeoutGrpcIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutGrpcPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutHttp2 {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.VirtualNodeSpecListenerTimeoutHttp2Idle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.VirtualNodeSpecListenerTimeoutHttp2PerRequest;
}
export interface VirtualNodeSpecListenerTimeoutHttp2Idle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutHttp2PerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutHttp {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.VirtualNodeSpecListenerTimeoutHttpIdle;
    /**
     * Per request timeout.
     */
    perRequest?: outputs.VirtualNodeSpecListenerTimeoutHttpPerRequest;
}
export interface VirtualNodeSpecListenerTimeoutHttpIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutHttpPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTimeoutTcp {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: outputs.VirtualNodeSpecListenerTimeoutTcpIdle;
}
export interface VirtualNodeSpecListenerTimeoutTcpIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: string;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: number;
}
export interface VirtualNodeSpecListenerTls {
    /**
     * Listener's TLS certificate.
     */
    certificate: outputs.VirtualNodeSpecListenerTlsCertificate;
    /**
     * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
     */
    mode: string;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation?: outputs.VirtualNodeSpecListenerTlsValidation;
}
export interface VirtualNodeSpecListenerTlsCertificate {
    /**
     * An AWS Certificate Manager (ACM) certificate.
     */
    acm?: outputs.VirtualNodeSpecListenerTlsCertificateAcm;
    /**
     * Local file certificate.
     */
    file?: outputs.VirtualNodeSpecListenerTlsCertificateFile;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecListenerTlsCertificateSds;
}
export interface VirtualNodeSpecListenerTlsCertificateAcm {
    /**
     * ARN for the certificate.
     */
    certificateArn: string;
}
export interface VirtualNodeSpecListenerTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: string;
}
export interface VirtualNodeSpecListenerTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecListenerTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames;
    /**
     * TLS validation context trust.
     */
    trust: outputs.VirtualNodeSpecListenerTlsValidationTrust;
}
export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: outputs.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch;
}
export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: string[];
}
export interface VirtualNodeSpecListenerTlsValidationTrust {
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: outputs.VirtualNodeSpecListenerTlsValidationTrustFile;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: outputs.VirtualNodeSpecListenerTlsValidationTrustSds;
}
export interface VirtualNodeSpecListenerTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: string;
}
export interface VirtualNodeSpecListenerTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: string;
}
export interface VirtualNodeSpecLogging {
    /**
     * Access log configuration for a virtual node.
     */
    accessLog?: outputs.VirtualNodeSpecLoggingAccessLog;
}
export interface VirtualNodeSpecLoggingAccessLog {
    /**
     * File object to send virtual node access logs to.
     */
    file?: outputs.VirtualNodeSpecLoggingAccessLogFile;
}
export interface VirtualNodeSpecLoggingAccessLogFile {
    /**
     * The specified format for the logs.
     */
    format?: outputs.VirtualNodeSpecLoggingAccessLogFileFormat;
    /**
     * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
     */
    path: string;
}
export interface VirtualNodeSpecLoggingAccessLogFileFormat {
    /**
     * The logging format for JSON.
     */
    jsons?: outputs.VirtualNodeSpecLoggingAccessLogFileFormatJson[];
    /**
     * The logging format for text. Must be between 1 and 1000 characters in length.
     */
    text?: string;
}
export interface VirtualNodeSpecLoggingAccessLogFileFormatJson {
    /**
     * The specified key for the JSON. Must be between 1 and 100 characters in length.
     */
    key: string;
    /**
     * The specified value for the JSON. Must be between 1 and 100 characters in length.
     */
    value: string;
}
export interface VirtualNodeSpecServiceDiscovery {
    /**
     * Any AWS Cloud Map information for the virtual node.
     */
    awsCloudMap?: outputs.VirtualNodeSpecServiceDiscoveryAwsCloudMap;
    /**
     * DNS service name for the virtual node.
     */
    dns?: outputs.VirtualNodeSpecServiceDiscoveryDns;
}
export interface VirtualNodeSpecServiceDiscoveryAwsCloudMap {
    /**
     * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
     */
    attributes?: {[key: string]: string};
    /**
     * Name of the AWS Cloud Map namespace to use.
     * Use the `aws.servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
     */
    namespaceName: string;
    /**
     * Name of the AWS Cloud Map service to use. Use the `aws.servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
     */
    serviceName: string;
}
export interface VirtualNodeSpecServiceDiscoveryDns {
    /**
     * DNS host name for your virtual node.
     */
    hostname: string;
    /**
     * The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
     */
    ipPreference?: string;
    /**
     * The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
     */
    responseType?: string;
}
export interface VirtualRouterSpec {
    /**
     * Listeners that the virtual router is expected to receive inbound traffic from.
     * Currently only one listener is supported per virtual router.
     */
    listeners?: outputs.VirtualRouterSpecListener[];
}
export interface VirtualRouterSpecListener {
    /**
     * Port mapping information for the listener.
     */
    portMapping: outputs.VirtualRouterSpecListenerPortMapping;
}
export interface VirtualRouterSpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: number;
    /**
     * Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
     */
    protocol: string;
}
export interface VirtualServiceSpec {
    /**
     * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
     */
    provider?: outputs.VirtualServiceSpecProvider;
}
export interface VirtualServiceSpecProvider {
    /**
     * Virtual node associated with a virtual service.
     */
    virtualNode?: outputs.VirtualServiceSpecProviderVirtualNode;
    /**
     * Virtual router associated with a virtual service.
     */
    virtualRouter?: outputs.VirtualServiceSpecProviderVirtualRouter;
}
export interface VirtualServiceSpecProviderVirtualNode {
    /**
     * Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
     */
    virtualNodeName: string;
}
export interface VirtualServiceSpecProviderVirtualRouter {
    /**
     * Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
     */
    virtualRouterName: string;
}
export interface GetGatewayRouteSpec {
    grpcRoutes: outputs.GetGatewayRouteSpecGrpcRoute[];
    http2Routes: outputs.GetGatewayRouteSpecHttp2Route[];
    httpRoutes: outputs.GetGatewayRouteSpecHttpRoute[];
    priority: number;
}
export interface GetGatewayRouteSpecGrpcRoute {
    actions: outputs.GetGatewayRouteSpecGrpcRouteAction[];
    matches: outputs.GetGatewayRouteSpecGrpcRouteMatch[];
}
export interface GetGatewayRouteSpecGrpcRouteAction {
    targets: outputs.GetGatewayRouteSpecGrpcRouteActionTarget[];
}
export interface GetGatewayRouteSpecGrpcRouteActionTarget {
    port: number;
    virtualServices: outputs.GetGatewayRouteSpecGrpcRouteActionTargetVirtualService[];
}
export interface GetGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    virtualServiceName: string;
}
export interface GetGatewayRouteSpecGrpcRouteMatch {
    port: number;
    serviceName: string;
}
export interface GetGatewayRouteSpecHttp2Route {
    actions: outputs.GetGatewayRouteSpecHttp2RouteAction[];
    matches: outputs.GetGatewayRouteSpecHttp2RouteMatch[];
}
export interface GetGatewayRouteSpecHttp2RouteAction {
    rewrites: outputs.GetGatewayRouteSpecHttp2RouteActionRewrite[];
    targets: outputs.GetGatewayRouteSpecHttp2RouteActionTarget[];
}
export interface GetGatewayRouteSpecHttp2RouteActionRewrite {
    hostnames: outputs.GetGatewayRouteSpecHttp2RouteActionRewriteHostname[];
    paths: outputs.GetGatewayRouteSpecHttp2RouteActionRewritePath[];
    prefixes: outputs.GetGatewayRouteSpecHttp2RouteActionRewritePrefix[];
}
export interface GetGatewayRouteSpecHttp2RouteActionRewriteHostname {
    defaultTargetHostname: string;
}
export interface GetGatewayRouteSpecHttp2RouteActionRewritePath {
    exact: string;
}
export interface GetGatewayRouteSpecHttp2RouteActionRewritePrefix {
    defaultPrefix: string;
    value: string;
}
export interface GetGatewayRouteSpecHttp2RouteActionTarget {
    port: number;
    virtualServices: outputs.GetGatewayRouteSpecHttp2RouteActionTargetVirtualService[];
}
export interface GetGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    virtualServiceName: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatch {
    headers: outputs.GetGatewayRouteSpecHttp2RouteMatchHeader[];
    hostnames: outputs.GetGatewayRouteSpecHttp2RouteMatchHostname[];
    paths: outputs.GetGatewayRouteSpecHttp2RouteMatchPath[];
    port: number;
    prefix: string;
    queryParameters: outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameter[];
}
export interface GetGatewayRouteSpecHttp2RouteMatchHeader {
    invert: boolean;
    matches: outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatch[];
    /**
     * Name of the gateway route.
     */
    name: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatch {
    exact: string;
    prefix: string;
    ranges: outputs.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange[];
    regex: string;
    suffix: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
    end: number;
    start: number;
}
export interface GetGatewayRouteSpecHttp2RouteMatchHostname {
    exact: string;
    suffix: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatchPath {
    exact: string;
    regex: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatchQueryParameter {
    matches: outputs.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch[];
    /**
     * Name of the gateway route.
     */
    name: string;
}
export interface GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
    exact: string;
}
export interface GetGatewayRouteSpecHttpRoute {
    actions: outputs.GetGatewayRouteSpecHttpRouteAction[];
    matches: outputs.GetGatewayRouteSpecHttpRouteMatch[];
}
export interface GetGatewayRouteSpecHttpRouteAction {
    rewrites: outputs.GetGatewayRouteSpecHttpRouteActionRewrite[];
    targets: outputs.GetGatewayRouteSpecHttpRouteActionTarget[];
}
export interface GetGatewayRouteSpecHttpRouteActionRewrite {
    hostnames: outputs.GetGatewayRouteSpecHttpRouteActionRewriteHostname[];
    paths: outputs.GetGatewayRouteSpecHttpRouteActionRewritePath[];
    prefixes: outputs.GetGatewayRouteSpecHttpRouteActionRewritePrefix[];
}
export interface GetGatewayRouteSpecHttpRouteActionRewriteHostname {
    defaultTargetHostname: string;
}
export interface GetGatewayRouteSpecHttpRouteActionRewritePath {
    exact: string;
}
export interface GetGatewayRouteSpecHttpRouteActionRewritePrefix {
    defaultPrefix: string;
    value: string;
}
export interface GetGatewayRouteSpecHttpRouteActionTarget {
    port: number;
    virtualServices: outputs.GetGatewayRouteSpecHttpRouteActionTargetVirtualService[];
}
export interface GetGatewayRouteSpecHttpRouteActionTargetVirtualService {
    virtualServiceName: string;
}
export interface GetGatewayRouteSpecHttpRouteMatch {
    headers: outputs.GetGatewayRouteSpecHttpRouteMatchHeader[];
    hostnames: outputs.GetGatewayRouteSpecHttpRouteMatchHostname[];
    paths: outputs.GetGatewayRouteSpecHttpRouteMatchPath[];
    port: number;
    prefix: string;
    queryParameters: outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameter[];
}
export interface GetGatewayRouteSpecHttpRouteMatchHeader {
    invert: boolean;
    matches: outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatch[];
    /**
     * Name of the gateway route.
     */
    name: string;
}
export interface GetGatewayRouteSpecHttpRouteMatchHeaderMatch {
    exact: string;
    prefix: string;
    ranges: outputs.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange[];
    regex: string;
    suffix: string;
}
export interface GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange {
    end: number;
    start: number;
}
export interface GetGatewayRouteSpecHttpRouteMatchHostname {
    exact: string;
    suffix: string;
}
export interface GetGatewayRouteSpecHttpRouteMatchPath {
    exact: string;
    regex: string;
}
export interface GetGatewayRouteSpecHttpRouteMatchQueryParameter {
    matches: outputs.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch[];
    /**
     * Name of the gateway route.
     */
    name: string;
}
export interface GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch {
    exact: string;
}
export interface GetMeshSpec {
    egressFilters: outputs.GetMeshSpecEgressFilter[];
    serviceDiscoveries: outputs.GetMeshSpecServiceDiscovery[];
}
export interface GetMeshSpecEgressFilter {
    type: string;
}
export interface GetMeshSpecServiceDiscovery {
    ipPreference: string;
}
export interface GetRouteSpec {
    grpcRoutes: outputs.GetRouteSpecGrpcRoute[];
    http2Routes: outputs.GetRouteSpecHttp2Route[];
    httpRoutes: outputs.GetRouteSpecHttpRoute[];
    priority: number;
    tcpRoutes: outputs.GetRouteSpecTcpRoute[];
}
export interface GetRouteSpecGrpcRoute {
    actions: outputs.GetRouteSpecGrpcRouteAction[];
    matches: outputs.GetRouteSpecGrpcRouteMatch[];
    retryPolicies: outputs.GetRouteSpecGrpcRouteRetryPolicy[];
    timeouts: outputs.GetRouteSpecGrpcRouteTimeout[];
}
export interface GetRouteSpecGrpcRouteAction {
    weightedTargets: outputs.GetRouteSpecGrpcRouteActionWeightedTarget[];
}
export interface GetRouteSpecGrpcRouteActionWeightedTarget {
    port: number;
    virtualNode: string;
    weight: number;
}
export interface GetRouteSpecGrpcRouteMatch {
    metadatas: outputs.GetRouteSpecGrpcRouteMatchMetadata[];
    methodName: string;
    port: number;
    prefix: string;
    serviceName: string;
}
export interface GetRouteSpecGrpcRouteMatchMetadata {
    invert: boolean;
    matches: outputs.GetRouteSpecGrpcRouteMatchMetadataMatch[];
    /**
     * Name of the route.
     */
    name: string;
}
export interface GetRouteSpecGrpcRouteMatchMetadataMatch {
    exact: string;
    prefix: string;
    ranges: outputs.GetRouteSpecGrpcRouteMatchMetadataMatchRange[];
    regex: string;
    suffix: string;
}
export interface GetRouteSpecGrpcRouteMatchMetadataMatchRange {
    end: number;
    start: number;
}
export interface GetRouteSpecGrpcRouteRetryPolicy {
    grpcRetryEvents: string[];
    httpRetryEvents: string[];
    maxRetries: number;
    perRetryTimeouts: outputs.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout[];
    tcpRetryEvents: string[];
}
export interface GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    unit: string;
    value: number;
}
export interface GetRouteSpecGrpcRouteTimeout {
    idles: outputs.GetRouteSpecGrpcRouteTimeoutIdle[];
    perRequests: outputs.GetRouteSpecGrpcRouteTimeoutPerRequest[];
}
export interface GetRouteSpecGrpcRouteTimeoutIdle {
    unit: string;
    value: number;
}
export interface GetRouteSpecGrpcRouteTimeoutPerRequest {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttp2Route {
    actions: outputs.GetRouteSpecHttp2RouteAction[];
    matches: outputs.GetRouteSpecHttp2RouteMatch[];
    retryPolicies: outputs.GetRouteSpecHttp2RouteRetryPolicy[];
    timeouts: outputs.GetRouteSpecHttp2RouteTimeout[];
}
export interface GetRouteSpecHttp2RouteAction {
    weightedTargets: outputs.GetRouteSpecHttp2RouteActionWeightedTarget[];
}
export interface GetRouteSpecHttp2RouteActionWeightedTarget {
    port: number;
    virtualNode: string;
    weight: number;
}
export interface GetRouteSpecHttp2RouteMatch {
    headers: outputs.GetRouteSpecHttp2RouteMatchHeader[];
    method: string;
    paths: outputs.GetRouteSpecHttp2RouteMatchPath[];
    port: number;
    prefix: string;
    queryParameters: outputs.GetRouteSpecHttp2RouteMatchQueryParameter[];
    scheme: string;
}
export interface GetRouteSpecHttp2RouteMatchHeader {
    invert: boolean;
    matches: outputs.GetRouteSpecHttp2RouteMatchHeaderMatch[];
    /**
     * Name of the route.
     */
    name: string;
}
export interface GetRouteSpecHttp2RouteMatchHeaderMatch {
    exact: string;
    prefix: string;
    ranges: outputs.GetRouteSpecHttp2RouteMatchHeaderMatchRange[];
    regex: string;
    suffix: string;
}
export interface GetRouteSpecHttp2RouteMatchHeaderMatchRange {
    end: number;
    start: number;
}
export interface GetRouteSpecHttp2RouteMatchPath {
    exact: string;
    regex: string;
}
export interface GetRouteSpecHttp2RouteMatchQueryParameter {
    matches: outputs.GetRouteSpecHttp2RouteMatchQueryParameterMatch[];
    /**
     * Name of the route.
     */
    name: string;
}
export interface GetRouteSpecHttp2RouteMatchQueryParameterMatch {
    exact: string;
}
export interface GetRouteSpecHttp2RouteRetryPolicy {
    httpRetryEvents: string[];
    maxRetries: number;
    perRetryTimeouts: outputs.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout[];
    tcpRetryEvents: string[];
}
export interface GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttp2RouteTimeout {
    idles: outputs.GetRouteSpecHttp2RouteTimeoutIdle[];
    perRequests: outputs.GetRouteSpecHttp2RouteTimeoutPerRequest[];
}
export interface GetRouteSpecHttp2RouteTimeoutIdle {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttp2RouteTimeoutPerRequest {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttpRoute {
    actions: outputs.GetRouteSpecHttpRouteAction[];
    matches: outputs.GetRouteSpecHttpRouteMatch[];
    retryPolicies: outputs.GetRouteSpecHttpRouteRetryPolicy[];
    timeouts: outputs.GetRouteSpecHttpRouteTimeout[];
}
export interface GetRouteSpecHttpRouteAction {
    weightedTargets: outputs.GetRouteSpecHttpRouteActionWeightedTarget[];
}
export interface GetRouteSpecHttpRouteActionWeightedTarget {
    port: number;
    virtualNode: string;
    weight: number;
}
export interface GetRouteSpecHttpRouteMatch {
    headers: outputs.GetRouteSpecHttpRouteMatchHeader[];
    method: string;
    paths: outputs.GetRouteSpecHttpRouteMatchPath[];
    port: number;
    prefix: string;
    queryParameters: outputs.GetRouteSpecHttpRouteMatchQueryParameter[];
    scheme: string;
}
export interface GetRouteSpecHttpRouteMatchHeader {
    invert: boolean;
    matches: outputs.GetRouteSpecHttpRouteMatchHeaderMatch[];
    /**
     * Name of the route.
     */
    name: string;
}
export interface GetRouteSpecHttpRouteMatchHeaderMatch {
    exact: string;
    prefix: string;
    ranges: outputs.GetRouteSpecHttpRouteMatchHeaderMatchRange[];
    regex: string;
    suffix: string;
}
export interface GetRouteSpecHttpRouteMatchHeaderMatchRange {
    end: number;
    start: number;
}
export interface GetRouteSpecHttpRouteMatchPath {
    exact: string;
    regex: string;
}
export interface GetRouteSpecHttpRouteMatchQueryParameter {
    matches: outputs.GetRouteSpecHttpRouteMatchQueryParameterMatch[];
    /**
     * Name of the route.
     */
    name: string;
}
export interface GetRouteSpecHttpRouteMatchQueryParameterMatch {
    exact: string;
}
export interface GetRouteSpecHttpRouteRetryPolicy {
    httpRetryEvents: string[];
    maxRetries: number;
    perRetryTimeouts: outputs.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout[];
    tcpRetryEvents: string[];
}
export interface GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttpRouteTimeout {
    idles: outputs.GetRouteSpecHttpRouteTimeoutIdle[];
    perRequests: outputs.GetRouteSpecHttpRouteTimeoutPerRequest[];
}
export interface GetRouteSpecHttpRouteTimeoutIdle {
    unit: string;
    value: number;
}
export interface GetRouteSpecHttpRouteTimeoutPerRequest {
    unit: string;
    value: number;
}
export interface GetRouteSpecTcpRoute {
    actions: outputs.GetRouteSpecTcpRouteAction[];
    matches: outputs.GetRouteSpecTcpRouteMatch[];
    timeouts: outputs.GetRouteSpecTcpRouteTimeout[];
}
export interface GetRouteSpecTcpRouteAction {
    weightedTargets: outputs.GetRouteSpecTcpRouteActionWeightedTarget[];
}
export interface GetRouteSpecTcpRouteActionWeightedTarget {
    port: number;
    virtualNode: string;
    weight: number;
}
export interface GetRouteSpecTcpRouteMatch {
    port: number;
}
export interface GetRouteSpecTcpRouteTimeout {
    idles: outputs.GetRouteSpecTcpRouteTimeoutIdle[];
}
export interface GetRouteSpecTcpRouteTimeoutIdle {
    unit: string;
    value: number;
}
export interface GetVirtualGatewaySpec {
    backendDefaults: outputs.GetVirtualGatewaySpecBackendDefault[];
    listeners: outputs.GetVirtualGatewaySpecListener[];
    loggings: outputs.GetVirtualGatewaySpecLogging[];
}
export interface GetVirtualGatewaySpecBackendDefault {
    clientPolicies: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicy[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicy {
    tls: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTl[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTl {
    certificates: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate[];
    enforce: boolean;
    ports: number[];
    validations: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate {
    files: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile[];
    sds: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile {
    certificateChain: string;
    privateKey: string;
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd {
    secretName: string;
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation {
    subjectAlternativeNames: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
    trusts: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
    matches: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
    exacts: string[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust {
    acms: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm[];
    files: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile[];
    sds: outputs.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm {
    certificateAuthorityArns: string[];
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile {
    certificateChain: string;
}
export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd {
    secretName: string;
}
export interface GetVirtualGatewaySpecListener {
    connectionPools: outputs.GetVirtualGatewaySpecListenerConnectionPool[];
    healthChecks: outputs.GetVirtualGatewaySpecListenerHealthCheck[];
    portMappings: outputs.GetVirtualGatewaySpecListenerPortMapping[];
    tls: outputs.GetVirtualGatewaySpecListenerTl[];
}
export interface GetVirtualGatewaySpecListenerConnectionPool {
    grpcs: outputs.GetVirtualGatewaySpecListenerConnectionPoolGrpc[];
    http2s: outputs.GetVirtualGatewaySpecListenerConnectionPoolHttp2[];
    https: outputs.GetVirtualGatewaySpecListenerConnectionPoolHttp[];
}
export interface GetVirtualGatewaySpecListenerConnectionPoolGrpc {
    maxRequests: number;
}
export interface GetVirtualGatewaySpecListenerConnectionPoolHttp2 {
    maxRequests: number;
}
export interface GetVirtualGatewaySpecListenerConnectionPoolHttp {
    maxConnections: number;
    maxPendingRequests: number;
}
export interface GetVirtualGatewaySpecListenerHealthCheck {
    healthyThreshold: number;
    intervalMillis: number;
    path: string;
    port: number;
    protocol: string;
    timeoutMillis: number;
    unhealthyThreshold: number;
}
export interface GetVirtualGatewaySpecListenerPortMapping {
    port: number;
    protocol: string;
}
export interface GetVirtualGatewaySpecListenerTl {
    certificates: outputs.GetVirtualGatewaySpecListenerTlCertificate[];
    mode: string;
    validations: outputs.GetVirtualGatewaySpecListenerTlValidation[];
}
export interface GetVirtualGatewaySpecListenerTlCertificate {
    acms: outputs.GetVirtualGatewaySpecListenerTlCertificateAcm[];
    files: outputs.GetVirtualGatewaySpecListenerTlCertificateFile[];
    sds: outputs.GetVirtualGatewaySpecListenerTlCertificateSd[];
}
export interface GetVirtualGatewaySpecListenerTlCertificateAcm {
    certificateArn: string;
}
export interface GetVirtualGatewaySpecListenerTlCertificateFile {
    certificateChain: string;
    privateKey: string;
}
export interface GetVirtualGatewaySpecListenerTlCertificateSd {
    secretName: string;
}
export interface GetVirtualGatewaySpecListenerTlValidation {
    subjectAlternativeNames: outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName[];
    trusts: outputs.GetVirtualGatewaySpecListenerTlValidationTrust[];
}
export interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName {
    matches: outputs.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch[];
}
export interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch {
    exacts: string[];
}
export interface GetVirtualGatewaySpecListenerTlValidationTrust {
    files: outputs.GetVirtualGatewaySpecListenerTlValidationTrustFile[];
    sds: outputs.GetVirtualGatewaySpecListenerTlValidationTrustSd[];
}
export interface GetVirtualGatewaySpecListenerTlValidationTrustFile {
    certificateChain: string;
}
export interface GetVirtualGatewaySpecListenerTlValidationTrustSd {
    secretName: string;
}
export interface GetVirtualGatewaySpecLogging {
    accessLogs: outputs.GetVirtualGatewaySpecLoggingAccessLog[];
}
export interface GetVirtualGatewaySpecLoggingAccessLog {
    files: outputs.GetVirtualGatewaySpecLoggingAccessLogFile[];
}
export interface GetVirtualGatewaySpecLoggingAccessLogFile {
    formats: outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormat[];
    path: string;
}
export interface GetVirtualGatewaySpecLoggingAccessLogFileFormat {
    jsons: outputs.GetVirtualGatewaySpecLoggingAccessLogFileFormatJson[];
    text: string;
}
export interface GetVirtualGatewaySpecLoggingAccessLogFileFormatJson {
    key: string;
    value: string;
}
export interface GetVirtualNodeSpec {
    backendDefaults: outputs.GetVirtualNodeSpecBackendDefault[];
    backends: outputs.GetVirtualNodeSpecBackend[];
    listeners: outputs.GetVirtualNodeSpecListener[];
    loggings: outputs.GetVirtualNodeSpecLogging[];
    serviceDiscoveries: outputs.GetVirtualNodeSpecServiceDiscovery[];
}
export interface GetVirtualNodeSpecBackend {
    virtualServices: outputs.GetVirtualNodeSpecBackendVirtualService[];
}
export interface GetVirtualNodeSpecBackendDefault {
    clientPolicies: outputs.GetVirtualNodeSpecBackendDefaultClientPolicy[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicy {
    tls: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTl[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTl {
    certificates: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate[];
    enforce: boolean;
    ports: number[];
    validations: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate {
    files: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile[];
    sds: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile {
    certificateChain: string;
    privateKey: string;
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd {
    secretName: string;
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation {
    subjectAlternativeNames: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
    trusts: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
    matches: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
    exacts: string[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust {
    acms: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm[];
    files: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile[];
    sds: outputs.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm {
    certificateAuthorityArns: string[];
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile {
    certificateChain: string;
}
export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd {
    secretName: string;
}
export interface GetVirtualNodeSpecBackendVirtualService {
    clientPolicies: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicy[];
    virtualServiceName: string;
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicy {
    tls: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl {
    certificates: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate[];
    enforce: boolean;
    ports: number[];
    validations: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate {
    files: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile[];
    sds: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile {
    certificateChain: string;
    privateKey: string;
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd {
    secretName: string;
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation {
    subjectAlternativeNames: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName[];
    trusts: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName {
    matches: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch {
    exacts: string[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust {
    acms: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm[];
    files: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile[];
    sds: outputs.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm {
    certificateAuthorityArns: string[];
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile {
    certificateChain: string;
}
export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd {
    secretName: string;
}
export interface GetVirtualNodeSpecListener {
    connectionPools: outputs.GetVirtualNodeSpecListenerConnectionPool[];
    healthChecks: outputs.GetVirtualNodeSpecListenerHealthCheck[];
    outlierDetections: outputs.GetVirtualNodeSpecListenerOutlierDetection[];
    portMappings: outputs.GetVirtualNodeSpecListenerPortMapping[];
    timeouts: outputs.GetVirtualNodeSpecListenerTimeout[];
    tls: outputs.GetVirtualNodeSpecListenerTl[];
}
export interface GetVirtualNodeSpecListenerConnectionPool {
    grpcs: outputs.GetVirtualNodeSpecListenerConnectionPoolGrpc[];
    http2s: outputs.GetVirtualNodeSpecListenerConnectionPoolHttp2[];
    https: outputs.GetVirtualNodeSpecListenerConnectionPoolHttp[];
    tcps: outputs.GetVirtualNodeSpecListenerConnectionPoolTcp[];
}
export interface GetVirtualNodeSpecListenerConnectionPoolGrpc {
    maxRequests: number;
}
export interface GetVirtualNodeSpecListenerConnectionPoolHttp2 {
    maxRequests: number;
}
export interface GetVirtualNodeSpecListenerConnectionPoolHttp {
    maxConnections: number;
    maxPendingRequests: number;
}
export interface GetVirtualNodeSpecListenerConnectionPoolTcp {
    maxConnections: number;
}
export interface GetVirtualNodeSpecListenerHealthCheck {
    healthyThreshold: number;
    intervalMillis: number;
    path: string;
    port: number;
    protocol: string;
    timeoutMillis: number;
    unhealthyThreshold: number;
}
export interface GetVirtualNodeSpecListenerOutlierDetection {
    baseEjectionDurations: outputs.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration[];
    intervals: outputs.GetVirtualNodeSpecListenerOutlierDetectionInterval[];
    maxEjectionPercent: number;
    maxServerErrors: number;
}
export interface GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerOutlierDetectionInterval {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerPortMapping {
    port: number;
    protocol: string;
}
export interface GetVirtualNodeSpecListenerTimeout {
    grpcs: outputs.GetVirtualNodeSpecListenerTimeoutGrpc[];
    http2s: outputs.GetVirtualNodeSpecListenerTimeoutHttp2[];
    https: outputs.GetVirtualNodeSpecListenerTimeoutHttp[];
    tcps: outputs.GetVirtualNodeSpecListenerTimeoutTcp[];
}
export interface GetVirtualNodeSpecListenerTimeoutGrpc {
    idles: outputs.GetVirtualNodeSpecListenerTimeoutGrpcIdle[];
    perRequests: outputs.GetVirtualNodeSpecListenerTimeoutGrpcPerRequest[];
}
export interface GetVirtualNodeSpecListenerTimeoutGrpcIdle {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutGrpcPerRequest {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutHttp2 {
    idles: outputs.GetVirtualNodeSpecListenerTimeoutHttp2Idle[];
    perRequests: outputs.GetVirtualNodeSpecListenerTimeoutHttp2PerRequest[];
}
export interface GetVirtualNodeSpecListenerTimeoutHttp2Idle {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutHttp2PerRequest {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutHttp {
    idles: outputs.GetVirtualNodeSpecListenerTimeoutHttpIdle[];
    perRequests: outputs.GetVirtualNodeSpecListenerTimeoutHttpPerRequest[];
}
export interface GetVirtualNodeSpecListenerTimeoutHttpIdle {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutHttpPerRequest {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTimeoutTcp {
    idles: outputs.GetVirtualNodeSpecListenerTimeoutTcpIdle[];
}
export interface GetVirtualNodeSpecListenerTimeoutTcpIdle {
    unit: string;
    value: number;
}
export interface GetVirtualNodeSpecListenerTl {
    certificates: outputs.GetVirtualNodeSpecListenerTlCertificate[];
    mode: string;
    validations: outputs.GetVirtualNodeSpecListenerTlValidation[];
}
export interface GetVirtualNodeSpecListenerTlCertificate {
    acms: outputs.GetVirtualNodeSpecListenerTlCertificateAcm[];
    files: outputs.GetVirtualNodeSpecListenerTlCertificateFile[];
    sds: outputs.GetVirtualNodeSpecListenerTlCertificateSd[];
}
export interface GetVirtualNodeSpecListenerTlCertificateAcm {
    certificateArn: string;
}
export interface GetVirtualNodeSpecListenerTlCertificateFile {
    certificateChain: string;
    privateKey: string;
}
export interface GetVirtualNodeSpecListenerTlCertificateSd {
    secretName: string;
}
export interface GetVirtualNodeSpecListenerTlValidation {
    subjectAlternativeNames: outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName[];
    trusts: outputs.GetVirtualNodeSpecListenerTlValidationTrust[];
}
export interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName {
    matches: outputs.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch[];
}
export interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch {
    exacts: string[];
}
export interface GetVirtualNodeSpecListenerTlValidationTrust {
    files: outputs.GetVirtualNodeSpecListenerTlValidationTrustFile[];
    sds: outputs.GetVirtualNodeSpecListenerTlValidationTrustSd[];
}
export interface GetVirtualNodeSpecListenerTlValidationTrustFile {
    certificateChain: string;
}
export interface GetVirtualNodeSpecListenerTlValidationTrustSd {
    secretName: string;
}
export interface GetVirtualNodeSpecLogging {
    accessLogs: outputs.GetVirtualNodeSpecLoggingAccessLog[];
}
export interface GetVirtualNodeSpecLoggingAccessLog {
    files: outputs.GetVirtualNodeSpecLoggingAccessLogFile[];
}
export interface GetVirtualNodeSpecLoggingAccessLogFile {
    formats: outputs.GetVirtualNodeSpecLoggingAccessLogFileFormat[];
    path: string;
}
export interface GetVirtualNodeSpecLoggingAccessLogFileFormat {
    jsons: outputs.GetVirtualNodeSpecLoggingAccessLogFileFormatJson[];
    text: string;
}
export interface GetVirtualNodeSpecLoggingAccessLogFileFormatJson {
    key: string;
    value: string;
}
export interface GetVirtualNodeSpecServiceDiscovery {
    awsCloudMaps: outputs.GetVirtualNodeSpecServiceDiscoveryAwsCloudMap[];
    dns: outputs.GetVirtualNodeSpecServiceDiscoveryDn[];
}
export interface GetVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    attributes: {[key: string]: string};
    namespaceName: string;
    serviceName: string;
}
export interface GetVirtualNodeSpecServiceDiscoveryDn {
    hostname: string;
    ipPreference: string;
    responseType: string;
}
export interface GetVirtualRouterSpec {
    listeners: outputs.GetVirtualRouterSpecListener[];
}
export interface GetVirtualRouterSpecListener {
    portMappings: outputs.GetVirtualRouterSpecListenerPortMapping[];
}
export interface GetVirtualRouterSpecListenerPortMapping {
    port: number;
    protocol: string;
}
export interface GetVirtualServiceSpec {
    providers: outputs.GetVirtualServiceSpecProvider[];
}
export interface GetVirtualServiceSpecProvider {
    virtualNodes: outputs.GetVirtualServiceSpecProviderVirtualNode[];
    virtualRouters: outputs.GetVirtualServiceSpecProviderVirtualRouter[];
}
export interface GetVirtualServiceSpecProviderVirtualNode {
    virtualNodeName: string;
}
export interface GetVirtualServiceSpecProviderVirtualRouter {
    virtualRouterName: string;
}
