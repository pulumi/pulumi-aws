// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";
import * as utilities from "../utilities";

export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'aws:emr/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    declare public readonly additionalInfo: pulumi.Output<string | undefined>;
    declare public readonly applications: pulumi.Output<string[] | undefined>;
    declare public /*out*/ readonly arn: pulumi.Output<string>;
    declare public readonly autoTerminationPolicy: pulumi.Output<outputs.emr.ClusterAutoTerminationPolicy | undefined>;
    declare public readonly autoscalingRole: pulumi.Output<string | undefined>;
    declare public readonly bootstrapActions: pulumi.Output<outputs.emr.ClusterBootstrapAction[] | undefined>;
    declare public /*out*/ readonly clusterState: pulumi.Output<string>;
    declare public readonly configurations: pulumi.Output<string | undefined>;
    declare public readonly configurationsJson: pulumi.Output<string | undefined>;
    declare public readonly coreInstanceFleet: pulumi.Output<outputs.emr.ClusterCoreInstanceFleet>;
    declare public readonly coreInstanceGroup: pulumi.Output<outputs.emr.ClusterCoreInstanceGroup>;
    declare public readonly customAmiId: pulumi.Output<string | undefined>;
    declare public readonly ebsRootVolumeSize: pulumi.Output<number | undefined>;
    declare public readonly ec2Attributes: pulumi.Output<outputs.emr.ClusterEc2Attributes | undefined>;
    declare public readonly keepJobFlowAliveWhenNoSteps: pulumi.Output<boolean>;
    declare public readonly kerberosAttributes: pulumi.Output<outputs.emr.ClusterKerberosAttributes | undefined>;
    declare public readonly listStepsStates: pulumi.Output<string[] | undefined>;
    declare public readonly logEncryptionKmsKeyId: pulumi.Output<string | undefined>;
    declare public readonly logUri: pulumi.Output<string | undefined>;
    declare public readonly masterInstanceFleet: pulumi.Output<outputs.emr.ClusterMasterInstanceFleet>;
    declare public readonly masterInstanceGroup: pulumi.Output<outputs.emr.ClusterMasterInstanceGroup>;
    declare public /*out*/ readonly masterPublicDns: pulumi.Output<string>;
    declare public readonly name: pulumi.Output<string>;
    declare public readonly osReleaseLabel: pulumi.Output<string | undefined>;
    declare public readonly placementGroupConfigs: pulumi.Output<outputs.emr.ClusterPlacementGroupConfig[] | undefined>;
    declare public readonly region: pulumi.Output<string>;
    declare public readonly releaseLabel: pulumi.Output<string>;
    declare public readonly scaleDownBehavior: pulumi.Output<string>;
    declare public readonly securityConfiguration: pulumi.Output<string | undefined>;
    declare public readonly serviceRole: pulumi.Output<string>;
    declare public readonly stepConcurrencyLevel: pulumi.Output<number | undefined>;
    declare public readonly steps: pulumi.Output<outputs.emr.ClusterStep[]>;
    declare public readonly tags: pulumi.Output<{[key: string]: string} | undefined>;
    declare public /*out*/ readonly tagsAll: pulumi.Output<{[key: string]: string}>;
    declare public readonly terminationProtection: pulumi.Output<boolean>;
    declare public readonly unhealthyNodeReplacement: pulumi.Output<boolean | undefined>;
    declare public readonly visibleToAllUsers: pulumi.Output<boolean | undefined>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["additionalInfo"] = state?.additionalInfo;
            resourceInputs["applications"] = state?.applications;
            resourceInputs["arn"] = state?.arn;
            resourceInputs["autoTerminationPolicy"] = state?.autoTerminationPolicy;
            resourceInputs["autoscalingRole"] = state?.autoscalingRole;
            resourceInputs["bootstrapActions"] = state?.bootstrapActions;
            resourceInputs["clusterState"] = state?.clusterState;
            resourceInputs["configurations"] = state?.configurations;
            resourceInputs["configurationsJson"] = state?.configurationsJson;
            resourceInputs["coreInstanceFleet"] = state?.coreInstanceFleet;
            resourceInputs["coreInstanceGroup"] = state?.coreInstanceGroup;
            resourceInputs["customAmiId"] = state?.customAmiId;
            resourceInputs["ebsRootVolumeSize"] = state?.ebsRootVolumeSize;
            resourceInputs["ec2Attributes"] = state?.ec2Attributes;
            resourceInputs["keepJobFlowAliveWhenNoSteps"] = state?.keepJobFlowAliveWhenNoSteps;
            resourceInputs["kerberosAttributes"] = state?.kerberosAttributes;
            resourceInputs["listStepsStates"] = state?.listStepsStates;
            resourceInputs["logEncryptionKmsKeyId"] = state?.logEncryptionKmsKeyId;
            resourceInputs["logUri"] = state?.logUri;
            resourceInputs["masterInstanceFleet"] = state?.masterInstanceFleet;
            resourceInputs["masterInstanceGroup"] = state?.masterInstanceGroup;
            resourceInputs["masterPublicDns"] = state?.masterPublicDns;
            resourceInputs["name"] = state?.name;
            resourceInputs["osReleaseLabel"] = state?.osReleaseLabel;
            resourceInputs["placementGroupConfigs"] = state?.placementGroupConfigs;
            resourceInputs["region"] = state?.region;
            resourceInputs["releaseLabel"] = state?.releaseLabel;
            resourceInputs["scaleDownBehavior"] = state?.scaleDownBehavior;
            resourceInputs["securityConfiguration"] = state?.securityConfiguration;
            resourceInputs["serviceRole"] = state?.serviceRole;
            resourceInputs["stepConcurrencyLevel"] = state?.stepConcurrencyLevel;
            resourceInputs["steps"] = state?.steps;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tagsAll"] = state?.tagsAll;
            resourceInputs["terminationProtection"] = state?.terminationProtection;
            resourceInputs["unhealthyNodeReplacement"] = state?.unhealthyNodeReplacement;
            resourceInputs["visibleToAllUsers"] = state?.visibleToAllUsers;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if (args?.releaseLabel === undefined && !opts.urn) {
                throw new Error("Missing required property 'releaseLabel'");
            }
            if (args?.serviceRole === undefined && !opts.urn) {
                throw new Error("Missing required property 'serviceRole'");
            }
            resourceInputs["additionalInfo"] = args?.additionalInfo;
            resourceInputs["applications"] = args?.applications;
            resourceInputs["autoTerminationPolicy"] = args?.autoTerminationPolicy;
            resourceInputs["autoscalingRole"] = args?.autoscalingRole;
            resourceInputs["bootstrapActions"] = args?.bootstrapActions;
            resourceInputs["configurations"] = args?.configurations;
            resourceInputs["configurationsJson"] = args?.configurationsJson;
            resourceInputs["coreInstanceFleet"] = args?.coreInstanceFleet;
            resourceInputs["coreInstanceGroup"] = args?.coreInstanceGroup;
            resourceInputs["customAmiId"] = args?.customAmiId;
            resourceInputs["ebsRootVolumeSize"] = args?.ebsRootVolumeSize;
            resourceInputs["ec2Attributes"] = args?.ec2Attributes;
            resourceInputs["keepJobFlowAliveWhenNoSteps"] = args?.keepJobFlowAliveWhenNoSteps;
            resourceInputs["kerberosAttributes"] = args?.kerberosAttributes;
            resourceInputs["listStepsStates"] = args?.listStepsStates;
            resourceInputs["logEncryptionKmsKeyId"] = args?.logEncryptionKmsKeyId;
            resourceInputs["logUri"] = args?.logUri;
            resourceInputs["masterInstanceFleet"] = args?.masterInstanceFleet;
            resourceInputs["masterInstanceGroup"] = args?.masterInstanceGroup;
            resourceInputs["name"] = args?.name;
            resourceInputs["osReleaseLabel"] = args?.osReleaseLabel;
            resourceInputs["placementGroupConfigs"] = args?.placementGroupConfigs;
            resourceInputs["region"] = args?.region;
            resourceInputs["releaseLabel"] = args?.releaseLabel;
            resourceInputs["scaleDownBehavior"] = args?.scaleDownBehavior;
            resourceInputs["securityConfiguration"] = args?.securityConfiguration;
            resourceInputs["serviceRole"] = args?.serviceRole;
            resourceInputs["stepConcurrencyLevel"] = args?.stepConcurrencyLevel;
            resourceInputs["steps"] = args?.steps;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["terminationProtection"] = args?.terminationProtection;
            resourceInputs["unhealthyNodeReplacement"] = args?.unhealthyNodeReplacement;
            resourceInputs["visibleToAllUsers"] = args?.visibleToAllUsers;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["clusterState"] = undefined /*out*/;
            resourceInputs["masterPublicDns"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    additionalInfo?: pulumi.Input<string>;
    applications?: pulumi.Input<pulumi.Input<string>[]>;
    arn?: pulumi.Input<string>;
    autoTerminationPolicy?: pulumi.Input<inputs.emr.ClusterAutoTerminationPolicy>;
    autoscalingRole?: pulumi.Input<string>;
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    clusterState?: pulumi.Input<string>;
    configurations?: pulumi.Input<string>;
    configurationsJson?: pulumi.Input<string>;
    coreInstanceFleet?: pulumi.Input<inputs.emr.ClusterCoreInstanceFleet>;
    coreInstanceGroup?: pulumi.Input<inputs.emr.ClusterCoreInstanceGroup>;
    customAmiId?: pulumi.Input<string>;
    ebsRootVolumeSize?: pulumi.Input<number>;
    ec2Attributes?: pulumi.Input<inputs.emr.ClusterEc2Attributes>;
    keepJobFlowAliveWhenNoSteps?: pulumi.Input<boolean>;
    kerberosAttributes?: pulumi.Input<inputs.emr.ClusterKerberosAttributes>;
    listStepsStates?: pulumi.Input<pulumi.Input<string>[]>;
    logEncryptionKmsKeyId?: pulumi.Input<string>;
    logUri?: pulumi.Input<string>;
    masterInstanceFleet?: pulumi.Input<inputs.emr.ClusterMasterInstanceFleet>;
    masterInstanceGroup?: pulumi.Input<inputs.emr.ClusterMasterInstanceGroup>;
    masterPublicDns?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    osReleaseLabel?: pulumi.Input<string>;
    placementGroupConfigs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterPlacementGroupConfig>[]>;
    region?: pulumi.Input<string>;
    releaseLabel?: pulumi.Input<string>;
    scaleDownBehavior?: pulumi.Input<string>;
    securityConfiguration?: pulumi.Input<string>;
    serviceRole?: pulumi.Input<string>;
    stepConcurrencyLevel?: pulumi.Input<number>;
    steps?: pulumi.Input<pulumi.Input<inputs.emr.ClusterStep>[]>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    tagsAll?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    terminationProtection?: pulumi.Input<boolean>;
    unhealthyNodeReplacement?: pulumi.Input<boolean>;
    visibleToAllUsers?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    additionalInfo?: pulumi.Input<string>;
    applications?: pulumi.Input<pulumi.Input<string>[]>;
    autoTerminationPolicy?: pulumi.Input<inputs.emr.ClusterAutoTerminationPolicy>;
    autoscalingRole?: pulumi.Input<string>;
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    configurations?: pulumi.Input<string>;
    configurationsJson?: pulumi.Input<string>;
    coreInstanceFleet?: pulumi.Input<inputs.emr.ClusterCoreInstanceFleet>;
    coreInstanceGroup?: pulumi.Input<inputs.emr.ClusterCoreInstanceGroup>;
    customAmiId?: pulumi.Input<string>;
    ebsRootVolumeSize?: pulumi.Input<number>;
    ec2Attributes?: pulumi.Input<inputs.emr.ClusterEc2Attributes>;
    keepJobFlowAliveWhenNoSteps?: pulumi.Input<boolean>;
    kerberosAttributes?: pulumi.Input<inputs.emr.ClusterKerberosAttributes>;
    listStepsStates?: pulumi.Input<pulumi.Input<string>[]>;
    logEncryptionKmsKeyId?: pulumi.Input<string>;
    logUri?: pulumi.Input<string>;
    masterInstanceFleet?: pulumi.Input<inputs.emr.ClusterMasterInstanceFleet>;
    masterInstanceGroup?: pulumi.Input<inputs.emr.ClusterMasterInstanceGroup>;
    name?: pulumi.Input<string>;
    osReleaseLabel?: pulumi.Input<string>;
    placementGroupConfigs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterPlacementGroupConfig>[]>;
    region?: pulumi.Input<string>;
    releaseLabel: pulumi.Input<string>;
    scaleDownBehavior?: pulumi.Input<string>;
    securityConfiguration?: pulumi.Input<string>;
    serviceRole: pulumi.Input<string>;
    stepConcurrencyLevel?: pulumi.Input<number>;
    steps?: pulumi.Input<pulumi.Input<inputs.emr.ClusterStep>[]>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    terminationProtection?: pulumi.Input<boolean>;
    unhealthyNodeReplacement?: pulumi.Input<boolean>;
    visibleToAllUsers?: pulumi.Input<boolean>;
}
