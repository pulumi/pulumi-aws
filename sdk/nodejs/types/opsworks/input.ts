// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../types/input";
import * as outputs from "../../types/output";
import * as enums from "../../types/enums";
import * as utilities from "../../utilities";

import {RoutingRule} from "@/s3";

export interface ApplicationAppSource {
    /**
     * Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    password?: pulumi.Input<string>;
    /**
     * For sources that are version-aware, the revision to use.
     */
    revision?: pulumi.Input<string>;
    /**
     * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    sshKey?: pulumi.Input<string>;
    /**
     * The type of source to use. For example, "archive".
     */
    type: pulumi.Input<string>;
    /**
     * The URL where the app resource can be found.
     */
    url?: pulumi.Input<string>;
    /**
     * Username to use when authenticating to the source.
     */
    username?: pulumi.Input<string>;
}

export interface ApplicationEnvironment {
    /**
     * Variable name.
     */
    key: pulumi.Input<string>;
    /**
     * Set visibility of the variable value to `true` or `false`.
     */
    secure?: pulumi.Input<boolean>;
    /**
     * Variable value.
     */
    value: pulumi.Input<string>;
}

export interface ApplicationSslConfiguration {
    /**
     * The contents of the certificate's domain.crt file.
     */
    certificate: pulumi.Input<string>;
    /**
     * Can be used to specify an intermediate certificate authority key or client authentication.
     */
    chain?: pulumi.Input<string>;
    /**
     * The private key; the contents of the certificate's domain.key file.
     */
    privateKey: pulumi.Input<string>;
}

export interface CustomLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    /**
     * A block the specifies how an opsworks logs look like. See Log Streams.
     */
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.CustomLayerCloudwatchConfigurationLogStream>[]>;
}

export interface CustomLayerCloudwatchConfigurationLogStream {
    /**
     * Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
     */
    batchCount?: pulumi.Input<number>;
    /**
     * Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
     */
    batchSize?: pulumi.Input<number>;
    /**
     * Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
     */
    bufferDuration?: pulumi.Input<number>;
    /**
     * Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
     */
    datetimeFormat?: pulumi.Input<string>;
    /**
     * Specifies the encoding of the log file so that the file can be read correctly. The default is `utf8`.
     */
    encoding?: pulumi.Input<string>;
    /**
     * Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
     */
    file: pulumi.Input<string>;
    /**
     * Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
     */
    fileFingerprintLines?: pulumi.Input<string>;
    /**
     * Specifies where to start to read data (`startOfFile` or `endOfFile`). The default is `startOfFile`.
     */
    initialPosition?: pulumi.Input<string>;
    /**
     * Specifies the destination log group. A log group is created automatically if it doesn't already exist.
     */
    logGroupName: pulumi.Input<string>;
    /**
     * Specifies the pattern for identifying the start of a log message.
     */
    multilineStartPattern?: pulumi.Input<string>;
    /**
     * Specifies the time zone of log event time stamps.
     */
    timeZone?: pulumi.Input<string>;
}

export interface CustomLayerEbsVolume {
    /**
     * Encrypt the volume.
     */
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface CustomLayerLoadBasedAutoScaling {
    /**
     * The downscaling settings, as defined below, used for load-based autoscaling
     */
    downscaling?: pulumi.Input<inputs.opsworks.CustomLayerLoadBasedAutoScalingDownscaling>;
    /**
     * Whether load-based auto scaling is enabled for the layer.
     */
    enable?: pulumi.Input<boolean>;
    /**
     * The upscaling settings, as defined below, used for load-based autoscaling
     */
    upscaling?: pulumi.Input<inputs.opsworks.CustomLayerLoadBasedAutoScalingUpscaling>;
}

export interface CustomLayerLoadBasedAutoScalingDownscaling {
    /**
     * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
     */
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
     */
    cpuThreshold?: pulumi.Input<number>;
    /**
     * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
     */
    ignoreMetricsTime?: pulumi.Input<number>;
    /**
     * The number of instances to add or remove when the load exceeds a threshold.
     */
    instanceCount?: pulumi.Input<number>;
    /**
     * The load threshold. A value of -1 disables the threshold.
     */
    loadThreshold?: pulumi.Input<number>;
    /**
     * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
     */
    memoryThreshold?: pulumi.Input<number>;
    /**
     * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
     */
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface CustomLayerLoadBasedAutoScalingUpscaling {
    /**
     * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
     */
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
     */
    cpuThreshold?: pulumi.Input<number>;
    /**
     * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
     */
    ignoreMetricsTime?: pulumi.Input<number>;
    /**
     * The number of instances to add or remove when the load exceeds a threshold.
     */
    instanceCount?: pulumi.Input<number>;
    /**
     * The load threshold. A value of -1 disables the threshold.
     */
    loadThreshold?: pulumi.Input<number>;
    /**
     * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
     */
    memoryThreshold?: pulumi.Input<number>;
    /**
     * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
     */
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface EcsClusterLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.EcsClusterLayerCloudwatchConfigurationLogStream>[]>;
}

export interface EcsClusterLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface EcsClusterLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface EcsClusterLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.EcsClusterLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.EcsClusterLayerLoadBasedAutoScalingUpscaling>;
}

export interface EcsClusterLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface EcsClusterLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface GangliaLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.GangliaLayerCloudwatchConfigurationLogStream>[]>;
}

export interface GangliaLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface GangliaLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface GangliaLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.GangliaLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.GangliaLayerLoadBasedAutoScalingUpscaling>;
}

export interface GangliaLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface GangliaLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface HaproxyLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.HaproxyLayerCloudwatchConfigurationLogStream>[]>;
}

export interface HaproxyLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface HaproxyLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface HaproxyLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.HaproxyLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.HaproxyLayerLoadBasedAutoScalingUpscaling>;
}

export interface HaproxyLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface HaproxyLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface InstanceEbsBlockDevice {
    deleteOnTermination?: pulumi.Input<boolean>;
    deviceName: pulumi.Input<string>;
    iops?: pulumi.Input<number>;
    snapshotId?: pulumi.Input<string>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface InstanceEphemeralBlockDevice {
    deviceName: pulumi.Input<string>;
    virtualName: pulumi.Input<string>;
}

export interface InstanceRootBlockDevice {
    deleteOnTermination?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface JavaAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.JavaAppLayerCloudwatchConfigurationLogStream>[]>;
}

export interface JavaAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface JavaAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface JavaAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.JavaAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.JavaAppLayerLoadBasedAutoScalingUpscaling>;
}

export interface JavaAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface JavaAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface MemcachedLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.MemcachedLayerCloudwatchConfigurationLogStream>[]>;
}

export interface MemcachedLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface MemcachedLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface MemcachedLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.MemcachedLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.MemcachedLayerLoadBasedAutoScalingUpscaling>;
}

export interface MemcachedLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface MemcachedLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface MysqlLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.MysqlLayerCloudwatchConfigurationLogStream>[]>;
}

export interface MysqlLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface MysqlLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface MysqlLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.MysqlLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.MysqlLayerLoadBasedAutoScalingUpscaling>;
}

export interface MysqlLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface MysqlLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface NodejsAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.NodejsAppLayerCloudwatchConfigurationLogStream>[]>;
}

export interface NodejsAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface NodejsAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface NodejsAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.NodejsAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.NodejsAppLayerLoadBasedAutoScalingUpscaling>;
}

export interface NodejsAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface NodejsAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface PhpAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.PhpAppLayerCloudwatchConfigurationLogStream>[]>;
}

export interface PhpAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface PhpAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface PhpAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.PhpAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.PhpAppLayerLoadBasedAutoScalingUpscaling>;
}

export interface PhpAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface PhpAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface RailsAppLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.RailsAppLayerCloudwatchConfigurationLogStream>[]>;
}

export interface RailsAppLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface RailsAppLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface RailsAppLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.RailsAppLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.RailsAppLayerLoadBasedAutoScalingUpscaling>;
}

export interface RailsAppLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface RailsAppLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface StackCustomCookbooksSource {
    /**
     * Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
     */
    password?: pulumi.Input<string>;
    /**
     * For sources that are version-aware, the revision to use.
     */
    revision?: pulumi.Input<string>;
    /**
     * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
     */
    sshKey?: pulumi.Input<string>;
    /**
     * The type of source to use. For example, "archive".
     */
    type: pulumi.Input<string>;
    /**
     * The URL where the cookbooks resource can be found.
     */
    url: pulumi.Input<string>;
    /**
     * Username to use when authenticating to the source.
     */
    username?: pulumi.Input<string>;
}

export interface StaticWebLayerCloudwatchConfiguration {
    enabled?: pulumi.Input<boolean>;
    logStreams?: pulumi.Input<pulumi.Input<inputs.opsworks.StaticWebLayerCloudwatchConfigurationLogStream>[]>;
}

export interface StaticWebLayerCloudwatchConfigurationLogStream {
    batchCount?: pulumi.Input<number>;
    batchSize?: pulumi.Input<number>;
    bufferDuration?: pulumi.Input<number>;
    datetimeFormat?: pulumi.Input<string>;
    encoding?: pulumi.Input<string>;
    file: pulumi.Input<string>;
    fileFingerprintLines?: pulumi.Input<string>;
    initialPosition?: pulumi.Input<string>;
    logGroupName: pulumi.Input<string>;
    multilineStartPattern?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
}

export interface StaticWebLayerEbsVolume {
    encrypted?: pulumi.Input<boolean>;
    /**
     * For PIOPS volumes, the IOPS per disk.
     */
    iops?: pulumi.Input<number>;
    /**
     * The path to mount the EBS volume on the layer's instances.
     */
    mountPoint: pulumi.Input<string>;
    /**
     * The number of disks to use for the EBS volume.
     */
    numberOfDisks: pulumi.Input<number>;
    /**
     * The RAID level to use for the volume.
     */
    raidLevel?: pulumi.Input<string>;
    /**
     * The size of the volume in gigabytes.
     */
    size: pulumi.Input<number>;
    /**
     * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
     */
    type?: pulumi.Input<string>;
}

export interface StaticWebLayerLoadBasedAutoScaling {
    downscaling?: pulumi.Input<inputs.opsworks.StaticWebLayerLoadBasedAutoScalingDownscaling>;
    enable?: pulumi.Input<boolean>;
    upscaling?: pulumi.Input<inputs.opsworks.StaticWebLayerLoadBasedAutoScalingUpscaling>;
}

export interface StaticWebLayerLoadBasedAutoScalingDownscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}

export interface StaticWebLayerLoadBasedAutoScalingUpscaling {
    alarms?: pulumi.Input<pulumi.Input<string>[]>;
    cpuThreshold?: pulumi.Input<number>;
    ignoreMetricsTime?: pulumi.Input<number>;
    instanceCount?: pulumi.Input<number>;
    loadThreshold?: pulumi.Input<number>;
    memoryThreshold?: pulumi.Input<number>;
    thresholdsWaitTime?: pulumi.Input<number>;
}
