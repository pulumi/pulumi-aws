// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../types/input";
import * as outputs from "../../types/output";
import * as enums from "../../types/enums";
import * as utilities from "../../utilities";

import {RoutingRule} from "@/s3";

export interface CapacityProviderAutoScalingGroupProvider {
    /**
     * - ARN of the associated auto scaling group.
     */
    autoScalingGroupArn: string;
    /**
     * - Configuration block defining the parameters of the auto scaling. Detailed below.
     */
    managedScaling: outputs.ecs.CapacityProviderAutoScalingGroupProviderManagedScaling;
    /**
     * - Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are `ENABLED` and `DISABLED`.
     */
    managedTerminationProtection: string;
}

export interface CapacityProviderAutoScalingGroupProviderManagedScaling {
    /**
     * Period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of 300 seconds is used.
     */
    instanceWarmupPeriod: number;
    /**
     * Maximum step adjustment size. A number between 1 and 10,000.
     */
    maximumScalingStepSize: number;
    /**
     * Minimum step adjustment size. A number between 1 and 10,000.
     */
    minimumScalingStepSize: number;
    /**
     * Whether auto scaling is managed by ECS. Valid values are `ENABLED` and `DISABLED`.
     */
    status: string;
    /**
     * Target utilization for the capacity provider. A number between 1 and 100.
     */
    targetCapacity: number;
}

export interface ClusterCapacityProvidersDefaultCapacityProviderStrategy {
    /**
     * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
     */
    base?: number;
    /**
     * Name of the capacity provider.
     */
    capacityProvider: string;
    /**
     * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The `weight` value is taken into consideration after the `base` count of tasks has been satisfied. Defaults to `0`.
     */
    weight?: number;
}

export interface ClusterConfiguration {
    /**
     * The details of the execute command configuration. Detailed below.
     */
    executeCommandConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfiguration;
}

export interface ClusterConfigurationExecuteCommandConfiguration {
    /**
     * The AWS Key Management Service key ID to encrypt the data between the local client and the container.
     */
    kmsKeyId?: string;
    /**
     * The log configuration for the results of the execute command actions Required when `logging` is `OVERRIDE`. Detailed below.
     */
    logConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfigurationLogConfiguration;
    /**
     * The log setting to use for redirecting logs for your execute command results. Valid values are `NONE`, `DEFAULT`, and `OVERRIDE`.
     */
    logging?: string;
}

export interface ClusterConfigurationExecuteCommandConfigurationLogConfiguration {
    /**
     * Whether or not to enable encryption on the CloudWatch logs. If not specified, encryption will be disabled.
     */
    cloudWatchEncryptionEnabled?: boolean;
    /**
     * The name of the CloudWatch log group to send logs to.
     */
    cloudWatchLogGroupName?: string;
    /**
     * Whether or not to enable encryption on the logs sent to S3. If not specified, encryption will be disabled.
     */
    s3BucketEncryptionEnabled?: boolean;
    /**
     * The name of the S3 bucket to send logs to.
     */
    s3BucketName?: string;
    /**
     * An optional folder in the S3 bucket to place logs in.
     */
    s3KeyPrefix?: string;
}

export interface ClusterDefaultCapacityProviderStrategy {
    /**
     * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
     */
    base?: number;
    /**
     * The short name of the capacity provider.
     */
    capacityProvider: string;
    /**
     * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
     */
    weight?: number;
}

export interface ClusterSetting {
    /**
     * Name of the setting to manage. Valid values: `containerInsights`.
     */
    name: string;
    /**
     * The value to assign to the setting. Valid values are `enabled` and `disabled`.
     */
    value: string;
}

export interface GetClusterSetting {
    name: string;
    value: string;
}

export interface ServiceCapacityProviderStrategy {
    /**
     * Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
     */
    base?: number;
    /**
     * Short name of the capacity provider.
     */
    capacityProvider: string;
    /**
     * Relative percentage of the total number of launched tasks that should use the specified capacity provider.
     */
    weight?: number;
}

export interface ServiceDeploymentCircuitBreaker {
    /**
     * Whether to enable the deployment circuit breaker logic for the service.
     */
    enable: boolean;
    /**
     * Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
     */
    rollback: boolean;
}

export interface ServiceDeploymentController {
    /**
     * Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`, `EXTERNAL`. Default: `ECS`.
     */
    type?: string;
}

export interface ServiceLoadBalancer {
    /**
     * Name of the container to associate with the load balancer (as it appears in a container definition).
     */
    containerName: string;
    /**
     * Port on the container to associate with the load balancer.
     */
    containerPort: number;
    /**
     * Name of the ELB (Classic) to associate with the service.
     */
    elbName?: string;
    /**
     * ARN of the Load Balancer target group to associate with the service.
     */
    targetGroupArn?: string;
}

export interface ServiceNetworkConfiguration {
    /**
     * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
     */
    assignPublicIp?: boolean;
    /**
     * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
     */
    securityGroups?: string[];
    /**
     * Subnets associated with the task or service.
     */
    subnets: string[];
}

export interface ServiceOrderedPlacementStrategy {
    /**
     * For the `spread` placement strategy, valid values are `instanceId` (or `host`,
     * which has the same effect), or any platform or custom attribute that is applied to a container instance.
     * For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
     * needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
     */
    field?: string;
    /**
     * Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
     */
    type: string;
}

export interface ServicePlacementConstraint {
    /**
     * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
     */
    expression?: string;
    /**
     * Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
     */
    type: string;
}

export interface ServiceServiceRegistries {
    /**
     * Container name value, already specified in the task definition, to be used for your service discovery service.
     */
    containerName?: string;
    /**
     * Port value, already specified in the task definition, to be used for your service discovery service.
     */
    containerPort?: number;
    /**
     * Port value used if your Service Discovery service specified an SRV record.
     */
    port?: number;
    /**
     * ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
     */
    registryArn: string;
}

export interface TaskDefinitionEphemeralStorage {
    /**
     * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is `21` GiB and the maximum supported value is `200` GiB.
     */
    sizeInGib: number;
}

export interface TaskDefinitionInferenceAccelerator {
    /**
     * Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
     */
    deviceName: string;
    /**
     * Elastic Inference accelerator type to use.
     */
    deviceType: string;
}

export interface TaskDefinitionPlacementConstraint {
    /**
     * Cluster Query Language expression to apply to the constraint. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
     */
    expression?: string;
    /**
     * Proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
     */
    type: string;
}

export interface TaskDefinitionProxyConfiguration {
    /**
     * Name of the container that will serve as the App Mesh proxy.
     */
    containerName: string;
    /**
     * Set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
     */
    properties?: {[key: string]: string};
    /**
     * Proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
     */
    type?: string;
}

export interface TaskDefinitionRuntimePlatform {
    /**
     * Must be set to either `X86_64` or `ARM64`; see [cpu architecture](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform)
     */
    cpuArchitecture?: string;
    /**
     * If the `requiresCompatibilities` is `FARGATE` this field is required; must be set to a valid option from the [operating system family in the runtime platform](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform) setting
     */
    operatingSystemFamily?: string;
}

export interface TaskDefinitionVolume {
    /**
     * Configuration block to configure a docker volume. Detailed below.
     */
    dockerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeDockerVolumeConfiguration;
    /**
     * Configuration block for an EFS volume. Detailed below.
     */
    efsVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfiguration;
    /**
     * Configuration block for an FSX Windows File Server volume. Detailed below.
     */
    fsxWindowsFileServerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration;
    /**
     * Path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
     */
    hostPath?: string;
    /**
     * Name of the volume. This name is referenced in the `sourceVolume`
     * parameter of container definition in the `mountPoints` section.
     */
    name: string;
}

export interface TaskDefinitionVolumeDockerVolumeConfiguration {
    /**
     * If this value is `true`, the Docker volume is created if it does not already exist. *Note*: This field is only used if the scope is `shared`.
     */
    autoprovision?: boolean;
    /**
     * Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
     */
    driver?: string;
    /**
     * Map of Docker driver specific options.
     */
    driverOpts?: {[key: string]: string};
    /**
     * Map of custom metadata to add to your Docker volume.
     */
    labels?: {[key: string]: string};
    /**
     * Scope for the Docker volume, which determines its lifecycle, either `task` or `shared`.  Docker volumes that are scoped to a `task` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as `shared` persist after the task stops.
     */
    scope: string;
}

export interface TaskDefinitionVolumeEfsVolumeConfiguration {
    /**
     * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
     */
    authorizationConfig?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig;
    /**
     * The Amazon FSx for Windows File Server file system ID to use.
     */
    fileSystemId: string;
    /**
     * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
     */
    rootDirectory?: string;
    /**
     * Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
     */
    transitEncryption?: string;
    /**
     * Port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
     */
    transitEncryptionPort?: number;
}

export interface TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig {
    /**
     * Access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
     */
    accessPointId?: string;
    /**
     * Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
     */
    iam?: string;
}

export interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration {
    /**
     * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
     */
    authorizationConfig: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig;
    /**
     * The Amazon FSx for Windows File Server file system ID to use.
     */
    fileSystemId: string;
    /**
     * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
     */
    rootDirectory: string;
}

export interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
    /**
     * The authorization credential option to use. The authorization credential options can be provided using either the Amazon Resource Name (ARN) of an AWS Secrets Manager secret or AWS Systems Manager Parameter Store parameter. The ARNs refer to the stored credentials.
     */
    credentialsParameter: string;
    /**
     * A fully qualified domain name hosted by an AWS Directory Service Managed Microsoft AD (Active Directory) or self-hosted AD on Amazon EC2.
     */
    domain: string;
}

export interface TaskSetCapacityProviderStrategy {
    /**
     * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
     */
    base?: number;
    /**
     * The short name or full Amazon Resource Name (ARN) of the capacity provider.
     */
    capacityProvider: string;
    /**
     * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
     */
    weight: number;
}

export interface TaskSetLoadBalancer {
    /**
     * The name of the container to associate with the load balancer (as it appears in a container definition).
     */
    containerName: string;
    /**
     * The port on the container to associate with the load balancer. Defaults to `0` if not specified.
     */
    containerPort?: number;
    /**
     * The name of the ELB (Classic) to associate with the service.
     */
    loadBalancerName?: string;
    /**
     * The ARN of the Load Balancer target group to associate with the service.
     */
    targetGroupArn?: string;
}

export interface TaskSetNetworkConfiguration {
    /**
     * Whether to assign a public IP address to the ENI (`FARGATE` launch type only). Valid values are `true` or `false`. Default `false`.
     */
    assignPublicIp?: boolean;
    /**
     * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. Maximum of 5.
     */
    securityGroups?: string[];
    /**
     * The subnets associated with the task or service. Maximum of 16.
     */
    subnets: string[];
}

export interface TaskSetScale {
    /**
     * The unit of measure for the scale value. Default: `PERCENT`.
     */
    unit?: string;
    /**
     * The value, specified as a percent total of a service's `desiredCount`, to scale the task set. Defaults to `0` if not specified. Accepted values are numbers between 0.0 and 100.0.
     */
    value?: number;
}

export interface TaskSetServiceRegistries {
    /**
     * The container name value, already specified in the task definition, to be used for your service discovery service.
     */
    containerName?: string;
    /**
     * The port value, already specified in the task definition, to be used for your service discovery service.
     */
    containerPort?: number;
    /**
     * The port value used if your Service Discovery service specified an SRV record.
     */
    port?: number;
    /**
     * The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service` resource). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html).
     */
    registryArn: string;
}

