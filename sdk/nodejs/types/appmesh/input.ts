// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../types/input";
import * as outputs from "../../types/output";
import * as enums from "../../types/enums";
import * as utilities from "../../utilities";

import {RoutingRule} from "@/s3";

export interface GatewayRouteSpec {
    /**
     * Specification of a gRPC gateway route.
     */
    grpcRoute?: pulumi.Input<inputs.appmesh.GatewayRouteSpecGrpcRoute>;
    /**
     * Specification of an HTTP/2 gateway route.
     */
    http2Route?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2Route>;
    /**
     * Specification of an HTTP gateway route.
     */
    httpRoute?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRoute>;
}

export interface GatewayRouteSpecGrpcRoute {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.GatewayRouteSpecGrpcRouteAction>;
    /**
     * Criteria for determining a request match.
     */
    match: pulumi.Input<inputs.appmesh.GatewayRouteSpecGrpcRouteMatch>;
}

export interface GatewayRouteSpecGrpcRouteAction {
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: pulumi.Input<inputs.appmesh.GatewayRouteSpecGrpcRouteActionTarget>;
}

export interface GatewayRouteSpecGrpcRouteActionTarget {
    /**
     * Virtual service gateway route target.
     */
    virtualService: pulumi.Input<inputs.appmesh.GatewayRouteSpecGrpcRouteActionTargetVirtualService>;
}

export interface GatewayRouteSpecGrpcRouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: pulumi.Input<string>;
}

export interface GatewayRouteSpecGrpcRouteMatch {
    /**
     * Fully qualified domain name for the service to match from the request.
     */
    serviceName: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttp2Route {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteAction>;
    /**
     * Criteria for determining a request match.
     */
    match: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteMatch>;
}

export interface GatewayRouteSpecHttp2RouteAction {
    /**
     * Gateway route action to rewrite.
     */
    rewrite?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteActionRewrite>;
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteActionTarget>;
}

export interface GatewayRouteSpecHttp2RouteActionRewrite {
    /**
     * Host name to rewrite.
     */
    hostname?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteActionRewriteHostname>;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteActionRewritePrefix>;
}

export interface GatewayRouteSpecHttp2RouteActionRewriteHostname {
    /**
     * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultTargetHostname: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttp2RouteActionRewritePrefix {
    /**
     * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultPrefix?: pulumi.Input<string>;
    /**
     * Value used to replace the incoming route prefix when rewritten.
     */
    value?: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttp2RouteActionTarget {
    /**
     * Virtual service gateway route target.
     */
    virtualService: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteActionTargetVirtualService>;
}

export interface GatewayRouteSpecHttp2RouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttp2RouteMatch {
    /**
     * Host name to rewrite.
     */
    hostname?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttp2RouteMatchHostname>;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttp2RouteMatchHostname {
    /**
     * Exact host name to match on.
     */
    exact?: pulumi.Input<string>;
    /**
     * Specified ending characters of the host name to match on.
     */
    suffix?: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteAction>;
    /**
     * Criteria for determining a request match.
     */
    match: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteMatch>;
}

export interface GatewayRouteSpecHttpRouteAction {
    /**
     * Gateway route action to rewrite.
     */
    rewrite?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteActionRewrite>;
    /**
     * Target that traffic is routed to when a request matches the gateway route.
     */
    target: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteActionTarget>;
}

export interface GatewayRouteSpecHttpRouteActionRewrite {
    /**
     * Host name to rewrite.
     */
    hostname?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteActionRewriteHostname>;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteActionRewritePrefix>;
}

export interface GatewayRouteSpecHttpRouteActionRewriteHostname {
    /**
     * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultTargetHostname: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttpRouteActionRewritePrefix {
    /**
     * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
     */
    defaultPrefix?: pulumi.Input<string>;
    /**
     * Value used to replace the incoming route prefix when rewritten.
     */
    value?: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttpRouteActionTarget {
    /**
     * Virtual service gateway route target.
     */
    virtualService: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteActionTargetVirtualService>;
}

export interface GatewayRouteSpecHttpRouteActionTargetVirtualService {
    /**
     * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttpRouteMatch {
    /**
     * Host name to rewrite.
     */
    hostname?: pulumi.Input<inputs.appmesh.GatewayRouteSpecHttpRouteMatchHostname>;
    /**
     * Specified beginning characters to rewrite.
     */
    prefix?: pulumi.Input<string>;
}

export interface GatewayRouteSpecHttpRouteMatchHostname {
    /**
     * Exact host name to match on.
     */
    exact?: pulumi.Input<string>;
    /**
     * Specified ending characters of the host name to match on.
     */
    suffix?: pulumi.Input<string>;
}

export interface MeshSpec {
    /**
     * Egress filter rules for the service mesh.
     */
    egressFilter?: pulumi.Input<inputs.appmesh.MeshSpecEgressFilter>;
}

export interface MeshSpecEgressFilter {
    /**
     * Egress filter type. By default, the type is `DROP_ALL`.
     * Valid values are `ALLOW_ALL` and `DROP_ALL`.
     */
    type?: pulumi.Input<string>;
}

export interface RouteSpec {
    /**
     * GRPC routing information for the route.
     */
    grpcRoute?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRoute>;
    /**
     * HTTP/2 routing information for the route.
     */
    http2Route?: pulumi.Input<inputs.appmesh.RouteSpecHttp2Route>;
    /**
     * HTTP routing information for the route.
     */
    httpRoute?: pulumi.Input<inputs.appmesh.RouteSpecHttpRoute>;
    /**
     * Priority for the route, between `0` and `1000`.
     * Routes are matched based on the specified value, where `0` is the highest priority.
     */
    priority?: pulumi.Input<number>;
    /**
     * TCP routing information for the route.
     */
    tcpRoute?: pulumi.Input<inputs.appmesh.RouteSpecTcpRoute>;
}

export interface RouteSpecGrpcRoute {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteAction>;
    /**
     * Criteria for determining an gRPC request match.
     */
    match?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteMatch>;
    /**
     * Retry policy.
     */
    retryPolicy?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteRetryPolicy>;
    /**
     * Types of timeouts.
     */
    timeout?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteTimeout>;
}

export interface RouteSpecGrpcRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteActionWeightedTarget>[]>;
}

export interface RouteSpecGrpcRouteActionWeightedTarget {
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: pulumi.Input<string>;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: pulumi.Input<number>;
}

export interface RouteSpecGrpcRouteMatch {
    /**
     * Data to match from the gRPC request.
     */
    metadatas?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteMatchMetadata>[]>;
    /**
     * Method name to match from the request. If you specify a name, you must also specify a `serviceName`.
     */
    methodName?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Fully qualified domain name for the service to match from the request.
     */
    serviceName?: pulumi.Input<string>;
}

export interface RouteSpecGrpcRouteMatchMetadata {
    /**
     * If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
     */
    invert?: pulumi.Input<boolean>;
    /**
     * Data to match from the request.
     */
    match?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatch>;
    /**
     * Name of the route. Must be between 1 and 50 characters in length.
     */
    name: pulumi.Input<string>;
}

export interface RouteSpecGrpcRouteMatchMetadataMatch {
    /**
     * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
     */
    exact?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Object that specifies the range of numbers that the value sent by the client must be included in.
     */
    range?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatchRange>;
    /**
     * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
     */
    regex?: pulumi.Input<string>;
    /**
     * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
     */
    suffix?: pulumi.Input<string>;
}

export interface RouteSpecGrpcRouteMatchMetadataMatchRange {
    /**
     * End of the range.
     */
    end: pulumi.Input<number>;
    /**
     * Start of the range.
     */
    start: pulumi.Input<number>;
}

export interface RouteSpecGrpcRouteRetryPolicy {
    /**
     * List of gRPC retry events.
     * Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
     */
    grpcRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Maximum number of retries.
     */
    maxRetries: pulumi.Input<number>;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout>;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     */
    tcpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Retry value.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecGrpcRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteTimeoutIdle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.RouteSpecGrpcRouteTimeoutPerRequest>;
}

export interface RouteSpecGrpcRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecGrpcRouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttp2Route {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteAction>;
    /**
     * Criteria for determining an gRPC request match.
     */
    match: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteMatch>;
    /**
     * Retry policy.
     */
    retryPolicy?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteRetryPolicy>;
    /**
     * Types of timeouts.
     */
    timeout?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteTimeout>;
}

export interface RouteSpecHttp2RouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteActionWeightedTarget>[]>;
}

export interface RouteSpecHttp2RouteActionWeightedTarget {
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: pulumi.Input<string>;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: pulumi.Input<number>;
}

export interface RouteSpecHttp2RouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteMatchHeader>[]>;
    /**
     * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
     */
    method?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix: pulumi.Input<string>;
    /**
     * Client request header scheme to match on. Valid values: `http`, `https`.
     */
    scheme?: pulumi.Input<string>;
}

export interface RouteSpecHttp2RouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: pulumi.Input<boolean>;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatch>;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: pulumi.Input<string>;
}

export interface RouteSpecHttp2RouteMatchHeaderMatch {
    /**
     * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
     */
    exact?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Object that specifies the range of numbers that the value sent by the client must be included in.
     */
    range?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatchRange>;
    /**
     * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
     */
    regex?: pulumi.Input<string>;
    /**
     * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
     */
    suffix?: pulumi.Input<string>;
}

export interface RouteSpecHttp2RouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: pulumi.Input<number>;
    /**
     * Start of the range.
     */
    start: pulumi.Input<number>;
}

export interface RouteSpecHttp2RouteRetryPolicy {
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Maximum number of retries.
     */
    maxRetries: pulumi.Input<number>;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout>;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     */
    tcpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Retry value.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttp2RouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteTimeoutIdle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.RouteSpecHttp2RouteTimeoutPerRequest>;
}

export interface RouteSpecHttp2RouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttp2RouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteAction>;
    /**
     * Criteria for determining an HTTP request match.
     */
    match: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteMatch>;
    /**
     * Retry policy.
     */
    retryPolicy?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteRetryPolicy>;
    /**
     * Types of timeouts.
     */
    timeout?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteTimeout>;
}

export interface RouteSpecHttpRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecHttpRouteActionWeightedTarget>[]>;
}

export interface RouteSpecHttpRouteActionWeightedTarget {
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: pulumi.Input<string>;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: pulumi.Input<number>;
}

export interface RouteSpecHttpRouteMatch {
    /**
     * Client request headers to match on.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecHttpRouteMatchHeader>[]>;
    /**
     * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
     */
    method?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix: pulumi.Input<string>;
    /**
     * Client request header scheme to match on. Valid values: `http`, `https`.
     */
    scheme?: pulumi.Input<string>;
}

export interface RouteSpecHttpRouteMatchHeader {
    /**
     * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
     */
    invert?: pulumi.Input<boolean>;
    /**
     * Method and value to match the header value sent with a request. Specify one match method.
     */
    match?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteMatchHeaderMatch>;
    /**
     * Name for the HTTP header in the client request that will be matched on.
     */
    name: pulumi.Input<string>;
}

export interface RouteSpecHttpRouteMatchHeaderMatch {
    /**
     * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
     */
    exact?: pulumi.Input<string>;
    /**
     * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
     * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Object that specifies the range of numbers that the value sent by the client must be included in.
     */
    range?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteMatchHeaderMatchRange>;
    /**
     * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
     */
    regex?: pulumi.Input<string>;
    /**
     * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
     */
    suffix?: pulumi.Input<string>;
}

export interface RouteSpecHttpRouteMatchHeaderMatchRange {
    /**
     * End of the range.
     */
    end: pulumi.Input<number>;
    /**
     * Start of the range.
     */
    start: pulumi.Input<number>;
}

export interface RouteSpecHttpRouteRetryPolicy {
    /**
     * List of HTTP retry events.
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
     */
    httpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Maximum number of retries.
     */
    maxRetries: pulumi.Input<number>;
    /**
     * Per-retry timeout.
     */
    perRetryTimeout: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteRetryPolicyPerRetryTimeout>;
    /**
     * List of TCP retry events. The only valid value is `connection-error`.
     */
    tcpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    /**
     * Retry unit. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Retry value.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttpRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteTimeoutIdle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.RouteSpecHttpRouteTimeoutPerRequest>;
}

export interface RouteSpecHttpRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecHttpRouteTimeoutPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface RouteSpecTcpRoute {
    /**
     * Action to take if a match is determined.
     */
    action: pulumi.Input<inputs.appmesh.RouteSpecTcpRouteAction>;
    /**
     * Types of timeouts.
     */
    timeout?: pulumi.Input<inputs.appmesh.RouteSpecTcpRouteTimeout>;
}

export interface RouteSpecTcpRouteAction {
    /**
     * Targets that traffic is routed to when a request matches the route.
     * You can specify one or more targets and their relative weights with which to distribute traffic.
     */
    weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteSpecTcpRouteActionWeightedTarget>[]>;
}

export interface RouteSpecTcpRouteActionWeightedTarget {
    /**
     * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
     */
    virtualNode: pulumi.Input<string>;
    /**
     * Relative weight of the weighted target. An integer between 0 and 100.
     */
    weight: pulumi.Input<number>;
}

export interface RouteSpecTcpRouteTimeout {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.RouteSpecTcpRouteTimeoutIdle>;
}

export interface RouteSpecTcpRouteTimeoutIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualGatewaySpec {
    /**
     * Defaults for backends.
     */
    backendDefaults?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaults>;
    /**
     * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
     */
    listener: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListener>;
    /**
     * Inbound and outbound access logging information for the virtual gateway.
     */
    logging?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecLogging>;
}

export interface VirtualGatewaySpecBackendDefaults {
    /**
     * Default client policy for virtual gateway backends.
     */
    clientPolicy?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicy>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTls>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate>;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: pulumi.Input<boolean>;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile>;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
    /**
     * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: pulumi.Input<string>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    /**
     * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
     */
    subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames>;
    /**
     * TLS validation context trust.
     */
    trust: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm>;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile>;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
}

export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListener {
    /**
     * Connection pool information for the listener.
     */
    connectionPool?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerConnectionPool>;
    /**
     * Health check information for the listener.
     */
    healthCheck?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerHealthCheck>;
    /**
     * Port mapping information for the listener.
     */
    portMapping: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerPortMapping>;
    /**
     * Transport Layer Security (TLS) properties for the listener
     */
    tls?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTls>;
}

export interface VirtualGatewaySpecListenerConnectionPool {
    /**
     * Connection pool information for gRPC listeners.
     */
    grpc?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerConnectionPoolGrpc>;
    /**
     * Connection pool information for HTTP listeners.
     */
    http?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp>;
    /**
     * Connection pool information for HTTP2 listeners.
     */
    http2?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp2>;
}

export interface VirtualGatewaySpecListenerConnectionPoolGrpc {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: pulumi.Input<number>;
}

export interface VirtualGatewaySpecListenerConnectionPoolHttp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: pulumi.Input<number>;
    /**
     * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
     */
    maxPendingRequests?: pulumi.Input<number>;
}

export interface VirtualGatewaySpecListenerConnectionPoolHttp2 {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: pulumi.Input<number>;
}

export interface VirtualGatewaySpecListenerHealthCheck {
    /**
     * Number of consecutive successful health checks that must occur before declaring listener healthy.
     */
    healthyThreshold: pulumi.Input<number>;
    /**
     * Time period in milliseconds between each health check execution.
     */
    intervalMillis: pulumi.Input<number>;
    /**
     * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
     */
    path?: pulumi.Input<string>;
    /**
     * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
     */
    port?: pulumi.Input<number>;
    /**
     * Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
     */
    protocol: pulumi.Input<string>;
    /**
     * Amount of time to wait when receiving a response from the health check, in milliseconds.
     */
    timeoutMillis: pulumi.Input<number>;
    /**
     * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
     */
    unhealthyThreshold: pulumi.Input<number>;
}

export interface VirtualGatewaySpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: pulumi.Input<number>;
    /**
     * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListenerTls {
    /**
     * Listener's TLS certificate.
     */
    certificate: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsCertificate>;
    /**
     * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
     */
    mode: pulumi.Input<string>;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidation>;
}

export interface VirtualGatewaySpecListenerTlsCertificate {
    /**
     * An AWS Certificate Manager (ACM) certificate.
     */
    acm?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsCertificateAcm>;
    /**
     * Local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsCertificateFile>;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsCertificateSds>;
}

export interface VirtualGatewaySpecListenerTlsCertificateAcm {
    /**
     * ARN for the certificate.
     */
    certificateArn: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListenerTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
    /**
     * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListenerTlsCertificateSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListenerTlsValidation {
    /**
     * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
     */
    subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames>;
    /**
     * TLS validation context trust.
     */
    trust: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrust>;
}

export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch>;
}

export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualGatewaySpecListenerTlsValidationTrust {
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustFile>;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustSds>;
}

export interface VirtualGatewaySpecListenerTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
}

export interface VirtualGatewaySpecListenerTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualGatewaySpecLogging {
    /**
     * Access log configuration for a virtual gateway.
     */
    accessLog?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecLoggingAccessLog>;
}

export interface VirtualGatewaySpecLoggingAccessLog {
    /**
     * File object to send virtual gateway access logs to.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualGatewaySpecLoggingAccessLogFile>;
}

export interface VirtualGatewaySpecLoggingAccessLogFile {
    /**
     * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
     */
    path: pulumi.Input<string>;
}

export interface VirtualNodeSpec {
    /**
     * Defaults for backends.
     */
    backendDefaults?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaults>;
    /**
     * Backends to which the virtual node is expected to send outbound traffic.
     */
    backends?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualNodeSpecBackend>[]>;
    /**
     * Listeners from which the virtual node is expected to receive inbound traffic.
     */
    listener?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListener>;
    /**
     * Inbound and outbound access logging information for the virtual node.
     */
    logging?: pulumi.Input<inputs.appmesh.VirtualNodeSpecLogging>;
    /**
     * Service discovery information for the virtual node.
     */
    serviceDiscovery?: pulumi.Input<inputs.appmesh.VirtualNodeSpecServiceDiscovery>;
}

export interface VirtualNodeSpecBackend {
    /**
     * Virtual service to use as a backend for a virtual node.
     */
    virtualService: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualService>;
}

export interface VirtualNodeSpecBackendDefaults {
    /**
     * Default client policy for virtual service backends. See above for details.
     */
    clientPolicy?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicy>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTls>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate>;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: pulumi.Input<boolean>;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile>;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames>;
    /**
     * TLS validation context trust.
     */
    trust: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm>;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile>;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendVirtualService {
    /**
     * Client policy for the backend.
     */
    clientPolicy?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicy>;
    /**
     * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
     */
    virtualServiceName: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicy {
    /**
     * Transport Layer Security (TLS) client policy.
     */
    tls?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTls>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTls {
    /**
     * Listener's TLS certificate.
     */
    certificate?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate>;
    /**
     * Whether the policy is enforced. Default is `true`.
     */
    enforce?: pulumi.Input<boolean>;
    /**
     * One or more ports that the policy is enforced for.
     */
    ports?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate {
    /**
     * Local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile>;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames>;
    /**
     * TLS validation context trust.
     */
    trust: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
    /**
     * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
     */
    acm?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm>;
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile>;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
    /**
     * One or more ACM ARNs.
     */
    certificateAuthorityArns: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
}

export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecListener {
    /**
     * Connection pool information for the listener.
     */
    connectionPool?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerConnectionPool>;
    /**
     * Health check information for the listener.
     */
    healthCheck?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerHealthCheck>;
    /**
     * Outlier detection information for the listener.
     */
    outlierDetection?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerOutlierDetection>;
    /**
     * Port mapping information for the listener.
     */
    portMapping: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerPortMapping>;
    /**
     * Timeouts for different protocols.
     */
    timeout?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeout>;
    /**
     * Transport Layer Security (TLS) properties for the listener
     */
    tls?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTls>;
}

export interface VirtualNodeSpecListenerConnectionPool {
    /**
     * Connection pool information for gRPC listeners.
     */
    grpc?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerConnectionPoolGrpc>;
    /**
     * Connection pool information for HTTP listeners.
     */
    http?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp>;
    /**
     * Connection pool information for HTTP2 listeners.
     */
    http2?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp2>;
    /**
     * Connection pool information for TCP listeners.
     */
    tcp?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerConnectionPoolTcp>;
}

export interface VirtualNodeSpecListenerConnectionPoolGrpc {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerConnectionPoolHttp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: pulumi.Input<number>;
    /**
     * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
     */
    maxPendingRequests?: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerConnectionPoolHttp2 {
    /**
     * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
     */
    maxRequests: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerConnectionPoolTcp {
    /**
     * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
     */
    maxConnections: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerHealthCheck {
    /**
     * Number of consecutive successful health checks that must occur before declaring listener healthy.
     */
    healthyThreshold: pulumi.Input<number>;
    /**
     * Time period in milliseconds between each health check execution.
     */
    intervalMillis: pulumi.Input<number>;
    /**
     * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
     */
    path?: pulumi.Input<string>;
    /**
     * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
     */
    port?: pulumi.Input<number>;
    /**
     * Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: pulumi.Input<string>;
    /**
     * Amount of time to wait when receiving a response from the health check, in milliseconds.
     */
    timeoutMillis: pulumi.Input<number>;
    /**
     * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
     */
    unhealthyThreshold: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerOutlierDetection {
    /**
     * Base amount of time for which a host is ejected.
     */
    baseEjectionDuration: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration>;
    /**
     * Time interval between ejection sweep analysis.
     */
    interval: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerOutlierDetectionInterval>;
    /**
     * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
     * Minimum value of `0`. Maximum value of `100`.
     */
    maxEjectionPercent: pulumi.Input<number>;
    /**
     * Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
     */
    maxServerErrors: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerOutlierDetectionInterval {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: pulumi.Input<number>;
    /**
     * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
     */
    protocol: pulumi.Input<string>;
}

export interface VirtualNodeSpecListenerTimeout {
    /**
     * Timeouts for gRPC listeners.
     */
    grpc?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutGrpc>;
    /**
     * Timeouts for HTTP listeners.
     */
    http?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttp>;
    /**
     * Timeouts for HTTP2 listeners.
     */
    http2?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2>;
    /**
     * Timeouts for TCP listeners.
     */
    tcp?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutTcp>;
}

export interface VirtualNodeSpecListenerTimeoutGrpc {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcIdle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcPerRequest>;
}

export interface VirtualNodeSpecListenerTimeoutGrpcIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutGrpcPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutHttp {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttpIdle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttpPerRequest>;
}

export interface VirtualNodeSpecListenerTimeoutHttp2 {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2Idle>;
    /**
     * Per request timeout.
     */
    perRequest?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2PerRequest>;
}

export interface VirtualNodeSpecListenerTimeoutHttp2Idle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutHttp2PerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutHttpIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutHttpPerRequest {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTimeoutTcp {
    /**
     * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
     */
    idle?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTimeoutTcpIdle>;
}

export interface VirtualNodeSpecListenerTimeoutTcpIdle {
    /**
     * Unit of time. Valid values: `ms`, `s`.
     */
    unit: pulumi.Input<string>;
    /**
     * Number of time units. Minimum value of `0`.
     */
    value: pulumi.Input<number>;
}

export interface VirtualNodeSpecListenerTls {
    /**
     * Listener's TLS certificate.
     */
    certificate: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsCertificate>;
    /**
     * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
     */
    mode: pulumi.Input<string>;
    /**
     * Listener's Transport Layer Security (TLS) validation context.
     */
    validation?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidation>;
}

export interface VirtualNodeSpecListenerTlsCertificate {
    /**
     * An AWS Certificate Manager (ACM) certificate.
     */
    acm?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsCertificateAcm>;
    /**
     * Local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsCertificateFile>;
    /**
     * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsCertificateSds>;
}

export interface VirtualNodeSpecListenerTlsCertificateAcm {
    /**
     * ARN for the certificate.
     */
    certificateArn: pulumi.Input<string>;
}

export interface VirtualNodeSpecListenerTlsCertificateFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
    /**
     * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    privateKey: pulumi.Input<string>;
}

export interface VirtualNodeSpecListenerTlsCertificateSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecListenerTlsValidation {
    /**
     * SANs for a TLS validation context.
     */
    subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames>;
    /**
     * TLS validation context trust.
     */
    trust: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidationTrust>;
}

export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames {
    /**
     * Criteria for determining a SAN's match.
     */
    match: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch>;
}

export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /**
     * Values sent must match the specified values exactly.
     */
    exacts: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VirtualNodeSpecListenerTlsValidationTrust {
    /**
     * TLS validation context trust for a local file certificate.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustFile>;
    /**
     * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
     */
    sds?: pulumi.Input<inputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustSds>;
}

export interface VirtualNodeSpecListenerTlsValidationTrustFile {
    /**
     * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
     */
    certificateChain: pulumi.Input<string>;
}

export interface VirtualNodeSpecListenerTlsValidationTrustSds {
    /**
     * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
     */
    secretName: pulumi.Input<string>;
}

export interface VirtualNodeSpecLogging {
    /**
     * Access log configuration for a virtual node.
     */
    accessLog?: pulumi.Input<inputs.appmesh.VirtualNodeSpecLoggingAccessLog>;
}

export interface VirtualNodeSpecLoggingAccessLog {
    /**
     * File object to send virtual node access logs to.
     */
    file?: pulumi.Input<inputs.appmesh.VirtualNodeSpecLoggingAccessLogFile>;
}

export interface VirtualNodeSpecLoggingAccessLogFile {
    /**
     * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
     */
    path: pulumi.Input<string>;
}

export interface VirtualNodeSpecServiceDiscovery {
    /**
     * Any AWS Cloud Map information for the virtual node.
     */
    awsCloudMap?: pulumi.Input<inputs.appmesh.VirtualNodeSpecServiceDiscoveryAwsCloudMap>;
    /**
     * DNS service name for the virtual node.
     */
    dns?: pulumi.Input<inputs.appmesh.VirtualNodeSpecServiceDiscoveryDns>;
}

export interface VirtualNodeSpecServiceDiscoveryAwsCloudMap {
    /**
     * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
     */
    attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Name of the AWS Cloud Map namespace to use.
     * Use the `aws.servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
     */
    namespaceName: pulumi.Input<string>;
    /**
     * Name of the AWS Cloud Map service to use. Use the `aws.servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
     */
    serviceName: pulumi.Input<string>;
}

export interface VirtualNodeSpecServiceDiscoveryDns {
    /**
     * DNS host name for your virtual node.
     */
    hostname: pulumi.Input<string>;
}

export interface VirtualRouterSpec {
    /**
     * Listeners that the virtual router is expected to receive inbound traffic from.
     * Currently only one listener is supported per virtual router.
     */
    listener: pulumi.Input<inputs.appmesh.VirtualRouterSpecListener>;
}

export interface VirtualRouterSpecListener {
    /**
     * Port mapping information for the listener.
     */
    portMapping: pulumi.Input<inputs.appmesh.VirtualRouterSpecListenerPortMapping>;
}

export interface VirtualRouterSpecListenerPortMapping {
    /**
     * Port used for the port mapping.
     */
    port: pulumi.Input<number>;
    /**
     * Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
     */
    protocol: pulumi.Input<string>;
}

export interface VirtualServiceSpec {
    /**
     * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
     */
    provider?: pulumi.Input<inputs.appmesh.VirtualServiceSpecProvider>;
}

export interface VirtualServiceSpecProvider {
    /**
     * Virtual node associated with a virtual service.
     */
    virtualNode?: pulumi.Input<inputs.appmesh.VirtualServiceSpecProviderVirtualNode>;
    /**
     * Virtual router associated with a virtual service.
     */
    virtualRouter?: pulumi.Input<inputs.appmesh.VirtualServiceSpecProviderVirtualRouter>;
}

export interface VirtualServiceSpecProviderVirtualNode {
    /**
     * Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
     */
    virtualNodeName: pulumi.Input<string>;
}

export interface VirtualServiceSpecProviderVirtualRouter {
    /**
     * Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
     */
    virtualRouterName: pulumi.Input<string>;
}
