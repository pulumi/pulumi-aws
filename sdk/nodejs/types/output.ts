// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

import {RoutingRule} from "../s3";

export interface GetAvailabilityZoneFilter {
    /**
     * Name of the filter field. Valid values can be found in the [EC2 DescribeAvailabilityZones API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html).
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}

export interface GetAvailabilityZonesFilter {
    /**
     * Name of the filter field. Valid values can be found in the [EC2 DescribeAvailabilityZones API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html).
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}

export interface GetRegionsFilter {
    /**
     * Name of the filter field. Valid values can be found in the [describe-regions AWS CLI Reference][1].
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}

export namespace accessanalyzer {
    export interface ArchiveRuleFilter {
        /**
         * Contains comparator.
         */
        contains: string[];
        /**
         * Filter criteria.
         */
        criteria: string;
        /**
         * Equals comparator.
         */
        eqs: string[];
        /**
         * Boolean comparator.
         */
        exists: string;
        /**
         * Not Equals comparator.
         */
        neqs: string[];
    }

}

export namespace acm {
    export interface CertificateDomainValidationOption {
        /**
         * Fully qualified domain name (FQDN) in the certificate.
         */
        domainName: string;
        /**
         * The name of the DNS record to create to validate the certificate
         */
        resourceRecordName: string;
        /**
         * The type of DNS record to create
         */
        resourceRecordType: string;
        /**
         * The value the DNS record needs to have
         */
        resourceRecordValue: string;
    }

    export interface CertificateOptions {
        /**
         * Whether certificate details should be added to a certificate transparency log. Valid values are `ENABLED` or `DISABLED`. See https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency for more details.
         */
        certificateTransparencyLoggingPreference?: string;
    }

    export interface CertificateRenewalSummary {
        /**
         * The status of ACM's managed renewal of the certificate
         */
        renewalStatus: string;
        /**
         * The reason that a renewal request was unsuccessful or is pending
         */
        renewalStatusReason: string;
        updatedAt: string;
    }

    export interface CertificateValidationOption {
        /**
         * Fully qualified domain name (FQDN) in the certificate.
         */
        domainName: string;
        /**
         * Domain name that you want ACM to use to send you validation emails. This domain name is the suffix of the email addresses that you want ACM to use. This must be the same as the `domainName` value or a superdomain of the `domainName` value. For example, if you request a certificate for `"testing.example.com"`, you can specify `"example.com"` for this value.
         */
        validationDomain: string;
    }

}

export namespace acmpca {
    export interface CertificateAuthorityCertificateAuthorityConfiguration {
        /**
         * Type of the public key algorithm and size, in bits, of the key pair that your key pair creates when it issues a certificate. Valid values can be found in the [ACM PCA Documentation](https://docs.aws.amazon.com/privateca/latest/APIReference/API_CertificateAuthorityConfiguration.html).
         */
        keyAlgorithm: string;
        /**
         * Name of the algorithm your private CA uses to sign certificate requests. Valid values can be found in the [ACM PCA Documentation](https://docs.aws.amazon.com/privateca/latest/APIReference/API_CertificateAuthorityConfiguration.html).
         */
        signingAlgorithm: string;
        /**
         * Nested argument that contains X.500 distinguished name information. At least one nested attribute must be specified.
         */
        subject: outputs.acmpca.CertificateAuthorityCertificateAuthorityConfigurationSubject;
    }

    export interface CertificateAuthorityCertificateAuthorityConfigurationSubject {
        /**
         * Fully qualified domain name (FQDN) associated with the certificate subject. Must be less than or equal to 64 characters in length.
         */
        commonName?: string;
        /**
         * Two digit code that specifies the country in which the certificate subject located. Must be less than or equal to 2 characters in length.
         */
        country?: string;
        /**
         * Disambiguating information for the certificate subject. Must be less than or equal to 64 characters in length.
         */
        distinguishedNameQualifier?: string;
        /**
         * Typically a qualifier appended to the name of an individual. Examples include Jr. for junior, Sr. for senior, and III for third. Must be less than or equal to 3 characters in length.
         */
        generationQualifier?: string;
        /**
         * First name. Must be less than or equal to 16 characters in length.
         */
        givenName?: string;
        /**
         * Concatenation that typically contains the first letter of the `givenName`, the first letter of the middle name if one exists, and the first letter of the `surname`. Must be less than or equal to 5 characters in length.
         */
        initials?: string;
        /**
         * Locality (such as a city or town) in which the certificate subject is located. Must be less than or equal to 128 characters in length.
         */
        locality?: string;
        /**
         * Legal name of the organization with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
         */
        organization?: string;
        /**
         * Subdivision or unit of the organization (such as sales or finance) with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
         */
        organizationalUnit?: string;
        /**
         * Typically a shortened version of a longer `givenName`. For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth, Liz, or Eliza. Must be less than or equal to 128 characters in length.
         */
        pseudonym?: string;
        /**
         * State in which the subject of the certificate is located. Must be less than or equal to 128 characters in length.
         */
        state?: string;
        /**
         * Family name. In the US and the UK for example, the surname of an individual is ordered last. In Asian cultures the surname is typically ordered first. Must be less than or equal to 40 characters in length.
         */
        surname?: string;
        /**
         * Title such as Mr. or Ms. which is pre-pended to the name to refer formally to the certificate subject. Must be less than or equal to 64 characters in length.
         */
        title?: string;
    }

    export interface CertificateAuthorityRevocationConfiguration {
        /**
         * Nested argument containing configuration of the certificate revocation list (CRL), if any, maintained by the certificate authority. Defined below.
         */
        crlConfiguration?: outputs.acmpca.CertificateAuthorityRevocationConfigurationCrlConfiguration;
        /**
         * Nested argument containing configuration of
         * the custom OCSP responder endpoint. Defined below.
         */
        ocspConfiguration?: outputs.acmpca.CertificateAuthorityRevocationConfigurationOcspConfiguration;
    }

    export interface CertificateAuthorityRevocationConfigurationCrlConfiguration {
        /**
         * Name inserted into the certificate CRL Distribution Points extension that enables the use of an alias for the CRL distribution point. Use this value if you don't want the name of your S3 bucket to be public. Must be less than or equal to 253 characters in length.
         */
        customCname?: string;
        /**
         * Boolean value that specifies whether certificate revocation lists (CRLs) are enabled. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * Number of days until a certificate expires. Must be between 1 and 5000.
         */
        expirationInDays?: number;
        /**
         * Name of the S3 bucket that contains the CRL. If you do not provide a value for the `customCname` argument, the name of your S3 bucket is placed into the CRL Distribution Points extension of the issued certificate. You must specify a bucket policy that allows ACM PCA to write the CRL to your bucket. Must be between 3 and 255 characters in length.
         */
        s3BucketName?: string;
        /**
         * Determines whether the CRL will be publicly readable or privately held in the CRL Amazon S3 bucket. Defaults to `PUBLIC_READ`.
         */
        s3ObjectAcl: string;
    }

    export interface CertificateAuthorityRevocationConfigurationOcspConfiguration {
        /**
         * Boolean value that specifies whether a custom OCSP responder is enabled.
         */
        enabled: boolean;
        /**
         * CNAME specifying a customized OCSP domain. Note: The value of the CNAME must not include a protocol prefix such as "http://" or "https://".
         */
        ocspCustomCname?: string;
    }

    export interface CertificateValidity {
        /**
         * Determines how `value` is interpreted. Valid values: `DAYS`, `MONTHS`, `YEARS`, `ABSOLUTE`, `END_DATE`.
         */
        type: string;
        /**
         * If `type` is `DAYS`, `MONTHS`, or `YEARS`, the relative time until the certificate expires. If `type` is `ABSOLUTE`, the date in seconds since the Unix epoch. If `type` is `END_DATE`, the  date in RFC 3339 format.
         */
        value: string;
    }

    export interface GetCertificateAuthorityRevocationConfiguration {
        crlConfigurations: outputs.acmpca.GetCertificateAuthorityRevocationConfigurationCrlConfiguration[];
        ocspConfigurations: outputs.acmpca.GetCertificateAuthorityRevocationConfigurationOcspConfiguration[];
    }

    export interface GetCertificateAuthorityRevocationConfigurationCrlConfiguration {
        customCname: string;
        enabled: boolean;
        expirationInDays: number;
        s3BucketName: string;
        s3ObjectAcl: string;
    }

    export interface GetCertificateAuthorityRevocationConfigurationOcspConfiguration {
        enabled: boolean;
        ocspCustomCname: string;
    }

}

export namespace alb {
    export interface GetListenerDefaultAction {
        authenticateCognitos: outputs.alb.GetListenerDefaultActionAuthenticateCognito[];
        authenticateOidcs: outputs.alb.GetListenerDefaultActionAuthenticateOidc[];
        fixedResponses: outputs.alb.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.alb.GetListenerDefaultActionForward[];
        order: number;
        redirects: outputs.alb.GetListenerDefaultActionRedirect[];
        targetGroupArn: string;
        type: string;
    }

    export interface GetListenerDefaultActionAuthenticateCognito {
        authenticationRequestExtraParams: {[key: string]: string};
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }

    export interface GetListenerDefaultActionAuthenticateOidc {
        authenticationRequestExtraParams: {[key: string]: string};
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        tokenEndpoint: string;
        userInfoEndpoint: string;
    }

    export interface GetListenerDefaultActionFixedResponse {
        contentType: string;
        messageBody: string;
        statusCode: string;
    }

    export interface GetListenerDefaultActionForward {
        stickinesses: outputs.alb.GetListenerDefaultActionForwardStickiness[];
        targetGroups: outputs.alb.GetListenerDefaultActionForwardTargetGroup[];
    }

    export interface GetListenerDefaultActionForwardStickiness {
        duration: number;
        enabled: boolean;
    }

    export interface GetListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the listener. Required if `loadBalancerArn` and `port` is not set.
         */
        arn: string;
        weight: number;
    }

    export interface GetListenerDefaultActionRedirect {
        host: string;
        path: string;
        /**
         * Port of the listener. Required if `arn` is not set.
         */
        port: string;
        protocol: string;
        query: string;
        statusCode: string;
    }

    export interface GetLoadBalancerAccessLogs {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }

    export interface GetLoadBalancerSubnetMapping {
        allocationId: string;
        ipv6Address: string;
        outpostId: string;
        privateIpv4Address: string;
        subnetId: string;
    }

    export interface GetTargetGroupHealthCheck {
        enabled: boolean;
        healthyThreshold: number;
        interval: number;
        matcher: string;
        path: string;
        port: string;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface GetTargetGroupStickiness {
        cookieDuration: number;
        cookieName: string;
        enabled: boolean;
        type: string;
    }

    export interface ListenerDefaultAction {
        /**
         * Configuration block for using Amazon Cognito to authenticate users. Specify only when `type` is `authenticate-cognito`. Detailed below.
         */
        authenticateCognito?: outputs.alb.ListenerDefaultActionAuthenticateCognito;
        /**
         * Configuration block for an identity provider that is compliant with OpenID Connect (OIDC). Specify only when `type` is `authenticate-oidc`. Detailed below.
         */
        authenticateOidc?: outputs.alb.ListenerDefaultActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.alb.ListenerDefaultActionFixedResponse;
        /**
         * Configuration block for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`. Detailed below.
         */
        forward?: outputs.alb.ListenerDefaultActionForward;
        /**
         * Order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first. Valid values are between `1` and `50000`.
         */
        order: number;
        /**
         * Configuration block for creating a redirect action. Required if `type` is `redirect`. Detailed below.
         */
        redirect?: outputs.alb.ListenerDefaultActionRedirect;
        /**
         * ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * Type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         *
         * The following arguments are optional:
         */
        type: string;
    }

    export interface ListenerDefaultActionAuthenticateCognito {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10. Detailed below.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * Behavior if the user is not authenticated. Valid values are `deny`, `allow` and `authenticate`.
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * Domain prefix or fully-qualified domain name of the Cognito user pool.
         *
         * The following arguments are optional:
         */
        userPoolDomain: string;
    }

    export interface ListenerDefaultActionAuthenticateOidc {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * Authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * Behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * Token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * User info endpoint of the IdP.
         *
         * The following arguments are optional:
         */
        userInfoEndpoint: string;
    }

    export interface ListenerDefaultActionFixedResponse {
        /**
         * Content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         *
         * The following arguments are optional:
         */
        contentType: string;
        /**
         * Message body.
         */
        messageBody?: string;
        /**
         * HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }

    export interface ListenerDefaultActionForward {
        /**
         * Configuration block for target group stickiness for the rule. Detailed below.
         */
        stickiness?: outputs.alb.ListenerDefaultActionForwardStickiness;
        /**
         * Set of 1-5 target group blocks. Detailed below.
         *
         * The following arguments are optional:
         */
        targetGroups: outputs.alb.ListenerDefaultActionForwardTargetGroup[];
    }

    export interface ListenerDefaultActionForwardStickiness {
        /**
         * Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         *
         * The following arguments are optional:
         */
        duration: number;
        /**
         * Whether target group stickiness is enabled. Default is `false`.
         */
        enabled?: boolean;
    }

    export interface ListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the target group.
         *
         * The following arguments are optional:
         */
        arn: string;
        /**
         * Weight. The range is 0 to 999.
         */
        weight?: number;
    }

    export interface ListenerDefaultActionRedirect {
        /**
         * Hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * Port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * Protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         *
         * The following arguments are optional:
         */
        statusCode: string;
    }

    export interface ListenerRuleAction {
        /**
         * Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
         */
        authenticateCognito?: outputs.alb.ListenerRuleActionAuthenticateCognito;
        /**
         * Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
         */
        authenticateOidc?: outputs.alb.ListenerRuleActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.alb.ListenerRuleActionFixedResponse;
        /**
         * Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`.
         */
        forward?: outputs.alb.ListenerRuleActionForward;
        order: number;
        /**
         * Information for creating a redirect action. Required if `type` is `redirect`.
         */
        redirect?: outputs.alb.ListenerRuleActionRedirect;
        /**
         * The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         */
        type: string;
    }

    export interface ListenerRuleActionAuthenticateCognito {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * The ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * The domain prefix or fully-qualified domain name of the Cognito user pool.
         */
        userPoolDomain: string;
    }

    export interface ListenerRuleActionAuthenticateOidc {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * The authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * The OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * The OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * The user info endpoint of the IdP.
         */
        userInfoEndpoint: string;
    }

    export interface ListenerRuleActionFixedResponse {
        /**
         * The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         */
        contentType: string;
        /**
         * The message body.
         */
        messageBody?: string;
        /**
         * The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }

    export interface ListenerRuleActionForward {
        /**
         * The target group stickiness for the rule.
         */
        stickiness?: outputs.alb.ListenerRuleActionForwardStickiness;
        /**
         * One or more target groups block.
         */
        targetGroups: outputs.alb.ListenerRuleActionForwardTargetGroup[];
    }

    export interface ListenerRuleActionForwardStickiness {
        /**
         * The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         */
        duration: number;
        /**
         * Indicates whether target group stickiness is enabled.
         */
        enabled?: boolean;
    }

    export interface ListenerRuleActionForwardTargetGroup {
        /**
         * The Amazon Resource Name (ARN) of the target group.
         */
        arn: string;
        /**
         * The weight. The range is 0 to 999.
         */
        weight?: number;
    }

    export interface ListenerRuleActionRedirect {
        /**
         * The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         */
        statusCode: string;
    }

    export interface ListenerRuleCondition {
        /**
         * Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
         */
        hostHeader?: outputs.alb.ListenerRuleConditionHostHeader;
        /**
         * HTTP headers to match. HTTP Header block fields documented below.
         */
        httpHeader?: outputs.alb.ListenerRuleConditionHttpHeader;
        /**
         * Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         */
        httpRequestMethod?: outputs.alb.ListenerRuleConditionHttpRequestMethod;
        /**
         * Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `queryString` condition.
         */
        pathPattern?: outputs.alb.ListenerRuleConditionPathPattern;
        /**
         * Query strings to match. Query String block fields documented below.
         */
        queryStrings?: outputs.alb.ListenerRuleConditionQueryString[];
        /**
         * Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         *
         * > **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         */
        sourceIp?: outputs.alb.ListenerRuleConditionSourceIp;
    }

    export interface ListenerRuleConditionHostHeader {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionHttpHeader {
        /**
         * Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
         */
        httpHeaderName: string;
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         */
        values: string[];
    }

    export interface ListenerRuleConditionHttpRequestMethod {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionPathPattern {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionQueryString {
        /**
         * Query string key pattern to match.
         */
        key?: string;
        /**
         * Query string value pattern to match.
         */
        value: string;
    }

    export interface ListenerRuleConditionSourceIp {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface LoadBalancerAccessLogs {
        /**
         * The S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `accessLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * The S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }

    export interface LoadBalancerSubnetMapping {
        /**
         * The allocation ID of the Elastic IP address for an internet-facing load balancer.
         */
        allocationId?: string;
        /**
         * The IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
         */
        ipv6Address?: string;
        outpostId: string;
        /**
         * The private IPv4 address for an internal load balancer.
         */
        privateIpv4Address?: string;
        /**
         * ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
         */
        subnetId: string;
    }

    export interface TargetGroupHealthCheck {
        /**
         * Whether health checks are enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
         */
        healthyThreshold?: number;
        /**
         * Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For `lambda` target groups, it needs to be greater than the timeout of the underlying `lambda`. Defaults to 30.
         */
        interval?: number;
        /**
         * Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s) or "0,12" for GRPC) or a range of values (for example, "200-299" or "0-99"). Required for HTTP/HTTPS/GRPC ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS/GRPC) not Network Load Balancers (i.e., TCP).
         */
        matcher: string;
        /**
         * Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
         */
        path: string;
        /**
         * The port the load balancer uses when performing health checks on targets. Default is traffic-port.
         */
        port?: string;
        /**
         * Protocol the load balancer uses when performing health checks on targets. Must be either `TCP`, `HTTP`, or `HTTPS`. The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS. Defaults to HTTP.
         */
        protocol?: string;
        /**
         * Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
         */
        timeout: number;
        /**
         * Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
         */
        unhealthyThreshold?: number;
    }

    export interface TargetGroupStickiness {
        /**
         * Only used when the type is `lbCookie`. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
         */
        cookieDuration?: number;
        /**
         * Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is `appCookie`.
         */
        cookieName?: string;
        /**
         * Boolean to enable / disable `stickiness`. Default is `true`.
         */
        enabled?: boolean;
        /**
         * The type of sticky sessions. The only current possible values are `lbCookie`, `appCookie` for ALBs, `sourceIp` for NLBs, and `sourceIpDestIp`, `sourceIpDestIpProto` for GWLBs.
         */
        type: string;
    }

    export interface TargetGroupTargetFailover {
        /**
         * Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onUnhealthy`. Default: `noRebalance`.
         */
        onDeregistration: string;
        /**
         * Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onDeregistration`. Default: `noRebalance`.
         */
        onUnhealthy: string;
    }

}

export namespace amp {
    export interface WorkspaceLoggingConfiguration {
        /**
         * The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
         */
        logGroupArn: string;
    }

}

export namespace amplify {
    export interface AppAutoBranchCreationConfig {
        /**
         * Basic authorization credentials for the autocreated branch.
         */
        basicAuthCredentials?: string;
        /**
         * Build specification (build spec) for the autocreated branch.
         */
        buildSpec?: string;
        /**
         * Enables auto building for the autocreated branch.
         */
        enableAutoBuild?: boolean;
        /**
         * Enables basic authorization for the autocreated branch.
         */
        enableBasicAuth?: boolean;
        /**
         * Enables performance mode for the branch.
         */
        enablePerformanceMode?: boolean;
        /**
         * Enables pull request previews for the autocreated branch.
         */
        enablePullRequestPreview?: boolean;
        /**
         * Environment variables for the autocreated branch.
         */
        environmentVariables?: {[key: string]: string};
        /**
         * Framework for the autocreated branch.
         */
        framework?: string;
        /**
         * Amplify environment name for the pull request.
         */
        pullRequestEnvironmentName?: string;
        /**
         * Describes the current stage for the autocreated branch. Valid values: `PRODUCTION`, `BETA`, `DEVELOPMENT`, `EXPERIMENTAL`, `PULL_REQUEST`.
         */
        stage?: string;
    }

    export interface AppCustomRule {
        /**
         * Condition for a URL rewrite or redirect rule, such as a country code.
         */
        condition?: string;
        /**
         * Source pattern for a URL rewrite or redirect rule.
         */
        source: string;
        /**
         * Status code for a URL rewrite or redirect rule. Valid values: `200`, `301`, `302`, `404`, `404-200`.
         */
        status?: string;
        /**
         * Target pattern for a URL rewrite or redirect rule.
         */
        target: string;
    }

    export interface AppProductionBranch {
        /**
         * Branch name for the production branch.
         */
        branchName: string;
        /**
         * Last deploy time of the production branch.
         */
        lastDeployTime: string;
        /**
         * Status code for a URL rewrite or redirect rule. Valid values: `200`, `301`, `302`, `404`, `404-200`.
         */
        status: string;
        /**
         * Thumbnail URL for the production branch.
         */
        thumbnailUrl: string;
    }

    export interface DomainAssociationSubDomain {
        /**
         * Branch name setting for the subdomain.
         */
        branchName: string;
        /**
         * DNS record for the subdomain.
         */
        dnsRecord: string;
        /**
         * Prefix setting for the subdomain.
         */
        prefix: string;
        /**
         * Verified status of the subdomain.
         */
        verified: boolean;
    }

}

export namespace apigateway {
    export interface AccountThrottleSetting {
        /**
         * Absolute maximum number of times API Gateway allows the API to be called per second (RPS).
         */
        burstLimit: number;
        /**
         * Number of times API Gateway allows the API to be called per second on average (RPS).
         */
        rateLimit: number;
    }

    export interface DocumentationPartLocation {
        /**
         * HTTP verb of a method. The default value is `*` for any method.
         */
        method?: string;
        /**
         * Name of the targeted API entity.
         */
        name?: string;
        /**
         * URL path of the target. The default value is `/` for the root resource.
         */
        path?: string;
        /**
         * HTTP status code of a response. The default value is `*` for any status code.
         */
        statusCode?: string;
        /**
         * Type of API entity to which the documentation content appliesE.g., `API`, `METHOD` or `REQUEST_BODY`
         */
        type: string;
    }

    export interface DomainNameEndpointConfiguration {
        /**
         * List of endpoint types. This resource currently only supports managing a single value. Valid values: `EDGE` or `REGIONAL`. If unspecified, defaults to `EDGE`. Must be declared as `REGIONAL` in non-Commercial partitions. Refer to the [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/create-regional-api.html) for more information on the difference between edge-optimized and regional APIs.
         */
        types: string;
    }

    export interface DomainNameMutualTlsAuthentication {
        /**
         * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
         */
        truststoreUri: string;
        /**
         * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
         */
        truststoreVersion?: string;
    }

    export interface GetDomainNameEndpointConfiguration {
        /**
         * List of endpoint types.
         */
        types: string[];
    }

    export interface GetRestApiEndpointConfiguration {
        types: string[];
        vpcEndpointIds: string[];
    }

    export interface IntegrationTlsConfig {
        /**
         * Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a [supported certificate authority](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-supported-certificate-authorities-for-http-endpoints.html). This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for `HTTP` and `HTTP_PROXY` integrations.
         */
        insecureSkipVerification?: boolean;
    }

    export interface MethodSettingsSettings {
        /**
         * Whether the cached responses are encrypted.
         */
        cacheDataEncrypted: boolean;
        /**
         * Time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
         */
        cacheTtlInSeconds: number;
        /**
         * Whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
         */
        cachingEnabled: boolean;
        /**
         * Whether data trace logging is enabled for this method, which effects the log entries pushed to Amazon CloudWatch Logs.
         */
        dataTraceEnabled: boolean;
        /**
         * Logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. The available levels are `OFF`, `ERROR`, and `INFO`.
         */
        loggingLevel: string;
        /**
         * Whether Amazon CloudWatch metrics are enabled for this method.
         */
        metricsEnabled: boolean;
        /**
         * Whether authorization is required for a cache invalidation request.
         */
        requireAuthorizationForCacheControl: boolean;
        /**
         * Throttling burst limit. Default: `-1` (throttling disabled).
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit. Default: `-1` (throttling disabled).
         */
        throttlingRateLimit?: number;
        /**
         * How to handle unauthorized requests for cache invalidation. The available values are `FAIL_WITH_403`, `SUCCEED_WITH_RESPONSE_HEADER`, `SUCCEED_WITHOUT_RESPONSE_HEADER`.
         */
        unauthorizedCacheControlHeaderStrategy: string;
    }

    export interface RestApiEndpointConfiguration {
        /**
         * List of endpoint types. This resource currently only supports managing a single value. Valid values: `EDGE`, `REGIONAL` or `PRIVATE`. If unspecified, defaults to `EDGE`. If set to `PRIVATE` recommend to set `putRestApiMode` = `merge` to not cause the endpoints and associated Route53 records to be deleted. Refer to the [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/create-regional-api.html) for more information on the difference between edge-optimized and regional APIs.
         */
        types: string;
        /**
         * Set of VPC Endpoint identifiers. It is only supported for `PRIVATE` endpoint type. If importing an OpenAPI specification via the `body` argument, this corresponds to the [`x-amazon-apigateway-endpoint-configuration` extension `vpcEndpointIds` property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-endpoint-configuration.html). If the argument value is provided and is different than the OpenAPI value, **the argument value will override the OpenAPI value**.
         */
        vpcEndpointIds: string[];
    }

    export interface StageAccessLogSettings {
        /**
         * ARN of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with `amazon-apigateway-`. Automatically removes trailing `:*` if present.
         */
        destinationArn: string;
        /**
         * Formatting and values recorded in the logs.
         * For more information on configuring the log format rules visit the AWS [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html)
         */
        format: string;
    }

    export interface StageCanarySettings {
        /**
         * Percent `0.0` - `100.0` of traffic to divert to the canary deployment.
         */
        percentTraffic?: number;
        /**
         * Map of overridden stage `variables` (including new variables) for the canary deployment.
         */
        stageVariableOverrides?: {[key: string]: string};
        /**
         * Whether the canary deployment uses the stage cache. Defaults to false.
         */
        useStageCache?: boolean;
    }

    export interface UsagePlanApiStage {
        /**
         * API Id of the associated API stage in a usage plan.
         */
        apiId: string;
        /**
         * API stage name of the associated API stage in a usage plan.
         */
        stage: string;
        /**
         * The throttling limits of the usage plan.
         */
        throttles?: outputs.apigateway.UsagePlanApiStageThrottle[];
    }

    export interface UsagePlanApiStageThrottle {
        /**
         * The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
         */
        burstLimit?: number;
        /**
         * Method to apply the throttle settings for. Specfiy the path and method, for example `/test/GET`.
         */
        path: string;
        /**
         * The API request steady-state rate limit.
         */
        rateLimit?: number;
    }

    export interface UsagePlanQuotaSettings {
        /**
         * Maximum number of requests that can be made in a given time period.
         */
        limit: number;
        /**
         * Number of requests subtracted from the given limit in the initial time period.
         */
        offset?: number;
        /**
         * Time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
         */
        period: string;
    }

    export interface UsagePlanThrottleSettings {
        /**
         * The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
         */
        burstLimit?: number;
        /**
         * The API request steady-state rate limit.
         */
        rateLimit?: number;
    }

}

export namespace apigatewayv2 {
    export interface ApiCorsConfiguration {
        /**
         * Whether credentials are included in the CORS request.
         */
        allowCredentials?: boolean;
        /**
         * Set of allowed HTTP headers.
         */
        allowHeaders?: string[];
        /**
         * Set of allowed HTTP methods.
         */
        allowMethods?: string[];
        /**
         * Set of allowed origins.
         */
        allowOrigins?: string[];
        /**
         * Set of exposed HTTP headers.
         */
        exposeHeaders?: string[];
        /**
         * Number of seconds that the browser should cache preflight request results.
         */
        maxAge?: number;
    }

    export interface AuthorizerJwtConfiguration {
        /**
         * List of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.
         */
        audiences?: string[];
        /**
         * Base domain of the identity provider that issues JSON Web Tokens, such as the `endpoint` attribute of the `aws.cognito.UserPool` resource.
         */
        issuer?: string;
    }

    export interface DomainNameDomainNameConfiguration {
        /**
         * ARN of an AWS-managed certificate that will be used by the endpoint for the domain name. AWS Certificate Manager is the only supported source. Use the `aws.acm.Certificate` resource to configure an ACM certificate.
         */
        certificateArn: string;
        /**
         * Endpoint type. Valid values: `REGIONAL`.
         */
        endpointType: string;
        /**
         * Amazon Route 53 Hosted Zone ID of the endpoint.
         */
        hostedZoneId: string;
        /**
         * ARN of the AWS-issued certificate used to validate custom domain ownership (when `certificateArn` is issued via an ACM Private CA or `mutualTlsAuthentication` is configured with an ACM-imported certificate.)
         */
        ownershipVerificationCertificateArn: string;
        /**
         * Transport Layer Security (TLS) version of the [security policy](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-custom-domain-tls-version.html) for the domain name. Valid values: `TLS_1_2`.
         */
        securityPolicy: string;
        /**
         * Target domain name.
         */
        targetDomainName: string;
    }

    export interface DomainNameMutualTlsAuthentication {
        /**
         * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
         */
        truststoreUri: string;
        /**
         * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
         */
        truststoreVersion?: string;
    }

    export interface GetApiCorsConfiguration {
        /**
         * Whether credentials are included in the CORS request.
         */
        allowCredentials: boolean;
        /**
         * Set of allowed HTTP headers.
         */
        allowHeaders: string[];
        /**
         * Set of allowed HTTP methods.
         */
        allowMethods: string[];
        /**
         * Set of allowed origins.
         */
        allowOrigins: string[];
        /**
         * Set of exposed HTTP headers.
         */
        exposeHeaders: string[];
        /**
         * Number of seconds that the browser should cache preflight request results.
         */
        maxAge: number;
    }

    export interface IntegrationResponseParameter {
        /**
         * Key-value map. The key of this map identifies the location of the request parameter to change, and how to change it. The corresponding value specifies the new data for the parameter.
         * See the [Amazon API Gateway Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html) for details.
         */
        mappings: {[key: string]: string};
        /**
         * HTTP status code in the range 200-599.
         */
        statusCode: string;
    }

    export interface IntegrationTlsConfig {
        /**
         * If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
         */
        serverNameToVerify?: string;
    }

    export interface RouteRequestParameter {
        /**
         * Request parameter key. This is a [request data mapping parameter](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-data-mapping.html#websocket-mapping-request-parameters).
         */
        requestParameterKey: string;
        /**
         * Boolean whether or not the parameter is required.
         */
        required: boolean;
    }

    export interface StageAccessLogSettings {
        /**
         * ARN of the CloudWatch Logs log group to receive access logs. Any trailing `:*` is trimmed from the ARN.
         */
        destinationArn: string;
        /**
         * Single line [format](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html#apigateway-cloudwatch-log-formats) of the access logs of data. Refer to log settings for [HTTP](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-logging-variables.html) or [Websocket](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-logging.html).
         */
        format: string;
    }

    export interface StageDefaultRouteSettings {
        /**
         * Whether data trace logging is enabled for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Defaults to `false`. Supported only for WebSocket APIs.
         */
        dataTraceEnabled?: boolean;
        /**
         * Whether detailed metrics are enabled for the default route. Defaults to `false`.
         */
        detailedMetricsEnabled?: boolean;
        /**
         * Logging level for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
         */
        loggingLevel: string;
        /**
         * Throttling burst limit for the default route.
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit for the default route.
         */
        throttlingRateLimit?: number;
    }

    export interface StageRouteSetting {
        /**
         * Whether data trace logging is enabled for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Defaults to `false`. Supported only for WebSocket APIs.
         */
        dataTraceEnabled?: boolean;
        /**
         * Whether detailed metrics are enabled for the route. Defaults to `false`.
         */
        detailedMetricsEnabled?: boolean;
        /**
         * Logging level for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
         */
        loggingLevel: string;
        /**
         * Route key.
         */
        routeKey: string;
        /**
         * Throttling burst limit for the route.
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit for the route.
         */
        throttlingRateLimit?: number;
    }

}

export namespace appautoscaling {
    export interface PolicyStepScalingPolicyConfiguration {
        /**
         * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are `ChangeInCapacity`, `ExactCapacity`, and `PercentChangeInCapacity`.
         */
        adjustmentType?: string;
        /**
         * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown?: number;
        /**
         * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
         */
        metricAggregationType?: string;
        /**
         * Minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
         */
        minAdjustmentMagnitude?: number;
        /**
         * Set of adjustments that manage scaling. These have the following structure:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const ecsPolicy = new aws.appautoscaling.Policy("ecsPolicy", {stepScalingPolicyConfiguration: {
         *     stepAdjustments: [
         *         {
         *             metricIntervalLowerBound: "1",
         *             metricIntervalUpperBound: "2",
         *             scalingAdjustment: -1,
         *         },
         *         {
         *             metricIntervalLowerBound: "2",
         *             metricIntervalUpperBound: "3",
         *             scalingAdjustment: 1,
         *         },
         *     ],
         * }});
         * ```
         */
        stepAdjustments?: outputs.appautoscaling.PolicyStepScalingPolicyConfigurationStepAdjustment[];
    }

    export interface PolicyStepScalingPolicyConfigurationStepAdjustment {
        /**
         * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
         */
        metricIntervalLowerBound?: string;
        /**
         * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as infinity. The upper bound must be greater than the lower bound.
         */
        metricIntervalUpperBound?: string;
        /**
         * Number of members by which to scale, when the adjustment bounds are breached. A positive value scales up. A negative value scales down.
         */
        scalingAdjustment: number;
    }

    export interface PolicyTargetTrackingScalingPolicyConfiguration {
        /**
         * Custom CloudWatch metric. Documentation can be found  at: [AWS Customized Metric Specification](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_CustomizedMetricSpecification.html). See supported fields below.
         */
        customizedMetricSpecification?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification;
        /**
         * Whether scale in by the target tracking policy is disabled. If the value is true, scale in is disabled and the target tracking policy won't remove capacity from the scalable resource. Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource. The default value is `false`.
         */
        disableScaleIn?: boolean;
        /**
         * Predefined metric. See supported fields below.
         */
        predefinedMetricSpecification?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification;
        /**
         * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
         */
        scaleInCooldown?: number;
        /**
         * Amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
         */
        scaleOutCooldown?: number;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification {
        /**
         * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
         */
        dimensions?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension[];
        /**
         * Name of the metric.
         */
        metricName?: string;
        /**
         * Metrics to include, as a metric data query.
         */
        metrics?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetric[];
        /**
         * Namespace of the metric.
         */
        namespace?: string;
        /**
         * Statistic of the metric. Valid values: `Average`, `Minimum`, `Maximum`, `SampleCount`, and `Sum`.
         */
        statistic?: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension {
        /**
         * Name of the policy. Must be between 1 and 255 characters in length.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetric {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in target tracking scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetric {
        /**
         * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
         */
        dimensions?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension {
        /**
         * Name of the policy. Must be between 1 and 255 characters in length.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification {
        /**
         * Metric type.
         */
        predefinedMetricType: string;
        /**
         * Reserved for future use if the `predefinedMetricType` is not `ALBRequestCountPerTarget`. If the `predefinedMetricType` is `ALBRequestCountPerTarget`, you must specify this argument. Documentation can be found at: [AWS Predefined Scaling Metric Specification](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedScalingMetricSpecification.html). Must be less than or equal to 1023 characters in length.
         */
        resourceLabel?: string;
    }

    export interface ScheduledActionScalableTargetAction {
        /**
         * Maximum capacity. At least one of `maxCapacity` or `minCapacity` must be set.
         */
        maxCapacity?: number;
        /**
         * Minimum capacity. At least one of `minCapacity` or `maxCapacity` must be set.
         */
        minCapacity?: number;
    }

}

export namespace appconfig {
    export interface ConfigurationProfileValidator {
        /**
         * Either the JSON Schema content or the ARN of an AWS Lambda function.
         */
        content?: string;
        /**
         * Type of validator. Valid values: `JSON_SCHEMA` and `LAMBDA`.
         */
        type: string;
    }

    export interface EnvironmentMonitor {
        /**
         * ARN of the Amazon CloudWatch alarm.
         */
        alarmArn: string;
        /**
         * ARN of an IAM role for AWS AppConfig to monitor `alarmArn`.
         */
        alarmRoleArn?: string;
    }

    export interface EventIntegrationEventFilter {
        /**
         * Source of the events.
         */
        source: string;
    }

    export interface ExtensionActionPoint {
        /**
         * An action defines the tasks the extension performs during the AppConfig workflow. Detailed below.
         */
        actions: outputs.appconfig.ExtensionActionPointAction[];
        /**
         * The point at which to perform the defined actions. Valid points are `PRE_CREATE_HOSTED_CONFIGURATION_VERSION`, `PRE_START_DEPLOYMENT`, `ON_DEPLOYMENT_START`, `ON_DEPLOYMENT_STEP`, `ON_DEPLOYMENT_BAKING`, `ON_DEPLOYMENT_COMPLETE`, `ON_DEPLOYMENT_ROLLED_BACK`.
         */
        point: string;
    }

    export interface ExtensionActionPointAction {
        /**
         * Information about the action.
         */
        description?: string;
        /**
         * The action name.
         */
        name: string;
        /**
         * An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
         */
        roleArn: string;
        /**
         * The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
         */
        uri: string;
    }

    export interface ExtensionParameter {
        /**
         * Information about the parameter.
         */
        description?: string;
        /**
         * The parameter name.
         */
        name: string;
        /**
         * Determines if a parameter value must be specified in the extension association.
         */
        required?: boolean;
    }

    export interface GetConfigurationProfileValidator {
        /**
         * Either the JSON Schema content or the ARN of an AWS Lambda function.
         */
        content: string;
        /**
         * Type of validator. Valid values: JSON_SCHEMA and LAMBDA.
         */
        type: string;
    }

    export interface GetEnvironmentMonitor {
        /**
         * ARN of the Amazon CloudWatch alarm.
         */
        alarmArn: string;
        /**
         * ARN of an IAM role for AWS AppConfig to monitor.
         */
        alarmRoleArn: string;
    }

}

export namespace appflow {
    export interface ConnectorProfileConnectorProfileConfig {
        /**
         * The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
         */
        connectorProfileCredentials: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials;
        /**
         * The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
         */
        connectorProfileProperties: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileProperties;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentials {
        /**
         * The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
         */
        amplitude?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude;
        /**
         * The connector-specific profile credentials required when using the custom connector. See Custom Connector Profile Credentials for more details.
         */
        customConnector?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector;
        /**
         * Connector-specific credentials required when using Datadog. See Datadog Connector Profile Credentials for more details.
         */
        datadog?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog;
        /**
         * The connector-specific credentials required when using Dynatrace. See Dynatrace Connector Profile Credentials for more details.
         */
        dynatrace?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace;
        /**
         * The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
         */
        googleAnalytics?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics;
        /**
         * The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
         */
        honeycode?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode;
        /**
         * The connector-specific credentials required when using Infor Nexus. See Infor Nexus Connector Profile Credentials for more details.
         */
        inforNexus?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus;
        /**
         * Connector-specific credentials required when using Marketo. See Marketo Connector Profile Credentials for more details.
         */
        marketo?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo;
        /**
         * Connector-specific credentials required when using Amazon Redshift. See Redshift Connector Profile Credentials for more details.
         */
        redshift?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift;
        /**
         * The connector-specific credentials required when using Salesforce. See Salesforce Connector Profile Credentials for more details.
         */
        salesforce?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce;
        /**
         * The connector-specific credentials required when using SAPOData. See SAPOData Connector Profile Credentials for more details.
         */
        sapoData?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData;
        /**
         * The connector-specific credentials required when using ServiceNow. See ServiceNow Connector Profile Credentials for more details.
         */
        serviceNow?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow;
        /**
         * Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
         */
        singular?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular;
        /**
         * Connector-specific credentials required when using Slack. See Slack Connector Profile Credentials for more details.
         */
        slack?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack;
        /**
         * The connector-specific credentials required when using Snowflake. See Snowflake Connector Profile Credentials for more details.
         */
        snowflake?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake;
        /**
         * The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
         */
        trendmicro?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro;
        /**
         * Connector-specific credentials required when using Veeva. See Veeva Connector Profile Credentials for more details.
         */
        veeva?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva;
        /**
         * Connector-specific credentials required when using Zendesk. See Zendesk Connector Profile Credentials for more details.
         */
        zendesk?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude {
        /**
         * Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        /**
         * The Secret Access Key portion of the credentials.
         */
        secretKey: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector {
        /**
         * Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey;
        /**
         * The authentication type that the custom connector uses for authenticating while creating a connector profile. One of: `APIKEY`, `BASIC`, `CUSTOM`, `OAUTH2`.
         */
        authenticationType: string;
        /**
         * Basic credentials that are required for the authentication of the user.
         */
        basic?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic;
        /**
         * If the connector uses the custom authentication mechanism, this holds the required credentials.
         */
        custom?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom;
        /**
         * OAuth 2.0 credentials required for the authentication of the user.
         */
        oauth2?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey {
        /**
         * Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        /**
         * The API secret key required for API key authentication.
         */
        apiSecretKey?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom {
        /**
         * A map that holds custom authentication credentials.
         */
        credentialsMap?: {[key: string]: string};
        /**
         * The custom authentication type that the connector uses.
         */
        customAuthenticationType: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2 {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId?: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret?: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest;
        /**
         * The refresh token used to refresh an expired access token.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog {
        /**
         * Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        /**
         * Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
         */
        applicationKey: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace {
        /**
         * The API tokens used by Dynatrace API to authenticate various API calls.
         */
        apiToken: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest;
        /**
         * The refresh token used to refresh an expired access token.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest;
        /**
         * The refresh token used to refresh an expired access token.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus {
        /**
         * The Access Key portion of the credentials.
         */
        accessKeyId: string;
        /**
         * Encryption keys used to encrypt data.
         */
        datakey: string;
        /**
         * The secret key used to sign requests.
         */
        secretAccessKey: string;
        /**
         * Identifier for the user.
         */
        userId: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The secret manager ARN, which contains the client ID and client secret of the connected app.
         */
        clientCredentialsArn?: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest;
        /**
         * The refresh token used to refresh an expired access token.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData {
        /**
         * The SAPOData basic authentication credentials.
         */
        basicAuthCredentials?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials;
        /**
         * The SAPOData OAuth type authentication credentials.
         */
        oauthCredentials?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest;
        /**
         * The refresh token used to refresh an expired access token.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular {
        /**
         * Unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro {
        /**
         * The API secret key required for API key authentication.
         */
        apiSecretKey: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva {
        /**
         * The password to use to connect to a resource.
         */
        password: string;
        /**
         * The username to use to connect to a resource.
         */
        username: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk {
        /**
         * The access token used to access the connector on your behalf.
         */
        accessToken?: string;
        /**
         * The identifier for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the OAuth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * Used by select connectors for which the OAuth workflow is supported. See OAuth Request for more details.
         */
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfileProperties {
        /**
         * The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
         */
        amplitude?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude;
        /**
         * The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
         */
        customConnector?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector;
        /**
         * Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
         */
        datadog?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog;
        /**
         * The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
         */
        dynatrace?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace;
        /**
         * The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
         */
        googleAnalytics?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics;
        /**
         * The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
         */
        honeycode?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode;
        /**
         * The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
         */
        inforNexus?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus;
        /**
         * Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
         */
        marketo?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo;
        /**
         * Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
         */
        redshift?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift;
        /**
         * The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
         */
        salesforce?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce;
        /**
         * The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
         */
        sapoData?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData;
        /**
         * The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
         */
        serviceNow?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow;
        /**
         * Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
         */
        singular?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular;
        /**
         * Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
         */
        slack?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack;
        /**
         * The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
         */
        snowflake?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake;
        /**
         * The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
         */
        trendmicro?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro;
        /**
         * Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
         */
        veeva?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva;
        /**
         * Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
         */
        zendesk?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude {
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector {
        /**
         * The OAuth 2.0 properties required for OAuth 2.0 authentication.
         */
        oauth2Properties?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties;
        /**
         * A map of properties that are required to create a profile for the custom connector.
         */
        profileProperties?: {[key: string]: string};
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties {
        /**
         * The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication. One of: `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`.
         */
        oauth2GrantType: string;
        /**
         * The token URL required for OAuth 2.0 authentication.
         */
        tokenUrl: string;
        /**
         * Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
         */
        tokenUrlCustomProperties?: {[key: string]: string};
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics {
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode {
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift {
        /**
         * A name for the associated Amazon S3 bucket.
         */
        bucketName: string;
        /**
         * The object key for the destination bucket in which Amazon AppFlow places the files.
         */
        bucketPrefix?: string;
        /**
         * The unique ID that's assigned to an Amazon Redshift cluster.
         */
        clusterIdentifier?: string;
        /**
         * ARN of the IAM role that permits AppFlow to access the database through Data API.
         */
        dataApiRoleArn?: string;
        /**
         * The name of an Amazon Redshift database.
         */
        databaseName?: string;
        /**
         * The JDBC URL of the Amazon Redshift cluster.
         */
        databaseUrl?: string;
        /**
         * ARN of the IAM role.
         */
        roleArn: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl?: string;
        /**
         * Indicates whether the connector profile applies to a sandbox or production environment.
         */
        isSandboxEnvironment?: boolean;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData {
        /**
         * The location of the SAPOData resource.
         */
        applicationHostUrl: string;
        /**
         * The application path to catalog service.
         */
        applicationServicePath: string;
        /**
         * The client number for the client creating the connection.
         */
        clientNumber: string;
        /**
         * The logon language of SAPOData instance.
         */
        logonLanguage?: string;
        /**
         * The SAPOData OAuth properties required for OAuth type authentication.
         */
        oauthProperties?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties;
        /**
         * The port number of the SAPOData instance.
         */
        portNumber: number;
        /**
         * The SAPOData Private Link service name to be used for private data transfers.
         */
        privateLinkServiceName?: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties {
        /**
         * The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
         */
        authCodeUrl: string;
        /**
         * The OAuth scopes required for OAuth type authentication.
         */
        oauthScopes: string[];
        /**
         * The token URL required for OAuth 2.0 authentication.
         */
        tokenUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular {
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake {
        /**
         * The name of the account.
         */
        accountName?: string;
        /**
         * A name for the associated Amazon S3 bucket.
         */
        bucketName: string;
        /**
         * The object key for the destination bucket in which Amazon AppFlow places the files.
         */
        bucketPrefix?: string;
        /**
         * The SAPOData Private Link service name to be used for private data transfers.
         */
        privateLinkServiceName?: string;
        /**
         * AWS Region of the Snowflake account.
         */
        region?: string;
        /**
         * Name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: `<Database>.<Schema>.<Stage Name>`.
         */
        stage: string;
        /**
         * The name of the Snowflake warehouse.
         */
        warehouse: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro {
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk {
        /**
         * The location of the Datadog resource.
         */
        instanceUrl: string;
    }

    export interface FlowDestinationFlowConfig {
        /**
         * API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
         */
        connectorProfileName?: string;
        /**
         * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
         */
        connectorType: string;
        /**
         * This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
         */
        destinationConnectorProperties: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorProperties;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorProperties {
        /**
         * Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
         */
        customConnector?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector;
        /**
         * Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
         */
        customerProfiles?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles;
        /**
         * Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
         */
        eventBridge?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge;
        /**
         * Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
         */
        honeycode?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode;
        lookoutMetrics?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics;
        /**
         * Properties that are required to query Marketo. See Generic Destination Properties for more details.
         */
        marketo?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo;
        /**
         * Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
         */
        redshift?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift;
        /**
         * Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
         */
        s3?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3;
        /**
         * Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
         */
        salesforce?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce;
        /**
         * Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
         */
        sapoData?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData;
        /**
         * Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
         */
        snowflake?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake;
        /**
         * Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
         */
        upsolver?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver;
        /**
         * Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
         */
        zendesk?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector {
        /**
         * Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
         */
        customProperties?: {[key: string]: string};
        /**
         * Entity specified in the custom connector as a destination in the flow.
         */
        entityName: string;
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig;
        /**
         * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
         */
        idFieldNames?: string[];
        /**
         * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
         */
        writeOperationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles {
        /**
         * Unique name of the Amazon Connect Customer Profiles domain.
         */
        domainName: string;
        /**
         * Object specified in the Amazon Connect Customer Profiles flow destination.
         */
        objectTypeName?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics {
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift {
        /**
         * Object key for the bucket in which Amazon AppFlow places the destination files.
         */
        bucketPrefix?: string;
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig;
        /**
         * Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
         */
        intermediateBucketName: string;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3 {
        /**
         * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
         */
        bucketName: string;
        /**
         * Object key for the bucket in which Amazon AppFlow places the destination files.
         */
        bucketPrefix?: string;
        /**
         * Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
         */
        s3OutputFormatConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig {
        /**
         * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
         */
        aggregationConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig;
        /**
         * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
         */
        fileType?: string;
        /**
         * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
         */
        prefixConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig;
        /**
         * Whether the data types from the source system need to be preserved (Only valid for `Parquet` file type)
         */
        preserveSourceDataTyping?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig {
        /**
         * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
         */
        aggregationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig {
        /**
         * Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
         */
        prefixFormat?: string;
        /**
         * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
         */
        prefixType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig;
        /**
         * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
         */
        idFieldNames?: string[];
        /**
         * Object specified in the flow destination.
         */
        object: string;
        /**
         * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
         */
        writeOperationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig;
        /**
         * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
         */
        idFieldNames?: string[];
        /**
         * Object path specified in the SAPOData flow destination.
         */
        objectPath: string;
        /**
         * Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
         */
        successResponseHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig;
        /**
         * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
         */
        writeOperationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake {
        /**
         * Object key for the bucket in which Amazon AppFlow places the destination files.
         */
        bucketPrefix?: string;
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig;
        /**
         * Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
         */
        intermediateBucketName: string;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver {
        /**
         * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
         */
        bucketName: string;
        /**
         * Object key for the bucket in which Amazon AppFlow places the destination files.
         */
        bucketPrefix?: string;
        /**
         * Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
         */
        s3OutputFormatConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig {
        /**
         * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
         */
        aggregationConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig;
        /**
         * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
         */
        fileType?: string;
        /**
         * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
         */
        prefixConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig {
        /**
         * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
         */
        aggregationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig {
        /**
         * Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
         */
        prefixFormat?: string;
        /**
         * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
         */
        prefixType: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk {
        /**
         * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
         */
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig;
        /**
         * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
         */
        idFieldNames?: string[];
        /**
         * Object specified in the flow destination.
         */
        object: string;
        /**
         * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are `INSERT`, `UPSERT`, `UPDATE`, and `DELETE`.
         */
        writeOperationType?: string;
    }

    export interface FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }

    export interface FlowSourceFlowConfig {
        /**
         * API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
         */
        connectorProfileName?: string;
        /**
         * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
         */
        connectorType: string;
        /**
         * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
         */
        incrementalPullConfig?: outputs.appflow.FlowSourceFlowConfigIncrementalPullConfig;
        /**
         * Information that is required to query a particular source connector. See Source Connector Properties for details.
         */
        sourceConnectorProperties: outputs.appflow.FlowSourceFlowConfigSourceConnectorProperties;
    }

    export interface FlowSourceFlowConfigIncrementalPullConfig {
        /**
         * Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
         */
        datetimeTypeFieldName?: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorProperties {
        /**
         * Information that is required for querying Amplitude. See Generic Source Properties for more details.
         */
        amplitude?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude;
        /**
         * Properties that are applied when the custom connector is being used as a source. See Custom Connector Source Properties.
         */
        customConnector?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector;
        /**
         * Information that is required for querying Datadog. See Generic Source Properties for more details.
         */
        datadog?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesDatadog;
        /**
         * Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        dynatrace?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace;
        /**
         * Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
         */
        googleAnalytics?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics;
        /**
         * Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
         */
        inforNexus?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus;
        /**
         * Information that is required for querying Marketo. See Generic Source Properties for more details.
         */
        marketo?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesMarketo;
        /**
         * Information that is required for querying Amazon S3. See S3 Source Properties for more details.
         */
        s3?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesS3;
        /**
         * Information that is required for querying Salesforce. See Salesforce Source Properties for more details.
         */
        salesforce?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce;
        /**
         * Information that is required for querying SAPOData as a flow source. See SAPO Source Properties for more details.
         */
        sapoData?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSapoData;
        /**
         * Information that is required for querying ServiceNow. See Generic Source Properties for more details.
         */
        serviceNow?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow;
        /**
         * Information that is required for querying Singular. See Generic Source Properties for more details.
         */
        singular?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSingular;
        /**
         * Information that is required for querying Slack. See Generic Source Properties for more details.
         */
        slack?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSlack;
        /**
         * Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        trendmicro?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro;
        /**
         * Information that is required for querying Veeva. See Veeva Source Properties for more details.
         */
        veeva?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesVeeva;
        /**
         * Information that is required for querying Zendesk. See Generic Source Properties for more details.
         */
        zendesk?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesZendesk;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesAmplitude {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector {
        /**
         * Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
         */
        customProperties?: {[key: string]: string};
        /**
         * Entity specified in the custom connector as a destination in the flow.
         */
        entityName: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesDatadog {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesDynatrace {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesInforNexus {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesMarketo {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesS3 {
        /**
         * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
         */
        bucketName: string;
        /**
         * Object key for the bucket in which Amazon AppFlow places the destination files.
         */
        bucketPrefix?: string;
        /**
         * When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
         */
        s3InputFormatConfig?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig {
        /**
         * File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
         */
        s3InputFileType?: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesSalesforce {
        /**
         * Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
         */
        enableDynamicFieldUpdate?: boolean;
        /**
         * Whether Amazon AppFlow includes deleted files in the flow run.
         */
        includeDeletedRecords?: boolean;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesSapoData {
        /**
         * Object path specified in the SAPOData flow destination.
         */
        objectPath: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesServiceNow {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesSingular {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesSlack {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesVeeva {
        /**
         * Document type specified in the Veeva document extract flow.
         */
        documentType?: string;
        /**
         * Boolean value to include All Versions of files in Veeva document extract flow.
         */
        includeAllVersions?: boolean;
        /**
         * Boolean value to include file renditions in Veeva document extract flow.
         */
        includeRenditions?: boolean;
        /**
         * Boolean value to include source files in Veeva document extract flow.
         */
        includeSourceFiles?: boolean;
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowSourceFlowConfigSourceConnectorPropertiesZendesk {
        /**
         * Object specified in the flow destination.
         */
        object: string;
    }

    export interface FlowTask {
        /**
         * Operation to be performed on the provided source fields. See Connector Operator for details.
         */
        connectorOperators?: outputs.appflow.FlowTaskConnectorOperator[];
        /**
         * Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
         */
        destinationField?: string;
        /**
         * Source fields to which a particular task is applied.
         */
        sourceFields: string[];
        /**
         * Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
         */
        taskProperties?: {[key: string]: string};
        /**
         * Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
         */
        taskType: string;
    }

    export interface FlowTaskConnectorOperator {
        /**
         * Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
         */
        amplitude?: string;
        /**
         * Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        customConnector?: string;
        /**
         * Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        datadog?: string;
        /**
         * Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        dynatrace?: string;
        /**
         * Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
         */
        googleAnalytics?: string;
        /**
         * Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        inforNexus?: string;
        /**
         * Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        marketo?: string;
        /**
         * Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        s3?: string;
        /**
         * Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        salesforce?: string;
        /**
         * Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        sapoData?: string;
        /**
         * Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        serviceNow?: string;
        /**
         * Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        singular?: string;
        /**
         * Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        slack?: string;
        /**
         * Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        trendmicro?: string;
        /**
         * Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        veeva?: string;
        /**
         * Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        zendesk?: string;
    }

    export interface FlowTriggerConfig {
        /**
         * Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
         */
        triggerProperties: outputs.appflow.FlowTriggerConfigTriggerProperties;
        /**
         * Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
         */
        triggerType: string;
    }

    export interface FlowTriggerConfigTriggerProperties {
        scheduled?: outputs.appflow.FlowTriggerConfigTriggerPropertiesScheduled;
    }

    export interface FlowTriggerConfigTriggerPropertiesScheduled {
        /**
         * Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
         */
        dataPullMode?: string;
        /**
         * Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
         */
        firstExecutionFrom?: string;
        /**
         * Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
         */
        scheduleEndTime?: string;
        /**
         * Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
         */
        scheduleExpression: string;
        /**
         * Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
         */
        scheduleOffset?: number;
        /**
         * Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
         */
        scheduleStartTime?: string;
        /**
         * Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
         */
        timezone?: string;
    }

}

export namespace appintegrations {
    export interface DataIntegrationScheduleConfig {
        /**
         * The start date for objects to import in the first flow run as an Unix/epoch timestamp in milliseconds or in ISO-8601 format. This needs to be a time in the past, meaning that the data created or updated before this given date will not be downloaded.
         */
        firstExecutionFrom: string;
        /**
         * The name of the object to pull from the data source. Examples of objects in Salesforce include `Case`, `Account`, or `Lead`.
         */
        object: string;
        /**
         * How often the data should be pulled from data source. Examples include `rate(1 hour)`, `rate(3 hours)`, `rate(1 day)`.
         */
        scheduleExpression: string;
    }

    export interface GetEventIntegrationEventFilter {
        /**
         * The source of the events.
         */
        source: string;
    }

}

export namespace appmesh {
    export interface GatewayRouteSpec {
        /**
         * Specification of a gRPC gateway route.
         */
        grpcRoute?: outputs.appmesh.GatewayRouteSpecGrpcRoute;
        /**
         * Specification of an HTTP/2 gateway route.
         */
        http2Route?: outputs.appmesh.GatewayRouteSpecHttp2Route;
        /**
         * Specification of an HTTP gateway route.
         */
        httpRoute?: outputs.appmesh.GatewayRouteSpecHttpRoute;
        /**
         * Priority for the gateway route, between `0` and `1000`.
         */
        priority?: number;
    }

    export interface GatewayRouteSpecGrpcRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecGrpcRouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecGrpcRouteMatch;
    }

    export interface GatewayRouteSpecGrpcRouteAction {
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecGrpcRouteActionTarget;
    }

    export interface GatewayRouteSpecGrpcRouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecGrpcRouteActionTargetVirtualService;
    }

    export interface GatewayRouteSpecGrpcRouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }

    export interface GatewayRouteSpecGrpcRouteMatch {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Fully qualified domain name for the service to match from the request.
         */
        serviceName: string;
    }

    export interface GatewayRouteSpecHttp2Route {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecHttp2RouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecHttp2RouteMatch;
    }

    export interface GatewayRouteSpecHttp2RouteAction {
        /**
         * Gateway route action to rewrite.
         */
        rewrite?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewrite;
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecHttp2RouteActionTarget;
    }

    export interface GatewayRouteSpecHttp2RouteActionRewrite {
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewriteHostname;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewritePrefix;
    }

    export interface GatewayRouteSpecHttp2RouteActionRewriteHostname {
        /**
         * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultTargetHostname: string;
    }

    export interface GatewayRouteSpecHttp2RouteActionRewritePrefix {
        /**
         * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultPrefix?: string;
        /**
         * Value used to replace the incoming route prefix when rewritten.
         */
        value?: string;
    }

    export interface GatewayRouteSpecHttp2RouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecHttp2RouteActionTargetVirtualService;
    }

    export interface GatewayRouteSpecHttp2RouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeader[];
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHostname;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchPath;
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchQueryParameter[];
    }

    export interface GatewayRouteSpecHttp2RouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }

    export interface GatewayRouteSpecHttp2RouteMatchHostname {
        /**
         * Exact host name to match on.
         */
        exact?: string;
        /**
         * Specified ending characters of the host name to match on.
         */
        suffix?: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }

    export interface GatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
    }

    export interface GatewayRouteSpecHttpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecHttpRouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecHttpRouteMatch;
    }

    export interface GatewayRouteSpecHttpRouteAction {
        /**
         * Gateway route action to rewrite.
         */
        rewrite?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewrite;
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecHttpRouteActionTarget;
    }

    export interface GatewayRouteSpecHttpRouteActionRewrite {
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewriteHostname;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewritePrefix;
    }

    export interface GatewayRouteSpecHttpRouteActionRewriteHostname {
        /**
         * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultTargetHostname: string;
    }

    export interface GatewayRouteSpecHttpRouteActionRewritePrefix {
        /**
         * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultPrefix?: string;
        /**
         * Value used to replace the incoming route prefix when rewritten.
         */
        value?: string;
    }

    export interface GatewayRouteSpecHttpRouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecHttpRouteActionTargetVirtualService;
    }

    export interface GatewayRouteSpecHttpRouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }

    export interface GatewayRouteSpecHttpRouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeader[];
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHostname;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchPath;
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchQueryParameter[];
    }

    export interface GatewayRouteSpecHttpRouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }

    export interface GatewayRouteSpecHttpRouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }

    export interface GatewayRouteSpecHttpRouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }

    export interface GatewayRouteSpecHttpRouteMatchHostname {
        /**
         * Exact host name to match on.
         */
        exact?: string;
        /**
         * Specified ending characters of the host name to match on.
         */
        suffix?: string;
    }

    export interface GatewayRouteSpecHttpRouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }

    export interface GatewayRouteSpecHttpRouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }

    export interface GatewayRouteSpecHttpRouteMatchQueryParameterMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
    }

    export interface GetGatewayRouteSpec {
        grpcRoutes: outputs.appmesh.GetGatewayRouteSpecGrpcRoute[];
        http2Routes: outputs.appmesh.GetGatewayRouteSpecHttp2Route[];
        httpRoutes: outputs.appmesh.GetGatewayRouteSpecHttpRoute[];
        priority: number;
    }

    export interface GetGatewayRouteSpecGrpcRoute {
        actions: outputs.appmesh.GetGatewayRouteSpecGrpcRouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecGrpcRouteMatch[];
    }

    export interface GetGatewayRouteSpecGrpcRouteAction {
        targets: outputs.appmesh.GetGatewayRouteSpecGrpcRouteActionTarget[];
    }

    export interface GetGatewayRouteSpecGrpcRouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecGrpcRouteActionTargetVirtualService[];
    }

    export interface GetGatewayRouteSpecGrpcRouteActionTargetVirtualService {
        virtualServiceName: string;
    }

    export interface GetGatewayRouteSpecGrpcRouteMatch {
        port: number;
        serviceName: string;
    }

    export interface GetGatewayRouteSpecHttp2Route {
        actions: outputs.appmesh.GetGatewayRouteSpecHttp2RouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatch[];
    }

    export interface GetGatewayRouteSpecHttp2RouteAction {
        rewrites: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewrite[];
        targets: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionTarget[];
    }

    export interface GetGatewayRouteSpecHttp2RouteActionRewrite {
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewriteHostname[];
        prefixes: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewritePrefix[];
    }

    export interface GetGatewayRouteSpecHttp2RouteActionRewriteHostname {
        defaultTargetHostname: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteActionRewritePrefix {
        defaultPrefix: string;
        value: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionTargetVirtualService[];
    }

    export interface GetGatewayRouteSpecHttp2RouteActionTargetVirtualService {
        virtualServiceName: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatch {
        headers: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeader[];
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchQueryParameter[];
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeaderMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchHostname {
        exact: string;
        suffix: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchPath {
        exact: string;
        regex: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchQueryParameter {
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }

    export interface GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
        exact: string;
    }

    export interface GetGatewayRouteSpecHttpRoute {
        actions: outputs.appmesh.GetGatewayRouteSpecHttpRouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatch[];
    }

    export interface GetGatewayRouteSpecHttpRouteAction {
        rewrites: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewrite[];
        targets: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionTarget[];
    }

    export interface GetGatewayRouteSpecHttpRouteActionRewrite {
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewriteHostname[];
        prefixes: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewritePrefix[];
    }

    export interface GetGatewayRouteSpecHttpRouteActionRewriteHostname {
        defaultTargetHostname: string;
    }

    export interface GetGatewayRouteSpecHttpRouteActionRewritePrefix {
        defaultPrefix: string;
        value: string;
    }

    export interface GetGatewayRouteSpecHttpRouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionTargetVirtualService[];
    }

    export interface GetGatewayRouteSpecHttpRouteActionTargetVirtualService {
        virtualServiceName: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatch {
        headers: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeader[];
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchQueryParameter[];
    }

    export interface GetGatewayRouteSpecHttpRouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeaderMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchHostname {
        exact: string;
        suffix: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchPath {
        exact: string;
        regex: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchQueryParameter {
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }

    export interface GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch {
        exact: string;
    }

    export interface GetMeshSpec {
        egressFilters: outputs.appmesh.GetMeshSpecEgressFilter[];
    }

    export interface GetMeshSpecEgressFilter {
        type: string;
    }

    export interface GetRouteSpec {
        grpcRoutes: outputs.appmesh.GetRouteSpecGrpcRoute[];
        http2Routes: outputs.appmesh.GetRouteSpecHttp2Route[];
        httpRoutes: outputs.appmesh.GetRouteSpecHttpRoute[];
        priority: number;
        tcpRoutes: outputs.appmesh.GetRouteSpecTcpRoute[];
    }

    export interface GetRouteSpecGrpcRoute {
        actions: outputs.appmesh.GetRouteSpecGrpcRouteAction[];
        matches: outputs.appmesh.GetRouteSpecGrpcRouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecGrpcRouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecGrpcRouteTimeout[];
    }

    export interface GetRouteSpecGrpcRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecGrpcRouteActionWeightedTarget[];
    }

    export interface GetRouteSpecGrpcRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }

    export interface GetRouteSpecGrpcRouteMatch {
        metadatas: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadata[];
        methodName: string;
        port: number;
        prefix: string;
        serviceName: string;
    }

    export interface GetRouteSpecGrpcRouteMatchMetadata {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadataMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }

    export interface GetRouteSpecGrpcRouteMatchMetadataMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadataMatchRange[];
        regex: string;
        suffix: string;
    }

    export interface GetRouteSpecGrpcRouteMatchMetadataMatchRange {
        end: number;
        start: number;
    }

    export interface GetRouteSpecGrpcRouteRetryPolicy {
        grpcRetryEvents: string[];
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }

    export interface GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecGrpcRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecGrpcRouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecGrpcRouteTimeoutPerRequest[];
    }

    export interface GetRouteSpecGrpcRouteTimeoutIdle {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecGrpcRouteTimeoutPerRequest {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttp2Route {
        actions: outputs.appmesh.GetRouteSpecHttp2RouteAction[];
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecHttp2RouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecHttp2RouteTimeout[];
    }

    export interface GetRouteSpecHttp2RouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecHttp2RouteActionWeightedTarget[];
    }

    export interface GetRouteSpecHttp2RouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }

    export interface GetRouteSpecHttp2RouteMatch {
        headers: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeader[];
        method: string;
        paths: outputs.appmesh.GetRouteSpecHttp2RouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetRouteSpecHttp2RouteMatchQueryParameter[];
        scheme: string;
    }

    export interface GetRouteSpecHttp2RouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeaderMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }

    export interface GetRouteSpecHttp2RouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }

    export interface GetRouteSpecHttp2RouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }

    export interface GetRouteSpecHttp2RouteMatchPath {
        exact: string;
        regex: string;
    }

    export interface GetRouteSpecHttp2RouteMatchQueryParameter {
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatchQueryParameterMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }

    export interface GetRouteSpecHttp2RouteMatchQueryParameterMatch {
        exact: string;
    }

    export interface GetRouteSpecHttp2RouteRetryPolicy {
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }

    export interface GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttp2RouteTimeout {
        idles: outputs.appmesh.GetRouteSpecHttp2RouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecHttp2RouteTimeoutPerRequest[];
    }

    export interface GetRouteSpecHttp2RouteTimeoutIdle {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttp2RouteTimeoutPerRequest {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttpRoute {
        actions: outputs.appmesh.GetRouteSpecHttpRouteAction[];
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecHttpRouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecHttpRouteTimeout[];
    }

    export interface GetRouteSpecHttpRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecHttpRouteActionWeightedTarget[];
    }

    export interface GetRouteSpecHttpRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }

    export interface GetRouteSpecHttpRouteMatch {
        headers: outputs.appmesh.GetRouteSpecHttpRouteMatchHeader[];
        method: string;
        paths: outputs.appmesh.GetRouteSpecHttpRouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetRouteSpecHttpRouteMatchQueryParameter[];
        scheme: string;
    }

    export interface GetRouteSpecHttpRouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatchHeaderMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }

    export interface GetRouteSpecHttpRouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecHttpRouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }

    export interface GetRouteSpecHttpRouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }

    export interface GetRouteSpecHttpRouteMatchPath {
        exact: string;
        regex: string;
    }

    export interface GetRouteSpecHttpRouteMatchQueryParameter {
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatchQueryParameterMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }

    export interface GetRouteSpecHttpRouteMatchQueryParameterMatch {
        exact: string;
    }

    export interface GetRouteSpecHttpRouteRetryPolicy {
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }

    export interface GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttpRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecHttpRouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecHttpRouteTimeoutPerRequest[];
    }

    export interface GetRouteSpecHttpRouteTimeoutIdle {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecHttpRouteTimeoutPerRequest {
        unit: string;
        value: number;
    }

    export interface GetRouteSpecTcpRoute {
        actions: outputs.appmesh.GetRouteSpecTcpRouteAction[];
        matches: outputs.appmesh.GetRouteSpecTcpRouteMatch[];
        timeouts: outputs.appmesh.GetRouteSpecTcpRouteTimeout[];
    }

    export interface GetRouteSpecTcpRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecTcpRouteActionWeightedTarget[];
    }

    export interface GetRouteSpecTcpRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }

    export interface GetRouteSpecTcpRouteMatch {
        port: number;
    }

    export interface GetRouteSpecTcpRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecTcpRouteTimeoutIdle[];
    }

    export interface GetRouteSpecTcpRouteTimeoutIdle {
        unit: string;
        value: number;
    }

    export interface GetVirtualGatewaySpec {
        backendDefaults: outputs.appmesh.GetVirtualGatewaySpecBackendDefault[];
        listeners: outputs.appmesh.GetVirtualGatewaySpecListener[];
        loggings: outputs.appmesh.GetVirtualGatewaySpecLogging[];
    }

    export interface GetVirtualGatewaySpecBackendDefault {
        clientPolicies: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicy[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicy {
        tls: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTl[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd {
        secretName: string;
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }

    export interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd {
        secretName: string;
    }

    export interface GetVirtualGatewaySpecListener {
        connectionPools: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPool[];
        healthChecks: outputs.appmesh.GetVirtualGatewaySpecListenerHealthCheck[];
        portMappings: outputs.appmesh.GetVirtualGatewaySpecListenerPortMapping[];
        tls: outputs.appmesh.GetVirtualGatewaySpecListenerTl[];
    }

    export interface GetVirtualGatewaySpecListenerConnectionPool {
        grpcs: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolGrpc[];
        http2s: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolHttp2[];
        https: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolHttp[];
    }

    export interface GetVirtualGatewaySpecListenerConnectionPoolGrpc {
        maxRequests: number;
    }

    export interface GetVirtualGatewaySpecListenerConnectionPoolHttp {
        maxConnections: number;
        maxPendingRequests: number;
    }

    export interface GetVirtualGatewaySpecListenerConnectionPoolHttp2 {
        maxRequests: number;
    }

    export interface GetVirtualGatewaySpecListenerHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path: string;
        port: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }

    export interface GetVirtualGatewaySpecListenerPortMapping {
        port: number;
        protocol: string;
    }

    export interface GetVirtualGatewaySpecListenerTl {
        certificates: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificate[];
        mode: string;
        validations: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidation[];
    }

    export interface GetVirtualGatewaySpecListenerTlCertificate {
        acms: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateAcm[];
        files: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateSd[];
    }

    export interface GetVirtualGatewaySpecListenerTlCertificateAcm {
        certificateArn: string;
    }

    export interface GetVirtualGatewaySpecListenerTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }

    export interface GetVirtualGatewaySpecListenerTlCertificateSd {
        secretName: string;
    }

    export interface GetVirtualGatewaySpecListenerTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrust[];
    }

    export interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch[];
    }

    export interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }

    export interface GetVirtualGatewaySpecListenerTlValidationTrust {
        files: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrustSd[];
    }

    export interface GetVirtualGatewaySpecListenerTlValidationTrustFile {
        certificateChain: string;
    }

    export interface GetVirtualGatewaySpecListenerTlValidationTrustSd {
        secretName: string;
    }

    export interface GetVirtualGatewaySpecLogging {
        accessLogs: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLog[];
    }

    export interface GetVirtualGatewaySpecLoggingAccessLog {
        files: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFile[];
    }

    export interface GetVirtualGatewaySpecLoggingAccessLogFile {
        formats: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFileFormat[];
        path: string;
    }

    export interface GetVirtualGatewaySpecLoggingAccessLogFileFormat {
        jsons: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFileFormatJson[];
        text: string;
    }

    export interface GetVirtualGatewaySpecLoggingAccessLogFileFormatJson {
        key: string;
        value: string;
    }

    export interface GetVirtualNodeSpec {
        backendDefaults: outputs.appmesh.GetVirtualNodeSpecBackendDefault[];
        backends: outputs.appmesh.GetVirtualNodeSpecBackend[];
        listeners: outputs.appmesh.GetVirtualNodeSpecListener[];
        loggings: outputs.appmesh.GetVirtualNodeSpecLogging[];
        serviceDiscoveries: outputs.appmesh.GetVirtualNodeSpecServiceDiscovery[];
    }

    export interface GetVirtualNodeSpecBackend {
        virtualServices: outputs.appmesh.GetVirtualNodeSpecBackendVirtualService[];
    }

    export interface GetVirtualNodeSpecBackendDefault {
        clientPolicies: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicy[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicy {
        tls: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTl[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }

    export interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecBackendVirtualService {
        clientPolicies: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicy[];
        virtualServiceName: string;
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicy {
        tls: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }

    export interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecListener {
        connectionPools: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPool[];
        healthChecks: outputs.appmesh.GetVirtualNodeSpecListenerHealthCheck[];
        outlierDetections: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetection[];
        portMappings: outputs.appmesh.GetVirtualNodeSpecListenerPortMapping[];
        timeouts: outputs.appmesh.GetVirtualNodeSpecListenerTimeout[];
        tls: outputs.appmesh.GetVirtualNodeSpecListenerTl[];
    }

    export interface GetVirtualNodeSpecListenerConnectionPool {
        grpcs: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolGrpc[];
        http2s: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolHttp2[];
        https: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolHttp[];
        tcps: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolTcp[];
    }

    export interface GetVirtualNodeSpecListenerConnectionPoolGrpc {
        maxRequests: number;
    }

    export interface GetVirtualNodeSpecListenerConnectionPoolHttp {
        maxConnections: number;
        maxPendingRequests: number;
    }

    export interface GetVirtualNodeSpecListenerConnectionPoolHttp2 {
        maxRequests: number;
    }

    export interface GetVirtualNodeSpecListenerConnectionPoolTcp {
        maxConnections: number;
    }

    export interface GetVirtualNodeSpecListenerHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path: string;
        port: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }

    export interface GetVirtualNodeSpecListenerOutlierDetection {
        baseEjectionDurations: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration[];
        intervals: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetectionInterval[];
        maxEjectionPercent: number;
        maxServerErrors: number;
    }

    export interface GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerOutlierDetectionInterval {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerPortMapping {
        port: number;
        protocol: string;
    }

    export interface GetVirtualNodeSpecListenerTimeout {
        grpcs: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpc[];
        http2s: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2[];
        https: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp[];
        tcps: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutTcp[];
    }

    export interface GetVirtualNodeSpecListenerTimeoutGrpc {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpcIdle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpcPerRequest[];
    }

    export interface GetVirtualNodeSpecListenerTimeoutGrpcIdle {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutGrpcPerRequest {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttp {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttpIdle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttpPerRequest[];
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttp2 {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2Idle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2PerRequest[];
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttp2Idle {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttp2PerRequest {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttpIdle {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutHttpPerRequest {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTimeoutTcp {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutTcpIdle[];
    }

    export interface GetVirtualNodeSpecListenerTimeoutTcpIdle {
        unit: string;
        value: number;
    }

    export interface GetVirtualNodeSpecListenerTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificate[];
        mode: string;
        validations: outputs.appmesh.GetVirtualNodeSpecListenerTlValidation[];
    }

    export interface GetVirtualNodeSpecListenerTlCertificate {
        acms: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateSd[];
    }

    export interface GetVirtualNodeSpecListenerTlCertificateAcm {
        certificateArn: string;
    }

    export interface GetVirtualNodeSpecListenerTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }

    export interface GetVirtualNodeSpecListenerTlCertificateSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecListenerTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrust[];
    }

    export interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch[];
    }

    export interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }

    export interface GetVirtualNodeSpecListenerTlValidationTrust {
        files: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrustSd[];
    }

    export interface GetVirtualNodeSpecListenerTlValidationTrustFile {
        certificateChain: string;
    }

    export interface GetVirtualNodeSpecListenerTlValidationTrustSd {
        secretName: string;
    }

    export interface GetVirtualNodeSpecLogging {
        accessLogs: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLog[];
    }

    export interface GetVirtualNodeSpecLoggingAccessLog {
        files: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFile[];
    }

    export interface GetVirtualNodeSpecLoggingAccessLogFile {
        formats: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFileFormat[];
        path: string;
    }

    export interface GetVirtualNodeSpecLoggingAccessLogFileFormat {
        jsons: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFileFormatJson[];
        text: string;
    }

    export interface GetVirtualNodeSpecLoggingAccessLogFileFormatJson {
        key: string;
        value: string;
    }

    export interface GetVirtualNodeSpecServiceDiscovery {
        awsCloudMaps: outputs.appmesh.GetVirtualNodeSpecServiceDiscoveryAwsCloudMap[];
        dns: outputs.appmesh.GetVirtualNodeSpecServiceDiscoveryDn[];
    }

    export interface GetVirtualNodeSpecServiceDiscoveryAwsCloudMap {
        attributes: {[key: string]: string};
        namespaceName: string;
        serviceName: string;
    }

    export interface GetVirtualNodeSpecServiceDiscoveryDn {
        hostname: string;
        ipPreference: string;
        responseType: string;
    }

    export interface GetVirtualRouterSpec {
        listeners: outputs.appmesh.GetVirtualRouterSpecListener[];
    }

    export interface GetVirtualRouterSpecListener {
        portMappings: outputs.appmesh.GetVirtualRouterSpecListenerPortMapping[];
    }

    export interface GetVirtualRouterSpecListenerPortMapping {
        port: number;
        protocol: string;
    }

    export interface GetVirtualServiceSpec {
        providers: outputs.appmesh.GetVirtualServiceSpecProvider[];
    }

    export interface GetVirtualServiceSpecProvider {
        virtualNodes: outputs.appmesh.GetVirtualServiceSpecProviderVirtualNode[];
        virtualRouters: outputs.appmesh.GetVirtualServiceSpecProviderVirtualRouter[];
    }

    export interface GetVirtualServiceSpecProviderVirtualNode {
        virtualNodeName: string;
    }

    export interface GetVirtualServiceSpecProviderVirtualRouter {
        virtualRouterName: string;
    }

    export interface MeshSpec {
        /**
         * Egress filter rules for the service mesh.
         */
        egressFilter?: outputs.appmesh.MeshSpecEgressFilter;
    }

    export interface MeshSpecEgressFilter {
        /**
         * Egress filter type. By default, the type is `DROP_ALL`.
         * Valid values are `ALLOW_ALL` and `DROP_ALL`.
         */
        type?: string;
    }

    export interface RouteSpec {
        /**
         * GRPC routing information for the route.
         */
        grpcRoute?: outputs.appmesh.RouteSpecGrpcRoute;
        /**
         * HTTP/2 routing information for the route.
         */
        http2Route?: outputs.appmesh.RouteSpecHttp2Route;
        /**
         * HTTP routing information for the route.
         */
        httpRoute?: outputs.appmesh.RouteSpecHttpRoute;
        /**
         * Priority for the route, between `0` and `1000`.
         * Routes are matched based on the specified value, where `0` is the highest priority.
         */
        priority?: number;
        /**
         * TCP routing information for the route.
         */
        tcpRoute?: outputs.appmesh.RouteSpecTcpRoute;
    }

    export interface RouteSpecGrpcRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecGrpcRouteAction;
        /**
         * Criteria for determining an gRPC request match.
         */
        match?: outputs.appmesh.RouteSpecGrpcRouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecGrpcRouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecGrpcRouteTimeout;
    }

    export interface RouteSpecGrpcRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecGrpcRouteActionWeightedTarget[];
    }

    export interface RouteSpecGrpcRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }

    export interface RouteSpecGrpcRouteMatch {
        /**
         * Data to match from the gRPC request.
         */
        metadatas?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadata[];
        /**
         * Method name to match from the request. If you specify a name, you must also specify a `serviceName`.
         */
        methodName?: string;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Fully qualified domain name for the service to match from the request.
         */
        serviceName?: string;
    }

    export interface RouteSpecGrpcRouteMatchMetadata {
        /**
         * If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
         */
        invert?: boolean;
        /**
         * Data to match from the request.
         */
        match?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatch;
        /**
         * Name of the route. Must be between 1 and 50 characters in length.
         */
        name: string;
    }

    export interface RouteSpecGrpcRouteMatchMetadataMatch {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatchRange;
        /**
         * The regex used to match the path.
         */
        regex?: string;
        /**
         * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
         */
        suffix?: string;
    }

    export interface RouteSpecGrpcRouteMatchMetadataMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }

    export interface RouteSpecGrpcRouteRetryPolicy {
        /**
         * List of gRPC retry events.
         * Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
         */
        grpcRetryEvents?: string[];
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         *
         *
         * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
         */
        tcpRetryEvents?: string[];
    }

    export interface RouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }

    export interface RouteSpecGrpcRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecGrpcRouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecGrpcRouteTimeoutPerRequest;
    }

    export interface RouteSpecGrpcRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecGrpcRouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecHttp2Route {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecHttp2RouteAction;
        /**
         * Criteria for determining an gRPC request match.
         */
        match: outputs.appmesh.RouteSpecHttp2RouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecHttp2RouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecHttp2RouteTimeout;
    }

    export interface RouteSpecHttp2RouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecHttp2RouteActionWeightedTarget[];
    }

    export interface RouteSpecHttp2RouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }

    export interface RouteSpecHttp2RouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.RouteSpecHttp2RouteMatchHeader[];
        /**
         * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
         */
        method?: string;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.RouteSpecHttp2RouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.RouteSpecHttp2RouteMatchQueryParameter[];
        /**
         * Client request header scheme to match on. Valid values: `http`, `https`.
         */
        scheme?: string;
    }

    export interface RouteSpecHttp2RouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }

    export interface RouteSpecHttp2RouteMatchHeaderMatch {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatchRange;
        /**
         * The regex used to match the path.
         */
        regex?: string;
        /**
         * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
         */
        suffix?: string;
    }

    export interface RouteSpecHttp2RouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }

    export interface RouteSpecHttp2RouteMatchPath {
        /**
         * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
         */
        exact?: string;
        /**
         * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
         */
        regex?: string;
    }

    export interface RouteSpecHttp2RouteMatchQueryParameter {
        /**
         * Criteria for determining an gRPC request match.
         */
        match?: outputs.appmesh.RouteSpecHttp2RouteMatchQueryParameterMatch;
        /**
         * Name to use for the route. Must be between 1 and 255 characters in length.
         */
        name: string;
    }

    export interface RouteSpecHttp2RouteMatchQueryParameterMatch {
        /**
         * The exact path to match on.
         */
        exact?: string;
    }

    export interface RouteSpecHttp2RouteRetryPolicy {
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         *
         *
         * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
         */
        tcpRetryEvents?: string[];
    }

    export interface RouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }

    export interface RouteSpecHttp2RouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecHttp2RouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecHttp2RouteTimeoutPerRequest;
    }

    export interface RouteSpecHttp2RouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecHttp2RouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecHttpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecHttpRouteAction;
        /**
         * Criteria for determining an HTTP request match.
         */
        match: outputs.appmesh.RouteSpecHttpRouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecHttpRouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecHttpRouteTimeout;
    }

    export interface RouteSpecHttpRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecHttpRouteActionWeightedTarget[];
    }

    export interface RouteSpecHttpRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }

    export interface RouteSpecHttpRouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.RouteSpecHttpRouteMatchHeader[];
        /**
         * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
         */
        method?: string;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.RouteSpecHttpRouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.RouteSpecHttpRouteMatchQueryParameter[];
        /**
         * Client request header scheme to match on. Valid values: `http`, `https`.
         */
        scheme?: string;
    }

    export interface RouteSpecHttpRouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.RouteSpecHttpRouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }

    export interface RouteSpecHttpRouteMatchHeaderMatch {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecHttpRouteMatchHeaderMatchRange;
        /**
         * The regex used to match the path.
         */
        regex?: string;
        /**
         * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
         */
        suffix?: string;
    }

    export interface RouteSpecHttpRouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }

    export interface RouteSpecHttpRouteMatchPath {
        /**
         * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
         */
        exact?: string;
        /**
         * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
         */
        regex?: string;
    }

    export interface RouteSpecHttpRouteMatchQueryParameter {
        /**
         * Criteria for determining an gRPC request match.
         */
        match?: outputs.appmesh.RouteSpecHttpRouteMatchQueryParameterMatch;
        /**
         * Name to use for the route. Must be between 1 and 255 characters in length.
         */
        name: string;
    }

    export interface RouteSpecHttpRouteMatchQueryParameterMatch {
        /**
         * The exact path to match on.
         */
        exact?: string;
    }

    export interface RouteSpecHttpRouteRetryPolicy {
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecHttpRouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         *
         *
         * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
         */
        tcpRetryEvents?: string[];
    }

    export interface RouteSpecHttpRouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }

    export interface RouteSpecHttpRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecHttpRouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecHttpRouteTimeoutPerRequest;
    }

    export interface RouteSpecHttpRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecHttpRouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface RouteSpecTcpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecTcpRouteAction;
        /**
         * Criteria for determining an gRPC request match.
         */
        match?: outputs.appmesh.RouteSpecTcpRouteMatch;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecTcpRouteTimeout;
    }

    export interface RouteSpecTcpRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecTcpRouteActionWeightedTarget[];
    }

    export interface RouteSpecTcpRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }

    export interface RouteSpecTcpRouteMatch {
        /**
         * The port number to match from the request.
         */
        port?: number;
    }

    export interface RouteSpecTcpRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecTcpRouteTimeoutIdle;
    }

    export interface RouteSpecTcpRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualGatewaySpec {
        /**
         * Defaults for backends.
         */
        backendDefaults?: outputs.appmesh.VirtualGatewaySpecBackendDefaults;
        /**
         * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
         */
        listeners: outputs.appmesh.VirtualGatewaySpecListener[];
        /**
         * Inbound and outbound access logging information for the virtual gateway.
         */
        logging?: outputs.appmesh.VirtualGatewaySpecLogging;
    }

    export interface VirtualGatewaySpecBackendDefaults {
        /**
         * Default client policy for virtual gateway backends.
         */
        clientPolicy?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicy;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTls;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
        /**
         * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }

    export interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualGatewaySpecListener {
        /**
         * Connection pool information for the listener.
         */
        connectionPool?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPool;
        /**
         * Health check information for the listener.
         */
        healthCheck?: outputs.appmesh.VirtualGatewaySpecListenerHealthCheck;
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualGatewaySpecListenerPortMapping;
        /**
         * Transport Layer Security (TLS) properties for the listener
         */
        tls?: outputs.appmesh.VirtualGatewaySpecListenerTls;
    }

    export interface VirtualGatewaySpecListenerConnectionPool {
        /**
         * Connection pool information for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolGrpc;
        /**
         * Connection pool information for HTTP listeners.
         */
        http?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp;
        /**
         * Connection pool information for HTTP2 listeners.
         */
        http2?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp2;
    }

    export interface VirtualGatewaySpecListenerConnectionPoolGrpc {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }

    export interface VirtualGatewaySpecListenerConnectionPoolHttp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
        /**
         * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
         *
         * The `http2` connection pool object supports the following:
         */
        maxPendingRequests?: number;
    }

    export interface VirtualGatewaySpecListenerConnectionPoolHttp2 {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }

    export interface VirtualGatewaySpecListenerHealthCheck {
        /**
         * Number of consecutive successful health checks that must occur before declaring listener healthy.
         */
        healthyThreshold: number;
        /**
         * Time period in milliseconds between each health check execution.
         */
        intervalMillis: number;
        /**
         * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
         */
        path?: string;
        /**
         * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
         */
        port: number;
        /**
         * Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
         */
        protocol: string;
        /**
         * Amount of time to wait when receiving a response from the health check, in milliseconds.
         */
        timeoutMillis: number;
        /**
         * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
         */
        unhealthyThreshold: number;
    }

    export interface VirtualGatewaySpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }

    export interface VirtualGatewaySpecListenerTls {
        /**
         * Listener's TLS certificate.
         */
        certificate: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificate;
        /**
         * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
         */
        mode: string;
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidation;
    }

    export interface VirtualGatewaySpecListenerTlsCertificate {
        /**
         * An AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateAcm;
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateSds;
    }

    export interface VirtualGatewaySpecListenerTlsCertificateAcm {
        /**
         * ARN for the certificate.
         */
        certificateArn: string;
    }

    export interface VirtualGatewaySpecListenerTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }

    export interface VirtualGatewaySpecListenerTlsCertificateSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualGatewaySpecListenerTlsValidation {
        /**
         * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrust;
    }

    export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch;
    }

    export interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }

    export interface VirtualGatewaySpecListenerTlsValidationTrust {
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustSds;
    }

    export interface VirtualGatewaySpecListenerTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }

    export interface VirtualGatewaySpecListenerTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualGatewaySpecLogging {
        /**
         * Access log configuration for a virtual gateway.
         */
        accessLog?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLog;
    }

    export interface VirtualGatewaySpecLoggingAccessLog {
        /**
         * File object to send virtual gateway access logs to.
         */
        file?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFile;
    }

    export interface VirtualGatewaySpecLoggingAccessLogFile {
        /**
         * The specified format for the logs.
         */
        format?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFileFormat;
        /**
         * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
         */
        path: string;
    }

    export interface VirtualGatewaySpecLoggingAccessLogFileFormat {
        /**
         * The logging format for JSON.
         */
        jsons?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFileFormatJson[];
        /**
         * The logging format for text. Must be between 1 and 1000 characters in length.
         */
        text?: string;
    }

    export interface VirtualGatewaySpecLoggingAccessLogFileFormatJson {
        /**
         * The specified key for the JSON. Must be between 1 and 100 characters in length.
         */
        key: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: string;
    }

    export interface VirtualNodeSpec {
        /**
         * Defaults for backends.
         */
        backendDefaults?: outputs.appmesh.VirtualNodeSpecBackendDefaults;
        /**
         * Backends to which the virtual node is expected to send outbound traffic.
         */
        backends?: outputs.appmesh.VirtualNodeSpecBackend[];
        /**
         * Listeners from which the virtual node is expected to receive inbound traffic.
         */
        listeners?: outputs.appmesh.VirtualNodeSpecListener[];
        /**
         * Inbound and outbound access logging information for the virtual node.
         */
        logging?: outputs.appmesh.VirtualNodeSpecLogging;
        /**
         * Service discovery information for the virtual node.
         */
        serviceDiscovery?: outputs.appmesh.VirtualNodeSpecServiceDiscovery;
    }

    export interface VirtualNodeSpecBackend {
        /**
         * Virtual service to use as a backend for a virtual node.
         */
        virtualService: outputs.appmesh.VirtualNodeSpecBackendVirtualService;
    }

    export interface VirtualNodeSpecBackendDefaults {
        /**
         * Default client policy for virtual service backends. See above for details.
         */
        clientPolicy?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicy;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTls;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }

    export interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecBackendVirtualService {
        /**
         * Client policy for the backend.
         */
        clientPolicy?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicy;
        /**
         * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTls;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }

    export interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecListener {
        /**
         * Connection pool information for the listener.
         */
        connectionPool?: outputs.appmesh.VirtualNodeSpecListenerConnectionPool;
        /**
         * Health check information for the listener.
         */
        healthCheck?: outputs.appmesh.VirtualNodeSpecListenerHealthCheck;
        /**
         * Outlier detection information for the listener.
         */
        outlierDetection?: outputs.appmesh.VirtualNodeSpecListenerOutlierDetection;
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualNodeSpecListenerPortMapping;
        /**
         * Timeouts for different protocols.
         */
        timeout?: outputs.appmesh.VirtualNodeSpecListenerTimeout;
        /**
         * Transport Layer Security (TLS) properties for the listener
         */
        tls?: outputs.appmesh.VirtualNodeSpecListenerTls;
    }

    export interface VirtualNodeSpecListenerConnectionPool {
        /**
         * Connection pool information for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolGrpc;
        /**
         * Connection pool information for HTTP2 listeners.
         */
        http2s?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp2[];
        /**
         * Connection pool information for HTTP listeners.
         */
        https?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp[];
        /**
         * Connection pool information for TCP listeners.
         */
        tcps?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolTcp[];
    }

    export interface VirtualNodeSpecListenerConnectionPoolGrpc {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }

    export interface VirtualNodeSpecListenerConnectionPoolHttp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
        /**
         * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
         *
         * The `http2` connection pool object supports the following:
         */
        maxPendingRequests?: number;
    }

    export interface VirtualNodeSpecListenerConnectionPoolHttp2 {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }

    export interface VirtualNodeSpecListenerConnectionPoolTcp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
    }

    export interface VirtualNodeSpecListenerHealthCheck {
        /**
         * Number of consecutive successful health checks that must occur before declaring listener healthy.
         */
        healthyThreshold: number;
        /**
         * Time period in milliseconds between each health check execution.
         */
        intervalMillis: number;
        /**
         * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
         */
        path?: string;
        /**
         * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
         */
        port: number;
        /**
         * Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
        /**
         * Amount of time to wait when receiving a response from the health check, in milliseconds.
         */
        timeoutMillis: number;
        /**
         * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
         */
        unhealthyThreshold: number;
    }

    export interface VirtualNodeSpecListenerOutlierDetection {
        /**
         * Base amount of time for which a host is ejected.
         */
        baseEjectionDuration: outputs.appmesh.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration;
        /**
         * Time interval between ejection sweep analysis.
         */
        interval: outputs.appmesh.VirtualNodeSpecListenerOutlierDetectionInterval;
        /**
         * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
         * Minimum value of `0`. Maximum value of `100`.
         */
        maxEjectionPercent: number;
        /**
         * Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
         */
        maxServerErrors: number;
    }

    export interface VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerOutlierDetectionInterval {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }

    export interface VirtualNodeSpecListenerTimeout {
        /**
         * Timeouts for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpc;
        /**
         * Timeouts for HTTP listeners.
         */
        http?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp;
        /**
         * Timeouts for HTTP2 listeners.
         */
        http2?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2;
        /**
         * Timeouts for TCP listeners.
         */
        tcp?: outputs.appmesh.VirtualNodeSpecListenerTimeoutTcp;
    }

    export interface VirtualNodeSpecListenerTimeoutGrpc {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcPerRequest;
    }

    export interface VirtualNodeSpecListenerTimeoutGrpcIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutGrpcPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutHttp {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttpIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttpPerRequest;
    }

    export interface VirtualNodeSpecListenerTimeoutHttp2 {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2Idle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2PerRequest;
    }

    export interface VirtualNodeSpecListenerTimeoutHttp2Idle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutHttp2PerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutHttpIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutHttpPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTimeoutTcp {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutTcpIdle;
    }

    export interface VirtualNodeSpecListenerTimeoutTcpIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }

    export interface VirtualNodeSpecListenerTls {
        /**
         * Listener's TLS certificate.
         */
        certificate: outputs.appmesh.VirtualNodeSpecListenerTlsCertificate;
        /**
         * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
         */
        mode: string;
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation?: outputs.appmesh.VirtualNodeSpecListenerTlsValidation;
    }

    export interface VirtualNodeSpecListenerTlsCertificate {
        /**
         * An AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateAcm;
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateSds;
    }

    export interface VirtualNodeSpecListenerTlsCertificateAcm {
        /**
         * ARN for the certificate.
         */
        certificateArn: string;
    }

    export interface VirtualNodeSpecListenerTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }

    export interface VirtualNodeSpecListenerTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecListenerTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrust;
    }

    export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch;
    }

    export interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }

    export interface VirtualNodeSpecListenerTlsValidationTrust {
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustSds;
    }

    export interface VirtualNodeSpecListenerTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }

    export interface VirtualNodeSpecListenerTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }

    export interface VirtualNodeSpecLogging {
        /**
         * Access log configuration for a virtual node.
         */
        accessLog?: outputs.appmesh.VirtualNodeSpecLoggingAccessLog;
    }

    export interface VirtualNodeSpecLoggingAccessLog {
        /**
         * File object to send virtual node access logs to.
         */
        file?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFile;
    }

    export interface VirtualNodeSpecLoggingAccessLogFile {
        /**
         * The specified format for the logs.
         */
        format?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFileFormat;
        /**
         * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
         */
        path: string;
    }

    export interface VirtualNodeSpecLoggingAccessLogFileFormat {
        /**
         * The logging format for JSON.
         */
        jsons?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFileFormatJson[];
        /**
         * The logging format for text. Must be between 1 and 1000 characters in length.
         */
        text?: string;
    }

    export interface VirtualNodeSpecLoggingAccessLogFileFormatJson {
        /**
         * The specified key for the JSON. Must be between 1 and 100 characters in length.
         */
        key: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: string;
    }

    export interface VirtualNodeSpecServiceDiscovery {
        /**
         * Any AWS Cloud Map information for the virtual node.
         */
        awsCloudMap?: outputs.appmesh.VirtualNodeSpecServiceDiscoveryAwsCloudMap;
        /**
         * DNS service name for the virtual node.
         */
        dns?: outputs.appmesh.VirtualNodeSpecServiceDiscoveryDns;
    }

    export interface VirtualNodeSpecServiceDiscoveryAwsCloudMap {
        /**
         * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
         */
        attributes?: {[key: string]: string};
        /**
         * Name of the AWS Cloud Map namespace to use.
         * Use the `aws.servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
         */
        namespaceName: string;
        /**
         * Name of the AWS Cloud Map service to use. Use the `aws.servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
         */
        serviceName: string;
    }

    export interface VirtualNodeSpecServiceDiscoveryDns {
        /**
         * DNS host name for your virtual node.
         */
        hostname: string;
        /**
         * The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
         */
        ipPreference?: string;
        /**
         * The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
         */
        responseType?: string;
    }

    export interface VirtualRouterSpec {
        /**
         * Listeners that the virtual router is expected to receive inbound traffic from.
         * Currently only one listener is supported per virtual router.
         */
        listeners?: outputs.appmesh.VirtualRouterSpecListener[];
    }

    export interface VirtualRouterSpecListener {
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualRouterSpecListenerPortMapping;
    }

    export interface VirtualRouterSpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }

    export interface VirtualServiceSpec {
        /**
         * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
         */
        provider?: outputs.appmesh.VirtualServiceSpecProvider;
    }

    export interface VirtualServiceSpecProvider {
        /**
         * Virtual node associated with a virtual service.
         */
        virtualNode?: outputs.appmesh.VirtualServiceSpecProviderVirtualNode;
        /**
         * Virtual router associated with a virtual service.
         */
        virtualRouter?: outputs.appmesh.VirtualServiceSpecProviderVirtualRouter;
    }

    export interface VirtualServiceSpecProviderVirtualNode {
        /**
         * Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
         */
        virtualNodeName: string;
    }

    export interface VirtualServiceSpecProviderVirtualRouter {
        /**
         * Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
         */
        virtualRouterName: string;
    }

}

export namespace apprunner {
    export interface CustomDomainAssociationCertificateValidationRecord {
        /**
         * Certificate CNAME record name.
         */
        name: string;
        /**
         * Current state of the certificate CNAME record validation. It should change to `SUCCESS` after App Runner completes validation with your DNS.
         */
        status: string;
        /**
         * Record type, always `CNAME`.
         */
        type: string;
        /**
         * Certificate CNAME record value.
         */
        value: string;
    }

    export interface ObservabilityConfigurationTraceConfiguration {
        /**
         * Implementation provider chosen for tracing App Runner services. Valid values: `AWSXRAY`.
         */
        vendor?: string;
    }

    export interface ServiceEncryptionConfiguration {
        /**
         * ARN of the KMS key used for encryption.
         */
        kmsKey: string;
    }

    export interface ServiceHealthCheckConfiguration {
        /**
         * Number of consecutive checks that must succeed before App Runner decides that the service is healthy. Defaults to 1. Minimum value of 1. Maximum value of 20.
         */
        healthyThreshold?: number;
        /**
         * Time interval, in seconds, between health checks. Defaults to 5. Minimum value of 1. Maximum value of 20.
         */
        interval?: number;
        /**
         * URL to send requests to for health checks. Defaults to `/`. Minimum length of 0. Maximum length of 51200.
         */
        path?: string;
        /**
         * IP protocol that App Runner uses to perform health checks for your service. Valid values: `TCP`, `HTTP`. Defaults to `TCP`. If you set protocol to `HTTP`, App Runner sends health check requests to the HTTP path specified by `path`.
         */
        protocol?: string;
        /**
         * Time, in seconds, to wait for a health check response before deciding it failed. Defaults to 2. Minimum value of  1. Maximum value of 20.
         */
        timeout?: number;
        /**
         * Number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Defaults to 5. Minimum value of  1. Maximum value of 20.
         */
        unhealthyThreshold?: number;
    }

    export interface ServiceInstanceConfiguration {
        /**
         * Number of CPU units reserved for each instance of your App Runner service represented as a String. Defaults to `1024`. Valid values: `256|512|1024|2048|4096|(0.25|0.5|1|2|4) vCPU`.
         */
        cpu?: string;
        /**
         * ARN of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.
         */
        instanceRoleArn?: string;
        /**
         * Amount of memory, in MB or GB, reserved for each instance of your App Runner service. Defaults to `2048`. Valid values: `512|1024|2048|3072|4096|6144|8192|10240|12288|(0.5|1|2|3|4|6|8|10|12) GB`.
         */
        memory?: string;
    }

    export interface ServiceNetworkConfiguration {
        /**
         * Network configuration settings for outbound message traffic. See Egress Configuration below for more details.
         */
        egressConfiguration: outputs.apprunner.ServiceNetworkConfigurationEgressConfiguration;
        /**
         * Network configuration settings for inbound network traffic. See Ingress Configuration below for more details.
         */
        ingressConfiguration: outputs.apprunner.ServiceNetworkConfigurationIngressConfiguration;
    }

    export interface ServiceNetworkConfigurationEgressConfiguration {
        /**
         * The type of egress configuration. Valid values are: `DEFAULT` and `VPC`.
         */
        egressType: string;
        /**
         * The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when `EgressType = VPC`.
         */
        vpcConnectorArn?: string;
    }

    export interface ServiceNetworkConfigurationIngressConfiguration {
        /**
         * Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to True. To make the service privately accessible, from only within an Amazon VPC set it to False.
         */
        isPubliclyAccessible?: boolean;
    }

    export interface ServiceObservabilityConfiguration {
        /**
         * ARN of the observability configuration that is associated with the service. Specified only when `observabilityEnabled` is `true`.
         */
        observabilityConfigurationArn?: string;
        /**
         * When `true`, an observability configuration resource is associated with the service.
         */
        observabilityEnabled: boolean;
    }

    export interface ServiceSourceConfiguration {
        /**
         * Describes resources needed to authenticate access to some source repositories. See Authentication Configuration below for more details.
         */
        authenticationConfiguration?: outputs.apprunner.ServiceSourceConfigurationAuthenticationConfiguration;
        /**
         * Whether continuous integration from the source repository is enabled for the App Runner service. If set to `true`, each repository change (source code commit or new image version) starts a deployment. Defaults to `true`.
         */
        autoDeploymentsEnabled?: boolean;
        /**
         * Description of a source code repository. See Code Repository below for more details.
         */
        codeRepository?: outputs.apprunner.ServiceSourceConfigurationCodeRepository;
        /**
         * Description of a source image repository. See Image Repository below for more details.
         */
        imageRepository?: outputs.apprunner.ServiceSourceConfigurationImageRepository;
    }

    export interface ServiceSourceConfigurationAuthenticationConfiguration {
        /**
         * ARN of the IAM role that grants the App Runner service access to a source repository. Required for ECR image repositories (but not for ECR Public)
         */
        accessRoleArn?: string;
        /**
         * ARN of the App Runner connection that enables the App Runner service to connect to a source repository. Required for GitHub code repositories.
         */
        connectionArn?: string;
    }

    export interface ServiceSourceConfigurationCodeRepository {
        /**
         * Configuration for building and running the service from a source code repository. See Code Configuration below for more details.
         */
        codeConfiguration?: outputs.apprunner.ServiceSourceConfigurationCodeRepositoryCodeConfiguration;
        /**
         * Location of the repository that contains the source code.
         */
        repositoryUrl: string;
        /**
         * Version that should be used within the source code repository. See Source Code Version below for more details.
         */
        sourceCodeVersion: outputs.apprunner.ServiceSourceConfigurationCodeRepositorySourceCodeVersion;
    }

    export interface ServiceSourceConfigurationCodeRepositoryCodeConfiguration {
        /**
         * Basic configuration for building and running the App Runner service. Use this parameter to quickly launch an App Runner service without providing an apprunner.yaml file in the source code repository (or ignoring the file if it exists). See Code Configuration Values below for more details.
         */
        codeConfigurationValues?: outputs.apprunner.ServiceSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues;
        /**
         * Source of the App Runner configuration. Valid values: `REPOSITORY`, `API`. Values are interpreted as follows:
         */
        configurationSource: string;
    }

    export interface ServiceSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues {
        /**
         * Command App Runner runs to build your application.
         */
        buildCommand?: string;
        /**
         * Port that your application listens to in the container. Defaults to `"8080"`.
         */
        port?: string;
        /**
         * Runtime environment type for building and running an App Runner service. Represents a programming language runtime. Valid values: `PYTHON_3`, `NODEJS_12`, `NODEJS_14`, `NODEJS_16`, `CORRETTO_8`, `CORRETTO_11`, `GO_1`, `DOTNET_6`, `PHP_81`, `RUBY_31`.
         */
        runtime: string;
        /**
         * Secrets and parameters available to your service as environment variables. A map of key/value pairs, where the key is the desired name of the Secret in the environment (i.e. it does not have to match the name of the secret in Secrets Manager or SSM Parameter Store), and the value is the ARN of the secret from AWS Secrets Manager or the ARN of the parameter in AWS SSM Parameter Store.
         */
        runtimeEnvironmentSecrets?: {[key: string]: string};
        /**
         * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of `AWSAPPRUNNER` are reserved for system use and aren't valid.
         */
        runtimeEnvironmentVariables?: {[key: string]: string};
        /**
         * Command App Runner runs to start your application.
         */
        startCommand?: string;
    }

    export interface ServiceSourceConfigurationCodeRepositorySourceCodeVersion {
        /**
         * Type of version identifier. For a git-based repository, branches represent versions. Valid values: `BRANCH`.
         */
        type: string;
        /**
         * Source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
         */
        value: string;
    }

    export interface ServiceSourceConfigurationImageRepository {
        /**
         * Configuration for running the identified image. See Image Configuration below for more details.
         */
        imageConfiguration?: outputs.apprunner.ServiceSourceConfigurationImageRepositoryImageConfiguration;
        /**
         * Identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the
         * image name format, see Pulling an image in the Amazon ECR User Guide.
         */
        imageIdentifier: string;
        /**
         * Type of the image repository. This reflects the repository provider and whether the repository is private or public. Valid values: `ECR` , `ECR_PUBLIC`.
         */
        imageRepositoryType: string;
    }

    export interface ServiceSourceConfigurationImageRepositoryImageConfiguration {
        /**
         * Port that your application listens to in the container. Defaults to `"8080"`.
         */
        port?: string;
        /**
         * Secrets and parameters available to your service as environment variables. A map of key/value pairs, where the key is the desired name of the Secret in the environment (i.e. it does not have to match the name of the secret in Secrets Manager or SSM Parameter Store), and the value is the ARN of the secret from AWS Secrets Manager or the ARN of the parameter in AWS SSM Parameter Store.
         */
        runtimeEnvironmentSecrets?: {[key: string]: string};
        /**
         * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of `AWSAPPRUNNER` are reserved for system use and aren't valid.
         */
        runtimeEnvironmentVariables?: {[key: string]: string};
        /**
         * Command App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
         */
        startCommand?: string;
    }

    export interface VpcIngressConnectionIngressVpcConfiguration {
        /**
         * The ID of the VPC endpoint that your App Runner service connects to.
         */
        vpcEndpointId?: string;
        /**
         * The ID of the VPC that is used for the VPC endpoint.
         */
        vpcId?: string;
    }

}

export namespace appstream {
    export interface DirectoryConfigServiceAccountCredentials {
        /**
         * User name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
         */
        accountName: string;
        /**
         * Password for the account.
         */
        accountPassword: string;
    }

    export interface FleetComputeCapacity {
        /**
         * Number of currently available instances that can be used to stream sessions.
         */
        available: number;
        /**
         * Desired number of streaming instances.
         */
        desiredInstances: number;
        /**
         * Number of instances in use for streaming.
         */
        inUse: number;
        /**
         * Total number of simultaneous streaming instances that are running.
         */
        running: number;
    }

    export interface FleetDomainJoinInfo {
        /**
         * Fully qualified name of the directory (for example, corp.example.com).
         */
        directoryName: string;
        /**
         * Distinguished name of the organizational unit for computer accounts.
         */
        organizationalUnitDistinguishedName: string;
    }

    export interface FleetVpcConfig {
        /**
         * Identifiers of the security groups for the fleet or image builder.
         */
        securityGroupIds: string[];
        /**
         * Identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance.
         */
        subnetIds: string[];
    }

    export interface ImageBuilderAccessEndpoint {
        /**
         * Type of interface endpoint.
         */
        endpointType: string;
        /**
         * Identifier (ID) of the VPC in which the interface endpoint is used.
         */
        vpceId: string;
    }

    export interface ImageBuilderDomainJoinInfo {
        /**
         * Fully qualified name of the directory (for example, corp.example.com).
         */
        directoryName?: string;
        /**
         * Distinguished name of the organizational unit for computer accounts.
         */
        organizationalUnitDistinguishedName?: string;
    }

    export interface ImageBuilderVpcConfig {
        /**
         * Identifiers of the security groups for the image builder or image builder.
         */
        securityGroupIds: string[];
        /**
         * Identifiers of the subnets to which a network interface is attached from the image builder instance or image builder instance.
         */
        subnetIds: string[];
    }

    export interface StackAccessEndpoint {
        /**
         * Type of the interface endpoint.
         * See the [`AccessEndpoint` AWS API documentation](https://docs.aws.amazon.com/appstream2/latest/APIReference/API_AccessEndpoint.html) for valid values.
         */
        endpointType: string;
        /**
         * ID of the VPC in which the interface endpoint is used.
         */
        vpceId: string;
    }

    export interface StackApplicationSettings {
        /**
         * Whether application settings should be persisted.
         */
        enabled: boolean;
        /**
         * Name of the settings group.
         * Required when `enabled` is `true`.
         * Can be up to 100 characters.
         */
        settingsGroup?: string;
    }

    export interface StackStorageConnector {
        /**
         * Type of storage connector.
         * Valid values are `HOMEFOLDERS`, `GOOGLE_DRIVE`, or `ONE_DRIVE`.
         */
        connectorType: string;
        /**
         * Names of the domains for the account.
         */
        domains: string[];
        /**
         * ARN of the storage connector.
         */
        resourceIdentifier: string;
    }

    export interface StackStreamingExperienceSettings {
        /**
         * The preferred protocol that you want to use while streaming your application.
         * Valid values are `TCP` and `UDP`.
         */
        preferredProtocol?: string;
    }

    export interface StackUserSetting {
        /**
         * Action that is enabled or disabled.
         * Valid values are `CLIPBOARD_COPY_FROM_LOCAL_DEVICE`,  `CLIPBOARD_COPY_TO_LOCAL_DEVICE`, `FILE_UPLOAD`, `FILE_DOWNLOAD`, `PRINTING_TO_LOCAL_DEVICE`, `DOMAIN_PASSWORD_SIGNIN`, or `DOMAIN_SMART_CARD_SIGNIN`.
         */
        action: string;
        /**
         * Whether the action is enabled or disabled.
         * Valid values are `ENABLED` or `DISABLED`.
         */
        permission: string;
    }

}

export namespace appsync {
    export interface DataSourceDynamodbConfig {
        /**
         * The DeltaSyncConfig for a versioned data source. See Delta Sync Config
         */
        deltaSyncConfig?: outputs.appsync.DataSourceDynamodbConfigDeltaSyncConfig;
        /**
         * AWS region of the DynamoDB table. Defaults to current region.
         */
        region: string;
        /**
         * Name of the DynamoDB table.
         */
        tableName: string;
        /**
         * Set to `true` to use Amazon Cognito credentials with this data source.
         */
        useCallerCredentials?: boolean;
        /**
         * Detects Conflict Detection and Resolution with this data source.
         */
        versioned?: boolean;
    }

    export interface DataSourceDynamodbConfigDeltaSyncConfig {
        /**
         * The number of minutes that an Item is stored in the data source.
         */
        baseTableTtl?: number;
        /**
         * The table name.
         */
        deltaSyncTableName: string;
        /**
         * The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
         */
        deltaSyncTableTtl?: number;
    }

    export interface DataSourceElasticsearchConfig {
        /**
         * HTTP endpoint of the Elasticsearch domain.
         */
        endpoint: string;
        /**
         * AWS region of Elasticsearch domain. Defaults to current region.
         */
        region: string;
    }

    export interface DataSourceEventBridgeConfig {
        /**
         * ARN for the EventBridge bus.
         */
        eventBusArn: string;
    }

    export interface DataSourceHttpConfig {
        /**
         * Authorization configuration in case the HTTP endpoint requires authorization. See Authorization Config.
         */
        authorizationConfig?: outputs.appsync.DataSourceHttpConfigAuthorizationConfig;
        /**
         * HTTP URL.
         */
        endpoint: string;
    }

    export interface DataSourceHttpConfigAuthorizationConfig {
        /**
         * Authorization type that the HTTP endpoint requires. Default values is `AWS_IAM`.
         */
        authorizationType?: string;
        /**
         * Identity and Access Management (IAM) settings. See AWS IAM Config.
         */
        awsIamConfig?: outputs.appsync.DataSourceHttpConfigAuthorizationConfigAwsIamConfig;
    }

    export interface DataSourceHttpConfigAuthorizationConfigAwsIamConfig {
        /**
         * Signing Amazon Web Services Region for IAM authorization.
         */
        signingRegion?: string;
        /**
         * Signing service name for IAM authorization.
         */
        signingServiceName?: string;
    }

    export interface DataSourceLambdaConfig {
        /**
         * ARN for the Lambda function.
         */
        functionArn: string;
    }

    export interface DataSourceOpensearchserviceConfig {
        /**
         * HTTP endpoint of the Elasticsearch domain.
         */
        endpoint: string;
        /**
         * AWS region of the DynamoDB table. Defaults to current region.
         */
        region: string;
    }

    export interface DataSourceRelationalDatabaseConfig {
        /**
         * Amazon RDS HTTP endpoint configuration. See HTTP Endpoint Config.
         */
        httpEndpointConfig?: outputs.appsync.DataSourceRelationalDatabaseConfigHttpEndpointConfig;
        /**
         * Source type for the relational database. Valid values: `RDS_HTTP_ENDPOINT`.
         */
        sourceType?: string;
    }

    export interface DataSourceRelationalDatabaseConfigHttpEndpointConfig {
        /**
         * AWS secret store ARN for database credentials.
         */
        awsSecretStoreArn: string;
        /**
         * Logical database name.
         */
        databaseName?: string;
        /**
         * Amazon RDS cluster identifier.
         */
        dbClusterIdentifier: string;
        /**
         * AWS Region for RDS HTTP endpoint. Defaults to current region.
         */
        region: string;
        /**
         * Logical schema name.
         */
        schema?: string;
    }

    export interface FunctionRuntime {
        /**
         * The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
         */
        name: string;
        /**
         * The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
         */
        runtimeVersion: string;
    }

    export interface FunctionSyncConfig {
        /**
         * Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
         */
        conflictDetection?: string;
        /**
         * Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
         */
        conflictHandler?: string;
        /**
         * Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
         */
        lambdaConflictHandlerConfig?: outputs.appsync.FunctionSyncConfigLambdaConflictHandlerConfig;
    }

    export interface FunctionSyncConfigLambdaConflictHandlerConfig {
        /**
         * ARN for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: string;
    }

    export interface GraphQLApiAdditionalAuthenticationProvider {
        /**
         * Authentication type. Valid values: `API_KEY`, `AWS_IAM`, `AMAZON_COGNITO_USER_POOLS`, `OPENID_CONNECT`, `AWS_LAMBDA`
         */
        authenticationType: string;
        /**
         * Nested argument containing Lambda authorizer configuration. Defined below.
         */
        lambdaAuthorizerConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfig;
        /**
         * Nested argument containing OpenID Connect configuration. Defined below.
         */
        openidConnectConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfig;
        /**
         * Amazon Cognito User Pool configuration. Defined below.
         */
        userPoolConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderUserPoolConfig;
    }

    export interface GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfig {
        /**
         * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
         */
        authorizerResultTtlInSeconds?: number;
        /**
         * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
         */
        authorizerUri: string;
        /**
         * Regular expression for validation of tokens before the Lambda function is called.
         */
        identityValidationExpression?: string;
    }

    export interface GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfig {
        /**
         * Number of milliseconds a token is valid after being authenticated.
         */
        authTtl?: number;
        /**
         * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
         */
        clientId?: string;
        /**
         * Number of milliseconds a token is valid after being issued to a user.
         */
        iatTtl?: number;
        /**
         * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
         */
        issuer: string;
    }

    export interface GraphQLApiAdditionalAuthenticationProviderUserPoolConfig {
        /**
         * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
         */
        appIdClientRegex?: string;
        /**
         * AWS region in which the user pool was created.
         */
        awsRegion: string;
        /**
         * User pool ID.
         */
        userPoolId: string;
    }

    export interface GraphQLApiLambdaAuthorizerConfig {
        /**
         * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
         */
        authorizerResultTtlInSeconds?: number;
        /**
         * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
         */
        authorizerUri: string;
        /**
         * Regular expression for validation of tokens before the Lambda function is called.
         */
        identityValidationExpression?: string;
    }

    export interface GraphQLApiLogConfig {
        /**
         * Amazon Resource Name of the service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account.
         */
        cloudwatchLogsRoleArn: string;
        /**
         * Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging  level. Valid values: `true`, `false`. Default value: `false`
         */
        excludeVerboseContent?: boolean;
        /**
         * Field logging level. Valid values: `ALL`, `ERROR`, `NONE`.
         */
        fieldLogLevel: string;
    }

    export interface GraphQLApiOpenidConnectConfig {
        /**
         * Number of milliseconds a token is valid after being authenticated.
         */
        authTtl?: number;
        /**
         * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
         */
        clientId?: string;
        /**
         * Number of milliseconds a token is valid after being issued to a user.
         */
        iatTtl?: number;
        /**
         * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
         */
        issuer: string;
    }

    export interface GraphQLApiUserPoolConfig {
        /**
         * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
         */
        appIdClientRegex?: string;
        /**
         * AWS region in which the user pool was created.
         */
        awsRegion: string;
        /**
         * Action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration. Valid: `ALLOW` and `DENY`
         */
        defaultAction: string;
        /**
         * User pool ID.
         */
        userPoolId: string;
    }

    export interface ResolverCachingConfig {
        /**
         * The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
         */
        cachingKeys?: string[];
        /**
         * The TTL in seconds for a resolver that has caching activated. Valid values are between `1` and `3600` seconds.
         */
        ttl?: number;
    }

    export interface ResolverPipelineConfig {
        /**
         * A list of Function objects.
         */
        functions?: string[];
    }

    export interface ResolverRuntime {
        /**
         * The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
         */
        name: string;
        /**
         * The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
         */
        runtimeVersion: string;
    }

    export interface ResolverSyncConfig {
        /**
         * Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
         */
        conflictDetection?: string;
        /**
         * Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
         */
        conflictHandler?: string;
        /**
         * Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
         */
        lambdaConflictHandlerConfig?: outputs.appsync.ResolverSyncConfigLambdaConflictHandlerConfig;
    }

    export interface ResolverSyncConfigLambdaConflictHandlerConfig {
        /**
         * ARN for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: string;
    }

}

export namespace athena {
    export interface DatabaseAclConfiguration {
        /**
         * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
         *
         * > **NOTE:** When Athena queries are executed, result files may be created in the specified bucket. Consider using `forceDestroy` on the bucket too in order to avoid any problems when destroying the bucket.
         */
        s3AclOption: string;
    }

    export interface DatabaseEncryptionConfiguration {
        /**
         * Type of key; one of `SSE_S3`, `SSE_KMS`, `CSE_KMS`
         */
        encryptionOption: string;
        /**
         * KMS key ARN or ID; required for key types `SSE_KMS` and `CSE_KMS`.
         */
        kmsKey?: string;
    }

    export interface WorkgroupConfiguration {
        /**
         * Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least `10485760`.
         */
        bytesScannedCutoffPerQuery?: number;
        /**
         * Boolean whether the settings for the workgroup override client-side settings. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html). Defaults to `true`.
         */
        enforceWorkgroupConfiguration?: boolean;
        /**
         * Configuration block for the Athena Engine Versioning. For more information, see [Athena Engine Versioning](https://docs.aws.amazon.com/athena/latest/ug/engine-versions.html). See Engine Version below.
         */
        engineVersion?: outputs.athena.WorkgroupConfigurationEngineVersion;
        /**
         * Role used in a notebook session for accessing the user's resources.
         */
        executionRole?: string;
        /**
         * Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to `true`.
         */
        publishCloudwatchMetricsEnabled?: boolean;
        /**
         * If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
         */
        requesterPaysEnabled?: boolean;
        /**
         * Configuration block with result settings. See Result Configuration below.
         */
        resultConfiguration?: outputs.athena.WorkgroupConfigurationResultConfiguration;
    }

    export interface WorkgroupConfigurationEngineVersion {
        /**
         * The engine version on which the query runs. If `selectedEngineVersion` is set to `AUTO`, the effective engine version is chosen by Athena.
         */
        effectiveEngineVersion: string;
        /**
         * Requested engine version. Defaults to `AUTO`.
         */
        selectedEngineVersion?: string;
    }

    export interface WorkgroupConfigurationResultConfiguration {
        /**
         * That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
         */
        aclConfiguration?: outputs.athena.WorkgroupConfigurationResultConfigurationAclConfiguration;
        /**
         * Configuration block with encryption settings. See Encryption Configuration below.
         */
        encryptionConfiguration?: outputs.athena.WorkgroupConfigurationResultConfigurationEncryptionConfiguration;
        /**
         * AWS account ID that you expect to be the owner of the Amazon S3 bucket.
         */
        expectedBucketOwner?: string;
        /**
         * Location in Amazon S3 where your query results are stored, such as `s3://path/to/query/bucket/`. For more information, see [Queries and Query Result Files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
         */
        outputLocation?: string;
    }

    export interface WorkgroupConfigurationResultConfigurationAclConfiguration {
        /**
         * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
         */
        s3AclOption: string;
    }

    export interface WorkgroupConfigurationResultConfigurationEncryptionConfiguration {
        /**
         * Whether Amazon S3 server-side encryption with Amazon S3-managed keys (`SSE_S3`), server-side encryption with KMS-managed keys (`SSE_KMS`), or client-side encryption with KMS-managed keys (`CSE_KMS`) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
         */
        encryptionOption?: string;
        /**
         * For `SSE_KMS` and `CSE_KMS`, this is the KMS key ARN.
         */
        kmsKeyArn?: string;
    }

}

export namespace auditmanager {
    export interface AssessmentAssessmentReportsDestination {
        /**
         * Destination of the assessment report. This value be in the form `s3://{bucket_name}`.
         */
        destination: string;
        /**
         * Destination type. Currently, `S3` is the only valid value.
         */
        destinationType: string;
    }

    export interface AssessmentRole {
        /**
         * Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: string;
        /**
         * Type of customer persona. For assessment creation, type must always be `PROCESS_OWNER`.
         */
        roleType: string;
    }

    export interface AssessmentRolesAll {
        /**
         * Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: string;
        /**
         * Type of customer persona. For assessment creation, type must always be `PROCESS_OWNER`.
         */
        roleType: string;
    }

    export interface AssessmentScope {
        /**
         * Amazon Web Services accounts that are in scope for the assessment. See `awsAccounts` below.
         */
        awsAccounts?: outputs.auditmanager.AssessmentScopeAwsAccount[];
        /**
         * Amazon Web Services services that are included in the scope of the assessment. See `awsServices` below.
         */
        awsServices?: outputs.auditmanager.AssessmentScopeAwsService[];
    }

    export interface AssessmentScopeAwsAccount {
        /**
         * Identifier for the Amazon Web Services account.
         */
        id: string;
    }

    export interface AssessmentScopeAwsService {
        /**
         * Name of the Amazon Web Service.
         */
        serviceName: string;
    }

    export interface ControlControlMappingSource {
        /**
         * Description of the source.
         */
        sourceDescription?: string;
        /**
         * Frequency of evidence collection. Valid values are `DAILY`, `WEEKLY`, or `MONTHLY`.
         */
        sourceFrequency?: string;
        sourceId: string;
        /**
         * The keyword to search for in CloudTrail logs, Config rules, Security Hub checks, and Amazon Web Services API names. See `sourceKeyword` below.
         */
        sourceKeyword?: outputs.auditmanager.ControlControlMappingSourceSourceKeyword;
        /**
         * Name of the source.
         */
        sourceName: string;
        /**
         * The setup option for the data source. This option reflects if the evidence collection is automated or manual. Valid values are `System_Controls_Mapping` (automated) and `Procedural_Controls_Mapping` (manual).
         */
        sourceSetUpOption: string;
        /**
         * Type of data source for evidence collection. If `sourceSetUpOption` is manual, the only valid value is `MANUAL`. If `sourceSetUpOption` is automated, valid values are `AWS_Cloudtrail`, `AWS_Config`, `AWS_Security_Hub`, or `AWS_API_Call`.
         *
         * The following arguments are optional:
         */
        sourceType: string;
        /**
         * Instructions for troubleshooting the control.
         */
        troubleshootingText?: string;
    }

    export interface ControlControlMappingSourceSourceKeyword {
        /**
         * Input method for the keyword. Valid values are `SELECT_FROM_LIST`.
         */
        keywordInputType: string;
        /**
         * The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call. See the [Audit Manager supported control data sources documentation](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources.html) for more information.
         */
        keywordValue: string;
    }

    export interface FrameworkControlSet {
        /**
         * List of controls within the control set. See `controls` below.
         */
        controls?: outputs.auditmanager.FrameworkControlSetControl[];
        /**
         * Unique identifier of the control.
         */
        id: string;
        /**
         * Name of the control set.
         */
        name: string;
    }

    export interface FrameworkControlSetControl {
        /**
         * Unique identifier of the control.
         */
        id: string;
    }

    export interface GetControlControlMappingSource {
        sourceDescription: string;
        sourceFrequency: string;
        sourceId: string;
        sourceKeyword?: outputs.auditmanager.GetControlControlMappingSourceSourceKeyword;
        sourceName: string;
        sourceSetUpOption: string;
        sourceType: string;
        troubleshootingText: string;
    }

    export interface GetControlControlMappingSourceSourceKeyword {
        keywordInputType: string;
        keywordValue: string;
    }

    export interface GetFrameworkControlSet {
        controls?: outputs.auditmanager.GetFrameworkControlSetControl[];
        id: string;
        /**
         * Name of the framework.
         */
        name: string;
    }

    export interface GetFrameworkControlSetControl {
        id: string;
    }

}

export namespace autoscaling {
    export interface GetAmiIdsFilter {
        /**
         * Name of the DescribeAutoScalingGroup filter. The recommended values are: `tag-key`, `tag-value`, and `tag:<tag name>`
         */
        name: string;
        /**
         * Value of the filter.
         */
        values: string[];
    }

    export interface GetGroupLaunchTemplate {
        /**
         * ID of the launch template.
         */
        id: string;
        /**
         * Specify the exact name of the desired autoscaling group.
         */
        name: string;
        /**
         * Template version.
         */
        version: string;
    }

    export interface GetGroupMixedInstancesPolicy {
        /**
         * List of instances distribution objects.
         */
        instancesDistributions: outputs.autoscaling.GetGroupMixedInstancesPolicyInstancesDistribution[];
        /**
         * List of launch templates along with the overrides.
         */
        launchTemplates: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplate[];
    }

    export interface GetGroupMixedInstancesPolicyInstancesDistribution {
        /**
         * Strategy used when launching on-demand instances.
         */
        onDemandAllocationStrategy: string;
        /**
         * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances.
         */
        onDemandBaseCapacity: number;
        onDemandPercentageAboveBaseCapacity: number;
        /**
         * Strategy used when launching Spot instances.
         */
        spotAllocationStrategy: string;
        /**
         * Number of Spot pools per availability zone to allocate capacity.
         */
        spotInstancePools: number;
        /**
         * Maximum price per unit hour that the user is willing to pay for the Spot instances.
         */
        spotMaxPrice: string;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplate {
        /**
         * List of overriding launch template specification objects.
         */
        launchTemplateSpecifications: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification[];
        /**
         * List of properties overriding the same properties in the launch template.
         */
        overrides: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverride[];
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        /**
         * ID of the launch template.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName: string;
        /**
         * Template version.
         */
        version: string;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverride {
        /**
         * List of instance requirements objects.
         * * `acceleratorCount - List of objects describing the minimum and maximum number of accelerators for an instance type.
         */
        instanceRequirements: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirement[];
        /**
         * Overriding instance type.
         */
        instanceType: string;
        /**
         * List of overriding launch template specification objects.
         */
        launchTemplateSpecifications: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification[];
        /**
         * Number of capacity units, which gives the instance type a proportional weight to other instance types.
         */
        weightedCapacity: string;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirement {
        acceleratorCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCount[];
        /**
         * List of accelerator manufacturer names.
         */
        acceleratorManufacturers: string[];
        /**
         * List of accelerator names.
         */
        acceleratorNames: string[];
        /**
         * List of objects describing the minimum and maximum total memory of the accelerators.
         */
        acceleratorTotalMemoryMibs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMib[];
        /**
         * List of accelerator types.
         */
        acceleratorTypes: string[];
        /**
         * List of instance types to apply the specified attributes against.
         */
        allowedInstanceTypes: string[];
        /**
         * Indicates whether bare metal instances are included, excluded, or required.
         */
        bareMetal: string;
        /**
         * List of objects describing the minimum and maximum baseline EBS bandwidth (Mbps).
         */
        baselineEbsBandwidthMbps: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbp[];
        /**
         * Indicates whether burstable performance instance types are included, excluded, or required.
         */
        burstablePerformance: string;
        /**
         * List of CPU manufacturer names.
         */
        cpuManufacturers: string[];
        /**
         * List of excluded instance types.
         */
        excludedInstanceTypes: string[];
        /**
         * List of instance generation names.
         */
        instanceGenerations: string[];
        /**
         * Indicates whether instance types with instance store volumes are included, excluded, or required.
         */
        localStorage: string;
        /**
         * List of local storage type names.
         */
        localStorageTypes: string[];
        /**
         * List of objects describing the minimum and maximum amount of memory (GiB) per vCPU.
         */
        memoryGibPerVcpus: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpus[];
        /**
         * List of objects describing the minimum and maximum amount of memory (MiB).
         */
        memoryMibs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMib[];
        /**
         * List of objects describing the minimum and maximum amount of network bandwidth (Gbps).
         */
        networkBandwidthGbps: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbp[];
        /**
         * List of objects describing the minimum and maximum amount of network interfaces.
         */
        networkInterfaceCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCount[];
        /**
         * Price protection threshold for On-Demand Instances.
         */
        onDemandMaxPricePercentageOverLowestPrice: number;
        /**
         * Indicates whether instance types must support On-Demand Instance Hibernation.
         */
        requireHibernateSupport: boolean;
        /**
         * Price protection threshold for Spot Instances.
         */
        spotMaxPricePercentageOverLowestPrice: number;
        /**
         * List of objects describing the minimum and maximum total storage (GB).
         */
        totalLocalStorageGbs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGb[];
        /**
         * List of objects describing the minimum and maximum number of vCPUs.
         */
        vcpuCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCount[];
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMib {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbp {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpus {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMib {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbp {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGb {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
        /**
         * ID of the launch template.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName: string;
        /**
         * Template version.
         */
        version: string;
    }

    export interface GetGroupTag {
        /**
         * Key.
         */
        key: string;
        /**
         * Whether the tag is propagated to Amazon EC2 instances launched via this ASG.
         */
        propagateAtLaunch: boolean;
        /**
         * Value.
         */
        value: string;
    }

    export interface GetGroupTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Traffic source type.
         */
        type: string;
    }

    export interface GetGroupWarmPool {
        /**
         * List of instance reuse policy objects.
         */
        instanceReusePolicies: outputs.autoscaling.GetGroupWarmPoolInstanceReusePolicy[];
        maxGroupPreparedCapacity: number;
        /**
         * Minimum number of instances to maintain in the warm pool.
         */
        minSize: number;
        /**
         * Instance state to transition to after the lifecycle actions are complete.
         */
        poolState: string;
    }

    export interface GetGroupWarmPoolInstanceReusePolicy {
        /**
         * Indicates whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
         */
        reuseOnScaleIn: boolean;
    }

    export interface GroupInitialLifecycleHook {
        defaultResult: string;
        heartbeatTimeout?: number;
        lifecycleTransition: string;
        /**
         * Name of the Auto Scaling Group. By default generated by Pulumi. Conflicts with `namePrefix`.
         */
        name: string;
        notificationMetadata?: string;
        notificationTargetArn?: string;
        roleArn?: string;
    }

    export interface GroupInstanceRefresh {
        /**
         * Override default parameters for Instance Refresh.
         */
        preferences?: outputs.autoscaling.GroupInstanceRefreshPreferences;
        /**
         * Strategy to use for instance refresh. The only allowed value is `Rolling`. See [StartInstanceRefresh Action](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_StartInstanceRefresh.html#API_StartInstanceRefresh_RequestParameters) for more information.
         */
        strategy: string;
        /**
         * Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of `launchConfiguration`, `launchTemplate`, or `mixedInstancesPolicy`.
         *
         * > **NOTE:** A refresh is started when any of the following Auto Scaling Group properties change: `launchConfiguration`, `launchTemplate`, `mixedInstancesPolicy`. Additional properties can be specified in the `triggers` property of `instanceRefresh`.
         *
         * > **NOTE:** A refresh will not start when `version = "$Latest"` is configured in the `launchTemplate` block. To trigger the instance refresh when a launch template is changed, configure `version` to use the `latestVersion` attribute of the `aws.ec2.LaunchTemplate` resource.
         *
         * > **NOTE:** Auto Scaling Groups support up to one active instance refresh at a time. When this resource is updated, any existing refresh is cancelled.
         *
         * > **NOTE:** Depending on health check settings and group size, an instance refresh may take a long time or fail. This resource does not wait for the instance refresh to complete.
         */
        triggers?: string[];
    }

    export interface GroupInstanceRefreshPreferences {
        /**
         * Automatically rollback if instance refresh fails. Defaults to `false`.
         */
        autoRollback?: boolean;
        /**
         * Number of seconds to wait after a checkpoint. Defaults to `3600`.
         */
        checkpointDelay?: string;
        /**
         * List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be `100`.
         */
        checkpointPercentages?: number[];
        /**
         * Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
         */
        instanceWarmup?: string;
        /**
         * Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to `90`.
         */
        minHealthyPercentage?: number;
        /**
         * Replace instances that already have your desired configuration. Defaults to `false`.
         */
        skipMatching?: boolean;
    }

    export interface GroupLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
         */
        version?: string;
    }

    export interface GroupMixedInstancesPolicy {
        /**
         * Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
         */
        instancesDistribution: outputs.autoscaling.GroupMixedInstancesPolicyInstancesDistribution;
        /**
         * Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
         */
        launchTemplate: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplate;
    }

    export interface GroupMixedInstancesPolicyInstancesDistribution {
        /**
         * Strategy to use when launching on-demand instances. Valid values: `prioritized`, `lowest-price`. Default: `prioritized`.
         */
        onDemandAllocationStrategy: string;
        /**
         * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
         */
        onDemandBaseCapacity: number;
        /**
         * Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
         */
        onDemandPercentageAboveBaseCapacity: number;
        /**
         * How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`, `capacity-optimized-prioritized`, and `price-capacity-optimized`. Default: `lowest-price`.
         */
        spotAllocationStrategy: string;
        /**
         * Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Only available with `spotAllocationStrategy` set to `lowest-price`. Otherwise it must be set to `0`, if it has been defined before. Default: `2`.
         */
        spotInstancePools: number;
        /**
         * Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
         */
        spotMaxPrice?: string;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplate {
        /**
         * Nested argument defines the Launch Template. Defined below.
         */
        launchTemplateSpecification: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification;
        /**
         * List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
         */
        overrides?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverride[];
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        /**
         * ID of the launch template. Conflicts with `launchTemplateName`.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template. Conflicts with `launchTemplateId`.
         */
        launchTemplateName: string;
        /**
         * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
         */
        version?: string;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverride {
        /**
         * Override the instance type in the Launch Template with instance types that satisfy the requirements.
         */
        instanceRequirements?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements;
        /**
         * Override the instance type in the Launch Template.
         */
        instanceType?: string;
        /**
         * Nested argument defines the Launch Template. Defined below.
         */
        launchTemplateSpecification?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification;
        /**
         * Number of capacity units, which gives the instance type a proportional weight to other instance types.
         */
        weightedCapacity?: string;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
         */
        acceleratorCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * List of accelerator types. Default is any accelerator type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorTypes?: string[];
        /**
         * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
         *
         * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * List of CPU manufacturer names. Default is any manufacturer.
         *
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        cpuManufacturers?: string[];
        /**
         * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * List of instance generation names. Default is any generation.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Default any storage type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu;
        /**
         * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
         */
        memoryMib?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib;
        /**
         * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
         */
        networkBandwidthGbps?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount;
        /**
         * Price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * Price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
        /**
         * ID of the launch template. Conflicts with `launchTemplateName`.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template. Conflicts with `launchTemplateId`.
         */
        launchTemplateName: string;
        /**
         * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
         */
        version?: string;
    }

    export interface GroupTag {
        /**
         * Key
         */
        key: string;
        /**
         * Enables propagation of the tag to
         * Amazon EC2 instances launched via this ASG
         *
         * To declare multiple tags, additional `tag` blocks can be specified.
         *
         * > **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so the provider does not attempt to remove them and so if the `minSize` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service.
         */
        propagateAtLaunch: boolean;
        /**
         * Value
         */
        value: string;
    }

    export interface GroupTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Provides additional context for the value of Identifier.
         * The following lists the valid values:
         * `elb` if `identifier` is the name of a Classic Load Balancer.
         * `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
         * `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
         */
        type?: string;
    }

    export interface GroupWarmPool {
        /**
         * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
         */
        instanceReusePolicy?: outputs.autoscaling.GroupWarmPoolInstanceReusePolicy;
        /**
         * Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
         */
        maxGroupPreparedCapacity?: number;
        /**
         * Minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
         */
        minSize?: number;
        /**
         * Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
         */
        poolState?: string;
    }

    export interface GroupWarmPoolInstanceReusePolicy {
        /**
         * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
         */
        reuseOnScaleIn?: boolean;
    }

    export interface PolicyPredictiveScalingConfiguration {
        /**
         * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are `HonorMaxCapacity` or `IncreaseMaxCapacity`. Default is `HonorMaxCapacity`.
         */
        maxCapacityBreachBehavior?: string;
        /**
         * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is `0` to `100`. If set to `0`, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
         */
        maxCapacityBuffer?: string;
        /**
         * This structure includes the metrics and target utilization to use for predictive scaling.
         */
        metricSpecification: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecification;
        /**
         * Predictive scaling mode. Valid values are `ForecastAndScale` and `ForecastOnly`. Default is `ForecastOnly`.
         */
        mode?: string;
        /**
         * Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is `0`.
         */
        schedulingBufferTime?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecification {
        /**
         * Customized capacity metric specification. The field is only valid when you use `customizedLoadMetricSpecification`
         */
        customizedCapacityMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification;
        /**
         * Customized load metric specification.
         */
        customizedLoadMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification;
        /**
         * Customized scaling metric specification.
         */
        customizedScalingMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification;
        /**
         * Predefined load metric specification.
         */
        predefinedLoadMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification;
        /**
         * Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
         */
        predefinedMetricPairSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification;
        /**
         * Predefined scaling metric specification.
         */
        predefinedScalingMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification {
        /**
         * List of up to 10 structures that defines custom capacity metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery[];
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification {
        /**
         * List of up to 10 structures that defines custom load metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery[];
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification {
        /**
         * List of up to 10 structures that defines custom scaling metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery[];
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification {
        /**
         * Metric type. Valid values are `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`, or `ALBTargetGroupRequestCount`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
         */
        resourceLabel?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification {
        /**
         * Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is `ASGCPUUtilization`, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are `ASGCPUUtilization`, `ASGNetworkIn`, `ASGNetworkOut`, or `ALBRequestCount`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
         */
        resourceLabel?: string;
    }

    export interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification {
        /**
         * Describes a scaling metric for a predictive scaling policy. Valid values are `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, or `ALBRequestCountPerTarget`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
         */
        resourceLabel?: string;
    }

    export interface PolicyStepAdjustment {
        /**
         * Lower bound for the
         * difference between the alarm threshold and the CloudWatch metric.
         * Without a value, AWS will treat this bound as negative infinity.
         */
        metricIntervalLowerBound?: string;
        /**
         * Upper bound for the
         * difference between the alarm threshold and the CloudWatch metric.
         * Without a value, AWS will treat this bound as positive infinity. The upper bound
         * must be greater than the lower bound.
         *
         * Notice the bounds are **relative** to the alarm threshold, meaning that the starting point is not 0%, but the alarm threshold. Check the official [docs](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-steps) for a detailed example.
         *
         * The following arguments are only available to "TargetTrackingScaling" type policies:
         */
        metricIntervalUpperBound?: string;
        /**
         * Number of members by which to
         * scale, when the adjustment bounds are breached. A positive value scales
         * up. A negative value scales down.
         */
        scalingAdjustment: number;
    }

    export interface PolicyTargetTrackingConfiguration {
        /**
         * Customized metric. Conflicts with `predefinedMetricSpecification`.
         */
        customizedMetricSpecification?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecification;
        /**
         * Whether scale in by the target tracking policy is disabled.
         */
        disableScaleIn?: boolean;
        /**
         * Predefined metric. Conflicts with `customizedMetricSpecification`.
         */
        predefinedMetricSpecification?: outputs.autoscaling.PolicyTargetTrackingConfigurationPredefinedMetricSpecification;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        metricDimensions?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName?: string;
        /**
         * Metrics to include, as a metric data query.
         */
        metrics?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric[];
        /**
         * Namespace of the metric.
         */
        namespace?: string;
        /**
         * Statistic of the metric.
         */
        statistic?: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in target tracking scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }

    export interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }

    export interface PolicyTargetTrackingConfigurationPredefinedMetricSpecification {
        /**
         * Metric type.
         */
        predefinedMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }

    export interface TagTag {
        /**
         * Tag name.
         */
        key: string;
        /**
         * Whether to propagate the tags to instances launched by the ASG.
         */
        propagateAtLaunch: boolean;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface TrafficSourceAttachmentTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Provides additional context for the value of `identifier`.
         * The following lists the valid values:
         * `elb` if `identifier` is the name of a Classic Load Balancer.
         * `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
         * `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
         */
        type: string;
    }

}

export namespace autoscalingplans {
    export interface ScalingPlanApplicationSource {
        /**
         * ARN of a AWS CloudFormation stack.
         */
        cloudformationStackArn?: string;
        /**
         * Set of tags.
         */
        tagFilters?: outputs.autoscalingplans.ScalingPlanApplicationSourceTagFilter[];
    }

    export interface ScalingPlanApplicationSourceTagFilter {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag values.
         */
        values?: string[];
    }

    export interface ScalingPlanScalingInstruction {
        /**
         * Customized load metric to use for predictive scaling. You must specify either `customizedLoadMetricSpecification` or `predefinedLoadMetricSpecification` when configuring predictive scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedLoadMetricSpecification.html).
         */
        customizedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionCustomizedLoadMetricSpecification;
        /**
         * Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to `false`.
         */
        disableDynamicScaling?: boolean;
        /**
         * Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for `predictiveScalingMaxCapacityBehavior`.
         */
        maxCapacity: number;
        /**
         * Minimum capacity of the resource.
         */
        minCapacity: number;
        /**
         * Predefined load metric to use for predictive scaling. You must specify either `predefinedLoadMetricSpecification` or `customizedLoadMetricSpecification` when configuring predictive scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedLoadMetricSpecification.html).
         */
        predefinedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionPredefinedLoadMetricSpecification;
        /**
         * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource.
         * Valid values: `SetForecastCapacityToMaxCapacity`, `SetMaxCapacityAboveForecastCapacity`, `SetMaxCapacityToForecastCapacity`.
         */
        predictiveScalingMaxCapacityBehavior?: string;
        /**
         * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
         */
        predictiveScalingMaxCapacityBuffer?: number;
        /**
         * Predictive scaling mode. Valid values: `ForecastAndScale`, `ForecastOnly`.
         */
        predictiveScalingMode?: string;
        /**
         * ID of the resource. This string consists of the resource type and unique identifier.
         */
        resourceId: string;
        /**
         * Scalable dimension associated with the resource. Valid values: `autoscaling:autoScalingGroup:DesiredCapacity`, `dynamodb:index:ReadCapacityUnits`, `dynamodb:index:WriteCapacityUnits`, `dynamodb:table:ReadCapacityUnits`, `dynamodb:table:WriteCapacityUnits`, `ecs:service:DesiredCount`, `ec2:spot-fleet-request:TargetCapacity`, `rds:cluster:ReadReplicaCount`.
         */
        scalableDimension: string;
        /**
         * Controls whether a resource's externally created scaling policies are kept or replaced. Valid values: `KeepExternalPolicies`, `ReplaceExternalPolicies`. Defaults to `KeepExternalPolicies`.
         */
        scalingPolicyUpdateBehavior?: string;
        /**
         * Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.
         */
        scheduledActionBufferTime?: number;
        /**
         * Namespace of the AWS service. Valid values: `autoscaling`, `dynamodb`, `ecs`, `ec2`, `rds`.
         */
        serviceNamespace: string;
        /**
         * Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_TargetTrackingConfiguration.html).
         */
        targetTrackingConfigurations: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfiguration[];
    }

    export interface ScalingPlanScalingInstructionCustomizedLoadMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        dimensions?: {[key: string]: string};
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
        /**
         * Statistic of the metric. Currently, the value must always be `Sum`.
         */
        statistic: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }

    export interface ScalingPlanScalingInstructionPredefinedLoadMetricSpecification {
        /**
         * Metric type. Valid values: `ALBTargetGroupRequestCount`, `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`.
         */
        predefinedLoadMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }

    export interface ScalingPlanScalingInstructionTargetTrackingConfiguration {
        /**
         * Customized metric. You can specify either `customizedScalingMetricSpecification` or `predefinedScalingMetricSpecification`.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedScalingMetricSpecification.html).
         */
        customizedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification;
        /**
         * Boolean indicating whether scale in by the target tracking scaling policy is disabled. Defaults to `false`.
         */
        disableScaleIn?: boolean;
        /**
         * Estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics.
         * This value is used only if the resource is an Auto Scaling group.
         */
        estimatedInstanceWarmup?: number;
        /**
         * Predefined metric. You can specify either `predefinedScalingMetricSpecification` or `customizedScalingMetricSpecification`.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedScalingMetricSpecification.html).
         */
        predefinedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification;
        /**
         * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
         * This value is not used if the scalable resource is an Auto Scaling group.
         */
        scaleInCooldown?: number;
        /**
         * Amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
         * This value is not used if the scalable resource is an Auto Scaling group.
         */
        scaleOutCooldown?: number;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }

    export interface ScalingPlanScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        dimensions?: {[key: string]: string};
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
        /**
         * Statistic of the metric. Valid values: `Average`, `Maximum`, `Minimum`, `SampleCount`, `Sum`.
         */
        statistic: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }

    export interface ScalingPlanScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification {
        /**
         * Metric type. Valid values: `ALBRequestCountPerTarget`, `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, `DynamoDBReadCapacityUtilization`, `DynamoDBWriteCapacityUtilization`, `ECSServiceAverageCPUUtilization`, `ECSServiceAverageMemoryUtilization`, `EC2SpotFleetRequestAverageCPUUtilization`, `EC2SpotFleetRequestAverageNetworkIn`, `EC2SpotFleetRequestAverageNetworkOut`, `RDSReaderAverageCPUUtilization`, `RDSReaderAverageDatabaseConnections`.
         */
        predefinedScalingMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }

}

export namespace backup {
    export interface FrameworkControl {
        /**
         * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
         */
        inputParameters?: outputs.backup.FrameworkControlInputParameter[];
        /**
         * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
         */
        name: string;
        /**
         * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
         */
        scope?: outputs.backup.FrameworkControlScope;
    }

    export interface FrameworkControlInputParameter {
        /**
         * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
         */
        name?: string;
        /**
         * The value of parameter, for example, hourly.
         */
        value?: string;
    }

    export interface FrameworkControlScope {
        /**
         * The ID of the only AWS resource that you want your control scope to contain. Minimum number of 1 item. Maximum number of 100 items.
         */
        complianceResourceIds?: string[];
        /**
         * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
         */
        complianceResourceTypes?: string[];
        /**
         * Metadata that you can assign to help organize the frameworks you create. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {[key: string]: string};
    }

    export interface GetFrameworkControl {
        /**
         * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
         */
        inputParameters: outputs.backup.GetFrameworkControlInputParameter[];
        /**
         * Backup framework name.
         */
        name: string;
        /**
         * Scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
         */
        scopes: outputs.backup.GetFrameworkControlScope[];
    }

    export interface GetFrameworkControlInputParameter {
        /**
         * Backup framework name.
         */
        name: string;
        /**
         * Value of parameter, for example, hourly.
         */
        value: string;
    }

    export interface GetFrameworkControlScope {
        /**
         * The ID of the only AWS resource that you want your control scope to contain.
         */
        complianceResourceIds: string[];
        /**
         * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
         */
        complianceResourceTypes: string[];
        /**
         * Tag key-value pair applied to those AWS resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided.
         */
        tags: {[key: string]: string};
    }

    export interface GetReportPlanReportDeliveryChannel {
        /**
         * List of the format of your reports: CSV, JSON, or both.
         */
        formats: string[];
        /**
         * Unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: string;
        /**
         * Prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name.
         */
        s3KeyPrefix: string;
    }

    export interface GetReportPlanReportSetting {
        /**
         * (Optional) Specifies the list of accounts a report covers.
         */
        accounts: string[];
        /**
         * ARNs of the frameworks a report covers.
         */
        frameworkArns: string[];
        /**
         * Specifies the number of frameworks a report covers.
         */
        numberOfFrameworks: number;
        /**
         * (Optional) Specifies the list of Organizational Units a report covers.
         */
        organizationUnits: string[];
        /**
         * (Optional) Specifies the list of regions a report covers.
         */
        regions: string[];
        /**
         * Identifies the report template for the report. Reports are built using a report template.
         */
        reportTemplate: string;
    }

    export interface PlanAdvancedBackupSetting {
        /**
         * Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Set to `{ WindowsVSS = "enabled" }` to enable Windows VSS backup option and create a VSS Windows backup.
         */
        backupOptions: {[key: string]: string};
        /**
         * The type of AWS resource to be backed up. For VSS Windows backups, the only supported resource type is Amazon EC2. Valid values: `EC2`.
         */
        resourceType: string;
    }

    export interface PlanRule {
        /**
         * The amount of time in minutes AWS Backup attempts a backup before canceling the job and returning an error.
         */
        completionWindow?: number;
        /**
         * Configuration block(s) with copy operation settings. Detailed below.
         */
        copyActions?: outputs.backup.PlanRuleCopyAction[];
        /**
         * Enable continuous backups for supported resources.
         */
        enableContinuousBackup?: boolean;
        /**
         * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
         */
        lifecycle?: outputs.backup.PlanRuleLifecycle;
        /**
         * Metadata that you can assign to help organize the resources that you create.
         */
        recoveryPointTags?: {[key: string]: string};
        /**
         * An display name for a backup rule.
         */
        ruleName: string;
        /**
         * A CRON expression specifying when AWS Backup initiates a backup job.
         */
        schedule?: string;
        /**
         * The amount of time in minutes before beginning a backup.
         */
        startWindow?: number;
        /**
         * The name of a logical container where backups are stored.
         */
        targetVaultName: string;
    }

    export interface PlanRuleCopyAction {
        /**
         * An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
         */
        destinationVaultArn: string;
        /**
         * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
         */
        lifecycle?: outputs.backup.PlanRuleCopyActionLifecycle;
    }

    export interface PlanRuleCopyActionLifecycle {
        /**
         * Specifies the number of days after creation that a recovery point is moved to cold storage.
         */
        coldStorageAfter?: number;
        /**
         * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than `coldStorageAfter`.
         */
        deleteAfter?: number;
    }

    export interface PlanRuleLifecycle {
        /**
         * Specifies the number of days after creation that a recovery point is moved to cold storage.
         */
        coldStorageAfter?: number;
        /**
         * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than `coldStorageAfter`.
         */
        deleteAfter?: number;
    }

    export interface ReportPlanReportDeliveryChannel {
        /**
         * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
         */
        formats?: string[];
        /**
         * The unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: string;
        /**
         * The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
         */
        s3KeyPrefix?: string;
    }

    export interface ReportPlanReportSetting {
        /**
         * Specifies the list of accounts a report covers.
         */
        accounts?: string[];
        /**
         * Specifies the Amazon Resource Names (ARNs) of the frameworks a report covers.
         */
        frameworkArns?: string[];
        /**
         * Specifies the number of frameworks a report covers.
         */
        numberOfFrameworks?: number;
        /**
         * Specifies the list of Organizational Units a report covers.
         */
        organizationUnits?: string[];
        /**
         * Specifies the list of regions a report covers.
         */
        regions?: string[];
        /**
         * Identifies the report template for the report. Reports are built using a report template. The report templates are: `RESOURCE_COMPLIANCE_REPORT` | `CONTROL_COMPLIANCE_REPORT` | `BACKUP_JOB_REPORT` | `COPY_JOB_REPORT` | `RESTORE_JOB_REPORT`.
         */
        reportTemplate: string;
    }

    export interface SelectionCondition {
        stringEquals?: outputs.backup.SelectionConditionStringEqual[];
        stringLikes?: outputs.backup.SelectionConditionStringLike[];
        stringNotEquals?: outputs.backup.SelectionConditionStringNotEqual[];
        stringNotLikes?: outputs.backup.SelectionConditionStringNotLike[];
    }

    export interface SelectionConditionStringEqual {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }

    export interface SelectionConditionStringLike {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }

    export interface SelectionConditionStringNotEqual {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }

    export interface SelectionConditionStringNotLike {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }

    export interface SelectionSelectionTag {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * An operation, such as `StringEquals`, that is applied to a key-value pair used to filter resources in a selection.
         */
        type: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }

}

export namespace batch {
    export interface ComputeEnvironmentComputeResources {
        /**
         * The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. Valid items are `BEST_FIT_PROGRESSIVE`, `SPOT_CAPACITY_OPTIMIZED` or `BEST_FIT`. Defaults to `BEST_FIT`. See [AWS docs](https://docs.aws.amazon.com/batch/latest/userguide/allocation-strategies.html) for details. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        allocationStrategy?: string;
        /**
         * Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20% (`20`), then the Spot price must be below 20% of the current On-Demand price for that EC2 instance. If you leave this field empty, the default value is 100% of the On-Demand price. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        bidPercentage?: number;
        /**
         * The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        desiredVcpus: number;
        /**
         * Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment. If Ec2Configuration isn't specified, the default is ECS_AL2. This parameter isn't applicable to jobs that are running on Fargate resources, and shouldn't be specified.
         */
        ec2Configurations: outputs.batch.ComputeEnvironmentComputeResourcesEc2Configuration[];
        /**
         * The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        ec2KeyPair?: string;
        /**
         * The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use `ec2Configuration` `imageIdOverride` instead)
         */
        imageId?: string;
        /**
         * The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        instanceRole?: string;
        /**
         * A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        instanceTypes?: string[];
        /**
         * The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        launchTemplate?: outputs.batch.ComputeEnvironmentComputeResourcesLaunchTemplate;
        /**
         * The maximum number of EC2 vCPUs that an environment can reach.
         */
        maxVcpus: number;
        /**
         * The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        minVcpus?: number;
        /**
         * The Amazon EC2 placement group to associate with your compute resources.
         */
        placementGroup?: string;
        /**
         * A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
         */
        securityGroupIds?: string[];
        /**
         * The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        spotIamFleetRole?: string;
        /**
         * A list of VPC subnets into which the compute resources are launched.
         */
        subnets: string[];
        /**
         * Key-value pair tags to be applied to resources that are launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        tags?: {[key: string]: string};
        /**
         * The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.
         */
        type: string;
    }

    export interface ComputeEnvironmentComputeResourcesEc2Configuration {
        /**
         * The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `imageId` argument in the `computeResources` block.
         */
        imageIdOverride: string;
        /**
         * The image type to match with the instance type to select an AMI. If the `imageIdOverride` parameter isn't specified, then a recent [Amazon ECS-optimized Amazon Linux 2 AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html#al2ami) (`ECS_AL2`) is used.
         */
        imageType?: string;
    }

    export interface ComputeEnvironmentComputeResourcesLaunchTemplate {
        /**
         * ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
         */
        launchTemplateId?: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName?: string;
        /**
         * The version number of the launch template. Default: The default version of the launch template.
         */
        version?: string;
    }

    export interface ComputeEnvironmentEksConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the Amazon EKS cluster.
         */
        eksClusterArn: string;
        /**
         * The namespace of the Amazon EKS cluster. AWS Batch manages pods in this namespace.
         */
        kubernetesNamespace: string;
    }

    export interface GetJobQueueComputeEnvironmentOrder {
        computeEnvironment: string;
        order: number;
    }

    export interface GetSchedulingPolicyFairSharePolicy {
        /**
         * Value used to reserve some of the available maximum vCPU for fair share identifiers that have not yet been used. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html).
         */
        computeReservation: number;
        shareDecaySeconds: number;
        /**
         * One or more share distribution blocks which define the weights for the fair share identifiers for the fair share policy. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html). The `shareDistribution` block is documented below.
         */
        shareDistributions: outputs.batch.GetSchedulingPolicyFairSharePolicyShareDistribution[];
    }

    export interface GetSchedulingPolicyFairSharePolicyShareDistribution {
        /**
         * Fair share identifier or fair share identifier prefix. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        shareIdentifier: string;
        /**
         * Weight factor for the fair share identifier. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        weightFactor: number;
    }

    export interface JobDefinitionRetryStrategy {
        /**
         * The number of times to move a job to the `RUNNABLE` status. You may specify between `1` and `10` attempts.
         */
        attempts?: number;
        /**
         * The evaluate on exit conditions under which the job should be retried or failed. If this parameter is specified, then the `attempts` parameter must also be specified. You may specify up to 5 configuration blocks.
         */
        evaluateOnExits?: outputs.batch.JobDefinitionRetryStrategyEvaluateOnExit[];
    }

    export interface JobDefinitionRetryStrategyEvaluateOnExit {
        /**
         * Specifies the action to take if all of the specified conditions are met. The values are not case sensitive. Valid values: `RETRY`, `EXIT`.
         */
        action: string;
        /**
         * A glob pattern to match against the decimal representation of the exit code returned for a job.
         */
        onExitCode?: string;
        /**
         * A glob pattern to match against the reason returned for a job.
         */
        onReason?: string;
        /**
         * A glob pattern to match against the status reason returned for a job.
         */
        onStatusReason?: string;
    }

    export interface JobDefinitionTimeout {
        /**
         * The time duration in seconds after which AWS Batch terminates your jobs if they have not finished. The minimum value for the timeout is `60` seconds.
         */
        attemptDurationSeconds?: number;
    }

    export interface SchedulingPolicyFairSharePolicy {
        /**
         * A value used to reserve some of the available maximum vCPU for fair share identifiers that have not yet been used. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html).
         */
        computeReservation?: number;
        shareDecaySeconds?: number;
        /**
         * One or more share distribution blocks which define the weights for the fair share identifiers for the fair share policy. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html). The `shareDistribution` block is documented below.
         */
        shareDistributions?: outputs.batch.SchedulingPolicyFairSharePolicyShareDistribution[];
    }

    export interface SchedulingPolicyFairSharePolicyShareDistribution {
        /**
         * A fair share identifier or fair share identifier prefix. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        shareIdentifier: string;
        /**
         * The weight factor for the fair share identifier. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        weightFactor?: number;
    }

}

export namespace budgets {
    export interface BudgetActionActionThreshold {
        /**
         * The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
         */
        actionThresholdType: string;
        /**
         * The threshold of a notification.
         */
        actionThresholdValue: number;
    }

    export interface BudgetActionDefinition {
        /**
         * The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
         */
        iamActionDefinition?: outputs.budgets.BudgetActionDefinitionIamActionDefinition;
        /**
         * The service control policies (SCPs) action definition details. See SCP Action Definition.
         */
        scpActionDefinition?: outputs.budgets.BudgetActionDefinitionScpActionDefinition;
        /**
         * The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
         */
        ssmActionDefinition?: outputs.budgets.BudgetActionDefinitionSsmActionDefinition;
    }

    export interface BudgetActionDefinitionIamActionDefinition {
        /**
         * A list of groups to be attached. There must be at least one group.
         */
        groups?: string[];
        /**
         * The Amazon Resource Name (ARN) of the policy to be attached.
         */
        policyArn: string;
        /**
         * A list of roles to be attached. There must be at least one role.
         */
        roles?: string[];
        /**
         * A list of users to be attached. There must be at least one user.
         */
        users?: string[];
    }

    export interface BudgetActionDefinitionScpActionDefinition {
        /**
         * The policy ID attached.
         */
        policyId: string;
        /**
         * A list of target IDs.
         */
        targetIds: string[];
    }

    export interface BudgetActionDefinitionSsmActionDefinition {
        /**
         * The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
         */
        actionSubType: string;
        /**
         * The EC2 and RDS instance IDs.
         */
        instanceIds: string[];
        /**
         * The Region to run the SSM document.
         */
        region: string;
    }

    export interface BudgetActionSubscriber {
        /**
         * The address that AWS sends budget notifications to, either an SNS topic or an email.
         */
        address: string;
        /**
         * The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
         */
        subscriptionType: string;
    }

    export interface BudgetAutoAdjustData {
        autoAdjustType: string;
        historicalOptions?: outputs.budgets.BudgetAutoAdjustDataHistoricalOptions;
        lastAutoAdjustTime: string;
    }

    export interface BudgetAutoAdjustDataHistoricalOptions {
        budgetAdjustmentPeriod: number;
        lookbackAvailablePeriods: number;
    }

    export interface BudgetCostFilter {
        /**
         * The name of a budget. Unique within accounts.
         */
        name: string;
        values: string[];
    }

    export interface BudgetCostTypes {
        /**
         * A boolean value whether to include credits in the cost budget. Defaults to `true`
         */
        includeCredit?: boolean;
        /**
         * Whether a budget includes discounts. Defaults to `true`
         */
        includeDiscount?: boolean;
        /**
         * A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
         */
        includeOtherSubscription?: boolean;
        /**
         * A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
         */
        includeRecurring?: boolean;
        /**
         * A boolean value whether to include refunds in the cost budget. Defaults to `true`
         */
        includeRefund?: boolean;
        /**
         * A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
         */
        includeSubscription?: boolean;
        /**
         * A boolean value whether to include support costs in the cost budget. Defaults to `true`
         */
        includeSupport?: boolean;
        /**
         * A boolean value whether to include tax in the cost budget. Defaults to `true`
         */
        includeTax?: boolean;
        /**
         * A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
         */
        includeUpfront?: boolean;
        /**
         * Whether a budget uses the amortized rate. Defaults to `false`
         */
        useAmortized?: boolean;
        /**
         * A boolean value whether to use blended costs in the cost budget. Defaults to `false`
         */
        useBlended?: boolean;
    }

    export interface BudgetNotification {
        /**
         * (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
         */
        comparisonOperator: string;
        /**
         * (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
         */
        notificationType: string;
        /**
         * (Optional) E-Mail addresses to notify. Either this or `subscriberSnsTopicArns` is required.
         */
        subscriberEmailAddresses?: string[];
        /**
         * (Optional) SNS topics to notify. Either this or `subscriberEmailAddresses` is required.
         */
        subscriberSnsTopicArns?: string[];
        /**
         * (Required) Threshold when the notification should be sent.
         */
        threshold: number;
        /**
         * (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
         */
        thresholdType: string;
    }

    export interface BudgetPlannedLimit {
        /**
         * (Required) The amount of cost or usage being measured for a budget.
         */
        amount: string;
        /**
         * (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
         */
        startTime: string;
        /**
         * (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
         */
        unit: string;
    }

    export interface GetBudgetAutoAdjustData {
        autoAdjustType: string;
        historicalOptions: outputs.budgets.GetBudgetAutoAdjustDataHistoricalOption[];
        lastAutoAdjustTime: string;
    }

    export interface GetBudgetAutoAdjustDataHistoricalOption {
        budgetAdjustmentPeriod: number;
        lookbackAvailablePeriods: number;
    }

    export interface GetBudgetBudgetLimit {
        /**
         * (Required) The amount of cost or usage being measured for a budget.
         */
        amount: string;
        /**
         * (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
         */
        unit: string;
    }

    export interface GetBudgetCalculatedSpend {
        actualSpends: outputs.budgets.GetBudgetCalculatedSpendActualSpend[];
    }

    export interface GetBudgetCalculatedSpendActualSpend {
        /**
         * (Required) The amount of cost or usage being measured for a budget.
         */
        amount: string;
        /**
         * (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
         */
        unit: string;
    }

    export interface GetBudgetCostFilter {
        /**
         * The name of a budget. Unique within accounts.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }

    export interface GetBudgetCostType {
        /**
         * A boolean value whether to include credits in the cost budget. Defaults to `true`
         */
        includeCredit: boolean;
        /**
         * Whether a budget includes discounts. Defaults to `true`
         */
        includeDiscount: boolean;
        /**
         * A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
         */
        includeOtherSubscription: boolean;
        /**
         * A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
         */
        includeRecurring: boolean;
        /**
         * A boolean value whether to include refunds in the cost budget. Defaults to `true`
         */
        includeRefund: boolean;
        /**
         * A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
         */
        includeSubscription: boolean;
        /**
         * A boolean value whether to include support costs in the cost budget. Defaults to `true`
         */
        includeSupport: boolean;
        /**
         * A boolean value whether to include tax in the cost budget. Defaults to `true`
         */
        includeTax: boolean;
        /**
         * A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
         */
        includeUpfront: boolean;
        /**
         * Whether a budget uses the amortized rate. Defaults to `false`
         */
        useAmortized: boolean;
        /**
         * A boolean value whether to use blended costs in the cost budget. Defaults to `false`
         */
        useBlended: boolean;
    }

    export interface GetBudgetNotification {
        /**
         * (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
         */
        comparisonOperator: string;
        /**
         * (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
         */
        notificationType: string;
        /**
         * (Optional) E-Mail addresses to notify. Either this or `subscriberSnsTopicArns` is required.
         */
        subscriberEmailAddresses: string[];
        /**
         * (Optional) SNS topics to notify. Either this or `subscriberEmailAddresses` is required.
         */
        subscriberSnsTopicArns: string[];
        /**
         * (Required) Threshold when the notification should be sent.
         */
        threshold: number;
        /**
         * (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
         */
        thresholdType: string;
    }

    export interface GetBudgetPlannedLimit {
        /**
         * (Required) The amount of cost or usage being measured for a budget.
         */
        amount: string;
        /**
         * (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
         */
        startTime: string;
        /**
         * (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
         */
        unit: string;
    }

}

export namespace cfg {
    export interface ConfigurationAggregatorAccountAggregationSource {
        /**
         * List of 12-digit account IDs of the account(s) being aggregated.
         */
        accountIds: string[];
        /**
         * If true, aggregate existing AWS Config regions and future regions.
         */
        allRegions?: boolean;
        /**
         * List of source regions being aggregated.
         *
         * Either `regions` or `allRegions` (as true) must be specified.
         */
        regions?: string[];
    }

    export interface ConfigurationAggregatorOrganizationAggregationSource {
        /**
         * If true, aggregate existing AWS Config regions and future regions.
         */
        allRegions?: boolean;
        /**
         * List of source regions being aggregated.
         */
        regions?: string[];
        /**
         * ARN of the IAM role used to retrieve AWS Organization details associated with the aggregator account.
         *
         * Either `regions` or `allRegions` (as true) must be specified.
         */
        roleArn: string;
    }

    export interface ConformancePackInputParameter {
        /**
         * The input key.
         */
        parameterName: string;
        /**
         * The input value.
         */
        parameterValue: string;
    }

    export interface DeliveryChannelSnapshotDeliveryProperties {
        /**
         * The frequency with which AWS Config recurringly delivers configuration snapshotsE.g., `One_Hour` or `Three_Hours`. Valid values are listed [here](https://docs.aws.amazon.com/config/latest/APIReference/API_ConfigSnapshotDeliveryProperties.html#API_ConfigSnapshotDeliveryProperties_Contents).
         */
        deliveryFrequency?: string;
    }

    export interface OrganizationConformancePackInputParameter {
        /**
         * The input key.
         */
        parameterName: string;
        /**
         * The input value.
         */
        parameterValue: string;
    }

    export interface RecorderRecordingGroup {
        /**
         * Specifies whether AWS Config records configuration changes for every supported type of regional resource (which includes any new type that will become supported in the future). Conflicts with `resourceTypes`. Defaults to `true`.
         */
        allSupported?: boolean;
        /**
         * An object that specifies how AWS Config excludes resource types from being recorded by the configuration recorder.To use this option, you must set the useOnly field of RecordingStrategy to `EXCLUSION_BY_RESOURCE_TYPES` Requires `allSupported = false`. Conflicts with `resourceTypes`.
         */
        exclusionByResourceTypes: outputs.cfg.RecorderRecordingGroupExclusionByResourceType[];
        /**
         * Specifies whether AWS Config includes all supported types of _global resources_ with the resources that it records. Requires `allSupported = true`. Conflicts with `resourceTypes`.
         */
        includeGlobalResourceTypes?: boolean;
        /**
         * Recording Strategy - see below..
         */
        recordingStrategies: outputs.cfg.RecorderRecordingGroupRecordingStrategy[];
        /**
         * A list that specifies the types of AWS resources for which AWS Config records configuration changes (for example, `AWS::EC2::Instance` or `AWS::CloudTrail::Trail`). See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types. In order to use this attribute, `allSupported` must be set to false.
         */
        resourceTypes?: string[];
    }

    export interface RecorderRecordingGroupExclusionByResourceType {
        /**
         * A list that specifies the types of AWS resources for which AWS Config records configuration changes (for example, `AWS::EC2::Instance` or `AWS::CloudTrail::Trail`). See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types. In order to use this attribute, `allSupported` must be set to false.
         */
        resourceTypes?: string[];
    }

    export interface RecorderRecordingGroupRecordingStrategy {
        useOnly?: string;
    }

    export interface RemediationConfigurationExecutionControls {
        /**
         * Configuration block for SSM controls. See below.
         */
        ssmControls?: outputs.cfg.RemediationConfigurationExecutionControlsSsmControls;
    }

    export interface RemediationConfigurationExecutionControlsSsmControls {
        /**
         * Maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. The default value is 10%.
         */
        concurrentExecutionRatePercentage?: number;
        /**
         * Percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. The default is 50%.
         */
        errorPercentage?: number;
    }

    export interface RemediationConfigurationParameter {
        /**
         * Name of the attribute.
         */
        name: string;
        /**
         * Value is dynamic and changes at run-time.
         */
        resourceValue?: string;
        /**
         * Value is static and does not change at run-time.
         */
        staticValue?: string;
        /**
         * List of static values.
         */
        staticValues: string[];
    }

    export interface RuleScope {
        /**
         * The IDs of the only AWS resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for `complianceResourceTypes`.
         */
        complianceResourceId?: string;
        /**
         * A list of resource types of only those AWS resources that you want to trigger an evaluation for the ruleE.g., `AWS::EC2::Instance`. You can only specify one type if you also specify a resource ID for `complianceResourceId`. See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types.
         */
        complianceResourceTypes?: string[];
        /**
         * The tag key that is applied to only those AWS resources that you want you want to trigger an evaluation for the rule.
         */
        tagKey?: string;
        /**
         * The tag value applied to only those AWS resources that you want to trigger an evaluation for the rule.
         */
        tagValue?: string;
    }

    export interface RuleSource {
        /**
         * Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to `CUSTOM_POLICY`. See Custom Policy Details Below.
         */
        customPolicyDetails?: outputs.cfg.RuleSourceCustomPolicyDetails;
        /**
         * Indicates whether AWS or the customer owns and manages the AWS Config rule. Valid values are `AWS`, `CUSTOM_LAMBDA` or `CUSTOM_POLICY`. For more information about managed rules, see the [AWS Config Managed Rules documentation](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html). For more information about custom rules, see the [AWS Config Custom Rules documentation](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html). Custom Lambda Functions require permissions to allow the AWS Config service to invoke them, e.g., via the `aws.lambda.Permission` resource.
         */
        owner: string;
        /**
         * Provides the source and type of the event that causes AWS Config to evaluate your AWS resources. Only valid if `owner` is `CUSTOM_LAMBDA` or `CUSTOM_POLICY`. See Source Detail Below.
         */
        sourceDetails?: outputs.cfg.RuleSourceSourceDetail[];
        /**
         * For AWS Config managed rules, a predefined identifier, e.g `IAM_PASSWORD_POLICY`. For custom Lambda rules, the identifier is the ARN of the Lambda Function, such as `arn:aws:lambda:us-east-1:123456789012:function:custom_rule_name` or the `arn` attribute of the `aws.lambda.Function` resource.
         */
        sourceIdentifier?: string;
    }

    export interface RuleSourceCustomPolicyDetails {
        /**
         * The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is `false`.
         */
        enableDebugLogDelivery?: boolean;
        /**
         * The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
         */
        policyRuntime: string;
        /**
         * The policy definition containing the logic for your Config Custom Policy rule.
         */
        policyText: string;
    }

    export interface RuleSourceSourceDetail {
        /**
         * The source of the event, such as an AWS service, that triggers AWS Config to evaluate your AWSresources. This defaults to `aws.config` and is the only valid value.
         */
        eventSource?: string;
        /**
         * The frequency that you want AWS Config to run evaluations for a rule that istriggered periodically. If specified, requires `messageType` to be `ScheduledNotification`.
         */
        maximumExecutionFrequency?: string;
        /**
         * The type of notification that triggers AWS Config to run an evaluation for a rule. You canspecify the following notification types:
         */
        messageType?: string;
    }

}

export namespace chime {
    export interface SdkvoiceGlobalSettingsVoiceConnector {
        /**
         * The S3 bucket that stores the Voice Connector's call detail records.
         */
        cdrBucket?: string;
    }

    export interface SdkvoiceSipMediaApplicationEndpoints {
        /**
         * Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
         */
        lambdaArn: string;
    }

    export interface SdkvoiceSipRuleTargetApplication {
        /**
         * The AWS Region of the target application.
         */
        awsRegion: string;
        /**
         * Priority of the SIP media application in the target list.
         */
        priority: number;
        /**
         * The SIP media application ID.
         */
        sipMediaApplicationId: string;
    }

    export interface SdkvoiceVoiceProfileDomainServerSideEncryptionConfiguration {
        /**
         * ARN for KMS Key.
         *
         * The following arguments are optional:
         */
        kmsKeyArn: string;
    }

    export interface VoiceConnectorGroupConnector {
        /**
         * The priority associated with the Amazon Chime Voice Connector, with 1 being the highest priority. Higher priority Amazon Chime Voice Connectors are attempted first.
         */
        priority: number;
        /**
         * The Amazon Chime Voice Connector ID.
         */
        voiceConnectorId: string;
    }

    export interface VoiceConnectorOrganizationRoute {
        /**
         * The FQDN or IP address to contact for origination traffic.
         */
        host: string;
        /**
         * The designated origination route port. Defaults to `5060`.
         */
        port?: number;
        /**
         * The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
         */
        priority: number;
        /**
         * The protocol to use for the origination route. Encryption-enabled Amazon Chime Voice Connectors use TCP protocol by default.
         */
        protocol: string;
        /**
         * The weight associated with the host. If hosts are equal in priority, calls are redistributed among them based on their relative weight.
         */
        weight: number;
    }

    export interface VoiceConnectorStreamingMediaInsightsConfiguration {
        /**
         * The media insights configuration that will be invoked by the Voice Connector.
         */
        configurationArn?: string;
        /**
         * When `true`, the media insights configuration is not enabled. Defaults to `false`.
         */
        disabled?: boolean;
    }

    export interface VoiceConnectorTerminationCredentialsCredential {
        /**
         * RFC2617 compliant password associated with the SIP credentials.
         */
        password: string;
        /**
         * RFC2617 compliant username associated with the SIP credentials.
         */
        username: string;
    }

}

export namespace chimesdkmediapipelines {
    export interface MediaInsightsPipelineConfigurationElement {
        /**
         * Configuration for Amazon Transcribe Call Analytics processor.
         */
        amazonTranscribeCallAnalyticsProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfiguration;
        /**
         * Configuration for Amazon Transcribe processor.
         */
        amazonTranscribeProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfiguration;
        /**
         * Configuration for Kinesis Data Stream sink.
         */
        kinesisDataStreamSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfiguration;
        /**
         * Configuration for Lambda Function sink.
         */
        lambdaFunctionSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfiguration;
        /**
         * Configuration for S3 recording sink.
         */
        s3RecordingSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementS3RecordingSinkConfiguration;
        /**
         * Configuration for SNS Topic sink.
         */
        snsTopicSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementSnsTopicSinkConfiguration;
        /**
         * Configuration for SQS Queue sink.
         */
        sqsQueueSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementSqsQueueSinkConfiguration;
        /**
         * Element type.
         */
        type: string;
        /**
         * Configuration for Voice analytics processor.
         */
        voiceAnalyticsProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfiguration;
    }

    export interface MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfiguration {
        /**
         * Filter for category events to be delivered to insights target.
         */
        callAnalyticsStreamCategories?: string[];
        /**
         * Labels all personally identifiable information (PII) identified in Utterance events.
         */
        contentIdentificationType?: string;
        /**
         * Redacts all personally identifiable information (PII) identified in Utterance events.
         */
        contentRedactionType?: string;
        /**
         * Enables partial result stabilization in Utterance events.
         */
        enablePartialResultsStabilization?: boolean;
        /**
         * Filters partial Utterance events from delivery to the insights target.
         */
        filterPartialResults?: boolean;
        /**
         * Language code for the transcription model.
         */
        languageCode: string;
        /**
         * Name of custom language model for transcription.
         */
        languageModelName?: string;
        /**
         * Level of stability to use when partial results stabilization is enabled.
         */
        partialResultsStability?: string;
        /**
         * Types of personally identifiable information (PII) to redact from an Utterance event.
         */
        piiEntityTypes?: string;
        /**
         * Settings for post call analytics.
         */
        postCallAnalyticsSettings?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettings;
        /**
         * Method for applying a vocabulary filter to Utterance events.
         */
        vocabularyFilterMethod?: string;
        /**
         * Name of the custom vocabulary filter to use when processing Utterance events.
         */
        vocabularyFilterName?: string;
        /**
         * Name of the custom vocabulary to use when processing Utterance events.
         */
        vocabularyName?: string;
    }

    export interface MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettings {
        /**
         * Should output be redacted.
         */
        contentRedactionOutput?: string;
        /**
         * ARN of the role used by AWS Transcribe to upload your post call analysis.
         */
        dataAccessRoleArn: string;
        /**
         * ID of the KMS key used to encrypt the output.
         */
        outputEncryptionKmsKeyId?: string;
        /**
         * The Amazon S3 location where you want your Call Analytics post-call transcription output stored.
         */
        outputLocation: string;
    }

    export interface MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfiguration {
        /**
         * Labels all personally identifiable information (PII) identified in Utterance events.
         */
        contentIdentificationType?: string;
        /**
         * Redacts all personally identifiable information (PII) identified in Utterance events.
         */
        contentRedactionType?: string;
        /**
         * Enables partial result stabilization in Utterance events.
         */
        enablePartialResultsStabilization?: boolean;
        /**
         * Filters partial Utterance events from delivery to the insights target.
         */
        filterPartialResults?: boolean;
        /**
         * Language code for the transcription model.
         */
        languageCode: string;
        /**
         * Name of custom language model for transcription.
         */
        languageModelName?: string;
        /**
         * Level of stability to use when partial results stabilization is enabled.
         */
        partialResultsStability?: string;
        /**
         * Types of personally identifiable information (PII) to redact from an Utterance event.
         */
        piiEntityTypes?: string;
        /**
         * Enables speaker partitioning (diarization) in your Transcript events.
         */
        showSpeakerLabel?: boolean;
        /**
         * Method for applying a vocabulary filter to Utterance events.
         */
        vocabularyFilterMethod?: string;
        /**
         * Name of the custom vocabulary filter to use when processing Utterance events.
         */
        vocabularyFilterName?: string;
        /**
         * Name of the custom vocabulary to use when processing Utterance events.
         */
        vocabularyName?: string;
    }

    export interface MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfiguration {
        /**
         * Kinesis Data Stream to deliver results.
         */
        insightsTarget: string;
    }

    export interface MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfiguration {
        /**
         * Kinesis Data Stream to deliver results.
         */
        insightsTarget: string;
    }

    export interface MediaInsightsPipelineConfigurationElementS3RecordingSinkConfiguration {
        /**
         * S3 URI to deliver recordings.
         */
        destination?: string;
    }

    export interface MediaInsightsPipelineConfigurationElementSnsTopicSinkConfiguration {
        /**
         * Kinesis Data Stream to deliver results.
         */
        insightsTarget: string;
    }

    export interface MediaInsightsPipelineConfigurationElementSqsQueueSinkConfiguration {
        /**
         * Kinesis Data Stream to deliver results.
         */
        insightsTarget: string;
    }

    export interface MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfiguration {
        /**
         * Enable speaker search.
         */
        speakerSearchStatus: string;
        /**
         * Enable voice tone analysis.
         */
        voiceToneAnalysisStatus: string;
    }

    export interface MediaInsightsPipelineConfigurationRealTimeAlertConfiguration {
        /**
         * Disables real time alert rules.
         */
        disabled: boolean;
        /**
         * Collection of real time alert rules
         */
        rules: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRule[];
    }

    export interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRule {
        /**
         * Configuration for an issue detection rule.
         */
        issueDetectionConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfiguration;
        /**
         * Configuration for a keyword match rule.
         */
        keywordMatchConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfiguration;
        /**
         * Configuration for a sentiment rule.
         */
        sentimentConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfiguration;
        /**
         * Element type.
         */
        type: string;
    }

    export interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfiguration {
        /**
         * Rule name.
         */
        ruleName: string;
    }

    export interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfiguration {
        /**
         * Collection of keywords to match.
         */
        keywords: string[];
        /**
         * Negate the rule.
         */
        negate: boolean;
        /**
         * Rule name.
         */
        ruleName: string;
    }

    export interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfiguration {
        /**
         * Rule name.
         */
        ruleName: string;
        /**
         * Sentiment type to match.
         */
        sentimentType: string;
        /**
         * Analysis interval.
         */
        timePeriod: number;
    }

}

export namespace cleanrooms {
    export interface CollaborationDataEncryptionMetadata {
        allowClearText: boolean;
        allowDuplicates: boolean;
        allowJoinsOnColumnsWithDifferentNames: boolean;
        preserveNulls: boolean;
    }

    export interface CollaborationMember {
        accountId: string;
        displayName: string;
        memberAbilities: string[];
        status: string;
    }

}

export namespace cloudformation {
    export interface CloudFormationTypeLoggingConfig {
        /**
         * Name of the CloudWatch Log Group where CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName: string;
        /**
         * Amazon Resource Name (ARN) of the IAM Role CloudFormation assumes when sending error logging information to CloudWatch Logs.
         */
        logRoleArn: string;
    }

    export interface GetCloudFormationTypeLoggingConfig {
        /**
         * Name of the CloudWatch Log Group where CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName: string;
        /**
         * ARN of the IAM Role CloudFormation assumes when sending error logging information to CloudWatch Logs.
         */
        logRoleArn: string;
    }

    export interface StackSetAutoDeployment {
        /**
         * Whether or not auto-deployment is enabled.
         */
        enabled?: boolean;
        /**
         * Whether or not to retain stacks when the account is removed.
         */
        retainStacksOnAccountRemoval?: boolean;
    }

    export interface StackSetInstanceDeploymentTargets {
        /**
         * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
         */
        organizationalUnitIds?: string[];
    }

    export interface StackSetInstanceOperationPreferences {
        /**
         * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureToleranceCount?: number;
        /**
         * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureTolerancePercentage?: number;
        /**
         * The maximum number of accounts in which to perform this operation at one time.
         */
        maxConcurrentCount?: number;
        /**
         * The maximum percentage of accounts in which to perform this operation at one time.
         */
        maxConcurrentPercentage?: number;
        /**
         * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are `SEQUENTIAL` and `PARALLEL`.
         */
        regionConcurrencyType?: string;
        /**
         * The order of the Regions in where you want to perform the stack operation.
         */
        regionOrders?: string[];
    }

    export interface StackSetManagedExecution {
        /**
         * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
         */
        active?: boolean;
    }

    export interface StackSetOperationPreferences {
        /**
         * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureToleranceCount?: number;
        /**
         * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureTolerancePercentage?: number;
        /**
         * The maximum number of accounts in which to perform this operation at one time.
         */
        maxConcurrentCount?: number;
        /**
         * The maximum percentage of accounts in which to perform this operation at one time.
         */
        maxConcurrentPercentage?: number;
        /**
         * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
         */
        regionConcurrencyType?: string;
        /**
         * The order of the Regions in where you want to perform the stack operation.
         */
        regionOrders?: string[];
    }

}

export namespace cloudfront {
    export interface CachePolicyParametersInCacheKeyAndForwardedToOrigin {
        /**
         * Whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
         */
        cookiesConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig;
        /**
         * Flag determines whether the Accept-Encoding HTTP header is included in the cache key and in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingBrotli?: boolean;
        /**
         * Whether the Accept-Encoding HTTP header is included in the cache key and in requests sent to the origin by CloudFront.
         */
        enableAcceptEncodingGzip?: boolean;
        /**
         * Whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
         */
        headersConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig;
        /**
         * Whether any URL query strings in viewer requests are included in the cache key. It also automatically includes these query strings in requests that CloudFront sends to the origin. Please refer to the Query String Config for more information.
         */
        queryStringsConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig;
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig {
        /**
         * Whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values for `cookieBehavior` are `none`, `whitelist`, `allExcept`, and `all`.
         */
        cookieBehavior: string;
        /**
         * Object that contains a list of cookie names. See Items for more information.
         */
        cookies?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies;
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies {
        items?: string[];
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig {
        /**
         * Whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values for `headerBehavior` are `none` and `whitelist`.
         */
        headerBehavior?: string;
        /**
         * Object contains a list of header names. See Items for more information.
         */
        headers?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders;
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders {
        items?: string[];
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
        /**
         * Whether URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values for `queryStringBehavior` are `none`, `whitelist`, `allExcept`, and `all`.
         */
        queryStringBehavior: string;
        /**
         * Configuration parameter that contains a list of query string names. See Items for more information.
         */
        queryStrings?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings;
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings {
        items?: string[];
    }

    export interface DistributionCustomErrorResponse {
        /**
         * Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
         */
        errorCachingMinTtl?: number;
        /**
         * 4xx or 5xx HTTP status code that you want to customize.
         */
        errorCode: number;
        /**
         * HTTP status code that you want CloudFront to return with the custom error page to the viewer.
         */
        responseCode?: number;
        /**
         * Path of the custom error page (for example, `/custom_404.html`).
         */
        responsePagePath?: string;
    }

    export interface DistributionDefaultCacheBehavior {
        /**
         * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
         */
        allowedMethods: string[];
        /**
         * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the `defaultCacheBehavior` either `cachePolicyId` or `forwardedValues` must be set.
         */
        cachePolicyId?: string;
        /**
         * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
         */
        cachedMethods: string[];
        /**
         * Whether you want CloudFront to automatically compress content for web requests that include `Accept-Encoding: gzip` in the request header (default: `false`).
         */
        compress?: boolean;
        /**
         * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an `Cache-Control max-age` or `Expires` header.
         */
        defaultTtl: number;
        /**
         * Field level encryption configuration ID.
         */
        fieldLevelEncryptionId?: string;
        /**
         * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
         */
        forwardedValues?: outputs.cloudfront.DistributionDefaultCacheBehaviorForwardedValues;
        /**
         * A config block that triggers a cloudfront function with specific actions (maximum 2).
         */
        functionAssociations?: outputs.cloudfront.DistributionDefaultCacheBehaviorFunctionAssociation[];
        /**
         * A config block that triggers a lambda function with specific actions (maximum 4).
         */
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionDefaultCacheBehaviorLambdaFunctionAssociation[];
        /**
         * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of `Cache-Control max-age`, `Cache-Control s-maxage`, and `Expires` headers.
         */
        maxTtl: number;
        /**
         * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
         */
        minTtl?: number;
        /**
         * Unique identifier of the origin request policy that is attached to the behavior.
         */
        originRequestPolicyId?: string;
        /**
         * ARN of the real-time log configuration that is attached to this cache behavior.
         */
        realtimeLogConfigArn?: string;
        /**
         * Identifier for a response headers policy.
         */
        responseHeadersPolicyId?: string;
        /**
         * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
         */
        smoothStreaming?: boolean;
        /**
         * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
         */
        targetOriginId: string;
        /**
         * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the [CloudFront User Guide](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html) for more information about this feature.
         */
        trustedKeyGroups: string[];
        /**
         * List of AWS account IDs (or `self`) that you want to allow to create signed URLs for private content. See the [CloudFront User Guide](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html) for more information about this feature.
         */
        trustedSigners: string[];
        /**
         * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of `allow-all`, `https-only`, or `redirect-to-https`.
         */
        viewerProtocolPolicy: string;
    }

    export interface DistributionDefaultCacheBehaviorForwardedValues {
        /**
         * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
         */
        cookies: outputs.cloudfront.DistributionDefaultCacheBehaviorForwardedValuesCookies;
        /**
         * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify `*` to include all headers.
         */
        headers: string[];
        /**
         * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
         */
        queryString: boolean;
        /**
         * When specified, along with a value of `true` for `queryString`, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of `true` for `queryString`, all query string keys are cached.
         */
        queryStringCacheKeys: string[];
    }

    export interface DistributionDefaultCacheBehaviorForwardedValuesCookies {
        /**
         * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify `all`, `none` or `whitelist`. If `whitelist`, you must include the subsequent `whitelistedNames`.
         */
        forward: string;
        /**
         * If you have specified `whitelist` to `forward`, the whitelisted cookies that you want CloudFront to forward to your origin.
         */
        whitelistedNames: string[];
    }

    export interface DistributionDefaultCacheBehaviorFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request` or `viewer-response`.
         */
        eventType: string;
        /**
         * ARN of the CloudFront function.
         */
        functionArn: string;
    }

    export interface DistributionDefaultCacheBehaviorLambdaFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request`, `origin-request`, `viewer-response`, `origin-response`.
         */
        eventType: string;
        /**
         * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: `true`, `false`.
         */
        includeBody?: boolean;
        /**
         * ARN of the Lambda function.
         */
        lambdaArn: string;
    }

    export interface DistributionLoggingConfig {
        /**
         * Amazon S3 bucket to store the access logs in, for example, `myawslogbucket.s3.amazonaws.com`.
         */
        bucket: string;
        /**
         * Whether to include cookies in access logs (default: `false`).
         */
        includeCookies?: boolean;
        /**
         * Prefix to the access log filenames for this distribution, for example, `myprefix/`.
         */
        prefix?: string;
    }

    export interface DistributionOrderedCacheBehavior {
        /**
         * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
         */
        allowedMethods: string[];
        /**
         * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the `defaultCacheBehavior` either `cachePolicyId` or `forwardedValues` must be set.
         */
        cachePolicyId?: string;
        /**
         * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
         */
        cachedMethods: string[];
        /**
         * Whether you want CloudFront to automatically compress content for web requests that include `Accept-Encoding: gzip` in the request header (default: `false`).
         */
        compress?: boolean;
        /**
         * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an `Cache-Control max-age` or `Expires` header.
         */
        defaultTtl: number;
        /**
         * Field level encryption configuration ID.
         */
        fieldLevelEncryptionId?: string;
        /**
         * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
         */
        forwardedValues?: outputs.cloudfront.DistributionOrderedCacheBehaviorForwardedValues;
        /**
         * A config block that triggers a cloudfront function with specific actions (maximum 2).
         */
        functionAssociations?: outputs.cloudfront.DistributionOrderedCacheBehaviorFunctionAssociation[];
        /**
         * A config block that triggers a lambda function with specific actions (maximum 4).
         */
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionOrderedCacheBehaviorLambdaFunctionAssociation[];
        /**
         * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of `Cache-Control max-age`, `Cache-Control s-maxage`, and `Expires` headers.
         */
        maxTtl: number;
        /**
         * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
         */
        minTtl?: number;
        /**
         * Unique identifier of the origin request policy that is attached to the behavior.
         */
        originRequestPolicyId?: string;
        /**
         * Pattern (for example, `images/*.jpg`) that specifies which requests you want this cache behavior to apply to.
         */
        pathPattern: string;
        /**
         * ARN of the real-time log configuration that is attached to this cache behavior.
         */
        realtimeLogConfigArn?: string;
        /**
         * Identifier for a response headers policy.
         */
        responseHeadersPolicyId?: string;
        /**
         * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
         */
        smoothStreaming?: boolean;
        /**
         * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
         */
        targetOriginId: string;
        /**
         * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the [CloudFront User Guide](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html) for more information about this feature.
         */
        trustedKeyGroups?: string[];
        /**
         * List of AWS account IDs (or `self`) that you want to allow to create signed URLs for private content. See the [CloudFront User Guide](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html) for more information about this feature.
         */
        trustedSigners?: string[];
        /**
         * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of `allow-all`, `https-only`, or `redirect-to-https`.
         */
        viewerProtocolPolicy: string;
    }

    export interface DistributionOrderedCacheBehaviorForwardedValues {
        /**
         * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
         */
        cookies: outputs.cloudfront.DistributionOrderedCacheBehaviorForwardedValuesCookies;
        /**
         * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify `*` to include all headers.
         */
        headers: string[];
        /**
         * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
         */
        queryString: boolean;
        /**
         * When specified, along with a value of `true` for `queryString`, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of `true` for `queryString`, all query string keys are cached.
         */
        queryStringCacheKeys: string[];
    }

    export interface DistributionOrderedCacheBehaviorForwardedValuesCookies {
        /**
         * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify `all`, `none` or `whitelist`. If `whitelist`, you must include the subsequent `whitelistedNames`.
         */
        forward: string;
        /**
         * If you have specified `whitelist` to `forward`, the whitelisted cookies that you want CloudFront to forward to your origin.
         */
        whitelistedNames?: string[];
    }

    export interface DistributionOrderedCacheBehaviorFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request` or `viewer-response`.
         */
        eventType: string;
        /**
         * ARN of the CloudFront function.
         */
        functionArn: string;
    }

    export interface DistributionOrderedCacheBehaviorLambdaFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request`, `origin-request`, `viewer-response`, `origin-response`.
         */
        eventType: string;
        /**
         * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: `true`, `false`.
         */
        includeBody?: boolean;
        /**
         * ARN of the Lambda function.
         */
        lambdaArn: string;
    }

    export interface DistributionOrigin {
        /**
         * Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
         */
        connectionAttempts?: number;
        /**
         * Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
         */
        connectionTimeout?: number;
        /**
         * One or more sub-resources with `name` and `value` parameters that specify header data that will be sent to the origin (multiples allowed).
         */
        customHeaders?: outputs.cloudfront.DistributionOriginCustomHeader[];
        /**
         * The CloudFront custom origin configuration information. If an S3 origin is required, use `originAccessControlId` or `s3OriginConfig` instead.
         */
        customOriginConfig?: outputs.cloudfront.DistributionOriginCustomOriginConfig;
        /**
         * DNS domain name of either the S3 bucket, or web site of your custom origin.
         */
        domainName: string;
        /**
         * Unique identifier of a [CloudFront origin access control][8] for this origin.
         */
        originAccessControlId?: string;
        /**
         * Unique identifier for the origin.
         */
        originId: string;
        /**
         * Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
         */
        originPath?: string;
        /**
         * The CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
         */
        originShield?: outputs.cloudfront.DistributionOriginOriginShield;
        /**
         * The CloudFront S3 origin configuration information. If a custom origin is required, use `customOriginConfig` instead.
         */
        s3OriginConfig?: outputs.cloudfront.DistributionOriginS3OriginConfig;
    }

    export interface DistributionOriginCustomHeader {
        name: string;
        value: string;
    }

    export interface DistributionOriginCustomOriginConfig {
        /**
         * HTTP port the custom origin listens on.
         */
        httpPort: number;
        /**
         * HTTPS port the custom origin listens on.
         */
        httpsPort: number;
        /**
         * The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of `60`. But you can request an [increase](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#request-custom-request-timeout). Defaults to `5`.
         */
        originKeepaliveTimeout?: number;
        /**
         * Origin protocol policy to apply to your origin. One of `http-only`, `https-only`, or `match-viewer`.
         */
        originProtocolPolicy: string;
        /**
         * The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of `60`. But you can request an [increase](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#request-custom-request-timeout). Defaults to `30`.
         */
        originReadTimeout?: number;
        /**
         * SSL/TLS protocols that you want CloudFront to use when communicating with your origin over HTTPS. A list of one or more of `SSLv3`, `TLSv1`, `TLSv1.1`, and `TLSv1.2`.
         */
        originSslProtocols: string[];
    }

    export interface DistributionOriginGroup {
        /**
         * The failover criteria for when to failover to the secondary origin.
         */
        failoverCriteria: outputs.cloudfront.DistributionOriginGroupFailoverCriteria;
        /**
         * Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
         */
        members: outputs.cloudfront.DistributionOriginGroupMember[];
        /**
         * Unique identifier for the origin.
         */
        originId: string;
    }

    export interface DistributionOriginGroupFailoverCriteria {
        /**
         * List of HTTP status codes for the origin group.
         */
        statusCodes: number[];
    }

    export interface DistributionOriginGroupMember {
        /**
         * Unique identifier for the origin.
         */
        originId: string;
    }

    export interface DistributionOriginOriginShield {
        /**
         * Whether the distribution is enabled to accept end user requests for content.
         */
        enabled: boolean;
        /**
         * AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
         */
        originShieldRegion: string;
    }

    export interface DistributionOriginS3OriginConfig {
        /**
         * The CloudFront origin access identity to associate with the origin.
         */
        originAccessIdentity: string;
    }

    export interface DistributionRestrictions {
        geoRestriction: outputs.cloudfront.DistributionRestrictionsGeoRestriction;
    }

    export interface DistributionRestrictionsGeoRestriction {
        /**
         * [ISO 3166-1-alpha-2 codes][4] for which you want CloudFront either to distribute your content (`whitelist`) or not distribute your content (`blacklist`). If the type is specified as `none` an empty array can be used.
         */
        locations: string[];
        /**
         * Method that you want to use to restrict distribution of your content by country: `none`, `whitelist`, or `blacklist`.
         */
        restrictionType: string;
    }

    export interface DistributionTrustedKeyGroup {
        /**
         * Whether the distribution is enabled to accept end user requests for content.
         */
        enabled: boolean;
        /**
         * List of nested attributes for each trusted signer
         */
        items: outputs.cloudfront.DistributionTrustedKeyGroupItem[];
    }

    export interface DistributionTrustedKeyGroupItem {
        /**
         * ID of the key group that contains the public keys.
         */
        keyGroupId: string;
        /**
         * Set of active CloudFront key pairs associated with the signer account
         */
        keyPairIds: string[];
    }

    export interface DistributionTrustedSigner {
        /**
         * Whether the distribution is enabled to accept end user requests for content.
         */
        enabled: boolean;
        /**
         * List of nested attributes for each trusted signer
         */
        items: outputs.cloudfront.DistributionTrustedSignerItem[];
    }

    export interface DistributionTrustedSignerItem {
        /**
         * AWS account ID or `self`
         */
        awsAccountNumber: string;
        /**
         * Set of active CloudFront key pairs associated with the signer account
         */
        keyPairIds: string[];
    }

    export interface DistributionViewerCertificate {
        /**
         * ARN of the [AWS Certificate Manager](https://aws.amazon.com/certificate-manager/) certificate that you wish to use with this distribution. Specify this, `cloudfrontDefaultCertificate`, or `iamCertificateId`.  The ACM certificate must be in  US-EAST-1.
         */
        acmCertificateArn?: string;
        /**
         * `true` if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, `acmCertificateArn`, or `iamCertificateId`.
         */
        cloudfrontDefaultCertificate?: boolean;
        /**
         * IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, `acmCertificateArn`, or `cloudfrontDefaultCertificate`.
         */
        iamCertificateId?: string;
        /**
         * Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if `cloudfrontDefaultCertificate = false`. See all possible values in [this](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html) table under "Security policy." Some examples include: `TLSv1.2_2019` and `TLSv1.2_2021`. Default: `TLSv1`. **NOTE**: If you are using a custom certificate (specified with `acmCertificateArn` or `iamCertificateId`), and have specified `sni-only` in `sslSupportMethod`, `TLSv1` or later must be specified. If you have specified `vip` in `sslSupportMethod`, only `SSLv3` or `TLSv1` can be specified. If you have specified `cloudfrontDefaultCertificate`, `TLSv1` must be specified.
         */
        minimumProtocolVersion?: string;
        /**
         * How you want CloudFront to serve HTTPS requests. One of `vip` or `sni-only`. Required if you specify `acmCertificateArn` or `iamCertificateId`. **NOTE:** `vip` causes CloudFront to use a dedicated IP address and may incur extra charges.
         */
        sslSupportMethod?: string;
    }

    export interface FieldLevelEncryptionConfigContentTypeProfileConfig {
        /**
         * Object that contains an attribute `items` that contains the list of configurations for a field-level encryption content type-profile. See Content Type Profile.
         */
        contentTypeProfiles: outputs.cloudfront.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles;
        /**
         * specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
         */
        forwardWhenContentTypeIsUnknown: boolean;
    }

    export interface FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles {
        items: outputs.cloudfront.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem[];
    }

    export interface FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem {
        /**
         * he content type for a field-level encryption content type-profile mapping. Valid value is `application/x-www-form-urlencoded`.
         */
        contentType: string;
        /**
         * The format for a field-level encryption content type-profile mapping. Valid value is `URLEncoded`.
         */
        format: string;
        /**
         * The profile ID for a field-level encryption content type-profile mapping.
         */
        profileId?: string;
    }

    export interface FieldLevelEncryptionConfigQueryArgProfileConfig {
        /**
         * Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
         */
        forwardWhenQueryArgProfileIsUnknown: boolean;
        /**
         * Object that contains an attribute `items` that contains the list ofrofiles specified for query argument-profile mapping for field-level encryption. see Query Arg Profile.
         */
        queryArgProfiles?: outputs.cloudfront.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles;
    }

    export interface FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles {
        items?: outputs.cloudfront.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem[];
    }

    export interface FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem {
        /**
         * The profile ID for a field-level encryption content type-profile mapping.
         */
        profileId: string;
        /**
         * Query argument for field-level encryption query argument-profile mapping.
         */
        queryArg: string;
    }

    export interface FieldLevelEncryptionProfileEncryptionEntities {
        items?: outputs.cloudfront.FieldLevelEncryptionProfileEncryptionEntitiesItem[];
    }

    export interface FieldLevelEncryptionProfileEncryptionEntitiesItem {
        /**
         * Object that contains an attribute `items` that contains the list of field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted.
         */
        fieldPatterns: outputs.cloudfront.FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns;
        /**
         * The provider associated with the public key being used for encryption.
         */
        providerId: string;
        /**
         * The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
         */
        publicKeyId: string;
    }

    export interface FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns {
        items?: string[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOrigin {
        /**
         * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
         */
        cookiesConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig[];
        /**
         * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingBrotli: boolean;
        /**
         * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingGzip: boolean;
        /**
         * Object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
         */
        headersConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig[];
        /**
         * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
         */
        queryStringsConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig {
        /**
         * Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`, `allExcept`, `all`.
         */
        cookieBehavior: string;
        /**
         * Object that contains a list of cookie names. See Items for more information.
         */
        cookies: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookie[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookie {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig {
        /**
         * Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`.
         */
        headerBehavior: string;
        /**
         * Object that contains a list of header names. See Items for more information.
         */
        headers: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeader[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeader {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
        /**
         * Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`, `allExcept`, `all`.
         */
        queryStringBehavior: string;
        /**
         * Object that contains a list of query string names. See Items for more information.
         */
        queryStrings: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryString[];
    }

    export interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryString {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }

    export interface GetOriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies: outputs.cloudfront.GetOriginRequestPolicyCookiesConfigCookie[];
    }

    export interface GetOriginRequestPolicyCookiesConfigCookie {
        items: string[];
    }

    export interface GetOriginRequestPolicyHeadersConfig {
        headerBehavior: string;
        headers: outputs.cloudfront.GetOriginRequestPolicyHeadersConfigHeader[];
    }

    export interface GetOriginRequestPolicyHeadersConfigHeader {
        items: string[];
    }

    export interface GetOriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings: outputs.cloudfront.GetOriginRequestPolicyQueryStringsConfigQueryString[];
    }

    export interface GetOriginRequestPolicyQueryStringsConfigQueryString {
        items: string[];
    }

    export interface GetRealtimeLogConfigEndpoint {
        /**
         * (Required) Amazon Kinesis data stream configuration.
         */
        kinesisStreamConfigs: outputs.cloudfront.GetRealtimeLogConfigEndpointKinesisStreamConfig[];
        /**
         * (Required) Type of data stream where real-time log data is sent. The only valid value is `Kinesis`.
         */
        streamType: string;
    }

    export interface GetRealtimeLogConfigEndpointKinesisStreamConfig {
        /**
         * (Required) ARN of an IAM role that CloudFront can use to send real-time log data to the Kinesis data stream.
         * See the [AWS documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) for more information.
         */
        roleArn: string;
        /**
         * (Required) ARN of the Kinesis data stream.
         */
        streamArn: string;
    }

    export interface GetResponseHeadersPolicyCorsConfig {
        /**
         * A Boolean value that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header.
         */
        accessControlAllowCredentials: boolean;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header.
         */
        accessControlAllowHeaders: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowHeader[];
        /**
         * Object that contains an attribute `items` that contains a list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. Valid values: `GET` | `POST` | `OPTIONS` | `PUT` | `DELETE` | `HEAD` | `ALL`
         */
        accessControlAllowMethods: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowMethod[];
        /**
         * Object that contains an attribute `items` that contains a list of origins that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header.
         */
        accessControlAllowOrigins: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowOrigin[];
        /**
         * Object that contains an attribute `items` that contains a list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header.
         */
        accessControlExposeHeaders: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlExposeHeader[];
        /**
         * A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
         */
        accessControlMaxAgeSec: number;
        originOverride: boolean;
    }

    export interface GetResponseHeadersPolicyCorsConfigAccessControlAllowHeader {
        items: string[];
    }

    export interface GetResponseHeadersPolicyCorsConfigAccessControlAllowMethod {
        items: string[];
    }

    export interface GetResponseHeadersPolicyCorsConfigAccessControlAllowOrigin {
        items: string[];
    }

    export interface GetResponseHeadersPolicyCorsConfigAccessControlExposeHeader {
        items: string[];
    }

    export interface GetResponseHeadersPolicyCustomHeadersConfig {
        items: outputs.cloudfront.GetResponseHeadersPolicyCustomHeadersConfigItem[];
    }

    export interface GetResponseHeadersPolicyCustomHeadersConfigItem {
        /**
         * The HTTP header name.
         */
        header: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Value for the HTTP response header.
         */
        value: string;
    }

    export interface GetResponseHeadersPolicyRemoveHeadersConfig {
        items: outputs.cloudfront.GetResponseHeadersPolicyRemoveHeadersConfigItem[];
    }

    export interface GetResponseHeadersPolicyRemoveHeadersConfigItem {
        /**
         * The HTTP header name.
         */
        header: string;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfig {
        /**
         * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
         */
        contentSecurityPolicies: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy[];
        /**
         * A setting that determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. See Content Type Options for more information.
         */
        contentTypeOptions: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigContentTypeOption[];
        /**
         * Setting that determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. See Frame Options for more information.
         */
        frameOptions: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigFrameOption[];
        /**
         * Value of the Referrer-Policy HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicies: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicy[];
        /**
         * Settings that determine whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. See Strict Transport Security for more information.
         */
        strictTransportSecurities: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity[];
        /**
         * Settings that determine whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. See XSS Protection for more information.
         */
        xssProtections: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigXssProtection[];
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy {
        /**
         * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
         */
        contentSecurityPolicy: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigContentTypeOption {
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigFrameOption {
        /**
         * Value of the X-Frame-Options HTTP response header. Valid values: `DENY` | `SAMEORIGIN`
         */
        frameOption: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicy {
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Value of the Referrer-Policy HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicy: string;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity {
        /**
         * A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
         */
        accessControlMaxAgeSec: number;
        /**
         * Whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
         */
        includeSubdomains: boolean;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
         */
        preload: boolean;
    }

    export interface GetResponseHeadersPolicySecurityHeadersConfigXssProtection {
        /**
         * Whether CloudFront includes the mode=block directive in the X-XSS-Protection header.
         */
        modeBlock: boolean;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Boolean value that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0.
         */
        protection: boolean;
        /**
         * Whether CloudFront sets a reporting URI in the X-XSS-Protection header.
         */
        reportUri: string;
    }

    export interface GetResponseHeadersPolicyServerTimingHeadersConfig {
        /**
         * Whether CloudFront adds the `Server-Timing` header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
         */
        enabled: boolean;
        /**
         * Number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to.
         */
        samplingRate: number;
    }

    export interface MonitoringSubscriptionMonitoringSubscription {
        /**
         * A subscription configuration for additional CloudWatch metrics. See below.
         */
        realtimeMetricsSubscriptionConfig: outputs.cloudfront.MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig;
    }

    export interface MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig {
        /**
         * A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution. Valid values are `Enabled` and `Disabled`. See below.
         */
        realtimeMetricsSubscriptionStatus: string;
    }

    export interface OriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: outputs.cloudfront.OriginRequestPolicyCookiesConfigCookies;
    }

    export interface OriginRequestPolicyCookiesConfigCookies {
        items?: string[];
    }

    export interface OriginRequestPolicyHeadersConfig {
        headerBehavior?: string;
        headers?: outputs.cloudfront.OriginRequestPolicyHeadersConfigHeaders;
    }

    export interface OriginRequestPolicyHeadersConfigHeaders {
        items?: string[];
    }

    export interface OriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: outputs.cloudfront.OriginRequestPolicyQueryStringsConfigQueryStrings;
    }

    export interface OriginRequestPolicyQueryStringsConfigQueryStrings {
        items?: string[];
    }

    export interface RealtimeLogConfigEndpoint {
        /**
         * The Amazon Kinesis data stream configuration.
         */
        kinesisStreamConfig: outputs.cloudfront.RealtimeLogConfigEndpointKinesisStreamConfig;
        /**
         * The type of data stream where real-time log data is sent. The only valid value is `Kinesis`.
         */
        streamType: string;
    }

    export interface RealtimeLogConfigEndpointKinesisStreamConfig {
        /**
         * The ARN of an IAM role that CloudFront can use to send real-time log data to the Kinesis data stream.
         * See the [AWS documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) for more information.
         */
        roleArn: string;
        /**
         * The ARN of the Kinesis data stream.
         */
        streamArn: string;
    }

    export interface ResponseHeadersPolicyCorsConfig {
        /**
         * A Boolean value that CloudFront uses as the value for the `Access-Control-Allow-Credentials` HTTP response header.
         */
        accessControlAllowCredentials: boolean;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP header names that CloudFront includes as values for the `Access-Control-Allow-Headers` HTTP response header.
         */
        accessControlAllowHeaders: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP methods that CloudFront includes as values for the `Access-Control-Allow-Methods` HTTP response header. Valid values: `GET` | `POST` | `OPTIONS` | `PUT` | `DELETE` | `HEAD` | `ALL`
         */
        accessControlAllowMethods: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowMethods;
        /**
         * Object that contains an attribute `items` that contains a list of origins that CloudFront can use as the value for the `Access-Control-Allow-Origin` HTTP response header.
         */
        accessControlAllowOrigins: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP headers that CloudFront includes as values for the `Access-Control-Expose-Headers` HTTP response header.
         */
        accessControlExposeHeaders?: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders;
        /**
         * A number that CloudFront uses as the value for the `Access-Control-Max-Age` HTTP response header.
         */
        accessControlMaxAgeSec?: number;
        /**
         * A Boolean value that determines how CloudFront behaves for the HTTP response header.
         */
        originOverride: boolean;
    }

    export interface ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders {
        items?: string[];
    }

    export interface ResponseHeadersPolicyCorsConfigAccessControlAllowMethods {
        items?: string[];
    }

    export interface ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins {
        items?: string[];
    }

    export interface ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders {
        items?: string[];
    }

    export interface ResponseHeadersPolicyCustomHeadersConfig {
        items?: outputs.cloudfront.ResponseHeadersPolicyCustomHeadersConfigItem[];
    }

    export interface ResponseHeadersPolicyCustomHeadersConfigItem {
        /**
         * The HTTP response header name.
         */
        header: string;
        /**
         * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
         */
        override: boolean;
        /**
         * The value for the HTTP response header.
         */
        value: string;
    }

    export interface ResponseHeadersPolicyRemoveHeadersConfig {
        items?: outputs.cloudfront.ResponseHeadersPolicyRemoveHeadersConfigItem[];
    }

    export interface ResponseHeadersPolicyRemoveHeadersConfigItem {
        /**
         * The HTTP response header name.
         */
        header: string;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfig {
        /**
         * The policy directives and their values that CloudFront includes as values for the `Content-Security-Policy` HTTP response header. See Content Security Policy for more information.
         */
        contentSecurityPolicy?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy;
        /**
         * Determines whether CloudFront includes the `X-Content-Type-Options` HTTP response header with its value set to `nosniff`. See Content Type Options for more information.
         */
        contentTypeOptions?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions;
        /**
         * Determines whether CloudFront includes the `X-Frame-Options` HTTP response header and the header’s value. See Frame Options for more information.
         */
        frameOptions?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigFrameOptions;
        /**
         * Determines whether CloudFront includes the `Referrer-Policy` HTTP response header and the header’s value. See Referrer Policy for more information.
         */
        referrerPolicy?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy;
        /**
         * Determines whether CloudFront includes the `Strict-Transport-Security` HTTP response header and the header’s value. See Strict Transport Security for more information.
         */
        strictTransportSecurity?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity;
        /**
         * Determine whether CloudFront includes the `X-XSS-Protection` HTTP response header and the header’s value. See XSS Protection for more information.
         */
        xssProtection?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigXssProtection;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy {
        /**
         * The policy directives and their values that CloudFront includes as values for the `Content-Security-Policy` HTTP response header.
         */
        contentSecurityPolicy: string;
        /**
         * Whether CloudFront overrides the `Content-Security-Policy` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions {
        /**
         * Whether CloudFront overrides the `X-Content-Type-Options` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigFrameOptions {
        /**
         * The value of the `X-Frame-Options` HTTP response header. Valid values: `DENY` | `SAMEORIGIN`
         */
        frameOption: string;
        /**
         * Whether CloudFront overrides the `X-Frame-Options` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy {
        /**
         * Whether CloudFront overrides the `Referrer-Policy` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * The value of the `Referrer-Policy` HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicy: string;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity {
        /**
         * A number that CloudFront uses as the value for the `max-age` directive in the `Strict-Transport-Security` HTTP response header.
         */
        accessControlMaxAgeSec: number;
        /**
         * Whether CloudFront includes the `includeSubDomains` directive in the `Strict-Transport-Security` HTTP response header.
         */
        includeSubdomains?: boolean;
        /**
         * Whether CloudFront overrides the `Strict-Transport-Security` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Whether CloudFront includes the `preload` directive in the `Strict-Transport-Security` HTTP response header.
         */
        preload?: boolean;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigXssProtection {
        /**
         * Whether CloudFront includes the `mode=block` directive in the `X-XSS-Protection` header.
         */
        modeBlock?: boolean;
        /**
         * Whether CloudFront overrides the `X-XSS-Protection` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * A Boolean value that determines the value of the `X-XSS-Protection` HTTP response header. When this setting is `true`, the value of the `X-XSS-Protection` header is `1`. When this setting is `false`, the value of the `X-XSS-Protection` header is `0`.
         */
        protection: boolean;
        /**
         * A reporting URI, which CloudFront uses as the value of the report directive in the `X-XSS-Protection` header. You cannot specify a `reportUri` when `modeBlock` is `true`.
         */
        reportUri?: string;
    }

    export interface ResponseHeadersPolicyServerTimingHeadersConfig {
        /**
         * A Whether CloudFront adds the `Server-Timing` header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
         */
        enabled: boolean;
        /**
         * A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. Valid range: Minimum value of 0.0. Maximum value of 100.0.
         */
        samplingRate: number;
    }

}

export namespace cloudhsmv2 {
    export interface ClusterClusterCertificate {
        awsHardwareCertificate: string;
        clusterCertificate: string;
        clusterCsr: string;
        hsmCertificate: string;
        manufacturerHardwareCertificate: string;
    }

    export interface GetClusterClusterCertificate {
        awsHardwareCertificate: string;
        clusterCertificate: string;
        clusterCsr: string;
        hsmCertificate: string;
        manufacturerHardwareCertificate: string;
    }

}

export namespace cloudsearch {
    export interface DomainEndpointOptions {
        /**
         * Enables or disables the requirement that all requests to the domain arrive over HTTPS.
         */
        enforceHttps: boolean;
        /**
         * The minimum required TLS version. See the [AWS documentation](https://docs.aws.amazon.com/cloudsearch/latest/developerguide/API_DomainEndpointOptions.html) for valid values.
         */
        tlsSecurityPolicy: string;
    }

    export interface DomainIndexField {
        /**
         * The analysis scheme you want to use for a `text` field. The analysis scheme specifies the language-specific text processing options that are used during indexing.
         */
        analysisScheme?: string;
        /**
         * The default value for the field. This value is used when no value is specified for the field in the document data.
         */
        defaultValue?: string;
        /**
         * You can get facet information by enabling this.
         */
        facet?: boolean;
        /**
         * You can highlight information.
         */
        highlight?: boolean;
        /**
         * A unique name for the field. Field names must begin with a letter and be at least 3 and no more than 64 characters long. The allowed characters are: `a`-`z` (lower-case letters), `0`-`9`, and `_` (underscore). The name `score` is reserved and cannot be used as a field name.
         */
        name: string;
        /**
         * You can enable returning the value of all searchable fields.
         */
        return?: boolean;
        /**
         * You can set whether this index should be searchable or not.
         */
        search?: boolean;
        /**
         * You can enable the property to be sortable.
         */
        sort?: boolean;
        /**
         * A comma-separated list of source fields to map to the field. Specifying a source field copies data from one field to another, enabling you to use the same source data in different ways by configuring different options for the fields.
         */
        sourceFields?: string;
        /**
         * The field type. Valid values: `date`, `date-array`, `double`, `double-array`, `int`, `int-array`, `literal`, `literal-array`, `text`, `text-array`.
         */
        type: string;
    }

    export interface DomainScalingParameters {
        /**
         * The instance type that you want to preconfigure for your domain. See the [AWS documentation](https://docs.aws.amazon.com/cloudsearch/latest/developerguide/API_ScalingParameters.html) for valid values.
         */
        desiredInstanceType: string;
        /**
         * The number of partitions you want to preconfigure for your domain. Only valid when you select `search.2xlarge` as the instance type.
         */
        desiredPartitionCount: number;
        /**
         * The number of replicas you want to preconfigure for each index partition.
         */
        desiredReplicationCount: number;
    }

}

export namespace cloudtrail {
    export interface EventDataStoreAdvancedEventSelector {
        /**
         * Specifies the selector statements in an advanced event selector. Fields documented below.
         */
        fieldSelectors: outputs.cloudtrail.EventDataStoreAdvancedEventSelectorFieldSelector[];
        /**
         * The name of the event data store.
         */
        name: string;
    }

    export interface EventDataStoreAdvancedEventSelectorFieldSelector {
        /**
         * A list of values that includes events that match the last few characters of the event record field specified as the value of `field`.
         */
        endsWiths: string[];
        /**
         * A list of values that includes events that match the exact value of the event record field specified as the value of `field`. This is the only valid operator that you can use with the `readOnly`, `eventCategory`, and `resources.type` fields.
         */
        equals: string[];
        /**
         * Specifies a field in an event record on which to filter events to be logged. You can specify only the following values: `readOnly`, `eventSource`, `eventName`, `eventCategory`, `resources.type`, `resources.ARN`.
         */
        field: string;
        /**
         * A list of values that excludes events that match the last few characters of the event record field specified as the value of `field`.
         */
        notEndsWiths: string[];
        /**
         * A list of values that excludes events that match the exact value of the event record field specified as the value of `field`.
         */
        notEquals: string[];
        /**
         * A list of values that excludes events that match the first few characters of the event record field specified as the value of `field`.
         */
        notStartsWiths: string[];
        /**
         * A list of values that includes events that match the first few characters of the event record field specified as the value of `field`.
         */
        startsWiths: string[];
    }

    export interface TrailAdvancedEventSelector {
        /**
         * Specifies the selector statements in an advanced event selector. Fields documented below.
         */
        fieldSelectors: outputs.cloudtrail.TrailAdvancedEventSelectorFieldSelector[];
        /**
         * Name of the trail.
         */
        name?: string;
    }

    export interface TrailAdvancedEventSelectorFieldSelector {
        /**
         * A list of values that includes events that match the last few characters of the event record field specified as the value of `field`.
         */
        endsWiths?: string[];
        /**
         * A list of values that includes events that match the exact value of the event record field specified as the value of `field`. This is the only valid operator that you can use with the `readOnly`, `eventCategory`, and `resources.type` fields.
         */
        equals?: string[];
        /**
         * Field in an event record on which to filter events to be logged. You can specify only the following values: `readOnly`, `eventSource`, `eventName`, `eventCategory`, `resources.type`, `resources.ARN`.
         */
        field: string;
        /**
         * A list of values that excludes events that match the last few characters of the event record field specified as the value of `field`.
         */
        notEndsWiths?: string[];
        /**
         * A list of values that excludes events that match the exact value of the event record field specified as the value of `field`.
         */
        notEquals?: string[];
        /**
         * A list of values that excludes events that match the first few characters of the event record field specified as the value of `field`.
         */
        notStartsWiths?: string[];
        /**
         * A list of values that includes events that match the first few characters of the event record field specified as the value of `field`.
         */
        startsWiths?: string[];
    }

    export interface TrailEventSelector {
        /**
         * Configuration block for data events. See details below.
         */
        dataResources?: outputs.cloudtrail.TrailEventSelectorDataResource[];
        /**
         * A set of event sources to exclude. Valid values include: `kms.amazonaws.com` and `rdsdata.amazonaws.com`. `includeManagementEvents` must be set to`true` to allow this.
         */
        excludeManagementEventSources?: string[];
        /**
         * Whether to include management events for your trail. Defaults to `true`.
         */
        includeManagementEvents?: boolean;
        /**
         * Type of events to log. Valid values are `ReadOnly`, `WriteOnly`, `All`. Default value is `All`.
         */
        readWriteType?: string;
    }

    export interface TrailEventSelectorDataResource {
        /**
         * Resource type in which you want to log data events. You can specify only the following value: "AWS::S3::Object", "AWS::Lambda::Function" and "AWS::DynamoDB::Table".
         */
        type: string;
        /**
         * List of ARN strings or partial ARN strings to specify selectors for data audit events over data resources. ARN list is specific to single-valued `type`. For example, `arn:aws:s3:::<bucket name>/` for all objects in a bucket, `arn:aws:s3:::<bucket name>/key` for specific objects, `arn:aws:lambda` for all lambda events within an account, `arn:aws:lambda:<region>:<account number>:function:<function name>` for a specific Lambda function, `arn:aws:dynamodb` for all DDB events for all tables within an account, or `arn:aws:dynamodb:<region>:<account number>:table/<table name>` for a specific DynamoDB table.
         */
        values: string[];
    }

    export interface TrailInsightSelector {
        /**
         * Type of insights to log on a trail. Valid values are: `ApiCallRateInsight` and `ApiErrorRateInsight`.
         */
        insightType: string;
    }

}

export namespace cloudwatch {
    export interface EventConnectionAuthParameters {
        /**
         * Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with `basic` and `oauth`. Documented below.
         */
        apiKey?: outputs.cloudwatch.EventConnectionAuthParametersApiKey;
        /**
         * Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with `apiKey` and `oauth`. Documented below.
         */
        basic?: outputs.cloudwatch.EventConnectionAuthParametersBasic;
        /**
         * Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
         */
        invocationHttpParameters?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParameters;
        /**
         * Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with `basic` and `apiKey`. Documented below.
         */
        oauth?: outputs.cloudwatch.EventConnectionAuthParametersOauth;
    }

    export interface EventConnectionAuthParametersApiKey {
        /**
         * Header Name.
         */
        key: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value: string;
    }

    export interface EventConnectionAuthParametersBasic {
        /**
         * A password for the authorization. Created and stored in AWS Secrets Manager.
         */
        password: string;
        /**
         * A username for the authorization.
         */
        username: string;
    }

    export interface EventConnectionAuthParametersInvocationHttpParameters {
        /**
         * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        bodies?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersBody[];
        /**
         * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        headers?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersHeader[];
        /**
         * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        queryStrings?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersQueryString[];
    }

    export interface EventConnectionAuthParametersInvocationHttpParametersBody {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventConnectionAuthParametersInvocationHttpParametersHeader {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventConnectionAuthParametersInvocationHttpParametersQueryString {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventConnectionAuthParametersOauth {
        /**
         * The URL to the authorization endpoint.
         */
        authorizationEndpoint: string;
        /**
         * Contains the client parameters for OAuth authorization. Contains the following two parameters.
         */
        clientParameters?: outputs.cloudwatch.EventConnectionAuthParametersOauthClientParameters;
        /**
         * A password for the authorization. Created and stored in AWS Secrets Manager.
         */
        httpMethod: string;
        /**
         * OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
         */
        oauthHttpParameters: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParameters;
    }

    export interface EventConnectionAuthParametersOauthClientParameters {
        /**
         * The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
         */
        clientId: string;
        /**
         * The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
         */
        clientSecret: string;
    }

    export interface EventConnectionAuthParametersOauthOauthHttpParameters {
        /**
         * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        bodies?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersBody[];
        /**
         * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        headers?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersHeader[];
        /**
         * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        queryStrings?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersQueryString[];
    }

    export interface EventConnectionAuthParametersOauthOauthHttpParametersBody {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventConnectionAuthParametersOauthOauthHttpParametersHeader {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventConnectionAuthParametersOauthOauthHttpParametersQueryString {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * Header Name.
         */
        key?: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value?: string;
    }

    export interface EventEndpointEventBus {
        /**
         * The ARN of the event bus the endpoint is associated with.
         */
        eventBusArn: string;
    }

    export interface EventEndpointReplicationConfig {
        /**
         * The state of event replication. Valid values: `ENABLED`, `DISABLED`. The default state is `ENABLED`, which means you must supply a `roleArn`. If you don't have a `roleArn` or you don't want event replication enabled, set `state` to `DISABLED`.
         */
        state?: string;
    }

    export interface EventEndpointRoutingConfig {
        /**
         * Parameters used for failover. This includes what triggers failover and what happens when it's triggered. Documented below.
         */
        failoverConfig: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfig;
    }

    export interface EventEndpointRoutingConfigFailoverConfig {
        /**
         * Parameters used for the primary Region. Documented below.
         */
        primary: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfigPrimary;
        /**
         * Parameters used for the secondary Region, the Region that events are routed to when failover is triggered or event replication is enabled. Documented below.
         */
        secondary: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfigSecondary;
    }

    export interface EventEndpointRoutingConfigFailoverConfigPrimary {
        /**
         * The ARN of the health check used by the endpoint to determine whether failover is triggered.
         */
        healthCheck?: string;
    }

    export interface EventEndpointRoutingConfigFailoverConfigSecondary {
        /**
         * The name of the secondary Region.
         */
        route?: string;
    }

    export interface EventPermissionCondition {
        /**
         * Key for the condition. Valid values: `aws:PrincipalOrgID`.
         */
        key: string;
        /**
         * Type of condition. Value values: `StringEquals`.
         */
        type: string;
        /**
         * Value for the key.
         */
        value: string;
    }

    export interface EventTargetBatchTarget {
        /**
         * The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
         */
        arraySize?: number;
        /**
         * The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
         */
        jobAttempts?: number;
        /**
         * The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
         */
        jobDefinition: string;
        /**
         * The name to use for this execution of the job, if the target is an AWS Batch job.
         */
        jobName: string;
    }

    export interface EventTargetDeadLetterConfig {
        /**
         * ARN of the SQS queue specified as the target for the dead-letter queue.
         */
        arn?: string;
    }

    export interface EventTargetEcsTarget {
        /**
         * The capacity provider strategy to use for the task. If a `capacityProviderStrategy` specified, the `launchType` parameter must be omitted. If no `capacityProviderStrategy` or `launchType` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
         */
        capacityProviderStrategies?: outputs.cloudwatch.EventTargetEcsTargetCapacityProviderStrategy[];
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task.
         */
        enableEcsManagedTags?: boolean;
        /**
         * Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
         */
        enableExecuteCommand?: boolean;
        /**
         * Specifies an ECS task group for the task. The maximum length is 255 characters.
         */
        group?: string;
        /**
         * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
         */
        launchType?: string;
        /**
         * Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launchType` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
         */
        networkConfiguration?: outputs.cloudwatch.EventTargetEcsTargetNetworkConfiguration;
        /**
         * An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
         */
        orderedPlacementStrategies?: outputs.cloudwatch.EventTargetEcsTargetOrderedPlacementStrategy[];
        /**
         * An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
         */
        placementConstraints?: outputs.cloudwatch.EventTargetEcsTargetPlacementConstraint[];
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
         */
        platformVersion?: string;
        /**
         * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
         */
        propagateTags?: string;
        /**
         * A map of tags to assign to ecs resources.
         */
        tags?: {[key: string]: string};
        /**
         * The number of tasks to create based on the TaskDefinition. Defaults to `1`.
         */
        taskCount?: number;
        /**
         * The ARN of the task definition to use if the event target is an Amazon ECS cluster.
         */
        taskDefinitionArn: string;
    }

    export interface EventTargetEcsTargetCapacityProviderStrategy {
        /**
         * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
         */
        weight?: number;
    }

    export interface EventTargetEcsTargetNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
         */
        assignPublicIp?: boolean;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service.
         */
        subnets: string[];
    }

    export interface EventTargetEcsTargetOrderedPlacementStrategy {
        /**
         * The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).
         */
        field?: string;
        /**
         * Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
         */
        type: string;
    }

    export interface EventTargetEcsTargetPlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
         */
        type: string;
    }

    export interface EventTargetHttpTarget {
        /**
         * Enables you to specify HTTP headers to add to the request.
         */
        headerParameters?: {[key: string]: string};
        /**
         * The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*&#47;POST/pets/*`).
         */
        pathParameterValues?: string[];
        /**
         * Represents keys/values of query string parameters that are appended to the invoked endpoint.
         */
        queryStringParameters?: {[key: string]: string};
    }

    export interface EventTargetInputTransformer {
        /**
         * Key value pairs specified in the form of JSONPath (for example, time = $.time)
         * * You can have as many as 100 key-value pairs.
         * * You must use JSON dot notation, not bracket notation.
         * * The keys can't start with "AWS".
         */
        inputPaths?: {[key: string]: string};
        /**
         * Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.
         */
        inputTemplate: string;
    }

    export interface EventTargetKinesisTarget {
        /**
         * The JSON path to be extracted from the event and used as the partition key.
         */
        partitionKeyPath?: string;
    }

    export interface EventTargetRedshiftTarget {
        /**
         * The name of the database.
         */
        database: string;
        /**
         * The database user name.
         */
        dbUser?: string;
        /**
         * The name or ARN of the secret that enables access to the database.
         */
        secretsManagerArn?: string;
        /**
         * The SQL statement text to run.
         */
        sql?: string;
        /**
         * The name of the SQL statement.
         */
        statementName?: string;
        /**
         * Indicates whether to send an event back to EventBridge after the SQL statement runs.
         */
        withEvent?: boolean;
    }

    export interface EventTargetRetryPolicy {
        /**
         * The age in seconds to continue to make retry attempts.
         */
        maximumEventAgeInSeconds?: number;
        /**
         * maximum number of retry attempts to make before the request fails
         */
        maximumRetryAttempts?: number;
    }

    export interface EventTargetRunCommandTarget {
        /**
         * Can be either `tag:tag-key` or `InstanceIds`.
         */
        key: string;
        /**
         * If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.
         */
        values: string[];
    }

    export interface EventTargetSqsTarget {
        /**
         * The FIFO message group ID to use as the target.
         */
        messageGroupId?: string;
    }

    export interface GetLogDataProtectionPolicyDocumentStatement {
        /**
         * Set of at least 1 sensitive data identifiers that you want to mask. Read more in [Types of data that you can protect](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/protect-sensitive-log-data-types.html).
         */
        dataIdentifiers: string[];
        /**
         * Configures the data protection operation applied by this statement.
         */
        operation: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperation;
        /**
         * Name of this statement.
         */
        sid?: string;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperation {
        /**
         * Configures the detection of sensitive data.
         */
        audit?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAudit;
        /**
         * Configures the masking of sensitive data.
         *
         * > Every policy statement must specify exactly one operation.
         */
        deidentify?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationDeidentify;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationAudit {
        /**
         * Configures destinations to send audit findings to.
         */
        findingsDestination: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestination;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestination {
        /**
         * Configures CloudWatch Logs as a findings destination.
         */
        cloudwatchLogs?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogs;
        /**
         * Configures Kinesis Firehose as a findings destination.
         */
        firehose?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehose;
        /**
         * Configures S3 as a findings destination.
         */
        s3?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogs {
        /**
         * Name of the CloudWatch Log Group to send findings to.
         */
        logGroup: string;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehose {
        /**
         * Name of the Kinesis Firehose Delivery Stream to send findings to.
         */
        deliveryStream: string;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3 {
        /**
         * Name of the S3 Bucket to send findings to.
         */
        bucket: string;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationDeidentify {
        /**
         * An empty object that configures masking.
         */
        maskConfig: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfig;
    }

    export interface GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfig {
    }

    export interface InternetMonitorHealthEventsConfig {
        /**
         * The health event threshold percentage set for availability scores.
         */
        availabilityScoreThreshold?: number;
        /**
         * The health event threshold percentage set for performance scores.
         */
        performanceScoreThreshold?: number;
    }

    export interface InternetMonitorInternetMeasurementsLogDelivery {
        s3Config?: outputs.cloudwatch.InternetMonitorInternetMeasurementsLogDeliveryS3Config;
    }

    export interface InternetMonitorInternetMeasurementsLogDeliveryS3Config {
        bucketName: string;
        bucketPrefix?: string;
        logDeliveryStatus?: string;
    }

    export interface LogMetricFilterMetricTransformation {
        /**
         * The value to emit when a filter pattern does not match a log event. Conflicts with `dimensions`.
         */
        defaultValue?: string;
        /**
         * Map of fields to use as dimensions for the metric. Up to 3 dimensions are allowed. Conflicts with `defaultValue`.
         */
        dimensions?: {[key: string]: string};
        /**
         * The name of the CloudWatch metric to which the monitored log information should be published (e.g., `ErrorCount`)
         */
        name: string;
        /**
         * The destination namespace of the CloudWatch metric.
         */
        namespace: string;
        /**
         * The unit to assign to the metric. If you omit this, the unit is set as `None`.
         */
        unit?: string;
        /**
         * What to publish to the metric. For example, if you're counting the occurrences of a particular term like "Error", the value will be "1" for each occurrence. If you're counting the bytes transferred the published value will be the value in the log event.
         */
        value: string;
    }

    export interface MetricAlarmMetricQuery {
        /**
         * The ID of the account where the metrics are located, if this is a cross-account alarm.
         */
        accountId?: string;
        /**
         * The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the id of the other metrics to refer to those metrics, and can also use the id of other expressions to use the result of those expressions. For more information about metric math expressions, see Metric Math Syntax and Functions in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax).
         */
        expression?: string;
        /**
         * A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
         */
        id: string;
        /**
         * A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
         */
        label?: string;
        /**
         * The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
         */
        metric?: outputs.cloudwatch.MetricAlarmMetricQueryMetric;
        /**
         * Granularity in seconds of returned data points.
         * For metrics with regular resolution, valid values are any multiple of `60`.
         * For high-resolution metrics, valid values are `1`, `5`, `10`, `30`, or any multiple of `60`.
         */
        period?: number;
        /**
         * Specify exactly one `metricQuery` to be `true` to use that `metricQuery` result as the alarm.
         *
         * > **NOTE:**  You must specify either `metric` or `expression`. Not both.
         */
        returnData?: boolean;
    }

    export interface MetricAlarmMetricQueryMetric {
        /**
         * The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        dimensions?: {[key: string]: string};
        /**
         * The name for this metric.
         * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        metricName: string;
        /**
         * The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
         * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        namespace?: string;
        /**
         * Granularity in seconds of returned data points.
         * For metrics with regular resolution, valid values are any multiple of `60`.
         * For high-resolution metrics, valid values are `1`, `5`, `10`, `30`, or any multiple of `60`.
         */
        period: number;
        /**
         * The statistic to apply to this metric.
         * See docs for [supported statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
         */
        stat: string;
        /**
         * The unit for this metric.
         */
        unit?: string;
    }

    export interface MetricStreamExcludeFilter {
        /**
         * An array that defines the metrics you want to exclude for this metric namespace
         */
        metricNames?: string[];
        /**
         * Name of the metric namespace in the filter.
         */
        namespace: string;
    }

    export interface MetricStreamIncludeFilter {
        /**
         * An array that defines the metrics you want to include for this metric namespace
         */
        metricNames?: string[];
        /**
         * Name of the metric namespace in the filter.
         */
        namespace: string;
    }

    export interface MetricStreamStatisticsConfiguration {
        /**
         * The additional statistics to stream for the metrics listed in `includeMetrics`.
         */
        additionalStatistics: string[];
        /**
         * An array that defines the metrics that are to have additional statistics streamed. See details below.
         */
        includeMetrics: outputs.cloudwatch.MetricStreamStatisticsConfigurationIncludeMetric[];
    }

    export interface MetricStreamStatisticsConfigurationIncludeMetric {
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * Name of the metric namespace in the filter.
         */
        namespace: string;
    }

}

export namespace codeartifact {
    export interface RepositoryExternalConnections {
        /**
         * The name of the external connection associated with a repository.
         */
        externalConnectionName: string;
        packageFormat: string;
        status: string;
    }

    export interface RepositoryUpstream {
        /**
         * The name of an upstream repository.
         */
        repositoryName: string;
    }

}

export namespace codebuild {
    export interface ProjectArtifacts {
        /**
         * Artifact identifier. Must be the same specified inside the AWS CodeBuild build specification.
         */
        artifactIdentifier?: string;
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. your CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting output artifacts. If `type` is set to `NO_ARTIFACTS`, this value is ignored. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Information about the build output artifact location. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored. If `type` is set to `S3`, this is the name of the output bucket.
         */
        location?: string;
        /**
         * Name of the project. If `type` is set to `S3`, this is the name of the output artifact object
         */
        name?: string;
        /**
         * Namespace to use in storing build artifacts. If `type` is set to `S3`, then valid values are `BUILD_ID`, `NONE`.
         */
        namespaceType?: string;
        /**
         * Whether a name specified in the build specification overrides the artifact name.
         */
        overrideArtifactName?: boolean;
        /**
         * Type of build output artifact to create. If `type` is set to `S3`, valid values are `NONE`, `ZIP`
         */
        packaging?: string;
        /**
         * If `type` is set to `S3`, this is the path to the output artifact.
         */
        path?: string;
        /**
         * Build output artifact's type. Valid values: `CODEPIPELINE`, `NO_ARTIFACTS`, `S3`.
         */
        type: string;
    }

    export interface ProjectBuildBatchConfig {
        /**
         * Specifies if the build artifacts for the batch build should be combined into a single artifact location.
         */
        combineArtifacts?: boolean;
        /**
         * Configuration block specifying the restrictions for the batch build. Detailed below.
         */
        restrictions?: outputs.codebuild.ProjectBuildBatchConfigRestrictions;
        /**
         * Specifies the service role ARN for the batch build project.
         */
        serviceRole: string;
        /**
         * Specifies the maximum amount of time, in minutes, that the batch build must be completed in.
         */
        timeoutInMins?: number;
    }

    export interface ProjectBuildBatchConfigRestrictions {
        /**
         * An array of strings that specify the compute types that are allowed for the batch build. See [Build environment compute types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the AWS CodeBuild User Guide for these values.
         */
        computeTypesAlloweds?: string[];
        /**
         * Specifies the maximum number of builds allowed.
         */
        maximumBuildsAllowed?: number;
    }

    export interface ProjectCache {
        /**
         * Location where the AWS CodeBuild project stores cached resources. For type `S3`, the value must be a valid S3 bucket name/prefix.
         */
        location?: string;
        /**
         * Specifies settings that AWS CodeBuild uses to store and reuse build dependencies. Valid values:  `LOCAL_SOURCE_CACHE`, `LOCAL_DOCKER_LAYER_CACHE`, `LOCAL_CUSTOM_CACHE`.
         */
        modes?: string[];
        /**
         * Type of storage that will be used for the AWS CodeBuild project cache. Valid values: `NO_CACHE`, `LOCAL`, `S3`. Defaults to `NO_CACHE`.
         */
        type?: string;
    }

    export interface ProjectEnvironment {
        /**
         * ARN of the S3 bucket, path prefix and object key that contains the PEM-encoded certificate.
         */
        certificate?: string;
        /**
         * Information about the compute resources the build project will use. Valid values: `BUILD_GENERAL1_SMALL`, `BUILD_GENERAL1_MEDIUM`, `BUILD_GENERAL1_LARGE`, `BUILD_GENERAL1_2XLARGE`. `BUILD_GENERAL1_SMALL` is only valid if `type` is set to `LINUX_CONTAINER`. When `type` is set to `LINUX_GPU_CONTAINER`, `computeType` must be `BUILD_GENERAL1_LARGE`.
         */
        computeType: string;
        /**
         * Configuration block. Detailed below.
         */
        environmentVariables?: outputs.codebuild.ProjectEnvironmentEnvironmentVariable[];
        /**
         * Docker image to use for this build project. Valid values include [Docker images provided by CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html) (e.g `aws/codebuild/amazonlinux2-x86_64-standard:4.0`), [Docker Hub images](https://hub.docker.com/) (e.g., `pulumi/pulumi:latest`), and full Docker repository URIs such as those for ECR (e.g., `137112412989.dkr.ecr.us-west-2.amazonaws.com/amazonlinux:latest`).
         */
        image: string;
        /**
         * Type of credentials AWS CodeBuild uses to pull images in your build. Valid values: `CODEBUILD`, `SERVICE_ROLE`. When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an AWS CodeBuild curated image, you must use CodeBuild credentials. Defaults to `CODEBUILD`.
         */
        imagePullCredentialsType?: string;
        /**
         * Whether to enable running the Docker daemon inside a Docker container. Defaults to `false`.
         */
        privilegedMode?: boolean;
        /**
         * Configuration block. Detailed below.
         */
        registryCredential?: outputs.codebuild.ProjectEnvironmentRegistryCredential;
        /**
         * Type of environment variable. Valid values: `PARAMETER_STORE`, `PLAINTEXT`, `SECRETS_MANAGER`.
         */
        type: string;
    }

    export interface ProjectEnvironmentEnvironmentVariable {
        /**
         * Project's name.
         */
        name: string;
        /**
         * Build output artifact's type. Valid values: `CODEPIPELINE`, `NO_ARTIFACTS`, `S3`.
         */
        type?: string;
        /**
         * Environment variable's value.
         */
        value: string;
    }

    export interface ProjectEnvironmentRegistryCredential {
        /**
         * ARN or name of credentials created using AWS Secrets Manager.
         */
        credential: string;
        /**
         * Service that created the credentials to access a private Docker registry. Valid value: `SECRETS_MANAGER` (AWS Secrets Manager).
         */
        credentialProvider: string;
    }

    export interface ProjectFileSystemLocation {
        /**
         * The name used to access a file system created by Amazon EFS. CodeBuild creates an environment variable by appending the identifier in all capital letters to CODEBUILD\_. For example, if you specify my-efs for identifier, a new environment variable is create named CODEBUILD_MY-EFS.
         */
        identifier?: string;
        /**
         * A string that specifies the location of the file system created by Amazon EFS. Its format is `efs-dns-name:/directory-path`.
         */
        location?: string;
        /**
         * The mount options for a file system created by AWS EFS.
         */
        mountOptions?: string;
        /**
         * The location in the container where you mount the file system.
         */
        mountPoint?: string;
        /**
         * The type of the file system. The one supported type is `EFS`.
         */
        type?: string;
    }

    export interface ProjectLogsConfig {
        /**
         * Configuration block. Detailed below.
         */
        cloudwatchLogs?: outputs.codebuild.ProjectLogsConfigCloudwatchLogs;
        /**
         * Configuration block. Detailed below.
         */
        s3Logs?: outputs.codebuild.ProjectLogsConfigS3Logs;
    }

    export interface ProjectLogsConfigCloudwatchLogs {
        /**
         * Group name of the logs in CloudWatch Logs.
         */
        groupName?: string;
        /**
         * Current status of logs in CloudWatch Logs for a build project. Valid values: `ENABLED`, `DISABLED`. Defaults to `ENABLED`.
         */
        status?: string;
        /**
         * Stream name of the logs in CloudWatch Logs.
         */
        streamName?: string;
    }

    export interface ProjectLogsConfigS3Logs {
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. your CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting output artifacts. If `type` is set to `NO_ARTIFACTS`, this value is ignored. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Information about the build output artifact location. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored. If `type` is set to `S3`, this is the name of the output bucket.
         */
        location?: string;
        /**
         * Current status of logs in CloudWatch Logs for a build project. Valid values: `ENABLED`, `DISABLED`. Defaults to `ENABLED`.
         */
        status?: string;
    }

    export interface ProjectSecondaryArtifact {
        /**
         * Artifact identifier. Must be the same specified inside the AWS CodeBuild build specification.
         */
        artifactIdentifier: string;
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. The CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting output artifacts. If `type` is set to `NO_ARTIFACTS`, this value is ignored. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Information about the build output artifact location. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the name of the output bucket. If `path` is not specified, `location` can specify the path of the output artifact in the output bucket.
         */
        location?: string;
        /**
         * Name of the project. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the name of the output artifact object.
         */
        name?: string;
        /**
         * Namespace to use in storing build artifacts. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, valid values are `BUILD_ID` or `NONE`.
         */
        namespaceType?: string;
        /**
         * Whether a name specified in the build specification overrides the artifact name.
         */
        overrideArtifactName?: boolean;
        /**
         * Type of build output artifact to create. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, valid values are `NONE` or `ZIP`.
         */
        packaging?: string;
        /**
         * Along with `namespaceType` and `name`, the pattern that AWS CodeBuild uses to name and store the output artifact. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the path to the output artifact.
         */
        path?: string;
        /**
         * Build output artifact's type. Valid values `CODEPIPELINE`, `NO_ARTIFACTS`, and `S3`.
         */
        type: string;
    }

    export interface ProjectSecondarySource {
        /**
         * Configuration block that contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is `GITHUB`, `GITHUB_ENTERPRISE`, or `BITBUCKET`. `buildStatusConfig` blocks are documented below.
         */
        buildStatusConfig?: outputs.codebuild.ProjectSecondarySourceBuildStatusConfig;
        /**
         * The build spec declaration to use for this build project's related builds. This must be set when `type` is `NO_SOURCE`. It can either be a path to a file residing in the repository to be built or a local file path leveraging the `file()` built-in.
         */
        buildspec?: string;
        /**
         * Truncate git history to this many commits. Use `0` for a `Full` checkout which you need to run commands like `git branch --show-current`. See [AWS CodePipeline User Guide: Tutorial: Use full clone with a GitHub pipeline source](https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-github-gitclone.html) for details.
         */
        gitCloneDepth?: number;
        /**
         * Configuration block. Detailed below.
         */
        gitSubmodulesConfig?: outputs.codebuild.ProjectSecondarySourceGitSubmodulesConfig;
        /**
         * Ignore SSL warnings when connecting to source control.
         */
        insecureSsl?: boolean;
        /**
         * Location of the source code from git or s3.
         */
        location?: string;
        /**
         * Whether to report the status of a build's start and finish to your source provider. This option is only valid when your source provider is `GITHUB`, `BITBUCKET`, or `GITHUB_ENTERPRISE`.
         */
        reportBuildStatus?: boolean;
        /**
         * An identifier for this project source. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
         */
        sourceIdentifier: string;
        /**
         * Type of repository that contains the source code to be built. Valid values: `CODECOMMIT`, `CODEPIPELINE`, `GITHUB`, `GITHUB_ENTERPRISE`, `BITBUCKET` or `S3`.
         */
        type: string;
    }

    export interface ProjectSecondarySourceBuildStatusConfig {
        /**
         * Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        context?: string;
        /**
         * Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        targetUrl?: string;
    }

    export interface ProjectSecondarySourceGitSubmodulesConfig {
        /**
         * Whether to fetch Git submodules for the AWS CodeBuild build project.
         */
        fetchSubmodules: boolean;
    }

    export interface ProjectSecondarySourceVersion {
        /**
         * An identifier for a source in the build project.
         */
        sourceIdentifier: string;
        /**
         * The source version for the corresponding source identifier. See [AWS docs](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_ProjectSourceVersion.html#CodeBuild-Type-ProjectSourceVersion-sourceVersion) for more details.
         */
        sourceVersion: string;
    }

    export interface ProjectSource {
        /**
         * Configuration block that contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is `GITHUB`, `GITHUB_ENTERPRISE`, or `BITBUCKET`. `buildStatusConfig` blocks are documented below.
         */
        buildStatusConfig?: outputs.codebuild.ProjectSourceBuildStatusConfig;
        /**
         * Build specification to use for this build project's related builds. This must be set when `type` is `NO_SOURCE`.
         */
        buildspec?: string;
        /**
         * Truncate git history to this many commits. Use `0` for a `Full` checkout which you need to run commands like `git branch --show-current`. See [AWS CodePipeline User Guide: Tutorial: Use full clone with a GitHub pipeline source](https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-github-gitclone.html) for details.
         */
        gitCloneDepth?: number;
        /**
         * Configuration block. Detailed below.
         */
        gitSubmodulesConfig?: outputs.codebuild.ProjectSourceGitSubmodulesConfig;
        /**
         * Ignore SSL warnings when connecting to source control.
         */
        insecureSsl?: boolean;
        /**
         * Location of the source code from git or s3.
         */
        location?: string;
        /**
         * Whether to report the status of a build's start and finish to your source provider. This option is only valid when the `type` is `BITBUCKET` or `GITHUB`.
         */
        reportBuildStatus?: boolean;
        /**
         * Type of repository that contains the source code to be built. Valid values: `CODECOMMIT`, `CODEPIPELINE`, `GITHUB`, `GITHUB_ENTERPRISE`, `BITBUCKET`, `S3`, `NO_SOURCE`.
         */
        type: string;
    }

    export interface ProjectSourceBuildStatusConfig {
        /**
         * Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        context?: string;
        /**
         * Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        targetUrl?: string;
    }

    export interface ProjectSourceGitSubmodulesConfig {
        /**
         * Whether to fetch Git submodules for the AWS CodeBuild build project.
         */
        fetchSubmodules: boolean;
    }

    export interface ProjectVpcConfig {
        /**
         * Security group IDs to assign to running builds.
         */
        securityGroupIds: string[];
        /**
         * Subnet IDs within which to run builds.
         */
        subnets: string[];
        /**
         * ID of the VPC within which to run builds.
         */
        vpcId: string;
    }

    export interface ReportGroupExportConfig {
        /**
         * contains information about the S3 bucket where the run of a report is exported. see S3 Destination documented below.
         */
        s3Destination?: outputs.codebuild.ReportGroupExportConfigS3Destination;
        /**
         * The export configuration type. Valid values are `S3` and `NO_EXPORT`.
         */
        type: string;
    }

    export interface ReportGroupExportConfigS3Destination {
        /**
         * The name of the S3 bucket where the raw data of a report are exported.
         */
        bucket: string;
        /**
         * A boolean value that specifies if the results of a report are encrypted.
         * **Note: the API does not currently allow setting encryption as disabled**
         */
        encryptionDisabled?: boolean;
        /**
         * The encryption key for the report's encrypted raw data. The KMS key ARN.
         */
        encryptionKey: string;
        /**
         * The type of build output artifact to create. Valid values are: `NONE` (default) and `ZIP`.
         */
        packaging?: string;
        /**
         * The path to the exported report's raw data results.
         */
        path?: string;
    }

    export interface WebhookFilterGroup {
        /**
         * A webhook filter for the group. Filter blocks are documented below.
         */
        filters?: outputs.codebuild.WebhookFilterGroupFilter[];
    }

    export interface WebhookFilterGroupFilter {
        /**
         * If set to `true`, the specified filter does *not* trigger a build. Defaults to `false`.
         */
        excludeMatchedPattern?: boolean;
        /**
         * For a filter that uses `EVENT` type, a comma-separated string that specifies one event: `PUSH`, `PULL_REQUEST_CREATED`, `PULL_REQUEST_UPDATED`, `PULL_REQUEST_REOPENED`. `PULL_REQUEST_MERGED` works with GitHub & GitHub Enterprise only. For a filter that uses any of the other filter types, a regular expression.
         */
        pattern: string;
        /**
         * The webhook filter group's type. Valid values for this parameter are: `EVENT`, `BASE_REF`, `HEAD_REF`, `ACTOR_ACCOUNT_ID`, `FILE_PATH`, `COMMIT_MESSAGE`. At least one filter group must specify `EVENT` as its type.
         */
        type: string;
    }

}

export namespace codecommit {
    export interface TriggerTrigger {
        /**
         * The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
         */
        branches?: string[];
        /**
         * Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
         */
        customData?: string;
        /**
         * The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
         */
        destinationArn: string;
        /**
         * The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: `all`, `updateReference`, `createReference`, `deleteReference`.
         */
        events: string[];
        /**
         * The name of the trigger.
         */
        name: string;
    }

}

export namespace codedeploy {
    export interface DeploymentConfigMinimumHealthyHosts {
        /**
         * The type can either be `FLEET_PERCENT` or `HOST_COUNT`.
         */
        type?: string;
        /**
         * The value when the type is `FLEET_PERCENT` represents the minimum number of healthy instances as
         * a percentage of the total number of instances in the deployment. If you specify FLEET_PERCENT, at the start of the
         * deployment, AWS CodeDeploy converts the percentage to the equivalent number of instance and rounds up fractional instances.
         * When the type is `HOST_COUNT`, the value represents the minimum number of healthy instances as an absolute value.
         */
        value?: number;
    }

    export interface DeploymentConfigTrafficRoutingConfig {
        /**
         * The time based canary configuration information. If `type` is `TimeBasedLinear`, use `timeBasedLinear` instead.
         */
        timeBasedCanary?: outputs.codedeploy.DeploymentConfigTrafficRoutingConfigTimeBasedCanary;
        /**
         * The time based linear configuration information. If `type` is `TimeBasedCanary`, use `timeBasedCanary` instead.
         */
        timeBasedLinear?: outputs.codedeploy.DeploymentConfigTrafficRoutingConfigTimeBasedLinear;
        /**
         * Type of traffic routing config. One of `TimeBasedCanary`, `TimeBasedLinear`, `AllAtOnce`.
         */
        type?: string;
    }

    export interface DeploymentConfigTrafficRoutingConfigTimeBasedCanary {
        /**
         * The number of minutes between the first and second traffic shifts of a `TimeBasedCanary` deployment.
         */
        interval?: number;
        /**
         * The percentage of traffic to shift in the first increment of a `TimeBasedCanary` deployment.
         */
        percentage?: number;
    }

    export interface DeploymentConfigTrafficRoutingConfigTimeBasedLinear {
        /**
         * The number of minutes between each incremental traffic shift of a `TimeBasedLinear` deployment.
         */
        interval?: number;
        /**
         * The percentage of traffic that is shifted at the start of each increment of a `TimeBasedLinear` deployment.
         */
        percentage?: number;
    }

    export interface DeploymentGroupAlarmConfiguration {
        /**
         * A list of alarms configured for the deployment group. _A maximum of 10 alarms can be added to a deployment group_.
         */
        alarms?: string[];
        /**
         * Indicates whether the alarm configuration is enabled. This option is useful when you want to temporarily deactivate alarm monitoring for a deployment group without having to add the same alarms again later.
         */
        enabled?: boolean;
        /**
         * Indicates whether a deployment should continue if information about the current state of alarms cannot be retrieved from CloudWatch. The default value is `false`.
         */
        ignorePollAlarmFailure?: boolean;
    }

    export interface DeploymentGroupAutoRollbackConfiguration {
        /**
         * Indicates whether a defined automatic rollback configuration is currently enabled for this Deployment Group. If you enable automatic rollback, you must specify at least one event type.
         */
        enabled?: boolean;
        /**
         * The event type or types that trigger a rollback. Supported types are `DEPLOYMENT_FAILURE` and `DEPLOYMENT_STOP_ON_ALARM`.
         *
         * _Only one `autoRollbackConfiguration` is allowed_.
         */
        events?: string[];
    }

    export interface DeploymentGroupBlueGreenDeploymentConfig {
        /**
         * Information about the action to take when newly provisioned instances are ready to receive traffic in a blue/green deployment (documented below).
         */
        deploymentReadyOption?: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigDeploymentReadyOption;
        /**
         * Information about how instances are provisioned for a replacement environment in a blue/green deployment (documented below).
         */
        greenFleetProvisioningOption: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigGreenFleetProvisioningOption;
        /**
         * Information about whether to terminate instances in the original fleet during a blue/green deployment (documented below).
         *
         * _Only one `blueGreenDeploymentConfig` is allowed_.
         */
        terminateBlueInstancesOnDeploymentSuccess?: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess;
    }

    export interface DeploymentGroupBlueGreenDeploymentConfigDeploymentReadyOption {
        /**
         * When to reroute traffic from an original environment to a replacement environment in a blue/green deployment.
         */
        actionOnTimeout?: string;
        /**
         * The number of minutes to wait before the status of a blue/green deployment changed to Stopped if rerouting is not started manually. Applies only to the `STOP_DEPLOYMENT` option for `actionOnTimeout`.
         */
        waitTimeInMinutes?: number;
    }

    export interface DeploymentGroupBlueGreenDeploymentConfigGreenFleetProvisioningOption {
        /**
         * The method used to add instances to a replacement environment.
         */
        action?: string;
    }

    export interface DeploymentGroupBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess {
        /**
         * The action to take on instances in the original environment after a successful blue/green deployment.
         */
        action?: string;
        /**
         * The number of minutes to wait after a successful blue/green deployment before terminating instances from the original environment.
         */
        terminationWaitTimeInMinutes?: number;
    }

    export interface DeploymentGroupDeploymentStyle {
        /**
         * Indicates whether to route deployment traffic behind a load balancer. Valid Values are `WITH_TRAFFIC_CONTROL` or `WITHOUT_TRAFFIC_CONTROL`. Default is `WITHOUT_TRAFFIC_CONTROL`.
         */
        deploymentOption?: string;
        /**
         * Indicates whether to run an in-place deployment or a blue/green deployment. Valid Values are `IN_PLACE` or `BLUE_GREEN`. Default is `IN_PLACE`.
         *
         * _Only one `deploymentStyle` is allowed_.
         */
        deploymentType?: string;
    }

    export interface DeploymentGroupEc2TagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         *
         * Multiple occurrences of `ec2TagFilter` are allowed, where any instance that matches to at least one of the tag filters is selected.
         */
        value?: string;
    }

    export interface DeploymentGroupEc2TagSet {
        /**
         * Tag filters associated with the deployment group. See the AWS docs for details.
         */
        ec2TagFilters?: outputs.codedeploy.DeploymentGroupEc2TagSetEc2TagFilter[];
    }

    export interface DeploymentGroupEc2TagSetEc2TagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         *
         * Multiple occurrences of `ec2TagFilter` are allowed, where any instance that matches to at least one of the tag filters is selected.
         */
        value?: string;
    }

    export interface DeploymentGroupEcsService {
        /**
         * The name of the ECS cluster.
         */
        clusterName: string;
        /**
         * The name of the ECS service.
         */
        serviceName: string;
    }

    export interface DeploymentGroupLoadBalancerInfo {
        /**
         * The Classic Elastic Load Balancer to use in a deployment. Conflicts with `targetGroupInfo` and `targetGroupPairInfo`.
         */
        elbInfos?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoElbInfo[];
        /**
         * The (Application/Network Load Balancer) target group to use in a deployment. Conflicts with `elbInfo` and `targetGroupPairInfo`.
         */
        targetGroupInfos?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupInfo[];
        /**
         * The (Application/Network Load Balancer) target group pair to use in a deployment. Conflicts with `elbInfo` and `targetGroupInfo`.
         */
        targetGroupPairInfo?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfo;
    }

    export interface DeploymentGroupLoadBalancerInfoElbInfo {
        /**
         * The name of the load balancer that will be used to route traffic from original instances to replacement instances in a blue/green deployment. For in-place deployments, the name of the load balancer that instances are deregistered from so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
         */
        name?: string;
    }

    export interface DeploymentGroupLoadBalancerInfoTargetGroupInfo {
        /**
         * The name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
         */
        name?: string;
    }

    export interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfo {
        /**
         * Configuration block for the production traffic route (documented below).
         */
        prodTrafficRoute: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute;
        /**
         * Configuration blocks for a target group within a target group pair (documented below).
         */
        targetGroups: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTargetGroup[];
        /**
         * Configuration block for the test traffic route (documented below).
         */
        testTrafficRoute?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute;
    }

    export interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute {
        /**
         * List of Amazon Resource Names (ARNs) of the load balancer listeners. Must contain exactly one listener ARN.
         */
        listenerArns: string[];
    }

    export interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTargetGroup {
        /**
         * Name of the target group.
         */
        name: string;
    }

    export interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute {
        /**
         * List of Amazon Resource Names (ARNs) of the load balancer listeners.
         */
        listenerArns: string[];
    }

    export interface DeploymentGroupOnPremisesInstanceTagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         */
        value?: string;
    }

    export interface DeploymentGroupTriggerConfiguration {
        /**
         * The event type or types for which notifications are triggered. Some values that are supported: `DeploymentStart`, `DeploymentSuccess`, `DeploymentFailure`, `DeploymentStop`, `DeploymentRollback`, `InstanceStart`, `InstanceSuccess`, `InstanceFailure`.  See [the CodeDeploy documentation](http://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-sns-event-notifications-create-trigger.html) for all possible values.
         */
        triggerEvents: string[];
        /**
         * The name of the notification trigger.
         */
        triggerName: string;
        /**
         * The ARN of the SNS topic through which notifications are sent.
         */
        triggerTargetArn: string;
    }

}

export namespace codegurureviewer {
    export interface RepositoryAssociationKmsKeyDetails {
        /**
         * The encryption option for a repository association. It is either owned by AWS Key Management Service (KMS) (`AWS_OWNED_CMK`) or customer managed (`CUSTOMER_MANAGED_CMK`).
         */
        encryptionOption?: string;
        /**
         * The ID of the AWS KMS key that is associated with a repository association.
         */
        kmsKeyId?: string;
    }

    export interface RepositoryAssociationRepository {
        bitbucket?: outputs.codegurureviewer.RepositoryAssociationRepositoryBitbucket;
        codecommit?: outputs.codegurureviewer.RepositoryAssociationRepositoryCodecommit;
        githubEnterpriseServer?: outputs.codegurureviewer.RepositoryAssociationRepositoryGithubEnterpriseServer;
        s3Bucket?: outputs.codegurureviewer.RepositoryAssociationRepositoryS3Bucket;
    }

    export interface RepositoryAssociationRepositoryBitbucket {
        /**
         * The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection.
         */
        connectionArn: string;
        /**
         * The name of the third party source repository.
         */
        name: string;
        /**
         * The username for the account that owns the repository.
         */
        owner: string;
    }

    export interface RepositoryAssociationRepositoryCodecommit {
        /**
         * The name of the AWS CodeCommit repository.
         */
        name: string;
    }

    export interface RepositoryAssociationRepositoryGithubEnterpriseServer {
        /**
         * The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection.
         */
        connectionArn: string;
        /**
         * The name of the third party source repository.
         */
        name: string;
        /**
         * The username for the account that owns the repository.
         */
        owner: string;
    }

    export interface RepositoryAssociationRepositoryS3Bucket {
        /**
         * The name of the S3 bucket used for associating a new S3 repository. Note: The name must begin with `codeguru-reviewer-`.
         */
        bucketName: string;
        /**
         * The name of the third party source repository.
         */
        name: string;
    }

    export interface RepositoryAssociationS3RepositoryDetail {
        /**
         * The name of the S3 bucket used for associating a new S3 repository. Note: The name must begin with `codeguru-reviewer-`.
         */
        bucketName: string;
        codeArtifacts: outputs.codegurureviewer.RepositoryAssociationS3RepositoryDetailCodeArtifact[];
    }

    export interface RepositoryAssociationS3RepositoryDetailCodeArtifact {
        buildArtifactsObjectKey: string;
        sourceCodeArtifactsObjectKey: string;
    }

}

export namespace codepipeline {
    export interface CustomActionTypeConfigurationProperty {
        /**
         * The description of the action configuration property.
         */
        description?: string;
        /**
         * Whether the configuration property is a key.
         */
        key: boolean;
        /**
         * The name of the action configuration property.
         */
        name: string;
        /**
         * Indicates that the property will be used in conjunction with PollForJobs.
         */
        queryable?: boolean;
        /**
         * Whether the configuration property is a required value.
         */
        required: boolean;
        /**
         * Whether the configuration property is secret.
         */
        secret: boolean;
        /**
         * The type of the configuration property. Valid values: `String`, `Number`, `Boolean`
         */
        type?: string;
    }

    export interface CustomActionTypeInputArtifactDetails {
        /**
         * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        maximumCount: number;
        /**
         * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        minimumCount: number;
    }

    export interface CustomActionTypeOutputArtifactDetails {
        /**
         * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        maximumCount: number;
        /**
         * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        minimumCount: number;
    }

    export interface CustomActionTypeSettings {
        /**
         * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
         */
        entityUrlTemplate?: string;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
         */
        executionUrlTemplate?: string;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
         */
        revisionUrlTemplate?: string;
        /**
         * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
         */
        thirdPartyConfigurationUrl?: string;
    }

    export interface PipelineArtifactStore {
        /**
         * The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An `encryptionKey` block is documented below.
         */
        encryptionKey?: outputs.codepipeline.PipelineArtifactStoreEncryptionKey;
        /**
         * The location where AWS CodePipeline stores artifacts for a pipeline; currently only `S3` is supported.
         */
        location: string;
        /**
         * The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
         */
        region: string;
        /**
         * The type of the artifact store, such as Amazon S3
         */
        type: string;
    }

    export interface PipelineArtifactStoreEncryptionKey {
        /**
         * The KMS key ARN or ID
         */
        id: string;
        /**
         * The type of key; currently only `KMS` is supported
         */
        type: string;
    }

    export interface PipelineStage {
        /**
         * The action(s) to include in the stage. Defined as an `action` block below
         */
        actions: outputs.codepipeline.PipelineStageAction[];
        /**
         * The name of the stage.
         */
        name: string;
    }

    export interface PipelineStageAction {
        /**
         * A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are `Approval`, `Build`, `Deploy`, `Invoke`, `Source` and `Test`.
         */
        category: string;
        /**
         * A map of the action declaration's configuration. Configurations options for action types and providers can be found in the [Pipeline Structure Reference](http://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements) and [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
         */
        configuration?: {[key: string]: string};
        /**
         * A list of artifact names to be worked on.
         */
        inputArtifacts?: string[];
        /**
         * The action declaration's name.
         */
        name: string;
        /**
         * The namespace all output variables will be accessed from.
         *
         * > **Note:** The input artifact of an action must exactly match the output artifact declared in a preceding action, but the input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions.
         */
        namespace?: string;
        /**
         * A list of artifact names to output. Output artifact names must be unique within a pipeline.
         */
        outputArtifacts?: string[];
        /**
         * The creator of the action being called. Possible values are `AWS`, `Custom` and `ThirdParty`.
         */
        owner: string;
        /**
         * The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
         */
        provider: string;
        /**
         * The region in which to run the action.
         */
        region: string;
        /**
         * The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
         */
        roleArn?: string;
        /**
         * The order in which actions are run.
         */
        runOrder: number;
        /**
         * A string that identifies the action type.
         */
        version: string;
    }

    export interface WebhookAuthenticationConfiguration {
        /**
         * A valid CIDR block for `IP` filtering. Required for `IP`.
         */
        allowedIpRange?: string;
        /**
         * The shared secret for the GitHub repository webhook. Set this as `secret` in your `githubRepositoryWebhook`'s `configuration` block. Required for `GITHUB_HMAC`.
         */
        secretToken?: string;
    }

    export interface WebhookFilter {
        /**
         * The [JSON path](https://github.com/json-path/JsonPath) to filter on.
         */
        jsonPath: string;
        /**
         * The value to match on (e.g., `refs/heads/{Branch}`). See [AWS docs](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_WebhookFilterRule.html) for details.
         */
        matchEquals: string;
    }

}

export namespace codestarconnections {
    export interface HostVpcConfiguration {
        /**
         * ID of the security group or security groups associated with the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnet or subnets associated with the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        subnetIds: string[];
        /**
         * The value of the Transport Layer Security (TLS) certificate associated with the infrastructure where your provider type is installed.
         */
        tlsCertificate?: string;
        /**
         * The ID of the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        vpcId: string;
    }

}

export namespace codestarnotifications {
    export interface NotificationRuleTarget {
        /**
         * The ARN of notification rule target. For example, a SNS Topic ARN.
         */
        address: string;
        /**
         * The status of the notification rule. Possible values are `ENABLED` and `DISABLED`, default is `ENABLED`.
         */
        status: string;
        /**
         * The type of the notification target. Default value is `SNS`.
         */
        type?: string;
    }

}

export namespace cognito {
    export interface GetUserPoolClientAnalyticsConfiguration {
        /**
         * (Optional) Application ARN for an Amazon Pinpoint application. Conflicts with `externalId` and `roleArn`.
         */
        applicationArn: string;
        /**
         * (Optional) Application ID for an Amazon Pinpoint application.
         */
        applicationId: string;
        /**
         * (Optional) ID for the Analytics Configuration. Conflicts with `applicationArn`.
         */
        externalId: string;
        /**
         * (Optional) ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * (Optional) If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }

    export interface GetUserPoolClientTokenValidityUnit {
        /**
         * (Optional) Time unit in for the value in `accessTokenValidity`, defaults to `hours`.
         */
        accessToken: string;
        /**
         * (Optional) Time unit in for the value in `idTokenValidity`, defaults to `hours`.
         */
        idToken: string;
        /**
         * (Optional) Time unit in for the value in `refreshTokenValidity`, defaults to `days`.
         */
        refreshToken: string;
    }

    export interface IdentityPoolCognitoIdentityProvider {
        /**
         * The client ID for the Amazon Cognito Identity User Pool.
         */
        clientId?: string;
        /**
         * The provider name for an Amazon Cognito Identity User Pool.
         */
        providerName?: string;
        /**
         * Whether server-side token validation is enabled for the identity provider’s token or not.
         */
        serverSideTokenCheck?: boolean;
    }

    export interface IdentityPoolRoleAttachmentRoleMapping {
        /**
         * Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type. `Required` if you specify Token or Rules as the Type.
         */
        ambiguousRoleResolution?: string;
        /**
         * A string identifying the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Depends on `cognitoIdentityProviders` set on `aws.cognito.IdentityPool` resource or a `aws.cognito.IdentityProvider` resource.
         */
        identityProvider: string;
        /**
         * The Rules Configuration to be used for mapping users to roles. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
         */
        mappingRules?: outputs.cognito.IdentityPoolRoleAttachmentRoleMappingMappingRule[];
        /**
         * The role mapping type.
         */
        type: string;
    }

    export interface IdentityPoolRoleAttachmentRoleMappingMappingRule {
        /**
         * The claim name that must be present in the token, for example, "isAdmin" or "paid".
         */
        claim: string;
        /**
         * The match condition that specifies how closely the claim value in the IdP token must match Value.
         */
        matchType: string;
        /**
         * The role ARN.
         */
        roleArn: string;
        /**
         * A brief string that the claim must match, for example, "paid" or "yes".
         */
        value: string;
    }

    export interface ManagedUserPoolClientAnalyticsConfiguration {
        /**
         * Application ARN for an Amazon Pinpoint application. It conflicts with `externalId` and `roleArn`.
         */
        applicationArn?: string;
        /**
         * Unique identifier for an Amazon Pinpoint application.
         */
        applicationId?: string;
        /**
         * ID for the Analytics Configuration and conflicts with `applicationArn`.
         */
        externalId?: string;
        /**
         * ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. It conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * If `userDataShared` is set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }

    export interface ManagedUserPoolClientTokenValidityUnits {
        /**
         * Time unit for the value in `accessTokenValidity` and defaults to `hours`.
         */
        accessToken: string;
        /**
         * Time unit for the value in `idTokenValidity`, and it defaults to `hours`.
         */
        idToken: string;
        /**
         * Time unit for the value in `refreshTokenValidity` and defaults to `days`.
         */
        refreshToken: string;
    }

    export interface ResourceServerScope {
        /**
         * The scope description.
         */
        scopeDescription: string;
        /**
         * The scope name.
         */
        scopeName: string;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfiguration {
        /**
         * Account takeover risk configuration actions. See details below.
         */
        actions: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActions;
        /**
         * The notify configuration used to construct email notifications. See details below.
         */
        notifyConfiguration: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationActions {
        /**
         * Action to take for a high risk. See action block below.
         */
        highAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction;
        /**
         * Action to take for a low risk. See action block below.
         */
        lowAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction;
        /**
         * Action to take for a medium risk. See action block below.
         */
        mediumAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction {
        /**
         * The action to take in response to the account takeover action. Valid values are `BLOCK`, `MFA_IF_CONFIGURED`, `MFA_REQUIRED` and `NO_ACTION`.
         */
        eventAction: string;
        notify: boolean;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction {
        /**
         * The action to take in response to the account takeover action. Valid values are `BLOCK`, `MFA_IF_CONFIGURED`, `MFA_REQUIRED` and `NO_ACTION`.
         */
        eventAction: string;
        notify: boolean;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction {
        /**
         * The action to take in response to the account takeover action. Valid values are `BLOCK`, `MFA_IF_CONFIGURED`, `MFA_REQUIRED` and `NO_ACTION`.
         */
        eventAction: string;
        notify: boolean;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration {
        /**
         * Email template used when a detected risk event is blocked. See notify email type below.
         */
        blockEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail;
        /**
         * The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
         */
        from?: string;
        /**
         * The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
         */
        mfaEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail;
        /**
         * The email template used when a detected risk event is allowed. See notify email type below.
         */
        noActionEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail;
        /**
         * The destination to which the receiver of an email should reply to.
         */
        replyTo?: string;
        /**
         * The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
         */
        sourceArn: string;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail {
        /**
         * The email HTML body.
         */
        htmlBody: string;
        /**
         * The email subject.
         */
        subject: string;
        /**
         * The email text body.
         */
        textBody: string;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail {
        /**
         * The email HTML body.
         */
        htmlBody: string;
        /**
         * The email subject.
         */
        subject: string;
        /**
         * The email text body.
         */
        textBody: string;
    }

    export interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail {
        /**
         * The email HTML body.
         */
        htmlBody: string;
        /**
         * The email subject.
         */
        subject: string;
        /**
         * The email text body.
         */
        textBody: string;
    }

    export interface RiskConfigurationCompromisedCredentialsRiskConfiguration {
        /**
         * The compromised credentials risk configuration actions. See details below.
         */
        actions: outputs.cognito.RiskConfigurationCompromisedCredentialsRiskConfigurationActions;
        /**
         * Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are `SIGN_IN`, `PASSWORD_CHANGE`, and `SIGN_UP`.
         */
        eventFilters: string[];
    }

    export interface RiskConfigurationCompromisedCredentialsRiskConfigurationActions {
        /**
         * The event action. Valid values are `BLOCK` or `NO_ACTION`.
         */
        eventAction: string;
    }

    export interface RiskConfigurationRiskExceptionConfiguration {
        /**
         * Overrides the risk decision to always block the pre-authentication requests.
         * The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
         * Can contain a maximum of 200 items.
         */
        blockedIpRangeLists?: string[];
        /**
         * Risk detection isn't performed on the IP addresses in this range list.
         * The IP range is in CIDR notation.
         * Can contain a maximum of 200 items.
         */
        skippedIpRangeLists?: string[];
    }

    export interface UserPoolAccountRecoverySetting {
        /**
         * List of Account Recovery Options of the following structure:
         */
        recoveryMechanisms: outputs.cognito.UserPoolAccountRecoverySettingRecoveryMechanism[];
    }

    export interface UserPoolAccountRecoverySettingRecoveryMechanism {
        /**
         * Name of the user pool.
         *
         * The following arguments are optional:
         */
        name: string;
        /**
         * Positive integer specifying priority of a method with 1 being the highest priority.
         */
        priority: number;
    }

    export interface UserPoolAdminCreateUserConfig {
        /**
         * Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
         */
        allowAdminCreateUserOnly?: boolean;
        /**
         * Invite message template structure. Detailed below.
         */
        inviteMessageTemplate?: outputs.cognito.UserPoolAdminCreateUserConfigInviteMessageTemplate;
    }

    export interface UserPoolAdminCreateUserConfigInviteMessageTemplate {
        /**
         * Message template for email messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
         */
        emailMessage?: string;
        /**
         * Subject line for email messages.
         */
        emailSubject?: string;
        /**
         * Message template for SMS messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
         */
        smsMessage?: string;
    }

    export interface UserPoolClientAnalyticsConfiguration {
        /**
         * Application ARN for an Amazon Pinpoint application. Conflicts with `externalId` and `roleArn`.
         */
        applicationArn?: string;
        /**
         * Application ID for an Amazon Pinpoint application.
         */
        applicationId?: string;
        /**
         * ID for the Analytics Configuration. Conflicts with `applicationArn`.
         */
        externalId?: string;
        /**
         * ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }

    export interface UserPoolClientTokenValidityUnits {
        /**
         * Time unit in for the value in `accessTokenValidity`, defaults to `hours`.
         */
        accessToken: string;
        /**
         * Time unit in for the value in `idTokenValidity`, defaults to `hours`.
         */
        idToken: string;
        /**
         * Time unit in for the value in `refreshTokenValidity`, defaults to `days`.
         */
        refreshToken: string;
    }

    export interface UserPoolDeviceConfiguration {
        /**
         * Whether a challenge is required on a new device. Only applicable to a new device.
         */
        challengeRequiredOnNewDevice?: boolean;
        /**
         * Whether a device is only remembered on user prompt. `false` equates to "Always" remember, `true` is "User Opt In," and not using a `deviceConfiguration` block is "No."
         */
        deviceOnlyRememberedOnUserPrompt?: boolean;
    }

    export interface UserPoolEmailConfiguration {
        /**
         * Email configuration set name from SES.
         */
        configurationSet?: string;
        /**
         * Email delivery method to use. `COGNITO_DEFAULT` for the default email functionality built into Cognito or `DEVELOPER` to use your Amazon SES configuration. Required to be `DEVELOPER` if `fromEmailAddress` is set.
         */
        emailSendingAccount?: string;
        /**
         * Sender’s email address or sender’s display name with their email address (e.g., `john@example.com`, `John Smith <john@example.com>` or `\"John Smith Ph.D.\" <john@example.com>`). Escaped double quotes are required around display names that contain certain characters as specified in [RFC 5322](https://tools.ietf.org/html/rfc5322).
         */
        fromEmailAddress?: string;
        /**
         * REPLY-TO email address.
         */
        replyToEmailAddress?: string;
        /**
         * ARN of the SES verified email identity to use. Required if `emailSendingAccount` is set to `DEVELOPER`.
         */
        sourceArn?: string;
    }

    export interface UserPoolLambdaConfig {
        /**
         * ARN of the lambda creating an authentication challenge.
         */
        createAuthChallenge?: string;
        /**
         * A custom email sender AWS Lambda trigger. See customEmailSender Below.
         */
        customEmailSender?: outputs.cognito.UserPoolLambdaConfigCustomEmailSender;
        /**
         * Custom Message AWS Lambda trigger.
         */
        customMessage?: string;
        /**
         * A custom SMS sender AWS Lambda trigger. See customSmsSender Below.
         */
        customSmsSender?: outputs.cognito.UserPoolLambdaConfigCustomSmsSender;
        /**
         * Defines the authentication challenge.
         */
        defineAuthChallenge?: string;
        /**
         * The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
         */
        kmsKeyId?: string;
        /**
         * Post-authentication AWS Lambda trigger.
         */
        postAuthentication?: string;
        /**
         * Post-confirmation AWS Lambda trigger.
         */
        postConfirmation?: string;
        /**
         * Pre-authentication AWS Lambda trigger.
         */
        preAuthentication?: string;
        /**
         * Pre-registration AWS Lambda trigger.
         */
        preSignUp?: string;
        /**
         * Allow to customize identity token claims before token generation.
         */
        preTokenGeneration?: string;
        /**
         * User migration Lambda config type.
         */
        userMigration?: string;
        /**
         * Verifies the authentication challenge response.
         */
        verifyAuthChallengeResponse?: string;
    }

    export interface UserPoolLambdaConfigCustomEmailSender {
        /**
         * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
         */
        lambdaArn: string;
        /**
         * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is `V1_0`.
         */
        lambdaVersion: string;
    }

    export interface UserPoolLambdaConfigCustomSmsSender {
        /**
         * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
         */
        lambdaArn: string;
        /**
         * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is `V1_0`.
         */
        lambdaVersion: string;
    }

    export interface UserPoolPasswordPolicy {
        /**
         * Minimum length of the password policy that you have set.
         */
        minimumLength?: number;
        /**
         * Whether you have required users to use at least one lowercase letter in their password.
         */
        requireLowercase?: boolean;
        /**
         * Whether you have required users to use at least one number in their password.
         */
        requireNumbers?: boolean;
        /**
         * Whether you have required users to use at least one symbol in their password.
         */
        requireSymbols?: boolean;
        /**
         * Whether you have required users to use at least one uppercase letter in their password.
         */
        requireUppercase?: boolean;
        /**
         * In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
         */
        temporaryPasswordValidityDays?: number;
    }

    export interface UserPoolSchema {
        /**
         * Attribute data type. Must be one of `Boolean`, `Number`, `String`, `DateTime`.
         */
        attributeDataType: string;
        /**
         * Whether the attribute type is developer only.
         */
        developerOnlyAttribute?: boolean;
        /**
         * Whether the attribute can be changed once it has been created.
         */
        mutable?: boolean;
        /**
         * Name of the attribute.
         */
        name: string;
        /**
         * Configuration block for the constraints for an attribute of the number type. Detailed below.
         */
        numberAttributeConstraints?: outputs.cognito.UserPoolSchemaNumberAttributeConstraints;
        /**
         * Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
         */
        required?: boolean;
        /**
         * Constraints for an attribute of the string type. Detailed below.
         */
        stringAttributeConstraints?: outputs.cognito.UserPoolSchemaStringAttributeConstraints;
    }

    export interface UserPoolSchemaNumberAttributeConstraints {
        /**
         * Maximum value of an attribute that is of the number data type.
         */
        maxValue?: string;
        /**
         * Minimum value of an attribute that is of the number data type.
         */
        minValue?: string;
    }

    export interface UserPoolSchemaStringAttributeConstraints {
        /**
         * Maximum length of an attribute value of the string type.
         */
        maxLength?: string;
        /**
         * Minimum length of an attribute value of the string type.
         */
        minLength?: string;
    }

    export interface UserPoolSmsConfiguration {
        /**
         * External ID used in IAM role trust relationships. For more information about using external IDs, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html).
         */
        externalId: string;
        /**
         * ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
         */
        snsCallerArn: string;
        /**
         * The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see [SMS message settings for Amazon Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-sms-settings.html).
         */
        snsRegion: string;
    }

    export interface UserPoolSoftwareTokenMfaConfiguration {
        /**
         * Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When `smsConfiguration` is not present, the `mfaConfiguration` argument must be set to `OFF` and the `softwareTokenMfaConfiguration` configuration block must be fully removed.
         */
        enabled: boolean;
    }

    export interface UserPoolUserAttributeUpdateSettings {
        /**
         * A list of attributes requiring verification before update. If set, the provided value(s) must also be set in `autoVerifiedAttributes`. Valid values: `email`, `phoneNumber`.
         */
        attributesRequireVerificationBeforeUpdates: string[];
    }

    export interface UserPoolUserPoolAddOns {
        /**
         * Mode for advanced security, must be one of `OFF`, `AUDIT` or `ENFORCED`.
         */
        advancedSecurityMode: string;
    }

    export interface UserPoolUsernameConfiguration {
        /**
         * Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
         */
        caseSensitive: boolean;
    }

    export interface UserPoolVerificationMessageTemplate {
        /**
         * Default email option. Must be either `CONFIRM_WITH_CODE` or `CONFIRM_WITH_LINK`. Defaults to `CONFIRM_WITH_CODE`.
         */
        defaultEmailOption?: string;
        /**
         * Email message template. Must contain the `{####}` placeholder. Conflicts with `emailVerificationMessage` argument.
         */
        emailMessage: string;
        /**
         * Email message template for sending a confirmation link to the user, it must contain the `{##Click Here##}` placeholder.
         */
        emailMessageByLink: string;
        /**
         * Subject line for the email message template. Conflicts with `emailVerificationSubject` argument.
         */
        emailSubject: string;
        /**
         * Subject line for the email message template for sending a confirmation link to the user.
         */
        emailSubjectByLink: string;
        /**
         * SMS message template. Must contain the `{####}` placeholder. Conflicts with `smsVerificationMessage` argument.
         */
        smsMessage: string;
    }

}

export namespace comprehend {
    export interface DocumentClassifierInputDataConfig {
        /**
         * List of training datasets produced by Amazon SageMaker Ground Truth.
         * Used if `dataFormat` is `AUGMENTED_MANIFEST`.
         * See the `augmentedManifests` Configuration Block section below.
         */
        augmentedManifests?: outputs.comprehend.DocumentClassifierInputDataConfigAugmentedManifest[];
        /**
         * The format for the training data.
         * One of `COMPREHEND_CSV` or `AUGMENTED_MANIFEST`.
         */
        dataFormat?: string;
        /**
         * Delimiter between labels when training a multi-label classifier.
         * Valid values are `|`, `~`, `!`, `@`, `#`, `$`, `%`, `^`, `*`, `-`, `_`, `+`, `=`, `\`, `:`, `;`, `>`, `?`, `/`, `<space>`, and `<tab>`.
         * Default is `|`.
         */
        labelDelimiter: string;
        /**
         * Location of training documents.
         * Used if `dataFormat` is `COMPREHEND_CSV`.
         */
        s3Uri?: string;
        testS3Uri?: string;
    }

    export interface DocumentClassifierInputDataConfigAugmentedManifest {
        /**
         * Location of annotation files.
         */
        annotationDataS3Uri?: string;
        /**
         * The JSON attribute that contains the annotations for the training documents.
         */
        attributeNames: string[];
        /**
         * Type of augmented manifest.
         * One of `PLAIN_TEXT_DOCUMENT` or `SEMI_STRUCTURED_DOCUMENT`.
         */
        documentType?: string;
        /**
         * Location of augmented manifest file.
         */
        s3Uri: string;
        /**
         * Location of source PDF files.
         */
        sourceDocumentsS3Uri?: string;
        /**
         * Purpose of data in augmented manifest.
         * One of `TRAIN` or `TEST`.
         */
        split?: string;
    }

    export interface DocumentClassifierOutputDataConfig {
        /**
         * KMS Key used to encrypt the output documents.
         * Can be a KMS Key ID, a KMS Key ARN, a KMS Alias name, or a KMS Alias ARN.
         */
        kmsKeyId?: string;
        /**
         * Full path for the output documents.
         */
        outputS3Uri: string;
        /**
         * Destination path for the output documents.
         * The full path to the output file will be returned in `outputS3Uri`.
         */
        s3Uri: string;
    }

    export interface DocumentClassifierVpcConfig {
        /**
         * List of security group IDs.
         */
        securityGroupIds: string[];
        /**
         * List of VPC subnets.
         */
        subnets: string[];
    }

    export interface EntityRecognizerInputDataConfig {
        /**
         * Specifies location of the document annotation data.
         * See the `annotations` Configuration Block section below.
         * One of `annotations` or `entityList` is required.
         */
        annotations?: outputs.comprehend.EntityRecognizerInputDataConfigAnnotations;
        /**
         * List of training datasets produced by Amazon SageMaker Ground Truth.
         * Used if `dataFormat` is `AUGMENTED_MANIFEST`.
         * See the `augmentedManifests` Configuration Block section below.
         */
        augmentedManifests?: outputs.comprehend.EntityRecognizerInputDataConfigAugmentedManifest[];
        /**
         * The format for the training data.
         * One of `COMPREHEND_CSV` or `AUGMENTED_MANIFEST`.
         */
        dataFormat?: string;
        /**
         * Specifies a collection of training documents.
         * Used if `dataFormat` is `COMPREHEND_CSV`.
         * See the `documents` Configuration Block section below.
         */
        documents?: outputs.comprehend.EntityRecognizerInputDataConfigDocuments;
        /**
         * Specifies location of the entity list data.
         * See the `entityList` Configuration Block section below.
         * One of `entityList` or `annotations` is required.
         */
        entityList?: outputs.comprehend.EntityRecognizerInputDataConfigEntityList;
        /**
         * Set of entity types to be recognized.
         * Has a maximum of 25 items.
         * See the `entityTypes` Configuration Block section below.
         */
        entityTypes: outputs.comprehend.EntityRecognizerInputDataConfigEntityType[];
    }

    export interface EntityRecognizerInputDataConfigAnnotations {
        /**
         * Location of training annotations.
         */
        s3Uri: string;
        testS3Uri?: string;
    }

    export interface EntityRecognizerInputDataConfigAugmentedManifest {
        /**
         * Location of annotation files.
         */
        annotationDataS3Uri?: string;
        /**
         * The JSON attribute that contains the annotations for the training documents.
         */
        attributeNames: string[];
        /**
         * Type of augmented manifest.
         * One of `PLAIN_TEXT_DOCUMENT` or `SEMI_STRUCTURED_DOCUMENT`.
         */
        documentType?: string;
        /**
         * Location of augmented manifest file.
         */
        s3Uri: string;
        /**
         * Location of source PDF files.
         */
        sourceDocumentsS3Uri?: string;
        /**
         * Purpose of data in augmented manifest.
         * One of `TRAIN` or `TEST`.
         */
        split?: string;
    }

    export interface EntityRecognizerInputDataConfigDocuments {
        /**
         * Specifies how the input files should be processed.
         * One of `ONE_DOC_PER_LINE` or `ONE_DOC_PER_FILE`.
         */
        inputFormat?: string;
        /**
         * Location of training documents.
         */
        s3Uri: string;
        testS3Uri?: string;
    }

    export interface EntityRecognizerInputDataConfigEntityList {
        /**
         * Location of entity list.
         */
        s3Uri: string;
    }

    export interface EntityRecognizerInputDataConfigEntityType {
        /**
         * An entity type to be matched by the Entity Recognizer.
         * Cannot contain a newline (`\n`), carriage return (`\r`), or tab (`\t`).
         */
        type: string;
    }

    export interface EntityRecognizerVpcConfig {
        /**
         * List of security group IDs.
         */
        securityGroupIds: string[];
        /**
         * List of VPC subnets.
         */
        subnets: string[];
    }

}

export namespace config {
    export interface AssumeRole {
        duration?: string;
        externalId?: string;
        policy?: string;
        policyArns?: string[];
        roleArn?: string;
        sessionName?: string;
        sourceIdentity?: string;
        tags?: {[key: string]: string};
        transitiveTagKeys?: string[];
    }

    export interface AssumeRoleWithWebIdentity {
        duration?: string;
        policy?: string;
        policyArns?: string[];
        roleArn?: string;
        sessionName?: string;
        webIdentityToken?: string;
        webIdentityTokenFile?: string;
    }

    export interface DefaultTags {
        tags?: {[key: string]: string};
    }

    export interface Endpoints {
        accessanalyzer?: string;
        account?: string;
        acm?: string;
        acmpca?: string;
        alexaforbusiness?: string;
        amg?: string;
        amp?: string;
        amplify?: string;
        amplifybackend?: string;
        amplifyuibuilder?: string;
        apigateway?: string;
        apigatewaymanagementapi?: string;
        apigatewayv2?: string;
        appautoscaling?: string;
        appconfig?: string;
        appconfigdata?: string;
        appflow?: string;
        appintegrations?: string;
        appintegrationsservice?: string;
        applicationautoscaling?: string;
        applicationcostprofiler?: string;
        applicationdiscovery?: string;
        applicationdiscoveryservice?: string;
        applicationinsights?: string;
        appmesh?: string;
        appregistry?: string;
        apprunner?: string;
        appstream?: string;
        appsync?: string;
        athena?: string;
        auditmanager?: string;
        augmentedairuntime?: string;
        autoscaling?: string;
        autoscalingplans?: string;
        backup?: string;
        backupgateway?: string;
        batch?: string;
        beanstalk?: string;
        billingconductor?: string;
        braket?: string;
        budgets?: string;
        ce?: string;
        chime?: string;
        chimesdkidentity?: string;
        chimesdkmediapipelines?: string;
        chimesdkmeetings?: string;
        chimesdkmessaging?: string;
        chimesdkvoice?: string;
        cleanrooms?: string;
        cloud9?: string;
        cloudcontrol?: string;
        cloudcontrolapi?: string;
        clouddirectory?: string;
        cloudformation?: string;
        cloudfront?: string;
        cloudhsm?: string;
        cloudhsmv2?: string;
        cloudsearch?: string;
        cloudsearchdomain?: string;
        cloudtrail?: string;
        cloudwatch?: string;
        cloudwatchevents?: string;
        cloudwatchevidently?: string;
        cloudwatchlog?: string;
        cloudwatchlogs?: string;
        cloudwatchobservabilityaccessmanager?: string;
        cloudwatchrum?: string;
        codeartifact?: string;
        codebuild?: string;
        codecommit?: string;
        codedeploy?: string;
        codeguruprofiler?: string;
        codegurureviewer?: string;
        codepipeline?: string;
        codestar?: string;
        codestarconnections?: string;
        codestarnotifications?: string;
        cognitoidentity?: string;
        cognitoidentityprovider?: string;
        cognitoidp?: string;
        cognitosync?: string;
        comprehend?: string;
        comprehendmedical?: string;
        computeoptimizer?: string;
        config?: string;
        configservice?: string;
        connect?: string;
        connectcontactlens?: string;
        connectparticipant?: string;
        connectwisdomservice?: string;
        controltower?: string;
        costandusagereportservice?: string;
        costexplorer?: string;
        cur?: string;
        customerprofiles?: string;
        databasemigration?: string;
        databasemigrationservice?: string;
        databrew?: string;
        dataexchange?: string;
        datapipeline?: string;
        datasync?: string;
        dax?: string;
        deploy?: string;
        detective?: string;
        devicefarm?: string;
        devopsguru?: string;
        directconnect?: string;
        directoryservice?: string;
        discovery?: string;
        dlm?: string;
        dms?: string;
        docdb?: string;
        docdbelastic?: string;
        drs?: string;
        ds?: string;
        dynamodb?: string;
        dynamodbstreams?: string;
        ebs?: string;
        ec2?: string;
        ec2instanceconnect?: string;
        ecr?: string;
        ecrpublic?: string;
        ecs?: string;
        efs?: string;
        eks?: string;
        elasticache?: string;
        elasticbeanstalk?: string;
        elasticinference?: string;
        elasticloadbalancing?: string;
        elasticloadbalancingv2?: string;
        elasticsearch?: string;
        elasticsearchservice?: string;
        elastictranscoder?: string;
        elb?: string;
        elbv2?: string;
        emr?: string;
        emrcontainers?: string;
        emrserverless?: string;
        es?: string;
        eventbridge?: string;
        events?: string;
        evidently?: string;
        finspace?: string;
        finspacedata?: string;
        firehose?: string;
        fis?: string;
        fms?: string;
        forecast?: string;
        forecastquery?: string;
        forecastqueryservice?: string;
        forecastservice?: string;
        frauddetector?: string;
        fsx?: string;
        gamelift?: string;
        glacier?: string;
        globalaccelerator?: string;
        glue?: string;
        gluedatabrew?: string;
        grafana?: string;
        greengrass?: string;
        greengrassv2?: string;
        groundstation?: string;
        guardduty?: string;
        health?: string;
        healthlake?: string;
        honeycode?: string;
        iam?: string;
        identitystore?: string;
        imagebuilder?: string;
        inspector?: string;
        inspector2?: string;
        inspectorv2?: string;
        internetmonitor?: string;
        iot?: string;
        iot1clickdevices?: string;
        iot1clickdevicesservice?: string;
        iot1clickprojects?: string;
        iotanalytics?: string;
        iotdata?: string;
        iotdataplane?: string;
        iotdeviceadvisor?: string;
        iotevents?: string;
        ioteventsdata?: string;
        iotfleethub?: string;
        iotjobsdata?: string;
        iotjobsdataplane?: string;
        iotsecuretunneling?: string;
        iotsitewise?: string;
        iotthingsgraph?: string;
        iottwinmaker?: string;
        iotwireless?: string;
        ivs?: string;
        ivschat?: string;
        kafka?: string;
        kafkaconnect?: string;
        kendra?: string;
        keyspaces?: string;
        kinesis?: string;
        kinesisanalytics?: string;
        kinesisanalyticsv2?: string;
        kinesisvideo?: string;
        kinesisvideoarchivedmedia?: string;
        kinesisvideomedia?: string;
        kinesisvideosignaling?: string;
        kinesisvideosignalingchannels?: string;
        kms?: string;
        lakeformation?: string;
        lambda?: string;
        lex?: string;
        lexmodelbuilding?: string;
        lexmodelbuildingservice?: string;
        lexmodels?: string;
        lexmodelsv2?: string;
        lexruntime?: string;
        lexruntimeservice?: string;
        lexruntimev2?: string;
        lexv2models?: string;
        lexv2runtime?: string;
        licensemanager?: string;
        lightsail?: string;
        location?: string;
        locationservice?: string;
        logs?: string;
        lookoutequipment?: string;
        lookoutforvision?: string;
        lookoutmetrics?: string;
        lookoutvision?: string;
        machinelearning?: string;
        macie?: string;
        macie2?: string;
        managedblockchain?: string;
        managedgrafana?: string;
        marketplacecatalog?: string;
        marketplacecommerceanalytics?: string;
        marketplaceentitlement?: string;
        marketplaceentitlementservice?: string;
        marketplacemetering?: string;
        mediaconnect?: string;
        mediaconvert?: string;
        medialive?: string;
        mediapackage?: string;
        mediapackagevod?: string;
        mediastore?: string;
        mediastoredata?: string;
        mediatailor?: string;
        memorydb?: string;
        meteringmarketplace?: string;
        mgh?: string;
        mgn?: string;
        migrationhub?: string;
        migrationhubconfig?: string;
        migrationhubrefactorspaces?: string;
        migrationhubstrategy?: string;
        migrationhubstrategyrecommendations?: string;
        mobile?: string;
        mq?: string;
        msk?: string;
        mturk?: string;
        mwaa?: string;
        neptune?: string;
        networkfirewall?: string;
        networkmanager?: string;
        nimble?: string;
        nimblestudio?: string;
        oam?: string;
        opensearch?: string;
        opensearchserverless?: string;
        opensearchservice?: string;
        opsworks?: string;
        opsworkscm?: string;
        organizations?: string;
        outposts?: string;
        panorama?: string;
        personalize?: string;
        personalizeevents?: string;
        personalizeruntime?: string;
        pi?: string;
        pinpoint?: string;
        pinpointemail?: string;
        pinpointsmsvoice?: string;
        pipes?: string;
        polly?: string;
        pricing?: string;
        prometheus?: string;
        prometheusservice?: string;
        proton?: string;
        qldb?: string;
        qldbsession?: string;
        quicksight?: string;
        ram?: string;
        rbin?: string;
        rds?: string;
        rdsdata?: string;
        rdsdataservice?: string;
        recyclebin?: string;
        redshift?: string;
        redshiftdata?: string;
        redshiftdataapiservice?: string;
        redshiftserverless?: string;
        rekognition?: string;
        resiliencehub?: string;
        resourceexplorer2?: string;
        resourcegroups?: string;
        resourcegroupstagging?: string;
        resourcegroupstaggingapi?: string;
        robomaker?: string;
        rolesanywhere?: string;
        route53?: string;
        route53domains?: string;
        route53recoverycluster?: string;
        route53recoverycontrolconfig?: string;
        route53recoveryreadiness?: string;
        route53resolver?: string;
        rum?: string;
        s3?: string;
        s3api?: string;
        s3control?: string;
        s3outposts?: string;
        sagemaker?: string;
        sagemakera2iruntime?: string;
        sagemakeredge?: string;
        sagemakeredgemanager?: string;
        sagemakerfeaturestoreruntime?: string;
        sagemakerruntime?: string;
        savingsplans?: string;
        scheduler?: string;
        schemas?: string;
        sdb?: string;
        secretsmanager?: string;
        securityhub?: string;
        securitylake?: string;
        serverlessapplicationrepository?: string;
        serverlessapprepo?: string;
        serverlessrepo?: string;
        servicecatalog?: string;
        servicecatalogappregistry?: string;
        servicediscovery?: string;
        servicequotas?: string;
        ses?: string;
        sesv2?: string;
        sfn?: string;
        shield?: string;
        signer?: string;
        simpledb?: string;
        sms?: string;
        snowball?: string;
        snowdevicemanagement?: string;
        sns?: string;
        sqs?: string;
        ssm?: string;
        ssmcontacts?: string;
        ssmincidents?: string;
        sso?: string;
        ssoadmin?: string;
        ssooidc?: string;
        stepfunctions?: string;
        storagegateway?: string;
        sts?: string;
        support?: string;
        swf?: string;
        synthetics?: string;
        textract?: string;
        timestreamquery?: string;
        timestreamwrite?: string;
        transcribe?: string;
        transcribeservice?: string;
        transcribestreaming?: string;
        transcribestreamingservice?: string;
        transfer?: string;
        translate?: string;
        verifiedpermissions?: string;
        voiceid?: string;
        vpclattice?: string;
        waf?: string;
        wafregional?: string;
        wafv2?: string;
        wellarchitected?: string;
        wisdom?: string;
        workdocs?: string;
        worklink?: string;
        workmail?: string;
        workmailmessageflow?: string;
        workspaces?: string;
        workspacesweb?: string;
        xray?: string;
    }

    export interface IgnoreTags {
        keyPrefixes?: string[];
        keys?: string[];
    }

}

export namespace connect {
    export interface BotAssociationLexBot {
        /**
         * The Region that the Amazon Lex (V1) bot was created in. Defaults to current region.
         */
        lexRegion: string;
        /**
         * The name of the Amazon Lex (V1) bot.
         */
        name: string;
    }

    export interface GetBotAssociationLexBot {
        /**
         * Region that the Amazon Lex (V1) bot was created in.
         */
        lexRegion: string;
        /**
         * Name of the Amazon Lex (V1) bot.
         */
        name: string;
    }

    export interface GetHoursOfOperationConfig {
        /**
         * Day that the hours of operation applies to.
         */
        day: string;
        /**
         * End time block specifies the time that your contact center closes. The `endTime` is documented below.
         */
        endTimes: outputs.connect.GetHoursOfOperationConfigEndTime[];
        /**
         * Start time block specifies the time that your contact center opens. The `startTime` is documented below.
         */
        startTimes: outputs.connect.GetHoursOfOperationConfigStartTime[];
    }

    export interface GetHoursOfOperationConfigEndTime {
        /**
         * Hour of opening.
         */
        hours: number;
        /**
         * Minute of opening.
         */
        minutes: number;
    }

    export interface GetHoursOfOperationConfigStartTime {
        /**
         * Hour of opening.
         */
        hours: number;
        /**
         * Minute of opening.
         */
        minutes: number;
    }

    export interface GetInstanceStorageConfigStorageConfig {
        /**
         * A block that specifies the configuration of the Kinesis Firehose delivery stream. Documented below.
         */
        kinesisFirehoseConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisFirehoseConfig[];
        /**
         * A block that specifies the configuration of the Kinesis data stream. Documented below.
         */
        kinesisStreamConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisStreamConfig[];
        /**
         * A block that specifies the configuration of the Kinesis video stream. Documented below.
         */
        kinesisVideoStreamConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfig[];
        /**
         * A block that specifies the configuration of S3 Bucket. Documented below.
         */
        s3Configs: outputs.connect.GetInstanceStorageConfigStorageConfigS3Config[];
        /**
         * A valid storage type. Valid Values: `S3` | `KINESIS_VIDEO_STREAM` | `KINESIS_STREAM` | `KINESIS_FIREHOSE`.
         */
        storageType: string;
    }

    export interface GetInstanceStorageConfigStorageConfigKinesisFirehoseConfig {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        firehoseArn: string;
    }

    export interface GetInstanceStorageConfigStorageConfigKinesisStreamConfig {
        /**
         * The Amazon Resource Name (ARN) of the data stream.
         */
        streamArn: string;
    }

    export interface GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfig {
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig[];
        /**
         * The prefix of the video stream. Minimum length of `1`. Maximum length of `128`. When read from the state, the value returned is `<prefix>-connect-<connect_instance_alias>-contact-` since the API appends additional details to the `prefix`.
         */
        prefix: string;
        /**
         * The number of hours to retain the data in a data store associated with the stream. Minimum value of `0`. Maximum value of `87600`. A value of `0` indicates that the stream does not persist data.
         */
        retentionPeriodHours: number;
    }

    export interface GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }

    export interface GetInstanceStorageConfigStorageConfigS3Config {
        /**
         * The S3 bucket name.
         */
        bucketName: string;
        /**
         * The S3 bucket prefix.
         */
        bucketPrefix: string;
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigS3ConfigEncryptionConfig[];
    }

    export interface GetInstanceStorageConfigStorageConfigS3ConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }

    export interface GetQueueOutboundCallerConfig {
        /**
         * Specifies the caller ID name.
         */
        outboundCallerIdName: string;
        /**
         * Specifies the caller ID number.
         */
        outboundCallerIdNumberId: string;
        /**
         * Outbound whisper flow to be used during an outbound call.
         */
        outboundFlowId: string;
    }

    export interface GetQuickConnectQuickConnectConfig {
        /**
         * Phone configuration of the Quick Connect. This is returned only if `quickConnectType` is `PHONE_NUMBER`. The `phoneConfig` block is documented below.
         */
        phoneConfigs: outputs.connect.GetQuickConnectQuickConnectConfigPhoneConfig[];
        /**
         * Queue configuration of the Quick Connect. This is returned only if `quickConnectType` is `QUEUE`. The `queueConfig` block is documented below.
         */
        queueConfigs: outputs.connect.GetQuickConnectQuickConnectConfigQueueConfig[];
        /**
         * Configuration type of the Quick Connect. Valid values are `PHONE_NUMBER`, `QUEUE`, `USER`.
         */
        quickConnectType: string;
        /**
         * User configuration of the Quick Connect. This is returned only if `quickConnectType` is `USER`. The `userConfig` block is documented below.
         */
        userConfigs: outputs.connect.GetQuickConnectQuickConnectConfigUserConfig[];
    }

    export interface GetQuickConnectQuickConnectConfigPhoneConfig {
        /**
         * Phone number in in E.164 format.
         */
        phoneNumber: string;
    }

    export interface GetQuickConnectQuickConnectConfigQueueConfig {
        /**
         * Identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Identifier for the queue.
         */
        queueId: string;
    }

    export interface GetQuickConnectQuickConnectConfigUserConfig {
        /**
         * Identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Identifier for the user.
         */
        userId: string;
    }

    export interface GetRoutingProfileMediaConcurrency {
        /**
         * Channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Number of contacts an agent can have on a channel simultaneously. Valid Range for `VOICE`: Minimum value of 1. Maximum value of 1. Valid Range for `CHAT`: Minimum value of 1. Maximum value of 10. Valid Range for `TASK`: Minimum value of 1. Maximum value of 10.
         */
        concurrency: number;
    }

    export interface GetRoutingProfileQueueConfig {
        /**
         * Channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Delay, in seconds, that a contact should be in the queue before they are routed to an available agent
         */
        delay: number;
        /**
         * Order in which contacts are to be handled for the queue.
         */
        priority: number;
        /**
         * ARN for the queue.
         */
        queueArn: string;
        /**
         * Identifier for the queue.
         */
        queueId: string;
        /**
         * Name for the queue.
         */
        queueName: string;
    }

    export interface GetUserHierarchyGroupHierarchyPath {
        /**
         * Details of level five. See below.
         */
        levelFives: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelFife[];
        /**
         * Details of level four. See below.
         */
        levelFours: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelFour[];
        /**
         * Details of level one. See below.
         */
        levelOnes: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelOne[];
        /**
         * Details of level three. See below.
         */
        levelThrees: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelThree[];
        /**
         * Details of level two. See below.
         */
        levelTwos: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelTwo[];
    }

    export interface GetUserHierarchyGroupHierarchyPathLevelFife {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }

    export interface GetUserHierarchyGroupHierarchyPathLevelFour {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }

    export interface GetUserHierarchyGroupHierarchyPathLevelOne {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }

    export interface GetUserHierarchyGroupHierarchyPathLevelThree {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }

    export interface GetUserHierarchyGroupHierarchyPathLevelTwo {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }

    export interface GetUserHierarchyStructureHierarchyStructure {
        /**
         * Details of level five. See below.
         */
        levelFives: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelFife[];
        /**
         * Details of level four. See below.
         */
        levelFours: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelFour[];
        /**
         * Details of level one. See below.
         */
        levelOnes: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelOne[];
        /**
         * Details of level three. See below.
         */
        levelThrees: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelThree[];
        /**
         * Details of level two. See below.
         */
        levelTwos: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelTwo[];
    }

    export interface GetUserHierarchyStructureHierarchyStructureLevelFife {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface GetUserHierarchyStructureHierarchyStructureLevelFour {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface GetUserHierarchyStructureHierarchyStructureLevelOne {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface GetUserHierarchyStructureHierarchyStructureLevelThree {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface GetUserHierarchyStructureHierarchyStructureLevelTwo {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface GetUserIdentityInfo {
        /**
         * The email address.
         */
        email: string;
        /**
         * The first name.
         */
        firstName: string;
        /**
         * The last name.
         */
        lastName: string;
    }

    export interface GetUserPhoneConfig {
        /**
         * The After Call Work (ACW) timeout setting, in seconds.
         */
        afterContactWorkTimeLimit: number;
        /**
         * When Auto-Accept Call is enabled for an available agent, the agent connects to contacts automatically.
         */
        autoAccept: boolean;
        /**
         * The phone number for the user's desk phone.
         */
        deskPhoneNumber: string;
        /**
         * The phone type. Valid values are `DESK_PHONE` and `SOFT_PHONE`.
         */
        phoneType: string;
    }

    export interface HoursOfOperationConfig {
        /**
         * Specifies the day that the hours of operation applies to.
         */
        day: string;
        /**
         * A end time block specifies the time that your contact center closes. The `endTime` is documented below.
         */
        endTime: outputs.connect.HoursOfOperationConfigEndTime;
        /**
         * A start time block specifies the time that your contact center opens. The `startTime` is documented below.
         */
        startTime: outputs.connect.HoursOfOperationConfigStartTime;
    }

    export interface HoursOfOperationConfigEndTime {
        /**
         * Specifies the hour of closing.
         */
        hours: number;
        /**
         * Specifies the minute of closing.
         */
        minutes: number;
    }

    export interface HoursOfOperationConfigStartTime {
        /**
         * Specifies the hour of opening.
         */
        hours: number;
        /**
         * Specifies the minute of opening.
         */
        minutes: number;
    }

    export interface InstanceStorageConfigStorageConfig {
        /**
         * A block that specifies the configuration of the Kinesis Firehose delivery stream. Documented below.
         */
        kinesisFirehoseConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisFirehoseConfig;
        /**
         * A block that specifies the configuration of the Kinesis data stream. Documented below.
         */
        kinesisStreamConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisStreamConfig;
        /**
         * A block that specifies the configuration of the Kinesis video stream. Documented below.
         */
        kinesisVideoStreamConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisVideoStreamConfig;
        /**
         * A block that specifies the configuration of S3 Bucket. Documented below.
         */
        s3Config?: outputs.connect.InstanceStorageConfigStorageConfigS3Config;
        /**
         * A valid storage type. Valid Values: `S3` | `KINESIS_VIDEO_STREAM` | `KINESIS_STREAM` | `KINESIS_FIREHOSE`.
         */
        storageType: string;
    }

    export interface InstanceStorageConfigStorageConfigKinesisFirehoseConfig {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        firehoseArn: string;
    }

    export interface InstanceStorageConfigStorageConfigKinesisStreamConfig {
        /**
         * The Amazon Resource Name (ARN) of the data stream.
         */
        streamArn: string;
    }

    export interface InstanceStorageConfigStorageConfigKinesisVideoStreamConfig {
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfig: outputs.connect.InstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig;
        /**
         * The prefix of the video stream. Minimum length of `1`. Maximum length of `128`. When read from the state, the value returned is `<prefix>-connect-<connect_instance_alias>-contact-` since the API appends additional details to the `prefix`.
         */
        prefix: string;
        /**
         * The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. Minimum value of `0`. Maximum value of `87600`. A value of `0`, indicates that the stream does not persist data.
         */
        retentionPeriodHours: number;
    }

    export interface InstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }

    export interface InstanceStorageConfigStorageConfigS3Config {
        /**
         * The S3 bucket name.
         */
        bucketName: string;
        /**
         * The S3 bucket prefix.
         */
        bucketPrefix: string;
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfig?: outputs.connect.InstanceStorageConfigStorageConfigS3ConfigEncryptionConfig;
    }

    export interface InstanceStorageConfigStorageConfigS3ConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }

    export interface PhoneNumberStatus {
        /**
         * The status message.
         */
        message: string;
        /**
         * The status of the phone number. Valid Values: `CLAIMED` | `IN_PROGRESS` | `FAILED`.
         */
        status: string;
    }

    export interface QueueOutboundCallerConfig {
        /**
         * Specifies the caller ID name.
         */
        outboundCallerIdName?: string;
        /**
         * Specifies the caller ID number.
         */
        outboundCallerIdNumberId?: string;
        /**
         * Specifies outbound whisper flow to be used during an outbound call.
         */
        outboundFlowId?: string;
    }

    export interface QuickConnectQuickConnectConfig {
        /**
         * Specifies the phone configuration of the Quick Connect. This is required only if `quickConnectType` is `PHONE_NUMBER`. The `phoneConfig` block is documented below.
         */
        phoneConfigs?: outputs.connect.QuickConnectQuickConnectConfigPhoneConfig[];
        /**
         * Specifies the queue configuration of the Quick Connect. This is required only if `quickConnectType` is `QUEUE`. The `queueConfig` block is documented below.
         */
        queueConfigs?: outputs.connect.QuickConnectQuickConnectConfigQueueConfig[];
        /**
         * Specifies the configuration type of the quick connect. valid values are `PHONE_NUMBER`, `QUEUE`, `USER`.
         */
        quickConnectType: string;
        /**
         * Specifies the user configuration of the Quick Connect. This is required only if `quickConnectType` is `USER`. The `userConfig` block is documented below.
         */
        userConfigs?: outputs.connect.QuickConnectQuickConnectConfigUserConfig[];
    }

    export interface QuickConnectQuickConnectConfigPhoneConfig {
        /**
         * Specifies the phone number in in E.164 format.
         */
        phoneNumber: string;
    }

    export interface QuickConnectQuickConnectConfigQueueConfig {
        /**
         * Specifies the identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Specifies the identifier for the queue.
         */
        queueId: string;
    }

    export interface QuickConnectQuickConnectConfigUserConfig {
        /**
         * Specifies the identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Specifies the identifier for the user.
         */
        userId: string;
    }

    export interface RoutingProfileMediaConcurrency {
        /**
         * Specifies the channels that agents can handle in the Contact Control Panel (CCP). Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Specifies the number of contacts an agent can have on a channel simultaneously. Valid Range for `VOICE`: Minimum value of 1. Maximum value of 1. Valid Range for `CHAT`: Minimum value of 1. Maximum value of 10. Valid Range for `TASK`: Minimum value of 1. Maximum value of 10.
         */
        concurrency: number;
    }

    export interface RoutingProfileQueueConfig {
        /**
         * Specifies the channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Specifies the delay, in seconds, that a contact should be in the queue before they are routed to an available agent
         */
        delay: number;
        /**
         * Specifies the order in which contacts are to be handled for the queue.
         */
        priority: number;
        /**
         * ARN for the queue.
         */
        queueArn: string;
        /**
         * Specifies the identifier for the queue.
         */
        queueId: string;
        /**
         * Name for the queue.
         */
        queueName: string;
    }

    export interface UserHierarchyGroupHierarchyPath {
        /**
         * A block that defines the details of level five. The level block is documented below.
         */
        levelFives: outputs.connect.UserHierarchyGroupHierarchyPathLevelFife[];
        /**
         * A block that defines the details of level four. The level block is documented below.
         */
        levelFours: outputs.connect.UserHierarchyGroupHierarchyPathLevelFour[];
        /**
         * A block that defines the details of level one. The level block is documented below.
         */
        levelOnes: outputs.connect.UserHierarchyGroupHierarchyPathLevelOne[];
        /**
         * A block that defines the details of level three. The level block is documented below.
         */
        levelThrees: outputs.connect.UserHierarchyGroupHierarchyPathLevelThree[];
        /**
         * A block that defines the details of level two. The level block is documented below.
         */
        levelTwos: outputs.connect.UserHierarchyGroupHierarchyPathLevelTwo[];
    }

    export interface UserHierarchyGroupHierarchyPathLevelFife {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }

    export interface UserHierarchyGroupHierarchyPathLevelFour {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }

    export interface UserHierarchyGroupHierarchyPathLevelOne {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }

    export interface UserHierarchyGroupHierarchyPathLevelThree {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }

    export interface UserHierarchyGroupHierarchyPathLevelTwo {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }

    export interface UserHierarchyStructureHierarchyStructure {
        /**
         * A block that defines the details of level five. The level block is documented below.
         *
         * Each level block supports the following arguments:
         */
        levelFive: outputs.connect.UserHierarchyStructureHierarchyStructureLevelFive;
        /**
         * A block that defines the details of level four. The level block is documented below.
         */
        levelFour: outputs.connect.UserHierarchyStructureHierarchyStructureLevelFour;
        /**
         * A block that defines the details of level one. The level block is documented below.
         */
        levelOne: outputs.connect.UserHierarchyStructureHierarchyStructureLevelOne;
        /**
         * A block that defines the details of level three. The level block is documented below.
         */
        levelThree: outputs.connect.UserHierarchyStructureHierarchyStructureLevelThree;
        /**
         * A block that defines the details of level two. The level block is documented below.
         */
        levelTwo: outputs.connect.UserHierarchyStructureHierarchyStructureLevelTwo;
    }

    export interface UserHierarchyStructureHierarchyStructureLevelFive {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * The name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface UserHierarchyStructureHierarchyStructureLevelFour {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * The name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface UserHierarchyStructureHierarchyStructureLevelOne {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * The name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface UserHierarchyStructureHierarchyStructureLevelThree {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * The name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface UserHierarchyStructureHierarchyStructureLevelTwo {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * The name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }

    export interface UserIdentityInfo {
        /**
         * The email address. If you are using SAML for identity management and include this parameter, an error is returned. Note that updates to the `email` is supported. From the [UpdateUserIdentityInfo API documentation](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateUserIdentityInfo.html) it is strongly recommended to limit who has the ability to invoke `UpdateUserIdentityInfo`. Someone with that ability can change the login credentials of other users by changing their email address. This poses a security risk to your organization. They can change the email address of a user to the attacker's email address, and then reset the password through email. For more information, see [Best Practices for Security Profiles](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-best-practices.html) in the Amazon Connect Administrator Guide.
         */
        email?: string;
        /**
         * The first name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
         */
        firstName?: string;
        /**
         * The last name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
         */
        lastName?: string;
    }

    export interface UserPhoneConfig {
        /**
         * The After Call Work (ACW) timeout setting, in seconds. Minimum value of 0.
         */
        afterContactWorkTimeLimit?: number;
        /**
         * When Auto-Accept Call is enabled for an available agent, the agent connects to contacts automatically.
         */
        autoAccept?: boolean;
        /**
         * The phone number for the user's desk phone. Required if `phoneType` is set as `DESK_PHONE`.
         */
        deskPhoneNumber?: string;
        /**
         * The phone type. Valid values are `DESK_PHONE` and `SOFT_PHONE`.
         */
        phoneType: string;
    }

}

export namespace costexplorer {
    export interface AnomalySubscriptionSubscriber {
        /**
         * The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
         */
        address: string;
        /**
         * The type of subscription. Valid Values: `SNS` | `EMAIL`.
         */
        type: string;
    }

    export interface AnomalySubscriptionThresholdExpression {
        /**
         * Return results that match both Dimension objects.
         */
        ands?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAnd[];
        /**
         * Configuration block for the filter that's based on  values. See Cost Category below.
         */
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionCostCategory;
        /**
         * Configuration block for the specific Dimension to use for.
         */
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionDimension;
        /**
         * Return results that match both Dimension object.
         */
        not?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNot;
        /**
         * Return results that match both Dimension object.
         */
        ors?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOr[];
        /**
         * Configuration block for the specific Tag to use for. See Tags below.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionTags;
    }

    export interface AnomalySubscriptionThresholdExpressionAnd {
        /**
         * Configuration block for the filter that's based on  values. See Cost Category below.
         */
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndCostCategory;
        /**
         * Configuration block for the specific Dimension to use for.
         */
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndTags;
    }

    export interface AnomalySubscriptionThresholdExpressionAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionNot {
        /**
         * Configuration block for the filter that's based on  values. See Cost Category below.
         */
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotCostCategory;
        /**
         * Configuration block for the specific Dimension to use for.
         */
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotTags;
    }

    export interface AnomalySubscriptionThresholdExpressionNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionOr {
        /**
         * Configuration block for the filter that's based on  values. See Cost Category below.
         */
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrCostCategory;
        /**
         * Configuration block for the specific Dimension to use for.
         */
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrTags;
    }

    export interface AnomalySubscriptionThresholdExpressionOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface AnomalySubscriptionThresholdExpressionTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRule {
        /**
         * Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
         */
        inheritedValue?: outputs.costexplorer.CostCategoryRuleInheritedValue;
        /**
         * Configuration block for the `Expression` object used to categorize costs. See below.
         */
        rule?: outputs.costexplorer.CostCategoryRuleRule;
        /**
         * You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
         */
        type?: string;
        /**
         * Default value for the cost category.
         */
        value?: string;
    }

    export interface CostCategoryRuleInheritedValue {
        /**
         * Key to extract cost category values.
         */
        dimensionKey?: string;
        /**
         * Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
         */
        dimensionName?: string;
    }

    export interface CostCategoryRuleRule {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands?: outputs.costexplorer.CostCategoryRuleRuleAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.CostCategoryRuleRuleDimension;
        /**
         * Return results that match both `Dimension` object.
         */
        not?: outputs.costexplorer.CostCategoryRuleRuleNot;
        /**
         * Return results that match both `Dimension` object.
         */
        ors?: outputs.costexplorer.CostCategoryRuleRuleOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleTags;
    }

    export interface CostCategoryRuleRuleAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleAndCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.CostCategoryRuleRuleAndDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleAndTags;
    }

    export interface CostCategoryRuleRuleAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleNotCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.CostCategoryRuleRuleNotDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleNotTags;
    }

    export interface CostCategoryRuleRuleNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleOrCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.CostCategoryRuleRuleOrDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleOrTags;
    }

    export interface CostCategoryRuleRuleOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategoryRuleRuleTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface CostCategorySplitChargeRule {
        /**
         * Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
         */
        method: string;
        /**
         * Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
         */
        parameters?: outputs.costexplorer.CostCategorySplitChargeRuleParameter[];
        /**
         * Cost Category value that you want to split.
         */
        source: string;
        /**
         * Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
         */
        targets: string[];
    }

    export interface CostCategorySplitChargeRuleParameter {
        /**
         * Parameter type.
         */
        type?: string;
        /**
         * Parameter values.
         */
        values?: string[];
    }

    export interface GetCostCategoryRule {
        /**
         * Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
         */
        inheritedValues: outputs.costexplorer.GetCostCategoryRuleInheritedValue[];
        /**
         * Configuration block for the `Expression` object used to categorize costs. See below.
         */
        rules: outputs.costexplorer.GetCostCategoryRuleRule[];
        /**
         * Parameter type.
         */
        type: string;
        /**
         * Default value for the cost category.
         */
        value: string;
    }

    export interface GetCostCategoryRuleInheritedValue {
        /**
         * Key to extract cost category values.
         */
        dimensionKey: string;
        /**
         * Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
         */
        dimensionName: string;
    }

    export interface GetCostCategoryRuleRule {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands: outputs.costexplorer.GetCostCategoryRuleRuleAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleDimension[];
        /**
         * Return results that do not match the `Dimension` object.
         */
        nots: outputs.costexplorer.GetCostCategoryRuleRuleNot[];
        /**
         * Return results that match either `Dimension` object.
         */
        ors: outputs.costexplorer.GetCostCategoryRuleRuleOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleTag[];
    }

    export interface GetCostCategoryRuleRuleAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleAndCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleAndDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleAndTag[];
    }

    export interface GetCostCategoryRuleRuleAndCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleAndDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleAndTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleNotCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleNotDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleNotTag[];
    }

    export interface GetCostCategoryRuleRuleNotCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleNotDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleNotTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleOrCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleOrDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleOrTag[];
    }

    export interface GetCostCategoryRuleRuleOrCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleOrDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleOrTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategoryRuleRuleTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetCostCategorySplitChargeRule {
        /**
         * Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
         */
        method: string;
        /**
         * Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
         */
        parameters: outputs.costexplorer.GetCostCategorySplitChargeRuleParameter[];
        /**
         * Cost Category value that you want to split.
         */
        source: string;
        /**
         * Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
         */
        targets: string[];
    }

    export interface GetCostCategorySplitChargeRuleParameter {
        /**
         * Parameter type.
         */
        type: string;
        /**
         * Parameter values.
         */
        values: string[];
    }

    export interface GetTagsFilter {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands?: outputs.costexplorer.GetTagsFilterAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.GetTagsFilterCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.GetTagsFilterDimension;
        /**
         * Return results that match both `Dimension` object.
         */
        not?: outputs.costexplorer.GetTagsFilterNot;
        /**
         * Return results that match both `Dimension` object.
         */
        ors?: outputs.costexplorer.GetTagsFilterOr[];
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterTags;
    }

    export interface GetTagsFilterAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.GetTagsFilterAndCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.GetTagsFilterAndDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterAndTags;
    }

    export interface GetTagsFilterAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterAndTags {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.GetTagsFilterNotCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.GetTagsFilterNotDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterNotTags;
    }

    export interface GetTagsFilterNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterNotTags {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.GetTagsFilterOrCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.GetTagsFilterOrDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterOrTags;
    }

    export interface GetTagsFilterOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterOrTags {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsFilterTags {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }

    export interface GetTagsSortBy {
        /**
         * key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
         */
        key?: string;
        /**
         * order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
         */
        sortOrder?: string;
    }

    export interface GetTagsTimePeriod {
        /**
         * Beginning of the time period.
         */
        end: string;
        /**
         * End of the time period.
         */
        start: string;
    }

}

export namespace datapipeline {
    export interface GetPipelineDefinitionParameterObject {
        attributes: outputs.datapipeline.GetPipelineDefinitionParameterObjectAttribute[];
        /**
         * ID of the object.
         */
        id: string;
    }

    export interface GetPipelineDefinitionParameterObjectAttribute {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }

    export interface GetPipelineDefinitionParameterValue {
        /**
         * ID of the object.
         */
        id: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }

    export interface GetPipelineDefinitionPipelineObject {
        /**
         * Key-value pairs that define the properties of the object. See below
         */
        fields?: outputs.datapipeline.GetPipelineDefinitionPipelineObjectField[];
        /**
         * ID of the object.
         */
        id: string;
        /**
         * ARN of the storage connector.
         */
        name: string;
    }

    export interface GetPipelineDefinitionPipelineObjectField {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as the identifier of another object
         */
        refValue: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }

    export interface PipelineDefinitionParameterObject {
        /**
         * Configuration block for attributes of the parameter object. See below
         */
        attributes?: outputs.datapipeline.PipelineDefinitionParameterObjectAttribute[];
        /**
         * ID of the parameter object.
         */
        id: string;
    }

    export interface PipelineDefinitionParameterObjectAttribute {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }

    export interface PipelineDefinitionParameterValue {
        /**
         * ID of the parameter value.
         */
        id: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }

    export interface PipelineDefinitionPipelineObject {
        /**
         * Configuration block for Key-value pairs that define the properties of the object. See below
         */
        fields?: outputs.datapipeline.PipelineDefinitionPipelineObjectField[];
        /**
         * ID of the object.
         */
        id: string;
        /**
         * ARN of the storage connector.
         */
        name: string;
    }

    export interface PipelineDefinitionPipelineObjectField {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as the identifier of another object
         */
        refValue?: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue?: string;
    }

}

export namespace datasync {
    export interface EfsLocationEc2Config {
        /**
         * List of Amazon Resource Names (ARNs) of the EC2 Security Groups that are associated with the EFS Mount Target.
         */
        securityGroupArns: string[];
        /**
         * Amazon Resource Name (ARN) of the EC2 Subnet that is associated with the EFS Mount Target.
         */
        subnetArn: string;
    }

    export interface FsxOpenZfsFileSystemProtocol {
        /**
         * Represents the Network File System (NFS) protocol that DataSync uses to access your FSx for OpenZFS file system. See below.
         */
        nfs: outputs.datasync.FsxOpenZfsFileSystemProtocolNfs;
    }

    export interface FsxOpenZfsFileSystemProtocolNfs {
        /**
         * Represents the mount options that are available for DataSync to access an NFS location. See below.
         */
        mountOptions: outputs.datasync.FsxOpenZfsFileSystemProtocolNfsMountOptions;
    }

    export interface FsxOpenZfsFileSystemProtocolNfsMountOptions {
        /**
         * The specific NFS version that you want DataSync to use for mounting your NFS share. Valid values: `AUTOMATIC`, `NFS3`, `NFS4_0` and `NFS4_1`. Default: `AUTOMATIC`
         */
        version?: string;
    }

    export interface LocationHdfsNameNode {
        /**
         * The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.
         */
        hostname: string;
        /**
         * The port that the NameNode uses to listen to client requests.
         */
        port: number;
    }

    export interface LocationHdfsQopConfiguration {
        /**
         * The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your dfs.data.transfer.protection setting in the hdfs-site.xml file on your Hadoop cluster. Valid values are `DISABLED`, `AUTHENTICATION`, `INTEGRITY` and `PRIVACY`.
         */
        dataTransferProtection?: string;
        /**
         * The RPC protection setting configured on the HDFS cluster. This setting corresponds to your hadoop.rpc.protection setting in your core-site.xml file on your Hadoop cluster. Valid values are `DISABLED`, `AUTHENTICATION`, `INTEGRITY` and `PRIVACY`.
         */
        rpcProtection?: string;
    }

    export interface LocationSmbMountOptions {
        /**
         * The specific SMB version that you want DataSync to use for mounting your SMB share. Valid values: `AUTOMATIC`, `SMB2`, and `SMB3`. Default: `AUTOMATIC`
         */
        version?: string;
    }

    export interface NfsLocationMountOptions {
        /**
         * The specific NFS version that you want DataSync to use for mounting your NFS share. Valid values: `AUTOMATIC`, `NFS3`, `NFS4_0` and `NFS4_1`. Default: `AUTOMATIC`
         */
        version?: string;
    }

    export interface NfsLocationOnPremConfig {
        /**
         * List of Amazon Resource Names (ARNs) of the DataSync Agents used to connect to the NFS server.
         */
        agentArns: string[];
    }

    export interface S3LocationS3Config {
        /**
         * ARN of the IAM Role used to connect to the S3 Bucket.
         */
        bucketAccessRoleArn: string;
    }

    export interface TaskExcludes {
        /**
         * The type of filter rule to apply. Valid values: `SIMPLE_PATTERN`.
         */
        filterType?: string;
        /**
         * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: `/folder1|/folder2`
         */
        value?: string;
    }

    export interface TaskIncludes {
        /**
         * The type of filter rule to apply. Valid values: `SIMPLE_PATTERN`.
         */
        filterType?: string;
        /**
         * A single filter string that consists of the patterns to include. The patterns are delimited by "|" (that is, a pipe), for example: `/folder1|/folder2`
         */
        value?: string;
    }

    export interface TaskOptions {
        /**
         * A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to `BEST_EFFORT`, the DataSync Task attempts to preserve the original (that is, the version before sync `PREPARING` phase) `atime` attribute on all source files. Valid values: `BEST_EFFORT`, `NONE`. Default: `BEST_EFFORT`.
         */
        atime?: string;
        /**
         * Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to `1048576`. Value values: `-1` or greater. Default: `-1` (unlimited).
         */
        bytesPerSecond?: number;
        /**
         * Group identifier of the file's owners. Valid values: `BOTH`, `INT_VALUE`, `NAME`, `NONE`. Default: `INT_VALUE` (preserve integer value of the ID).
         */
        gid?: string;
        /**
         * Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: `OFF`, `BASIC`, `TRANSFER`. Default: `OFF`.
         */
        logLevel?: string;
        /**
         * A file metadata that indicates the last time a file was modified (written to) before the sync `PREPARING` phase. Value values: `NONE`, `PRESERVE`. Default: `PRESERVE`.
         */
        mtime?: string;
        /**
         * Specifies whether object tags are maintained when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the NONE value. Valid values: `PRESERVE`, `NONE`. Default value: `PRESERVE`.
         */
        objectTags?: string;
        /**
         * Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: `ALWAYS`, `NEVER`. Default: `ALWAYS`.
         */
        overwriteMode?: string;
        /**
         * Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: `NONE`, `PRESERVE`. Default: `PRESERVE`.
         */
        posixPermissions?: string;
        /**
         * Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: `PRESERVE`, `REMOVE`. Default: `PRESERVE`.
         */
        preserveDeletedFiles?: string;
        /**
         * Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task can’t sync the actual contents of such devices, because many of the devices are non-terminal and don’t return an end of file (EOF) marker. Valid values: `NONE`, `PRESERVE`. Default: `NONE` (ignore special devices).
         */
        preserveDevices?: string;
        /**
         * Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: `NONE`, `OWNER_DACL`, `OWNER_DACL_SACL`. Default: `OWNER_DACL`.
         */
        securityDescriptorCopyFlags: string;
        /**
         * Determines whether tasks should be queued before executing the tasks. Valid values: `ENABLED`, `DISABLED`. Default `ENABLED`.
         */
        taskQueueing?: string;
        /**
         * Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: `CHANGED`, `ALL`. Default: `CHANGED`
         */
        transferMode?: string;
        /**
         * User identifier of the file's owners. Valid values: `BOTH`, `INT_VALUE`, `NAME`, `NONE`. Default: `INT_VALUE` (preserve integer value of the ID).
         */
        uid?: string;
        /**
         * Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: `NONE`, `POINT_IN_TIME_CONSISTENT`, `ONLY_FILES_TRANSFERRED`. Default: `POINT_IN_TIME_CONSISTENT`.
         */
        verifyMode?: string;
    }

    export interface TaskSchedule {
        /**
         * Specifies the schedule you want your task to use for repeated executions. For more information, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html).
         */
        scheduleExpression: string;
    }

}

export namespace dax {
    export interface ClusterNode {
        address: string;
        availabilityZone: string;
        id: string;
        /**
         * The port used by the configuration endpoint
         */
        port: number;
    }

    export interface ClusterServerSideEncryption {
        /**
         * Whether to enable encryption at rest. Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface ParameterGroupParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value for the parameter.
         */
        value: string;
    }

}

export namespace devicefarm {
    export interface DevicePoolRule {
        /**
         * The rule's stringified attribute. Valid values are: `APPIUM_VERSION`, `ARN`, `AVAILABILITY`, `FLEET_TYPE`, `FORM_FACTOR`, `INSTANCE_ARN`, `INSTANCE_LABELS`, `MANUFACTURER`, `MODEL`, `OS_VERSION`, `PLATFORM`, `REMOTE_ACCESS_ENABLED`, `REMOTE_DEBUG_ENABLED`.
         */
        attribute?: string;
        /**
         * Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute. Valid values are: `EQUALS`, `NOT_IN`, `IN`, `GREATER_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN`, `LESS_THAN_OR_EQUALS`, `CONTAINS`.
         */
        operator?: string;
        /**
         * The rule's value.
         */
        value?: string;
    }

    export interface TestGridProjectVpcConfig {
        /**
         * A list of VPC security group IDs in your Amazon VPC.
         */
        securityGroupIds: string[];
        /**
         * A list of VPC subnet IDs in your Amazon VPC.
         */
        subnetIds: string[];
        /**
         * The ID of the Amazon VPC.
         */
        vpcId: string;
    }

}

export namespace directconnect {
    export interface GetRouterConfigurationRouter {
        /**
         * Router platform
         */
        platform: string;
        /**
         * ID of the Router Type. For example: `CiscoSystemsInc-2900SeriesRouters-IOS124`
         *
         * There is currently no AWS API to retrieve the full list of `routerTypeIdentifier` values. Here is a list of known `RouterType` objects that can be used:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        routerTypeIdentifier: string;
        /**
         * Router operating system
         */
        software: string;
        /**
         * Router vendor
         */
        vendor: string;
        /**
         * Router XSLT Template Name
         */
        xsltTemplateName: string;
        xsltTemplateNameForMacSec: string;
    }

}

export namespace directoryservice {
    export interface DirectoryConnectSettings {
        availabilityZones: string[];
        /**
         * The IP addresses of the AD Connector servers.
         */
        connectIps: string[];
        /**
         * The DNS IP addresses of the domain to connect to.
         */
        customerDnsIps: string[];
        /**
         * The username corresponding to the password provided.
         */
        customerUsername: string;
        /**
         * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC that the directory is in.
         */
        vpcId: string;
    }

    export interface DirectoryVpcSettings {
        availabilityZones: string[];
        /**
         * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC that the directory is in.
         */
        vpcId: string;
    }

    export interface GetDirectoryConnectSetting {
        availabilityZones: string[];
        /**
         * IP addresses of the AD Connector servers.
         */
        connectIps: string[];
        /**
         * DNS IP addresses of the domain to connect to.
         */
        customerDnsIps: string[];
        /**
         * Username corresponding to the password provided.
         */
        customerUsername: string;
        /**
         * Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * ID of the VPC that the connector is in.
         */
        vpcId: string;
    }

    export interface GetDirectoryRadiusSetting {
        /**
         * The protocol specified for your RADIUS endpoints.
         */
        authenticationProtocol: string;
        /**
         * Display label.
         */
        displayLabel: string;
        /**
         * Port that your RADIUS server is using for communications.
         */
        radiusPort: number;
        /**
         * Maximum number of times that communication with the RADIUS server is attempted.
         */
        radiusRetries: number;
        /**
         * Set of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.
         */
        radiusServers: string[];
        /**
         * Amount of time, in seconds, to wait for the RADIUS server to respond.
         */
        radiusTimeout: number;
        /**
         * Not currently used.
         */
        useSameUsername: boolean;
    }

    export interface GetDirectoryVpcSetting {
        availabilityZones: string[];
        /**
         * Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * ID of the VPC that the connector is in.
         */
        vpcId: string;
    }

    export interface ServiceRegionVpcSettings {
        /**
         * The identifiers of the subnets for the directory servers.
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC in which to create the directory.
         */
        vpcId: string;
    }

    export interface SharedDirectoryTarget {
        /**
         * Identifier of the directory consumer account.
         */
        id: string;
        /**
         * Type of identifier to be used in the `id` field. Valid value is `ACCOUNT`. Default is `ACCOUNT`.
         */
        type?: string;
    }

}

export namespace dlm {
    export interface LifecyclePolicyPolicyDetails {
        /**
         * The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `action` configuration block.
         */
        action?: outputs.dlm.LifecyclePolicyPolicyDetailsAction;
        /**
         * The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `eventSource` configuration block.
         */
        eventSource?: outputs.dlm.LifecyclePolicyPolicyDetailsEventSource;
        /**
         * A set of optional parameters for snapshot and AMI lifecycle policies. See the `parameters` configuration block.
         */
        parameters?: outputs.dlm.LifecyclePolicyPolicyDetailsParameters;
        /**
         * The valid target resource types and actions a policy can manage. Specify `EBS_SNAPSHOT_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify `IMAGE_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify `EVENT_BASED_POLICY` to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is `EBS_SNAPSHOT_MANAGEMENT`.
         */
        policyType?: string;
        /**
         * The location of the resources to backup. If the source resources are located in an AWS Region, specify `CLOUD`. If the source resources are located on an Outpost in your account, specify `OUTPOST`. If you specify `OUTPOST`, Amazon Data Lifecycle Manager backs up all resources of the specified type with matching target tags across all of the Outposts in your account. Valid values are `CLOUD` and `OUTPOST`.
         */
        resourceLocations: string;
        /**
         * A list of resource types that should be targeted by the lifecycle policy. Valid values are `VOLUME` and `INSTANCE`.
         */
        resourceTypes?: string[];
        /**
         * See the `schedule` configuration block.
         */
        schedules?: outputs.dlm.LifecyclePolicyPolicyDetailsSchedule[];
        /**
         * A map of tag keys and their values. Any resources that match the `resourceTypes` and are tagged with _any_ of these tags will be targeted.
         *
         * > Note: You cannot have overlapping lifecycle policies that share the same `targetTags`. This provider is unable to detect this at plan time but it will fail during apply.
         */
        targetTags?: {[key: string]: string};
    }

    export interface LifecyclePolicyPolicyDetailsAction {
        /**
         * The rule for copying shared snapshots across Regions. See the `crossRegionCopy` configuration block.
         */
        crossRegionCopies: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopy[];
        /**
         * A descriptive name for the action.
         */
        name: string;
    }

    export interface LifecyclePolicyPolicyDetailsActionCrossRegionCopy {
        /**
         * The encryption settings for the copied snapshot. See the `encryptionConfiguration` block. Max of 1 per action.
         */
        encryptionConfiguration: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration;
        /**
         * Specifies the retention rule for cross-Region snapshot copies. See the `retainRule` block. Max of 1 per action.
         */
        retainRule?: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule;
        /**
         * The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
         */
        target: string;
    }

    export interface LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
         */
        cmkArn?: string;
        /**
         * To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled.
         */
        encrypted?: boolean;
    }

    export interface LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule {
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit: string;
    }

    export interface LifecyclePolicyPolicyDetailsEventSource {
        /**
         * A set of optional parameters for snapshot and AMI lifecycle policies. See the `parameters` configuration block.
         */
        parameters: outputs.dlm.LifecyclePolicyPolicyDetailsEventSourceParameters;
        /**
         * The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are `MANAGED_CWE`.
         */
        type: string;
    }

    export interface LifecyclePolicyPolicyDetailsEventSourceParameters {
        /**
         * The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account.
         */
        descriptionRegex: string;
        /**
         * The type of event. Currently, only `shareSnapshot` events are supported.
         */
        eventType: string;
        /**
         * The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account.
         */
        snapshotOwners: string[];
    }

    export interface LifecyclePolicyPolicyDetailsParameters {
        /**
         * Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is `false`.
         */
        excludeBootVolume?: boolean;
        /**
         * Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. `true` indicates that targeted instances are not rebooted when the policy runs. `false` indicates that target instances are rebooted when the policy runs. The default is `true` (instances are not rebooted).
         */
        noReboot?: boolean;
    }

    export interface LifecyclePolicyPolicyDetailsSchedule {
        /**
         * Copy all user-defined tags on a source volume to snapshots of the volume created by this policy.
         */
        copyTags: boolean;
        /**
         * See the `createRule` block. Max of 1 per schedule.
         */
        createRule: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCreateRule;
        /**
         * See the `crossRegionCopyRule` block. Max of 3 per schedule.
         */
        crossRegionCopyRules?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule[];
        /**
         * See the `deprecateRule` block. Max of 1 per schedule.
         */
        deprecateRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleDeprecateRule;
        /**
         * See the `fastRestoreRule` block. Max of 1 per schedule.
         */
        fastRestoreRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleFastRestoreRule;
        /**
         * A descriptive name for the action.
         */
        name: string;
        /**
         * Specifies the retention rule for cross-Region snapshot copies. See the `retainRule` block. Max of 1 per action.
         */
        retainRule: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleRetainRule;
        /**
         * See the `shareRule` block. Max of 1 per schedule.
         */
        shareRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleShareRule;
        /**
         * A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these.
         */
        tagsToAdd?: {[key: string]: string};
        /**
         * A map of tag keys and variable values, where the values are determined when the policy is executed. Only `$(instance-id)` or `$(timestamp)` are valid values. Can only be used when `resourceTypes` is `INSTANCE`.
         */
        variableTags?: {[key: string]: string};
    }

    export interface LifecyclePolicyPolicyDetailsScheduleCreateRule {
        /**
         * The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year.
         */
        cronExpression?: string;
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval?: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit: string;
        /**
         * Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify `CLOUD`. To create snapshots on the same Outpost as the source resource, specify `OUTPOST_LOCAL`. If you omit this parameter, `CLOUD` is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are `CLOUD` and `OUTPOST_LOCAL`.
         */
        location: string;
        /**
         * A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1.
         */
        times: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule {
        /**
         * The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
         */
        cmkArn?: string;
        /**
         * Copy all user-defined tags on a source volume to snapshots of the volume created by this policy.
         */
        copyTags?: boolean;
        /**
         * See the `deprecateRule` block. Max of 1 per schedule.
         */
        deprecateRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule;
        /**
         * To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled.
         */
        encrypted: boolean;
        /**
         * Specifies the retention rule for cross-Region snapshot copies. See the `retainRule` block. Max of 1 per action.
         */
        retainRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule;
        /**
         * The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
         */
        target: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule {
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule {
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleDeprecateRule {
        /**
         * Specifies the number of oldest AMIs to deprecate. Must be an integer between `1` and `1000`.
         */
        count?: number;
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval?: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit?: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleFastRestoreRule {
        /**
         * The Availability Zones in which to enable fast snapshot restore.
         */
        availabilityZones: string[];
        /**
         * Specifies the number of oldest AMIs to deprecate. Must be an integer between `1` and `1000`.
         */
        count?: number;
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval?: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit?: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleRetainRule {
        /**
         * Specifies the number of oldest AMIs to deprecate. Must be an integer between `1` and `1000`.
         */
        count?: number;
        /**
         * How often this lifecycle policy should be evaluated. `1`, `2`,`3`,`4`,`6`,`8`,`12` or `24` are valid values.
         */
        interval?: number;
        /**
         * The unit for how often the lifecycle policy should be evaluated. `HOURS` is currently the only allowed value and also the default value.
         */
        intervalUnit?: string;
    }

    export interface LifecyclePolicyPolicyDetailsScheduleShareRule {
        /**
         * The IDs of the AWS accounts with which to share the snapshots.
         */
        targetAccounts: string[];
        unshareInterval?: number;
        unshareIntervalUnit?: string;
    }

}

export namespace dms {
    export interface EndpointElasticsearchSettings {
        /**
         * Endpoint for the OpenSearch cluster.
         */
        endpointUri: string;
        /**
         * Maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster. Default is `300`.
         */
        errorRetryDuration?: number;
        /**
         * Maximum percentage of records that can fail to be written before a full load operation stops. Default is `10`.
         */
        fullLoadErrorPercentage?: number;
        /**
         * ARN of the IAM Role with permissions to write to the OpenSearch cluster.
         */
        serviceAccessRoleArn: string;
    }

    export interface EndpointKafkaSettings {
        /**
         * Kafka broker location. Specify in the form broker-hostname-or-ip:port.
         */
        broker: string;
        /**
         * Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. Default is `false`.
         */
        includeControlDetails?: boolean;
        /**
         * Include NULL and empty columns for records migrated to the endpoint. Default is `false`.
         */
        includeNullAndEmpty?: boolean;
        /**
         * Shows the partition value within the Kafka message output unless the partition type is `schema-table-type`. Default is `false`.
         */
        includePartitionValue?: boolean;
        /**
         * Includes any data definition language (DDL) operations that change the table in the control data, such as `rename-table`, `drop-table`, `add-column`, `drop-column`, and `rename-column`. Default is `false`.
         */
        includeTableAlterOperations?: boolean;
        /**
         * Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for `transactionId`, previous `transactionId`, and `transactionRecordId` (the record offset within a transaction). Default is `false`.
         */
        includeTransactionDetails?: boolean;
        /**
         * Output format for the records created on the endpoint. Message format is `JSON` (default) or `JSON_UNFORMATTED` (a single line with no tab).
         */
        messageFormat?: string;
        /**
         * Maximum size in bytes for records created on the endpoint Default is `1,000,000`.
         */
        messageMaxBytes?: number;
        /**
         * Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, AWS DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the `noHexPrefix` endpoint setting to enable migration of RAW data type columns without adding the `'0x'` prefix.
         */
        noHexPrefix?: boolean;
        /**
         * Prefixes schema and table names to partition values, when the partition type is `primary-key-type`. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. Default is `false`.
         */
        partitionIncludeSchemaTable?: boolean;
        /**
         * Secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
         */
        saslPassword?: string;
        /**
         * Secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
         */
        saslUsername?: string;
        /**
         * Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include `ssl-encryption`, `ssl-authentication`, and `sasl-ssl`. `sasl-ssl` requires `saslUsername` and `saslPassword`.
         */
        securityProtocol?: string;
        /**
         * ARN for the private certificate authority (CA) cert that AWS DMS uses to securely connect to your Kafka target endpoint.
         */
        sslCaCertificateArn?: string;
        /**
         * ARN of the client certificate used to securely connect to a Kafka target endpoint.
         */
        sslClientCertificateArn?: string;
        /**
         * ARN for the client private key used to securely connect to a Kafka target endpoint.
         */
        sslClientKeyArn?: string;
        /**
         * Password for the client private key used to securely connect to a Kafka target endpoint.
         */
        sslClientKeyPassword?: string;
        /**
         * Kafka topic for migration. Default is `kafka-default-topic`.
         */
        topic?: string;
    }

    export interface EndpointKinesisSettings {
        /**
         * Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. Default is `false`.
         */
        includeControlDetails?: boolean;
        /**
         * Include NULL and empty columns in the target. Default is `false`.
         */
        includeNullAndEmpty?: boolean;
        /**
         * Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. Default is `false`.
         */
        includePartitionValue?: boolean;
        /**
         * Includes any data definition language (DDL) operations that change the table in the control data. Default is `false`.
         */
        includeTableAlterOperations?: boolean;
        /**
         * Provides detailed transaction information from the source database. Default is `false`.
         */
        includeTransactionDetails?: boolean;
        /**
         * Output format for the records created. Default is `json`. Valid values are `json` and `json-unformatted` (a single line with no tab).
         */
        messageFormat?: string;
        /**
         * Prefixes schema and table names to partition values, when the partition type is primary-key-type. Default is `false`.
         */
        partitionIncludeSchemaTable?: boolean;
        /**
         * ARN of the IAM Role with permissions to write to the Kinesis data stream.
         */
        serviceAccessRoleArn?: string;
        /**
         * ARN of the Kinesis data stream.
         */
        streamArn?: string;
    }

    export interface EndpointMongodbSettings {
        /**
         * Authentication mechanism to access the MongoDB source endpoint. Default is `default`.
         */
        authMechanism?: string;
        /**
         * Authentication database name. Not used when `authType` is `no`. Default is `admin`.
         */
        authSource?: string;
        /**
         * Authentication type to access the MongoDB source endpoint. Default is `password`.
         */
        authType?: string;
        /**
         * Number of documents to preview to determine the document organization. Use this setting when `nestingLevel` is set to `one`. Default is `1000`.
         */
        docsToInvestigate?: string;
        /**
         * Document ID. Use this setting when `nestingLevel` is set to `none`. Default is `false`.
         */
        extractDocId?: string;
        /**
         * Specifies either document or table mode. Default is `none`. Valid values are `one` (table mode) and `none` (document mode).
         */
        nestingLevel?: string;
    }

    export interface EndpointRedisSettings {
        /**
         * The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
         */
        authPassword?: string;
        /**
         * The type of authentication to perform when connecting to a Redis target. Options include `none`, `auth-token`, and `auth-role`. The `auth-token` option requires an `authPassword` value to be provided. The `auth-role` option requires `authUserName` and `authPassword` values to be provided.
         */
        authType: string;
        /**
         * The username provided with the `auth-role` option of the AuthType setting for a Redis target endpoint.
         */
        authUserName?: string;
        /**
         * Transmission Control Protocol (TCP) port for the endpoint.
         */
        port: number;
        /**
         * Fully qualified domain name of the endpoint.
         */
        serverName: string;
        /**
         * The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
         */
        sslCaCertificateArn?: string;
        /**
         * The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database. Options include `plaintext`, `ssl-encryption`. The default is `ssl-encryption`.
         */
        sslSecurityProtocol?: string;
    }

    export interface EndpointRedshiftSettings {
        /**
         * Custom S3 Bucket Object prefix for intermediate storage.
         */
        bucketFolder?: string;
        /**
         * Custom S3 Bucket name for intermediate storage.
         */
        bucketName?: string;
        /**
         * The server-side encryption mode that you want to encrypt your intermediate .csv object files copied to S3. Defaults to `SSE_S3`. Valid values are `SSE_S3` and `SSE_KMS`.
         */
        encryptionMode?: string;
        /**
         * ARN or Id of KMS Key to use when `encryptionMode` is `SSE_KMS`.
         */
        serverSideEncryptionKmsKeyId?: string;
        /**
         * Amazon Resource Name (ARN) of the IAM Role with permissions to read from or write to the S3 Bucket for intermediate storage.
         */
        serviceAccessRoleArn?: string;
    }

    export interface EndpointS3Settings {
        /**
         * Whether to add column name information to the .csv output file. Default is `false`.
         */
        addColumnName?: boolean;
        /**
         * Custom S3 Bucket Object prefix for intermediate storage.
         */
        bucketFolder?: string;
        /**
         * Custom S3 Bucket name for intermediate storage.
         */
        bucketName?: string;
        /**
         * Predefined (canned) access control list for objects created in an S3 bucket. Valid values include `none`, `private`, `public-read`, `public-read-write`, `authenticated-read`, `aws-exec-read`, `bucket-owner-read`, and `bucket-owner-full-control`. Default is `none`.
         */
        cannedAclForObjects?: string;
        /**
         * Whether to write insert and update operations to .csv or .parquet output files. Default is `false`.
         */
        cdcInsertsAndUpdates?: boolean;
        /**
         * Whether to write insert operations to .csv or .parquet output files. Default is `false`.
         */
        cdcInsertsOnly?: boolean;
        /**
         * Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. Default is `60`.
         */
        cdcMaxBatchInterval?: number;
        /**
         * Minimum file size condition as defined in kilobytes to output a file to Amazon S3. Default is `32000`. **NOTE:** Previously, this setting was measured in megabytes but now represents kilobytes. Update configurations accordingly.
         */
        cdcMinFileSize?: number;
        /**
         * Folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If `cdcPath` is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
         */
        cdcPath?: string;
        /**
         * Set to compress target files. Default is `NONE`. Valid values are `GZIP` and `NONE`.
         */
        compressionType?: string;
        /**
         * Delimiter used to separate columns in the source files. Default is `,`.
         */
        csvDelimiter?: string;
        /**
         * String to use for all columns not included in the supplemental log.
         */
        csvNoSupValue?: string;
        /**
         * String to as null when writing to the target.
         */
        csvNullValue?: string;
        /**
         * Delimiter used to separate rows in the source files. Default is `\n`.
         */
        csvRowDelimiter?: string;
        /**
         * Output format for the files that AWS DMS uses to create S3 objects. Valid values are `csv` and `parquet`. Default is `csv`.
         */
        dataFormat?: string;
        /**
         * Size of one data page in bytes. Default is `1048576` (1 MiB).
         */
        dataPageSize?: number;
        /**
         * Date separating delimiter to use during folder partitioning. Valid values are `SLASH`, `UNDERSCORE`, `DASH`, and `NONE`. Default is `SLASH`.
         */
        datePartitionDelimiter?: string;
        /**
         * Partition S3 bucket folders based on transaction commit dates. Default is `false`.
         */
        datePartitionEnabled?: boolean;
        /**
         * Date format to use during folder partitioning. Use this parameter when `datePartitionEnabled` is set to true. Valid values are `YYYYMMDD`, `YYYYMMDDHH`, `YYYYMM`, `MMYYYYDD`, and `DDMMYYYY`. Default is `YYYYMMDD`.
         */
        datePartitionSequence?: string;
        /**
         * Maximum size in bytes of an encoded dictionary page of a column. Default is `1048576` (1 MiB).
         */
        dictPageSizeLimit?: number;
        /**
         * Whether to enable statistics for Parquet pages and row groups. Default is `true`.
         */
        enableStatistics?: boolean;
        /**
         * Type of encoding to use. Value values are `rleDictionary`, `plain`, and `plainDictionary`. Default is `rleDictionary`.
         */
        encodingType?: string;
        /**
         * The server-side encryption mode that you want to encrypt your intermediate .csv object files copied to S3. Defaults to `SSE_S3`. Valid values are `SSE_S3` and `SSE_KMS`.
         */
        encryptionMode?: string;
        /**
         * JSON document that describes how AWS DMS should interpret the data.
         */
        externalTableDefinition?: string;
        /**
         * When this value is set to `1`, DMS ignores the first row header in a .csv file. Default is `0`.
         */
        ignoreHeaderRows?: number;
        /**
         * Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is `false`.
         */
        includeOpForFullLoad?: boolean;
        /**
         * Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from `1` to `1048576`. Default is `1048576` (1 GB).
         */
        maxFileSize?: number;
        /**
         * Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is `false`.
         */
        parquetTimestampInMillisecond?: boolean;
        /**
         * Version of the .parquet file format. Default is `parquet-1-0`. Valid values are `parquet-1-0` and `parquet-2-0`.
         */
        parquetVersion?: string;
        /**
         * Whether DMS saves the transaction order for a CDC load on the S3 target specified by `cdcPath`. Default is `false`.
         */
        preserveTransactions?: boolean;
        /**
         * For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is `true`.
         */
        rfc4180?: boolean;
        /**
         * Number of rows in a row group. Default is `10000`.
         */
        rowGroupLength?: number;
        /**
         * ARN or Id of KMS Key to use when `encryptionMode` is `SSE_KMS`.
         */
        serverSideEncryptionKmsKeyId?: string;
        /**
         * ARN of the IAM Role with permissions to write to the OpenSearch cluster.
         */
        serviceAccessRoleArn?: string;
        /**
         * Column to add with timestamp information to the endpoint data for an Amazon S3 target.
         */
        timestampColumnName?: string;
        /**
         * Whether to use `csvNoSupValue` for columns not included in the supplemental log.
         */
        useCsvNoSupValue?: boolean;
        /**
         * When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is `false`.
         */
        useTaskStartTimeForFullLoadTimestamp?: boolean;
    }

    export interface GetEndpointElasticsearchSetting {
        endpointUri: string;
        errorRetryDuration: number;
        fullLoadErrorPercentage: number;
        serviceAccessRoleArn: string;
    }

    export interface GetEndpointKafkaSetting {
        broker: string;
        includeControlDetails: boolean;
        includeNullAndEmpty: boolean;
        includePartitionValue: boolean;
        includeTableAlterOperations: boolean;
        includeTransactionDetails: boolean;
        messageFormat: string;
        messageMaxBytes: number;
        noHexPrefix: boolean;
        partitionIncludeSchemaTable: boolean;
        saslPassword: string;
        saslUsername: string;
        securityProtocol: string;
        sslCaCertificateArn: string;
        sslClientCertificateArn: string;
        sslClientKeyArn: string;
        sslClientKeyPassword: string;
        topic: string;
    }

    export interface GetEndpointKinesisSetting {
        includeControlDetails: boolean;
        includeNullAndEmpty: boolean;
        includePartitionValue: boolean;
        includeTableAlterOperations: boolean;
        includeTransactionDetails: boolean;
        messageFormat: string;
        partitionIncludeSchemaTable: boolean;
        serviceAccessRoleArn: string;
        streamArn: string;
    }

    export interface GetEndpointMongodbSetting {
        authMechanism: string;
        authSource: string;
        authType: string;
        docsToInvestigate: string;
        extractDocId: string;
        nestingLevel: string;
    }

    export interface GetEndpointRedisSetting {
        authPassword: string;
        authType: string;
        authUserName: string;
        port: number;
        serverName: string;
        sslCaCertificateArn: string;
        sslSecurityProtocol: string;
    }

    export interface GetEndpointRedshiftSetting {
        bucketFolder: string;
        bucketName: string;
        encryptionMode: string;
        serverSideEncryptionKmsKeyId: string;
        serviceAccessRoleArn: string;
    }

    export interface GetEndpointS3Setting {
        addColumnName: boolean;
        bucketFolder: string;
        bucketName: string;
        cannedAclForObjects: string;
        cdcInsertsAndUpdates: boolean;
        cdcInsertsOnly: boolean;
        cdcMaxBatchInterval: number;
        cdcMinFileSize: number;
        cdcPath: string;
        compressionType: string;
        csvDelimiter: string;
        csvNoSupValue: string;
        csvNullValue: string;
        csvRowDelimiter: string;
        dataFormat: string;
        dataPageSize: number;
        datePartitionDelimiter: string;
        datePartitionEnabled: boolean;
        datePartitionSequence: string;
        dictPageSizeLimit: number;
        enableStatistics: boolean;
        encodingType: string;
        encryptionMode: string;
        externalTableDefinition: string;
        ignoreHeaderRows: number;
        ignoreHeadersRow: number;
        includeOpForFullLoad: boolean;
        maxFileSize: number;
        parquetTimestampInMillisecond: boolean;
        parquetVersion: string;
        preserveTransactions: boolean;
        rfc4180: boolean;
        rowGroupLength: number;
        serverSideEncryptionKmsKeyId: string;
        serviceAccessRoleArn: string;
        timestampColumnName: string;
        useCsvNoSupValue: boolean;
        useTaskStartTimeForFullLoadTimestamp: boolean;
    }

}

export namespace docdb {
    export interface ClusterParameterGroupParameter {
        /**
         * Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the DocumentDB parameter.
         */
        name: string;
        /**
         * The value of the DocumentDB parameter.
         */
        value: string;
    }

    export interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster.
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster.
         */
        isWriter: boolean;
    }

}

export namespace dynamodb {
    export interface GetTableAttribute {
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        type: string;
    }

    export interface GetTableGlobalSecondaryIndex {
        hashKey: string;
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        nonKeyAttributes: string[];
        projectionType: string;
        rangeKey: string;
        readCapacity: number;
        writeCapacity: number;
    }

    export interface GetTableLocalSecondaryIndex {
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        nonKeyAttributes: string[];
        projectionType: string;
        rangeKey: string;
    }

    export interface GetTablePointInTimeRecovery {
        enabled: boolean;
    }

    export interface GetTableReplica {
        kmsKeyArn: string;
        regionName: string;
    }

    export interface GetTableServerSideEncryption {
        enabled: boolean;
        kmsKeyArn: string;
    }

    export interface GetTableTtl {
        attributeName: string;
        enabled: boolean;
    }

    export interface GlobalTableReplica {
        /**
         * AWS region name of replica DynamoDB TableE.g., `us-east-1`
         */
        regionName: string;
    }

    export interface TableAttribute {
        /**
         * Name of the attribute
         */
        name: string;
        /**
         * Attribute type. Valid values are `S` (string), `N` (number), `B` (binary).
         */
        type: string;
    }

    export interface TableGlobalSecondaryIndex {
        /**
         * Name of the hash key in the index; must be defined as an attribute in the resource.
         */
        hashKey: string;
        /**
         * Name of the index.
         */
        name: string;
        /**
         * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
         */
        nonKeyAttributes?: string[];
        /**
         * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
         */
        projectionType: string;
        /**
         * Name of the range key; must be defined
         */
        rangeKey?: string;
        /**
         * Number of read units for this index. Must be set if billingMode is set to PROVISIONED.
         */
        readCapacity?: number;
        /**
         * Number of write units for this index. Must be set if billingMode is set to PROVISIONED.
         */
        writeCapacity?: number;
    }

    export interface TableLocalSecondaryIndex {
        /**
         * Name of the index
         */
        name: string;
        /**
         * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
         */
        nonKeyAttributes?: string[];
        /**
         * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
         */
        projectionType: string;
        /**
         * Name of the range key.
         */
        rangeKey: string;
    }

    export interface TablePointInTimeRecovery {
        /**
         * Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the `pointInTimeRecovery` block is not provided, this defaults to `false`.
         */
        enabled: boolean;
    }

    export interface TableReplica {
        /**
         * ARN of the table
         */
        arn: string;
        /**
         * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
         */
        kmsKeyArn: string;
        /**
         * Whether to enable Point In Time Recovery for the replica. Default is `false`.
         */
        pointInTimeRecovery?: boolean;
        /**
         * Whether to propagate the global table's tags to a replica. Default is `false`. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from `true` to `false` on a subsequent `apply` means replica tags are left as they were, unmanaged, not deleted.
         */
        propagateTags?: boolean;
        /**
         * Region name of the replica.
         */
        regionName: string;
        /**
         * ARN of the Table Stream. Only available when `streamEnabled = true`
         */
        streamArn: string;
        /**
         * Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when `streamEnabled = true`.
         */
        streamLabel: string;
    }

    export interface TableServerSideEncryption {
        /**
         * Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If `enabled` is `false` then server-side encryption is set to AWS-_owned_ key (shown as `DEFAULT` in the AWS console). Potentially confusingly, if `enabled` is `true` and no `kmsKeyArn` is specified then server-side encryption is set to the _default_ KMS-_managed_ key (shown as `KMS` in the AWS console). The [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html) explains the difference between AWS-_owned_ and KMS-_managed_ keys.
         */
        enabled: boolean;
        /**
         * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
         */
        kmsKeyArn: string;
    }

    export interface TableTtl {
        /**
         * Name of the table attribute to store the TTL timestamp in.
         */
        attributeName: string;
        /**
         * Whether TTL is enabled.
         */
        enabled?: boolean;
    }

}

export namespace ebs {
    export interface GetEbsVolumesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html).
         * For example, if matching against the `size` filter, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const tenOrTwentyGbVolumes = aws.ebs.getEbsVolumes({
         *     filters: [{
         *         name: "size",
         *         values: [
         *             "10",
         *             "20",
         *         ],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * EBS Volume IDs will be selected if any one of the given values match.
         */
        values: string[];
    }

    export interface GetSnapshotFilter {
        name: string;
        values: string[];
    }

    export interface GetSnapshotIdsFilter {
        name: string;
        values: string[];
    }

    export interface GetVolumeFilter {
        name: string;
        values: string[];
    }

    export interface SnapshotImportClientData {
        /**
         * A user-defined comment about the disk upload.
         */
        comment?: string;
        /**
         * The time that the disk upload ends.
         */
        uploadEnd: string;
        /**
         * The size of the uploaded disk image, in GiB.
         */
        uploadSize: number;
        /**
         * The time that the disk upload starts.
         */
        uploadStart: string;
    }

    export interface SnapshotImportDiskContainer {
        /**
         * The description of the disk image being imported.
         */
        description?: string;
        /**
         * The format of the disk image being imported. One of `VHD` or `VMDK`.
         */
        format: string;
        /**
         * The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..). One of `url` or `userBucket` must be set.
         */
        url?: string;
        /**
         * The Amazon S3 bucket for the disk image. One of `url` or `userBucket` must be set. Detailed below.
         */
        userBucket?: outputs.ebs.SnapshotImportDiskContainerUserBucket;
    }

    export interface SnapshotImportDiskContainerUserBucket {
        /**
         * The name of the Amazon S3 bucket where the disk image is located.
         */
        s3Bucket: string;
        /**
         * The file name of the disk image.
         */
        s3Key: string;
    }

}

export namespace ec2 {
    export interface AmiCopyEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType: string;
    }

    export interface AmiCopyEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }

    export interface AmiEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination?: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted?: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops?: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn?: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId?: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType?: string;
    }

    export interface AmiEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }

    export interface AmiFromInstanceEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType: string;
    }

    export interface AmiFromInstanceEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }

    export interface DefaultNetworkAclEgress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         *
         * > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         *
         * The following arguments are optional:
         */
        toPort: number;
    }

    export interface DefaultNetworkAclIngress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         *
         * > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         *
         * The following arguments are optional:
         */
        toPort: number;
    }

    export interface DefaultRouteTableRoute {
        /**
         * The CIDR block of the route.
         */
        cidrBlock?: string;
        /**
         * The Amazon Resource Name (ARN) of a core network.
         */
        coreNetworkArn?: string;
        /**
         * The ID of a managed prefix list destination of the route.
         *
         * One of the following target arguments must be supplied:
         */
        destinationPrefixListId?: string;
        /**
         * Identifier of a VPC Egress Only Internet Gateway.
         */
        egressOnlyGatewayId?: string;
        /**
         * Identifier of a VPC internet gateway or a virtual private gateway.
         */
        gatewayId?: string;
        /**
         * Identifier of an EC2 instance.
         */
        instanceId?: string;
        /**
         * The Ipv6 CIDR block of the route
         */
        ipv6CidrBlock?: string;
        /**
         * Identifier of a VPC NAT gateway.
         */
        natGatewayId?: string;
        /**
         * Identifier of an EC2 network interface.
         */
        networkInterfaceId?: string;
        /**
         * Identifier of an EC2 Transit Gateway.
         */
        transitGatewayId?: string;
        /**
         * Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
         */
        vpcEndpointId?: string;
        /**
         * Identifier of a VPC peering connection.
         *
         * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
         */
        vpcPeeringConnectionId?: string;
    }

    export interface DefaultSecurityGroupEgress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp`)
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of prefix list IDs (for allowing access to VPC endpoints)
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this egress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         */
        toPort: number;
    }

    export interface DefaultSecurityGroupIngress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp`)
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of prefix list IDs (for allowing access to VPC endpoints)
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this egress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         */
        toPort: number;
    }

    export interface FleetFleetInstanceSet {
        /**
         * The IDs of the instances.
         */
        instanceIds: string[];
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
         */
        lifecycle: string;
        /**
         * The value is `Windows` for Windows instances. Otherwise, the value is blank.
         */
        platform: string;
    }

    export interface FleetLaunchTemplateConfig {
        /**
         * Nested argument containing EC2 Launch Template to use. Defined below.
         */
        launchTemplateSpecification?: outputs.ec2.FleetLaunchTemplateConfigLaunchTemplateSpecification;
        /**
         * Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
         */
        overrides?: outputs.ec2.FleetLaunchTemplateConfigOverride[];
    }

    export interface FleetLaunchTemplateConfigLaunchTemplateSpecification {
        /**
         * The ID of the launch template.
         */
        launchTemplateId?: string;
        /**
         * The name of the launch template.
         */
        launchTemplateName?: string;
        /**
         * The launch template version number, `$Latest`, or `$Default.`
         */
        version: string;
    }

    export interface FleetLaunchTemplateConfigOverride {
        /**
         * Availability Zone in which to launch the instances.
         */
        availabilityZone?: string;
        /**
         * Override the instance type in the Launch Template with instance types that satisfy the requirements.
         */
        instanceRequirements?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirements;
        /**
         * Instance type.
         */
        instanceType?: string;
        /**
         * Maximum price per unit hour that you are willing to pay for a Spot Instance.
         */
        maxPrice?: string;
        /**
         * Priority for the launch template override. If `onDemandOptions` `allocationStrategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
         */
        priority?: number;
        /**
         * ID of the subnet in which to launch the instances.
         */
        subnetId?: string;
        /**
         * Number of units provided by the specified instance type.
         */
        weightedCapacity?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
         */
        acceleratorCount?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * The accelerator types that must be on the instance type. Default is any accelerator type.
         */
        acceleratorTypes?: string[];
        /**
         * The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.
         *
         * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * The CPU manufacturers to include. Default is any manufacturer.
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         */
        cpuManufacturers?: string[];
        /**
         * The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
        /**
         * The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
         */
        memoryMib: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
        /**
         * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set `targetCapacityUnitType` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface FleetOnDemandOptions {
        /**
         * The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
         */
        allocationStrategy?: string;
        /**
         * The maximum amount per hour for On-Demand Instances that you're willing to pay.
         */
        maxTotalPrice?: string;
        /**
         * The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
         * If you specify `minTargetCapacity`, at least one of the following must be specified: `singleAvailabilityZone` or `singleInstanceType`.
         */
        minTargetCapacity?: number;
        /**
         * Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
         */
        singleAvailabilityZone?: boolean;
        /**
         * Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
         */
        singleInstanceType?: boolean;
    }

    export interface FleetSpotOptions {
        /**
         * How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
         */
        allocationStrategy?: string;
        /**
         * Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
         */
        instanceInterruptionBehavior?: string;
        /**
         * Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocationStrategy` is set to `lowestPrice`. Default: `1`.
         */
        instancePoolsToUseCount?: number;
        /**
         * Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
         */
        maintenanceStrategies?: outputs.ec2.FleetSpotOptionsMaintenanceStrategies;
    }

    export interface FleetSpotOptionsMaintenanceStrategies {
        /**
         * Nested argument containing the capacity rebalance for your fleet request. Defined below.
         */
        capacityRebalance?: outputs.ec2.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance;
    }

    export interface FleetSpotOptionsMaintenanceStrategiesCapacityRebalance {
        /**
         * The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
         */
        replacementStrategy?: string;
        terminationDelay?: number;
    }

    export interface FleetTargetCapacitySpecification {
        /**
         * Default target capacity type. Valid values: `on-demand`, `spot`.
         */
        defaultTargetCapacityType: string;
        /**
         * The number of On-Demand units to request.
         */
        onDemandTargetCapacity?: number;
        /**
         * The number of Spot units to request.
         */
        spotTargetCapacity?: number;
        /**
         * The unit for the target capacity.
         * If you specify `targetCapacityUnitType`, `instanceRequirements` must be specified.
         */
        targetCapacityUnitType?: string;
        /**
         * The number of units to request, filled using `defaultTargetCapacityType`.
         */
        totalTargetCapacity: number;
    }

    export interface FlowLogDestinationOptions {
        /**
         * The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
         */
        fileFormat?: string;
        /**
         * Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
         */
        hiveCompatiblePartitions?: boolean;
        /**
         * Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
         */
        perHourPartition?: boolean;
    }

    export interface GetAmiBlockDeviceMapping {
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volumeSize"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
         */
        ebs: {[key: string]: string};
        /**
         * Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice: string;
        /**
         * Virtual device name (for instance stores).
         */
        virtualName: string;
    }

    export interface GetAmiFilter {
        /**
         * Name of the AMI that was provided during image creation.
         */
        name: string;
        values: string[];
    }

    export interface GetAmiIdsFilter {
        name: string;
        values: string[];
    }

    export interface GetAmiProductCode {
        productCodeId: string;
        productCodeType: string;
    }

    export interface GetCoipPoolFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A COIP Pool will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetCoipPoolsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A COIP Pool will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetCustomerGatewayFilter {
        name: string;
        values: string[];
    }

    export interface GetDedicatedHostFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetEipsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetElasticIpFilter {
        name: string;
        values: string[];
    }

    export interface GetInstanceCreditSpecification {
        cpuCredits: string;
    }

    export interface GetInstanceEbsBlockDevice {
        /**
         * If the root block device will be deleted on termination.
         */
        deleteOnTermination: boolean;
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * If the EBS volume is encrypted.
         */
        encrypted: boolean;
        /**
         * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
         */
        iops: number;
        kmsKeyId: string;
        /**
         * ID of the snapshot.
         */
        snapshotId: string;
        /**
         * Map of tags assigned to the Instance.
         */
        tags: {[key: string]: string};
        /**
         * Throughput of the volume, in MiB/s.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }

    export interface GetInstanceEnclaveOption {
        /**
         * Whether Nitro Enclaves are enabled.
         */
        enabled: boolean;
    }

    export interface GetInstanceEphemeralBlockDevice {
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * Whether the specified device included in the device mapping was suppressed or not (Boolean).
         */
        noDevice?: boolean;
        /**
         * Virtual device name.
         */
        virtualName?: string;
    }

    export interface GetInstanceFilter {
        name: string;
        values: string[];
    }

    export interface GetInstanceMaintenanceOption {
        /**
         * Automatic recovery behavior of the instance.
         */
        autoRecovery: string;
    }

    export interface GetInstanceMetadataOption {
        /**
         * State of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
        /**
         * If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
         */
        instanceMetadataTags: string;
    }

    export interface GetInstancePrivateDnsNameOption {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for EC2 instances.
         */
        hostnameType: string;
    }

    export interface GetInstanceRootBlockDevice {
        /**
         * If the root block device will be deleted on termination.
         */
        deleteOnTermination: boolean;
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * If the EBS volume is encrypted.
         */
        encrypted: boolean;
        /**
         * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
         */
        iops: number;
        kmsKeyId: string;
        /**
         * Map of tags assigned to the Instance.
         */
        tags: {[key: string]: string};
        /**
         * Throughput of the volume, in MiB/s.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }

    export interface GetInstanceTypeFpga {
        count: number;
        manufacturer: string;
        /**
         * Size of the instance memory, in MiB.
         */
        memorySize: number;
        name: string;
    }

    export interface GetInstanceTypeGpus {
        count: number;
        manufacturer: string;
        /**
         * Size of the instance memory, in MiB.
         */
        memorySize: number;
        name: string;
    }

    export interface GetInstanceTypeInferenceAccelerator {
        count: number;
        manufacturer: string;
        name: string;
    }

    export interface GetInstanceTypeInstanceDisk {
        count: number;
        size: number;
        type: string;
    }

    export interface GetInstanceTypeOfferingFilter {
        /**
         * Name of the filter. The `location` filter depends on the top-level `locationType` argument and if not specified, defaults to the current region.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetInstanceTypeOfferingsFilter {
        /**
         * Name of the filter. The `location` filter depends on the top-level `locationType` argument and if not specified, defaults to the current region.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetInstanceTypesFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetInstancesFilter {
        name: string;
        values: string[];
    }

    export interface GetInternetGatewayAttachment {
        /**
         * Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
         */
        state: string;
        /**
         * ID of an attached VPC.
         */
        vpcId: string;
    }

    export interface GetInternetGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An Internet Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetKeyPairFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetLaunchConfigurationEbsBlockDevice {
        /**
         * Whether the EBS Volume will be deleted on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Name of the device.
         */
        deviceName: string;
        /**
         * Whether the volume is Encrypted.
         */
        encrypted: boolean;
        /**
         * Provisioned IOPs of the volume.
         */
        iops: number;
        /**
         * Whether the device in the block device mapping of the AMI is suppressed.
         */
        noDevice: boolean;
        /**
         * Snapshot ID of the mount.
         */
        snapshotId: string;
        /**
         * Throughput of the volume.
         */
        throughput: number;
        /**
         * Size of the volume.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }

    export interface GetLaunchConfigurationEphemeralBlockDevice {
        /**
         * Name of the device.
         */
        deviceName: string;
        /**
         * Virtual Name of the device.
         */
        virtualName: string;
    }

    export interface GetLaunchConfigurationMetadataOption {
        /**
         * State of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
    }

    export interface GetLaunchConfigurationRootBlockDevice {
        /**
         * Whether the EBS Volume will be deleted on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Whether the volume is Encrypted.
         */
        encrypted: boolean;
        /**
         * Provisioned IOPs of the volume.
         */
        iops: number;
        /**
         * Throughput of the volume.
         */
        throughput: number;
        /**
         * Size of the volume.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }

    export interface GetLaunchTemplateBlockDeviceMapping {
        deviceName: string;
        ebs: outputs.ec2.GetLaunchTemplateBlockDeviceMappingEb[];
        noDevice: string;
        virtualName: string;
    }

    export interface GetLaunchTemplateBlockDeviceMappingEb {
        deleteOnTermination: string;
        encrypted: string;
        iops: number;
        kmsKeyId: string;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface GetLaunchTemplateCapacityReservationSpecification {
        capacityReservationPreference: string;
        capacityReservationTargets: outputs.ec2.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget[];
    }

    export interface GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
        capacityReservationId: string;
        capacityReservationResourceGroupArn: string;
    }

    export interface GetLaunchTemplateCpuOption {
        amdSevSnp: string;
        coreCount: number;
        threadsPerCore: number;
    }

    export interface GetLaunchTemplateCreditSpecification {
        cpuCredits: string;
    }

    export interface GetLaunchTemplateElasticGpuSpecification {
        type: string;
    }

    export interface GetLaunchTemplateElasticInferenceAccelerator {
        type: string;
    }

    export interface GetLaunchTemplateEnclaveOption {
        enabled: boolean;
    }

    export interface GetLaunchTemplateFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetLaunchTemplateHibernationOption {
        configured: boolean;
    }

    export interface GetLaunchTemplateIamInstanceProfile {
        arn: string;
        /**
         * Name of the launch template.
         */
        name: string;
    }

    export interface GetLaunchTemplateInstanceMarketOption {
        marketType: string;
        spotOptions: outputs.ec2.GetLaunchTemplateInstanceMarketOptionSpotOption[];
    }

    export interface GetLaunchTemplateInstanceMarketOptionSpotOption {
        blockDurationMinutes: number;
        instanceInterruptionBehavior: string;
        maxPrice: string;
        spotInstanceType: string;
        validUntil: string;
    }

    export interface GetLaunchTemplateInstanceRequirement {
        acceleratorCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementAcceleratorCount[];
        acceleratorManufacturers: string[];
        acceleratorNames: string[];
        acceleratorTotalMemoryMibs: outputs.ec2.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib[];
        acceleratorTypes: string[];
        allowedInstanceTypes: string[];
        bareMetal: string;
        baselineEbsBandwidthMbps: outputs.ec2.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp[];
        burstablePerformance: string;
        cpuManufacturers: string[];
        excludedInstanceTypes: string[];
        instanceGenerations: string[];
        localStorage: string;
        localStorageTypes: string[];
        memoryGibPerVcpus: outputs.ec2.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus[];
        memoryMibs: outputs.ec2.GetLaunchTemplateInstanceRequirementMemoryMib[];
        networkBandwidthGbps: outputs.ec2.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp[];
        networkInterfaceCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementNetworkInterfaceCount[];
        onDemandMaxPricePercentageOverLowestPrice: number;
        requireHibernateSupport: boolean;
        spotMaxPricePercentageOverLowestPrice: number;
        totalLocalStorageGbs: outputs.ec2.GetLaunchTemplateInstanceRequirementTotalLocalStorageGb[];
        vcpuCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementVcpuCount[];
    }

    export interface GetLaunchTemplateInstanceRequirementAcceleratorCount {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementMemoryMib {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementNetworkInterfaceCount {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementTotalLocalStorageGb {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateInstanceRequirementVcpuCount {
        max: number;
        min: number;
    }

    export interface GetLaunchTemplateLicenseSpecification {
        licenseConfigurationArn: string;
    }

    export interface GetLaunchTemplateMaintenanceOption {
        autoRecovery: string;
    }

    export interface GetLaunchTemplateMetadataOption {
        httpEndpoint: string;
        httpProtocolIpv6: string;
        httpPutResponseHopLimit: number;
        httpTokens: string;
        instanceMetadataTags: string;
    }

    export interface GetLaunchTemplateMonitoring {
        enabled: boolean;
    }

    export interface GetLaunchTemplateNetworkInterface {
        associateCarrierIpAddress: string;
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description: string;
        deviceIndex: number;
        interfaceType: string;
        ipv4AddressCount: number;
        ipv4Addresses: string[];
        ipv4PrefixCount: number;
        ipv4Prefixes: string[];
        ipv6AddressCount: number;
        ipv6Addresses: string[];
        ipv6PrefixCount: number;
        ipv6Prefixes: string[];
        networkCardIndex: number;
        networkInterfaceId: string;
        privateIpAddress: string;
        securityGroups: string[];
        subnetId: string;
    }

    export interface GetLaunchTemplatePlacement {
        affinity: string;
        availabilityZone: string;
        groupName: string;
        hostId: string;
        hostResourceGroupArn: string;
        partitionNumber: number;
        spreadDomain: string;
        tenancy: string;
    }

    export interface GetLaunchTemplatePrivateDnsNameOption {
        enableResourceNameDnsARecord: boolean;
        enableResourceNameDnsAaaaRecord: boolean;
        hostnameType: string;
    }

    export interface GetLaunchTemplateTagSpecification {
        resourceType: string;
        /**
         * Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
         */
        tags: {[key: string]: string};
    }

    export interface GetLocalGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetLocalGatewayRouteTableFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A local gateway route table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetLocalGatewayRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetLocalGatewayVirtualInterfaceFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetLocalGatewayVirtualInterfaceGroupFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetLocalGatewayVirtualInterfaceGroupsFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetLocalGatewaysFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetManagedPrefixListEntry {
        cidr: string;
        description: string;
    }

    export interface GetManagedPrefixListFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetManagedPrefixListsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A managed prefix list will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetNatGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An Nat Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetNatGatewaysFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Nat Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetNetworkAclsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetNetworkInsightsAnalysisAlternatePathHint {
        componentArn: string;
        componentId: string;
    }

    export interface GetNetworkInsightsAnalysisExplanation {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisExplanationAclRule[];
        acls: outputs.ec2.GetNetworkInsightsAnalysisExplanationAcl[];
        address: string;
        addresses: string[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisExplanationAttachedTo[];
        availabilityZones: string[];
        cidrs: string[];
        classicLoadBalancerListeners: outputs.ec2.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
        components: outputs.ec2.GetNetworkInsightsAnalysisExplanationComponent[];
        customerGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationCustomerGateway[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationDestinationVpc[];
        destinations: outputs.ec2.GetNetworkInsightsAnalysisExplanationDestination[];
        direction: string;
        elasticLoadBalancerListeners: outputs.ec2.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
        explanationCode: string;
        ingressRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationIngressRouteTable[];
        internetGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationInternetGateway[];
        loadBalancerArn: string;
        loadBalancerListenerPort: number;
        loadBalancerTargetGroup: outputs.ec2.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetGroups: outputs.ec2.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetPort: number;
        missingComponent: string;
        natGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationNatGateway[];
        networkInterfaces: outputs.ec2.GetNetworkInsightsAnalysisExplanationNetworkInterface[];
        packetField: string;
        port: number;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationPortRange[];
        prefixLists: outputs.ec2.GetNetworkInsightsAnalysisExplanationPrefixList[];
        protocols: string[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisExplanationRouteTableRoute[];
        routeTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationRouteTable[];
        securityGroup: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroupRule[];
        securityGroups: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationSourceVpc[];
        state: string;
        subnetRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationSubnetRouteTable[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisExplanationSubnet[];
        transitGatewayAttachments: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
        transitGatewayRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGateway[];
        vpcEndpoints: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpcEndpoint[];
        vpcPeeringConnections: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpcPeeringConnection[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpc[];
        vpnConnections: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpnConnection[];
        vpnGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpnGateway[];
    }

    export interface GetNetworkInsightsAnalysisExplanationAcl {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface GetNetworkInsightsAnalysisExplanationAclRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisExplanationAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
        instancePort: number;
        loadBalancerPort: number;
    }

    export interface GetNetworkInsightsAnalysisExplanationComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationCustomerGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationDestination {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationIngressRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationInternetGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationNatGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationNetworkInterface {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationPortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisExplanationPrefixList {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationSecurityGroup {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisExplanationSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationSubnetRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationVpcEndpoint {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationVpcPeeringConnection {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationVpnConnection {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisExplanationVpnGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponent {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAclRule[];
        additionalDetails: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAttachedTo[];
        components: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentComponent[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSourceVpc[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentTransitGateway[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentVpc[];
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface GetNetworkInsightsAnalysisForwardPathComponentVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponent {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAclRule[];
        additionalDetails: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAttachedTo[];
        components: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentComponent[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSourceVpc[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentTransitGateway[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentVpc[];
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface GetNetworkInsightsAnalysisReturnPathComponentVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
    }

    export interface GetNetworkInsightsPathFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetNetworkInterfaceAssociation {
        /**
         * Allocation ID.
         */
        allocationId: string;
        /**
         * Association ID.
         */
        associationId: string;
        /**
         * Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
         */
        carrierIp: string;
        /**
         * Customer-owned IP address.
         */
        customerOwnedIp: string;
        /**
         * ID of the Elastic IP address owner.
         */
        ipOwnerId: string;
        /**
         * Public DNS name.
         */
        publicDnsName: string;
        /**
         * Address of the Elastic IP address bound to the network interface.
         */
        publicIp: string;
    }

    export interface GetNetworkInterfaceAttachment {
        attachmentId: string;
        deviceIndex: number;
        instanceId: string;
        instanceOwnerId: string;
    }

    export interface GetNetworkInterfaceFilter {
        name: string;
        values: string[];
    }

    export interface GetNetworkInterfacesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }

    export interface GetPrefixListFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetPublicIpv4PoolPoolAddressRange {
        /**
         * Number of addresses in the range.
         */
        addressCount: number;
        /**
         * Number of available addresses in the range.
         */
        availableAddressCount: number;
        /**
         * First address in the range.
         */
        firstAddress: string;
        /**
         * Last address in the range.
         */
        lastAddress: string;
    }

    export interface GetPublicIpv4PoolsFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
         */
        values: string[];
    }

    export interface GetRouteTableAssociation {
        /**
         * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
         */
        gatewayId: string;
        /**
         * Whether the association is due to the main route table.
         */
        main: boolean;
        /**
         * Association ID.
         */
        routeTableAssociationId: string;
        /**
         * ID of the specific Route Table to retrieve.
         */
        routeTableId: string;
        /**
         * ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
         */
        subnetId: string;
    }

    export interface GetRouteTableFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetRouteTableRoute {
        /**
         * ID of the Carrier Gateway.
         */
        carrierGatewayId: string;
        /**
         * CIDR block of the route.
         */
        cidrBlock: string;
        /**
         * ARN of the core network.
         */
        coreNetworkArn: string;
        /**
         * The ID of a managed prefix list destination of the route.
         */
        destinationPrefixListId: string;
        /**
         * ID of the Egress Only Internet Gateway.
         */
        egressOnlyGatewayId: string;
        /**
         * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
         */
        gatewayId: string;
        /**
         * EC2 instance ID.
         */
        instanceId: string;
        /**
         * IPv6 CIDR block of the route.
         */
        ipv6CidrBlock: string;
        /**
         * Local Gateway ID.
         */
        localGatewayId: string;
        /**
         * NAT Gateway ID.
         */
        natGatewayId: string;
        /**
         * ID of the elastic network interface (eni) to use.
         */
        networkInterfaceId: string;
        /**
         * EC2 Transit Gateway ID.
         */
        transitGatewayId: string;
        /**
         * VPC Endpoint ID.
         */
        vpcEndpointId: string;
        /**
         * VPC Peering ID.
         */
        vpcPeeringConnectionId: string;
    }

    export interface GetRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetSecurityGroupFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Security Group will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetSecurityGroupsFilter {
        name: string;
        values: string[];
    }

    export interface GetSpotPriceFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetSubnetFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetSubnetsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
         * For example, if matching against tag `Name`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.ec2.getSubnets({
         *     filters: [{
         *         name: "tag:Name",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * Subnet IDs will be selected if any one of the given values match.
         */
        values: string[];
    }

    export interface GetTransitGatewayRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpcCidrBlockAssociation {
        /**
         * Association ID for the IPv4 CIDR block.
         */
        associationId: string;
        /**
         * Cidr block of the desired VPC.
         */
        cidrBlock: string;
        /**
         * Current state of the desired VPC.
         * Can be either `"pending"` or `"available"`.
         */
        state: string;
    }

    export interface GetVpcDhcpOptionsFilter {
        /**
         * Name of the field to filter.
         */
        name: string;
        /**
         * Set of values for filtering.
         */
        values: string[];
    }

    export interface GetVpcEndpointDnsEntry {
        /**
         * DNS name.
         */
        dnsName: string;
        /**
         * ID of the private hosted zone.
         */
        hostedZoneId: string;
    }

    export interface GetVpcEndpointDnsOption {
        dnsRecordIpType: string;
    }

    export interface GetVpcEndpointFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Endpoint will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpcEndpointServiceFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetVpcFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpcIamPoolCidrsFilter {
        name: string;
        values: string[];
    }

    export interface GetVpcIamPoolCidrsIpamPoolCidr {
        /**
         * A network CIDR.
         */
        cidr: string;
        /**
         * The provisioning state of that CIDR.
         */
        state: string;
    }

    export interface GetVpcIamPoolFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }

    export interface GetVpcIamPoolsFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }

    export interface GetVpcIamPoolsIpamPool {
        /**
         * IP protocol assigned to this pool.
         */
        addressFamily: string;
        /**
         * A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
         */
        allocationDefaultNetmaskLength: number;
        /**
         * The maximum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMaxNetmaskLength: number;
        /**
         * The minimum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMinNetmaskLength: number;
        /**
         * Tags that are required to create resources in using this pool.
         */
        allocationResourceTags: {[key: string]: string};
        /**
         * ARN of the pool
         */
        arn: string;
        /**
         * If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
         */
        autoImport: boolean;
        /**
         * Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
         */
        awsService: string;
        /**
         * Description for the IPAM pool.
         */
        description: string;
        /**
         * ID of the IPAM pool.
         */
        id?: string;
        ipamPoolId: string;
        /**
         * ID of the scope the pool belongs to.
         */
        ipamScopeId: string;
        ipamScopeType: string;
        /**
         * Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
         */
        locale: string;
        poolDepth: number;
        /**
         * Defines whether or not IPv6 pool space is publicly advertisable over the internet.
         */
        publiclyAdvertisable: boolean;
        /**
         * ID of the source IPAM pool.
         */
        sourceIpamPoolId: string;
        state: string;
        /**
         * Map of tags to assigned to the resource.
         */
        tags: {[key: string]: string};
    }

    export interface GetVpcPeeringConnectionCidrBlockSet {
        /**
         * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
         */
        cidrBlock: string;
    }

    export interface GetVpcPeeringConnectionFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Peering Connection will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpcPeeringConnectionPeerCidrBlockSet {
        /**
         * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
         */
        cidrBlock: string;
    }

    export interface GetVpcPeeringConnectionsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Peering Connection will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpcsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetVpnGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPN Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface InstanceCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
         */
        capacityReservationPreference?: string;
        /**
         * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
         *
         * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
         */
        capacityReservationTarget?: outputs.ec2.InstanceCapacityReservationSpecificationCapacityReservationTarget;
    }

    export interface InstanceCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }

    export interface InstanceCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp: string;
        /**
         * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
         */
        coreCount: number;
        /**
         * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
         *
         * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
         */
        threadsPerCore: number;
    }

    export interface InstanceCreditSpecification {
        /**
         * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
         */
        cpuCredits?: string;
    }

    export interface InstanceEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Snapshot ID to mount.
         */
        snapshotId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {[key: string]: string};
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
         */
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
         */
        volumeType: string;
    }

    export interface InstanceEnclaveOptions {
        /**
         * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled: boolean;
    }

    export interface InstanceEphemeralBlockDevice {
        /**
         * Name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: boolean;
        /**
         * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
         *
         * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
         */
        virtualName?: string;
    }

    export interface InstanceInstanceMarketOptions {
        /**
         * Type of market for the instance. Valid value is `spot`. Defaults to `spot`.
         */
        marketType: string;
        /**
         * Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
         */
        spotOptions: outputs.ec2.InstanceInstanceMarketOptionsSpotOptions;
    }

    export interface InstanceInstanceMarketOptionsSpotOptions {
        /**
         * The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
         */
        instanceInterruptionBehavior: string;
        /**
         * The maximum hourly price that you're willing to pay for a Spot Instance.
         */
        maxPrice: string;
        /**
         * The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
         */
        spotInstanceType: string;
        /**
         * The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
         */
        validUntil: string;
    }

    export interface InstanceLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
         */
        version?: string;
    }

    export interface InstanceMaintenanceOptions {
        /**
         * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery: string;
    }

    export interface InstanceMetadataOptions {
        /**
         * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
         */
        httpEndpoint?: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }

    export interface InstanceNetworkInterface {
        /**
         * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
         */
        deleteOnTermination?: boolean;
        /**
         * Integer index of the network interface attachment. Limited by instance type.
         */
        deviceIndex: number;
        /**
         * Integer index of the network card. Limited by instance type. The default index is `0`.
         */
        networkCardIndex?: number;
        /**
         * ID of the network interface to attach.
         */
        networkInterfaceId: string;
    }

    export interface InstancePrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType: string;
    }

    export interface InstanceRootBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {[key: string]: string};
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
         */
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
         */
        volumeType: string;
    }

    export interface LaunchConfigurationEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        encrypted: boolean;
        iops: number;
        noDevice?: boolean;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface LaunchConfigurationEphemeralBlockDevice {
        deviceName: string;
        noDevice?: boolean;
        virtualName?: string;
    }

    export interface LaunchConfigurationMetadataOptions {
        /**
         * The state of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
    }

    export interface LaunchConfigurationRootBlockDevice {
        deleteOnTermination?: boolean;
        encrypted: boolean;
        iops: number;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface LaunchTemplateBlockDeviceMapping {
        /**
         * The name of the device to mount.
         */
        deviceName?: string;
        /**
         * Configure EBS volume properties.
         */
        ebs?: outputs.ec2.LaunchTemplateBlockDeviceMappingEbs;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: string;
        /**
         * The [Instance Store Device
         * Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
         * (e.g., `"ephemeral0"`).
         */
        virtualName?: string;
    }

    export interface LaunchTemplateBlockDeviceMappingEbs {
        /**
         * Whether the volume should be destroyed on instance termination.
         * See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
         */
        deleteOnTermination?: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         * Cannot be used with `snapshotId`.
         */
        encrypted?: string;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
         * This must be set with a `volumeType` of `"io1/io2/gp3"`.
         */
        iops: number;
        /**
         * The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
         * `encrypted` must be set to `true` when this is set.
         */
        kmsKeyId?: string;
        /**
         * The Snapshot ID to mount.
         */
        snapshotId?: string;
        /**
         * The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
         */
        throughput: number;
        /**
         * The size of the volume in gigabytes.
         */
        volumeSize: number;
        /**
         * The volume type.
         * Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
         */
        volumeType: string;
    }

    export interface LaunchTemplateCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
         */
        capacityReservationPreference?: string;
        /**
         * Used to target a specific Capacity Reservation:
         */
        capacityReservationTarget?: outputs.ec2.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget;
    }

    export interface LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * The ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * The ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }

    export interface LaunchTemplateCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp?: string;
        /**
         * The number of CPU cores for the instance.
         */
        coreCount?: number;
        /**
         * The number of threads per CPU core.
         * To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
         * Otherwise, specify the default value of 2.
         *
         * Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
         */
        threadsPerCore?: number;
    }

    export interface LaunchTemplateCreditSpecification {
        /**
         * The credit option for CPU usage.
         * Can be `standard` or `unlimited`.
         * T3 instances are launched as `unlimited` by default.
         * T2 instances are launched as `standard` by default.
         */
        cpuCredits?: string;
    }

    export interface LaunchTemplateElasticGpuSpecification {
        /**
         * The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
         */
        type: string;
    }

    export interface LaunchTemplateElasticInferenceAccelerator {
        /**
         * Accelerator type.
         */
        type: string;
    }

    export interface LaunchTemplateEnclaveOptions {
        /**
         * If set to `true`, Nitro Enclaves will be enabled on the instance.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled?: boolean;
    }

    export interface LaunchTemplateHibernationOptions {
        /**
         * If set to `true`, the launched EC2 instance will hibernation enabled.
         */
        configured: boolean;
    }

    export interface LaunchTemplateIamInstanceProfile {
        /**
         * The Amazon Resource Name (ARN) of the instance profile.
         */
        arn?: string;
        /**
         * The name of the instance profile.
         */
        name?: string;
    }

    export interface LaunchTemplateInstanceMarketOptions {
        /**
         * The market type. Can be `spot`.
         */
        marketType?: string;
        /**
         * The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
         */
        spotOptions?: outputs.ec2.LaunchTemplateInstanceMarketOptionsSpotOptions;
    }

    export interface LaunchTemplateInstanceMarketOptionsSpotOptions {
        /**
         * The required duration in minutes. This value must be a multiple of 60.
         */
        blockDurationMinutes?: number;
        /**
         * The behavior when a Spot Instance is interrupted. Can be `hibernate`,
         * `stop`, or `terminate`. (Default: `terminate`).
         */
        instanceInterruptionBehavior?: string;
        /**
         * The maximum hourly price you're willing to pay for the Spot Instances.
         */
        maxPrice?: string;
        /**
         * The Spot Instance request type. Can be `one-time`, or `persistent`.
         */
        spotInstanceType?: string;
        /**
         * The end date of the request.
         */
        validUntil: string;
    }

    export interface LaunchTemplateInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
         */
        acceleratorCount?: outputs.ec2.LaunchTemplateInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * List of accelerator types. Default is any accelerator type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorTypes?: string[];
        /**
         * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
         *
         * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * List of CPU manufacturer names. Default is any manufacturer.
         *
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        cpuManufacturers?: string[];
        /**
         * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * List of instance generation names. Default is any generation.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Default any storage type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu;
        /**
         * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
         */
        memoryMib: outputs.ec2.LaunchTemplateInstanceRequirementsMemoryMib;
        /**
         * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.LaunchTemplateInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.LaunchTemplateInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount: outputs.ec2.LaunchTemplateInstanceRequirementsVcpuCount;
    }

    export interface LaunchTemplateInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface LaunchTemplateInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface LaunchTemplateInstanceRequirementsVcpuCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }

    export interface LaunchTemplateLicenseSpecification {
        /**
         * ARN of the license configuration.
         */
        licenseConfigurationArn: string;
    }

    export interface LaunchTemplateMaintenanceOptions {
        /**
         * Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery?: string;
    }

    export interface LaunchTemplateMetadataOptions {
        /**
         * Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
         */
        httpEndpoint: string;
        /**
         * Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
         */
        httpProtocolIpv6: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }

    export interface LaunchTemplateMonitoring {
        /**
         * If `true`, the launched EC2 instance will have detailed monitoring enabled.
         */
        enabled?: boolean;
    }

    export interface LaunchTemplateNetworkInterface {
        /**
         * Associate a Carrier IP address with `eth0` for a new network interface.
         * Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface.
         * Boolean value, can be left unset.
         */
        associateCarrierIpAddress?: string;
        /**
         * Associate a public ip address with the network interface.
         * Boolean value, can be left unset.
         */
        associatePublicIpAddress?: string;
        /**
         * Whether the network interface should be destroyed on instance termination.
         */
        deleteOnTermination?: string;
        /**
         * Description of the network interface.
         */
        description?: string;
        /**
         * The integer index of the network interface attachment.
         */
        deviceIndex?: number;
        /**
         * The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
         */
        interfaceType?: string;
        /**
         * The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4Addresses`
         */
        ipv4AddressCount?: number;
        /**
         * One or more private IPv4 addresses to associate. Conflicts with `ipv4AddressCount`
         */
        ipv4Addresses?: string[];
        /**
         * The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4Prefixes`
         */
        ipv4PrefixCount?: number;
        /**
         * One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4PrefixCount`
         */
        ipv4Prefixes?: string[];
        /**
         * The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6Addresses`
         */
        ipv6AddressCount?: number;
        /**
         * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6AddressCount`
         */
        ipv6Addresses?: string[];
        /**
         * The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6Prefixes`
         */
        ipv6PrefixCount?: number;
        /**
         * One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6PrefixCount`
         */
        ipv6Prefixes?: string[];
        /**
         * The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
         */
        networkCardIndex?: number;
        /**
         * The ID of the network interface to attach.
         */
        networkInterfaceId?: string;
        /**
         * The primary private IPv4 address.
         */
        privateIpAddress?: string;
        /**
         * A list of security group IDs to associate.
         */
        securityGroups?: string[];
        /**
         * The VPC Subnet ID to associate.
         */
        subnetId?: string;
    }

    export interface LaunchTemplatePlacement {
        /**
         * The affinity setting for an instance on a Dedicated Host.
         */
        affinity?: string;
        /**
         * The Availability Zone for the instance.
         */
        availabilityZone?: string;
        /**
         * The name of the placement group for the instance.
         */
        groupName?: string;
        /**
         * The ID of the Dedicated Host for the instance.
         */
        hostId?: string;
        /**
         * The ARN of the Host Resource Group in which to launch instances.
         */
        hostResourceGroupArn?: string;
        /**
         * The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
         */
        partitionNumber?: number;
        /**
         * Reserved for future use.
         */
        spreadDomain?: string;
        /**
         * The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
         */
        tenancy?: string;
    }

    export interface LaunchTemplatePrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord?: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord?: boolean;
        /**
         * The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType?: string;
    }

    export interface LaunchTemplateTagSpecification {
        /**
         * The type of resource to tag.
         */
        resourceType?: string;
        /**
         * A map of tags to assign to the resource.
         */
        tags?: {[key: string]: string};
    }

    export interface ManagedPrefixListEntry {
        /**
         * CIDR block of this entry.
         */
        cidr: string;
        /**
         * Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
         */
        description?: string;
    }

    export interface NetworkAclEgress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a
         * valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         *
         * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all'
         * protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         */
        toPort: number;
    }

    export interface NetworkAclIngress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a
         * valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         *
         * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all'
         * protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         */
        toPort: number;
    }

    export interface NetworkInsightsAnalysisAlternatePathHint {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn: string;
        /**
         * The ID of the component.
         */
        componentId: string;
    }

    export interface NetworkInsightsAnalysisExplanation {
        aclRules: outputs.ec2.NetworkInsightsAnalysisExplanationAclRule[];
        acls: outputs.ec2.NetworkInsightsAnalysisExplanationAcl[];
        address: string;
        addresses: string[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisExplanationAttachedTo[];
        availabilityZones: string[];
        cidrs: string[];
        classicLoadBalancerListeners: outputs.ec2.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
        components: outputs.ec2.NetworkInsightsAnalysisExplanationComponent[];
        customerGateways: outputs.ec2.NetworkInsightsAnalysisExplanationCustomerGateway[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisExplanationDestinationVpc[];
        destinations: outputs.ec2.NetworkInsightsAnalysisExplanationDestination[];
        direction: string;
        elasticLoadBalancerListeners: outputs.ec2.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
        explanationCode: string;
        ingressRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationIngressRouteTable[];
        internetGateways: outputs.ec2.NetworkInsightsAnalysisExplanationInternetGateway[];
        loadBalancerArn: string;
        loadBalancerListenerPort: number;
        loadBalancerTargetGroup: outputs.ec2.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetGroups: outputs.ec2.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetPort: number;
        missingComponent: string;
        natGateways: outputs.ec2.NetworkInsightsAnalysisExplanationNatGateway[];
        networkInterfaces: outputs.ec2.NetworkInsightsAnalysisExplanationNetworkInterface[];
        packetField: string;
        port: number;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationPortRange[];
        prefixLists: outputs.ec2.NetworkInsightsAnalysisExplanationPrefixList[];
        protocols: string[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisExplanationRouteTableRoute[];
        routeTables: outputs.ec2.NetworkInsightsAnalysisExplanationRouteTable[];
        securityGroup: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroup[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroupRule[];
        securityGroups: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroup[];
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisExplanationSourceVpc[];
        state: string;
        subnetRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationSubnetRouteTable[];
        subnets: outputs.ec2.NetworkInsightsAnalysisExplanationSubnet[];
        transitGatewayAttachments: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
        transitGatewayRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGateway[];
        vpcEndpoints: outputs.ec2.NetworkInsightsAnalysisExplanationVpcEndpoint[];
        vpcPeeringConnections: outputs.ec2.NetworkInsightsAnalysisExplanationVpcPeeringConnection[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisExplanationVpc[];
        vpnConnections: outputs.ec2.NetworkInsightsAnalysisExplanationVpnConnection[];
        vpnGateways: outputs.ec2.NetworkInsightsAnalysisExplanationVpnGateway[];
    }

    export interface NetworkInsightsAnalysisExplanationAcl {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface NetworkInsightsAnalysisExplanationAclRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisExplanationAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
        instancePort: number;
        loadBalancerPort: number;
    }

    export interface NetworkInsightsAnalysisExplanationComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationCustomerGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationDestination {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationIngressRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationInternetGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationNatGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationNetworkInterface {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationPortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisExplanationPrefixList {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface NetworkInsightsAnalysisExplanationSecurityGroup {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisExplanationSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationSubnetRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationTransitGatewayAttachment {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface NetworkInsightsAnalysisExplanationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationVpcEndpoint {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationVpcPeeringConnection {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationVpnConnection {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisExplanationVpnGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponent {
        aclRules: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAclRule[];
        additionalDetails: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAttachedTo[];
        components: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentComponent[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSourceVpc[];
        subnets: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentTransitGateway[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentVpc[];
    }

    export interface NetworkInsightsAnalysisForwardPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
    }

    export interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
    }

    export interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
    }

    export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface NetworkInsightsAnalysisForwardPathComponentVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponent {
        aclRules: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAclRule[];
        additionalDetails: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAttachedTo[];
        components: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentComponent[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSourceVpc[];
        subnets: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentTransitGateway[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentVpc[];
    }

    export interface NetworkInsightsAnalysisReturnPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
    }

    export interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
    }

    export interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
    }

    export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }

    export interface NetworkInsightsAnalysisReturnPathComponentVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }

    export interface NetworkInterfaceAttachment {
        attachmentId: string;
        /**
         * Integer to define the devices index.
         */
        deviceIndex: number;
        /**
         * ID of the instance to attach to.
         */
        instance: string;
    }

    export interface PeeringConnectionOptionsAccepter {
        /**
         * Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface PeeringConnectionOptionsRequester {
        /**
         * Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface RouteTableRoute {
        /**
         * Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
         */
        carrierGatewayId?: string;
        /**
         * The CIDR block of the route.
         */
        cidrBlock?: string;
        /**
         * The Amazon Resource Name (ARN) of a core network.
         */
        coreNetworkArn?: string;
        /**
         * The ID of a managed prefix list destination of the route.
         *
         * One of the following target arguments must be supplied:
         */
        destinationPrefixListId?: string;
        /**
         * Identifier of a VPC Egress Only Internet Gateway.
         */
        egressOnlyGatewayId?: string;
        /**
         * Identifier of a VPC internet gateway or a virtual private gateway.
         */
        gatewayId?: string;
        /**
         * The Ipv6 CIDR block of the route.
         */
        ipv6CidrBlock?: string;
        /**
         * Identifier of a Outpost local gateway.
         */
        localGatewayId?: string;
        /**
         * Identifier of a VPC NAT gateway.
         */
        natGatewayId?: string;
        /**
         * Identifier of an EC2 network interface.
         */
        networkInterfaceId?: string;
        /**
         * Identifier of an EC2 Transit Gateway.
         */
        transitGatewayId?: string;
        /**
         * Identifier of a VPC Endpoint.
         */
        vpcEndpointId?: string;
        /**
         * Identifier of a VPC peering connection.
         *
         * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
         */
        vpcPeeringConnectionId?: string;
    }

    export interface SecurityGroupEgress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this egress rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp`)
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of Prefix List IDs.
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this egress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         *
         * The following arguments are optional:
         *
         * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
         */
        toPort: number;
    }

    export interface SecurityGroupIngress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this ingress rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of Prefix List IDs.
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0.  The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
         *
         * The following arguments are optional:
         *
         * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this ingress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         */
        toPort: number;
    }

    export interface SpotFleetRequestLaunchSpecification {
        ami: string;
        associatePublicIpAddress?: boolean;
        /**
         * The availability zone in which to place the request.
         */
        availabilityZone: string;
        ebsBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationEbsBlockDevice[];
        ebsOptimized?: boolean;
        ephemeralBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice[];
        iamInstanceProfile?: string;
        iamInstanceProfileArn?: string;
        /**
         * The type of instance to request.
         */
        instanceType: string;
        keyName: string;
        monitoring?: boolean;
        placementGroup: string;
        placementTenancy?: string;
        rootBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationRootBlockDevice[];
        /**
         * The maximum bid price per unit hour.
         */
        spotPrice?: string;
        /**
         * The subnet in which to launch the requested instance.
         */
        subnetId: string;
        /**
         * A map of tags to assign to the resource. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {[key: string]: string};
        userData?: string;
        vpcSecurityGroupIds: string[];
        /**
         * The capacity added to the fleet by a fulfilled request.
         */
        weightedCapacity?: string;
    }

    export interface SpotFleetRequestLaunchSpecificationEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        encrypted: boolean;
        iops: number;
        kmsKeyId: string;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface SpotFleetRequestLaunchSpecificationEphemeralBlockDevice {
        deviceName: string;
        virtualName: string;
    }

    export interface SpotFleetRequestLaunchSpecificationRootBlockDevice {
        deleteOnTermination?: boolean;
        encrypted: boolean;
        iops: number;
        kmsKeyId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface SpotFleetRequestLaunchTemplateConfig {
        /**
         * Launch template specification. See Launch Template Specification below for more details.
         */
        launchTemplateSpecification: outputs.ec2.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification;
        /**
         * One or more override configurations. See Overrides below for more details.
         */
        overrides?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverride[];
    }

    export interface SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification {
        /**
         * The ID of the launch template. Conflicts with `name`.
         */
        id?: string;
        /**
         * The name of the launch template. Conflicts with `id`.
         */
        name?: string;
        /**
         * Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launchTemplate resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
         *
         * **Note:** The specified launch template can specify only a subset of the
         * inputs of `aws.ec2.LaunchTemplate`.  There are limitations on
         * what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instanceInitiatedShutdownBehavior` is confirmed unsupported.
         */
        version?: string;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverride {
        /**
         * The availability zone in which to place the request.
         */
        availabilityZone?: string;
        /**
         * The instance requirements. See below.
         */
        instanceRequirements?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements;
        /**
         * The type of instance to request.
         */
        instanceType?: string;
        /**
         * The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
         */
        priority: number;
        /**
         * The maximum spot bid for this override request.
         */
        spotPrice: string;
        /**
         * The subnet in which to launch the requested instance.
         */
        subnetId: string;
        /**
         * The capacity added to the fleet by a fulfilled request.
         */
        weightedCapacity: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
         */
        acceleratorCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * List of accelerator types. Default is any accelerator type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        acceleratorTypes?: string[];
        /**
         * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
         *
         * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * List of CPU manufacturer names. Default is any manufacturer.
         *
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        cpuManufacturers?: string[];
        /**
         * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * List of instance generation names. Default is any generation.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Default any storage type.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
        /**
         * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
         */
        memoryMib?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
        /**
         * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }

    export interface SpotFleetRequestSpotMaintenanceStrategies {
        /**
         * Nested argument containing the capacity rebalance for your fleet request. Defined below.
         */
        capacityRebalance?: outputs.ec2.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance;
    }

    export interface SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance {
        /**
         * The replacement strategy to use. Only available for spot fleets with `fleetType` set to `maintain`. Valid values: `launch`.
         */
        replacementStrategy?: string;
    }

    export interface SpotInstanceRequestCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
         */
        capacityReservationPreference?: string;
        /**
         * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
         *
         * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
         */
        capacityReservationTarget?: outputs.ec2.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget;
    }

    export interface SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }

    export interface SpotInstanceRequestCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp: string;
        /**
         * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
         */
        coreCount: number;
        /**
         * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
         *
         * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
         */
        threadsPerCore: number;
    }

    export interface SpotInstanceRequestCreditSpecification {
        /**
         * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
         */
        cpuCredits?: string;
    }

    export interface SpotInstanceRequestEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Snapshot ID to mount.
         */
        snapshotId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {[key: string]: string};
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
         */
        volumeType: string;
    }

    export interface SpotInstanceRequestEnclaveOptions {
        /**
         * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled: boolean;
    }

    export interface SpotInstanceRequestEphemeralBlockDevice {
        /**
         * Name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: boolean;
        /**
         * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
         *
         * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
         */
        virtualName?: string;
    }

    export interface SpotInstanceRequestLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
         */
        version?: string;
    }

    export interface SpotInstanceRequestMaintenanceOptions {
        /**
         * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery: string;
    }

    export interface SpotInstanceRequestMetadataOptions {
        /**
         * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
         */
        httpEndpoint?: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }

    export interface SpotInstanceRequestNetworkInterface {
        /**
         * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
         */
        deleteOnTermination?: boolean;
        /**
         * Integer index of the network interface attachment. Limited by instance type.
         */
        deviceIndex: number;
        /**
         * Integer index of the network card. Limited by instance type. The default index is `0`.
         */
        networkCardIndex?: number;
        /**
         * ID of the network interface to attach.
         */
        networkInterfaceId: string;
    }

    export interface SpotInstanceRequestPrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType: string;
    }

    export interface SpotInstanceRequestRootBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {[key: string]: string};
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
         */
        volumeType: string;
    }

    export interface TrafficMirrorFilterRuleDestinationPortRange {
        /**
         * Starting port of the range
         */
        fromPort?: number;
        /**
         * Ending port of the range
         */
        toPort?: number;
    }

    export interface TrafficMirrorFilterRuleSourcePortRange {
        /**
         * Starting port of the range
         */
        fromPort?: number;
        /**
         * Ending port of the range
         */
        toPort?: number;
    }

    export interface VpcEndpointDnsEntry {
        /**
         * The DNS name.
         */
        dnsName: string;
        /**
         * The ID of the private hosted zone.
         */
        hostedZoneId: string;
    }

    export interface VpcEndpointDnsOptions {
        /**
         * The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
         */
        dnsRecordIpType?: string;
        /**
         * Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Can only be specified if `privateDnsEnabled` is `true`.
         */
        privateDnsOnlyForInboundResolverEndpoint?: boolean;
    }

    export interface VpcEndpointServicePrivateDnsNameConfiguration {
        /**
         * Name of the record subdomain the service provider needs to create.
         */
        name: string;
        /**
         * Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
         */
        state: string;
        /**
         * Endpoint service verification type, for example `TXT`.
         */
        type: string;
        /**
         * Value the service provider adds to the private DNS name domain record before verification.
         */
        value: string;
    }

    export interface VpcIpamOperatingRegion {
        /**
         * The name of the Region you want to add to the IPAM.
         */
        regionName: string;
    }

    export interface VpcIpamPoolCidrCidrAuthorizationContext {
        /**
         * The plain-text authorization message for the prefix and account.
         */
        message?: string;
        /**
         * The signed authorization message for the prefix and account.
         */
        signature?: string;
    }

    export interface VpcIpamResourceDiscoveryOperatingRegion {
        /**
         * The name of the Region you want to add to the IPAM.
         */
        regionName: string;
    }

    export interface VpcPeeringConnectionAccepter {
        /**
         * Allow a local VPC to resolve public DNS hostnames to
         * private IP addresses when queried from instances in the peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface VpcPeeringConnectionAccepterAccepter {
        /**
         * Indicates whether a local VPC can resolve public DNS hostnames to
         * private IP addresses when queried from instances in a peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface VpcPeeringConnectionAccepterRequester {
        /**
         * Indicates whether a local VPC can resolve public DNS hostnames to
         * private IP addresses when queried from instances in a peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface VpcPeeringConnectionRequester {
        /**
         * Allow a local VPC to resolve public DNS hostnames to
         * private IP addresses when queried from instances in the peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }

    export interface VpnConnectionRoute {
        /**
         * The CIDR block associated with the local subnet of the customer data center.
         */
        destinationCidrBlock: string;
        /**
         * Indicates how the routes were provided.
         */
        source: string;
        /**
         * The current state of the static route.
         */
        state: string;
    }

    export interface VpnConnectionTunnel1LogOptions {
        /**
         * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
         */
        cloudwatchLogOptions: outputs.ec2.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions;
    }

    export interface VpnConnectionTunnel1LogOptionsCloudwatchLogOptions {
        /**
         * Enable or disable VPN tunnel logging feature. The default is `false`.
         */
        logEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
         */
        logGroupArn?: string;
        /**
         * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
         */
        logOutputFormat?: string;
    }

    export interface VpnConnectionTunnel2LogOptions {
        /**
         * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
         */
        cloudwatchLogOptions: outputs.ec2.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions;
    }

    export interface VpnConnectionTunnel2LogOptionsCloudwatchLogOptions {
        /**
         * Enable or disable VPN tunnel logging feature. The default is `false`.
         */
        logEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
         */
        logGroupArn?: string;
        /**
         * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
         */
        logOutputFormat?: string;
    }

    export interface VpnConnectionVgwTelemetry {
        /**
         * The number of accepted routes.
         */
        acceptedRouteCount: number;
        /**
         * The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
         */
        certificateArn: string;
        /**
         * The date and time of the last change in status.
         */
        lastStatusChange: string;
        /**
         * The Internet-routable IP address of the virtual private gateway's outside interface.
         */
        outsideIpAddress: string;
        /**
         * The status of the VPN tunnel.
         */
        status: string;
        /**
         * If an error occurs, a description of the error.
         */
        statusMessage: string;
    }

}

export namespace ec2clientvpn {
    export interface EndpointAuthenticationOption {
        /**
         * The ID of the Active Directory to be used for authentication if type is `directory-service-authentication`.
         */
        activeDirectoryId?: string;
        /**
         * The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Only necessary when type is set to `certificate-authentication`.
         */
        rootCertificateChainArn?: string;
        /**
         * The ARN of the IAM SAML identity provider if type is `federated-authentication`.
         */
        samlProviderArn?: string;
        /**
         * The ARN of the IAM SAML identity provider for the self service portal if type is `federated-authentication`.
         */
        selfServiceSamlProviderArn?: string;
        /**
         * The type of client authentication to be used. Specify `certificate-authentication` to use certificate-based authentication, `directory-service-authentication` to use Active Directory authentication, or `federated-authentication` to use Federated Authentication via SAML 2.0.
         */
        type: string;
    }

    export interface EndpointClientConnectOptions {
        /**
         * Indicates whether client connect options are enabled. The default is `false` (not enabled).
         */
        enabled: boolean;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function used for connection authorization.
         */
        lambdaFunctionArn: string;
    }

    export interface EndpointClientLoginBannerOptions {
        /**
         * Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters.
         */
        bannerText: string;
        /**
         * Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established. The default is `false` (not enabled).
         */
        enabled: boolean;
    }

    export interface EndpointConnectionLogOptions {
        /**
         * The name of the CloudWatch Logs log group.
         */
        cloudwatchLogGroup?: string;
        /**
         * The name of the CloudWatch Logs log stream to which the connection data is published.
         */
        cloudwatchLogStream: string;
        /**
         * Indicates whether connection logging is enabled.
         */
        enabled: boolean;
    }

    export interface GetEndpointAuthenticationOption {
        activeDirectoryId: string;
        rootCertificateChainArn: string;
        samlProviderArn: string;
        selfServiceSamlProviderArn: string;
        type: string;
    }

    export interface GetEndpointClientConnectOption {
        enabled: boolean;
        lambdaFunctionArn: string;
    }

    export interface GetEndpointClientLoginBannerOption {
        bannerText: string;
        enabled: boolean;
    }

    export interface GetEndpointConnectionLogOption {
        cloudwatchLogGroup: string;
        cloudwatchLogStream: string;
        enabled: boolean;
    }

    export interface GetEndpointFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeClientVpnEndpoints.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An endpoint will be selected if any one of the given values matches.
         */
        values: string[];
    }

}

export namespace ec2transitgateway {
    export interface GetAttachmentFilter {
        /**
         * Name of the field to filter by, as defined by the [underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetAttachmentsFilter {
        /**
         * Name of the filter check available value on [official documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html)
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetConnectFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetConnectPeerFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetDirectConnectGatewayAttachmentFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeTransitGatewayAttachments API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetMulticastDomainAssociation {
        /**
         * The ID of the subnet associated with the transit gateway multicast domain.
         */
        subnetId: string;
        /**
         * The ID of the transit gateway attachment.
         */
        transitGatewayAttachmentId: string;
    }

    export interface GetMulticastDomainFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayMulticastDomains.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A multicast domain will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetMulticastDomainMember {
        /**
         * The IP address assigned to the transit gateway multicast group.
         */
        groupIpAddress: string;
        /**
         * The group members' network interface ID.
         */
        networkInterfaceId: string;
    }

    export interface GetMulticastDomainSource {
        /**
         * The IP address assigned to the transit gateway multicast group.
         */
        groupIpAddress: string;
        /**
         * The group members' network interface ID.
         */
        networkInterfaceId: string;
    }

    export interface GetPeeringAttachmentFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayPeeringAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An EC2 Transit Gateway Peering Attachment be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetRouteTableAssociationsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetTransitGatewayRouteTableAssociations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetRouteTableFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetRouteTablePropagationsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetTransitGatewayRouteTablePropagations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }

    export interface GetTransitGatewayFilter {
        /**
         * Name of the field to filter by, as defined by the [underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGateways.html).
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetVpcAttachmentFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetVpcAttachmentsFilter {
        /**
         * Name of the filter check available value on [official documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayVpcAttachments.html)
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }

    export interface GetVpnAttachmentFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeTransitGatewayAttachments API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface InstanceConnectEndpointTimeouts {
        create?: string;
        delete?: string;
    }

}

export namespace ecr {
    export interface GetRepositoryEncryptionConfiguration {
        /**
         * Encryption type to use for the repository, either `AES256` or `KMS`.
         */
        encryptionType: string;
        /**
         * If `encryptionType` is `KMS`, the ARN of the KMS key used.
         */
        kmsKey: string;
    }

    export interface GetRepositoryImageScanningConfiguration {
        /**
         * Whether images are scanned after being pushed to the repository.
         */
        scanOnPush: boolean;
    }

    export interface RegistryScanningConfigurationRule {
        /**
         * One or more repository filter blocks, containing a `filter` (required string filtering repositories, see pattern regex [here](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_ScanningRepositoryFilter.html)) and a `filterType` (required string, currently only `WILDCARD` is supported).
         */
        repositoryFilters: outputs.ecr.RegistryScanningConfigurationRuleRepositoryFilter[];
        /**
         * The frequency that scans are performed at for a private registry. Can be `SCAN_ON_PUSH`, `CONTINUOUS_SCAN`, or `MANUAL`.
         */
        scanFrequency: string;
    }

    export interface RegistryScanningConfigurationRuleRepositoryFilter {
        filter: string;
        filterType: string;
    }

    export interface ReplicationConfigurationReplicationConfiguration {
        /**
         * The replication rules for a replication configuration. A maximum of 10 are allowed per `replicationConfiguration`. See Rule
         */
        rules: outputs.ecr.ReplicationConfigurationReplicationConfigurationRule[];
    }

    export interface ReplicationConfigurationReplicationConfigurationRule {
        /**
         * the details of a replication destination. A maximum of 25 are allowed per `rule`. See Destination.
         */
        destinations: outputs.ecr.ReplicationConfigurationReplicationConfigurationRuleDestination[];
        /**
         * filters for a replication rule. See Repository Filter.
         */
        repositoryFilters?: outputs.ecr.ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter[];
    }

    export interface ReplicationConfigurationReplicationConfigurationRuleDestination {
        /**
         * A Region to replicate to.
         */
        region: string;
        /**
         * The account ID of the destination registry to replicate to.
         */
        registryId: string;
    }

    export interface ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter {
        /**
         * The repository filter details.
         */
        filter: string;
        /**
         * The repository filter type. The only supported value is `PREFIX_MATCH`, which is a repository name prefix specified with the filter parameter.
         */
        filterType: string;
    }

    export interface RepositoryEncryptionConfiguration {
        /**
         * The encryption type to use for the repository. Valid values are `AES256` or `KMS`. Defaults to `AES256`.
         */
        encryptionType?: string;
        /**
         * The ARN of the KMS key to use when `encryptionType` is `KMS`. If not specified, uses the default AWS managed key for ECR.
         */
        kmsKey: string;
    }

    export interface RepositoryImageScanningConfiguration {
        /**
         * Indicates whether images are scanned after being pushed to the repository (true) or not scanned (false).
         */
        scanOnPush: boolean;
    }

}

export namespace ecrpublic {
    export interface RepositoryCatalogData {
        /**
         * A detailed description of the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The text must be in markdown format.
         */
        aboutText?: string;
        /**
         * The system architecture that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported architectures will appear as badges on the repository and are used as search filters: `ARM`, `ARM 64`, `x86`, `x86-64`
         */
        architectures?: string[];
        /**
         * A short description of the contents of the repository. This text appears in both the image details and also when searching for repositories on the Amazon ECR Public Gallery.
         */
        description?: string;
        /**
         * The base64-encoded repository logo payload. (Only visible for verified accounts) Note that drift detection is disabled for this attribute.
         */
        logoImageBlob: string;
        /**
         * The operating systems that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported operating systems will appear as badges on the repository and are used as search filters: `Linux`, `Windows`
         */
        operatingSystems?: string[];
        /**
         * Detailed information on how to use the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The usage text provides context, support information, and additional usage details for users of the repository. The text must be in markdown format.
         */
        usageText?: string;
    }

}

export namespace ecs {
    export interface CapacityProviderAutoScalingGroupProvider {
        /**
         * ARN of the associated auto scaling group.
         */
        autoScalingGroupArn: string;
        /**
         * Configuration block defining the parameters of the auto scaling. Detailed below.
         */
        managedScaling: outputs.ecs.CapacityProviderAutoScalingGroupProviderManagedScaling;
        /**
         * Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are `ENABLED` and `DISABLED`.
         */
        managedTerminationProtection: string;
    }

    export interface CapacityProviderAutoScalingGroupProviderManagedScaling {
        /**
         * Period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of 300 seconds is used.
         */
        instanceWarmupPeriod: number;
        /**
         * Maximum step adjustment size. A number between 1 and 10,000.
         */
        maximumScalingStepSize: number;
        /**
         * Minimum step adjustment size. A number between 1 and 10,000.
         */
        minimumScalingStepSize: number;
        /**
         * Whether auto scaling is managed by ECS. Valid values are `ENABLED` and `DISABLED`.
         */
        status: string;
        /**
         * Target utilization for the capacity provider. A number between 1 and 100.
         */
        targetCapacity: number;
    }

    export interface ClusterCapacityProvidersDefaultCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The `weight` value is taken into consideration after the `base` count of tasks has been satisfied. Defaults to `0`.
         */
        weight?: number;
    }

    export interface ClusterConfiguration {
        /**
         * The details of the execute command configuration. Detailed below.
         */
        executeCommandConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfiguration;
    }

    export interface ClusterConfigurationExecuteCommandConfiguration {
        /**
         * The AWS Key Management Service key ID to encrypt the data between the local client and the container.
         */
        kmsKeyId?: string;
        /**
         * The log configuration for the results of the execute command actions Required when `logging` is `OVERRIDE`. Detailed below.
         */
        logConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfigurationLogConfiguration;
        /**
         * The log setting to use for redirecting logs for your execute command results. Valid values are `NONE`, `DEFAULT`, and `OVERRIDE`.
         */
        logging?: string;
    }

    export interface ClusterConfigurationExecuteCommandConfigurationLogConfiguration {
        /**
         * Whether or not to enable encryption on the CloudWatch logs. If not specified, encryption will be disabled.
         */
        cloudWatchEncryptionEnabled?: boolean;
        /**
         * The name of the CloudWatch log group to send logs to.
         */
        cloudWatchLogGroupName?: string;
        /**
         * Whether or not to enable encryption on the logs sent to S3. If not specified, encryption will be disabled.
         */
        s3BucketEncryptionEnabled?: boolean;
        /**
         * The name of the S3 bucket to send logs to.
         */
        s3BucketName?: string;
        /**
         * An optional folder in the S3 bucket to place logs in.
         */
        s3KeyPrefix?: string;
    }

    export interface ClusterServiceConnectDefaults {
        /**
         * The ARN of the `aws.servicediscovery.HttpNamespace` that's used when you create a service and don't specify a Service Connect configuration.
         */
        namespace: string;
    }

    export interface ClusterSetting {
        /**
         * Name of the setting to manage. Valid values: `containerInsights`.
         */
        name: string;
        /**
         * The value to assign to the setting. Valid values are `enabled` and `disabled`.
         */
        value: string;
    }

    export interface GetClusterServiceConnectDefault {
        namespace: string;
    }

    export interface GetClusterSetting {
        name: string;
        value: string;
    }

    export interface GetTaskExecutionCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The `weight` value is taken into consideration after the `base` count of tasks has been satisfied. Defaults to `0`.
         */
        weight?: number;
    }

    export interface GetTaskExecutionNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see the [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) documentation.
         */
        assignPublicIp?: boolean;
        /**
         * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * Subnets associated with the task or service.
         */
        subnets: string[];
    }

    export interface GetTaskExecutionOverrides {
        /**
         * One or more container overrides that are sent to a task. See below.
         */
        containerOverrides?: outputs.ecs.GetTaskExecutionOverridesContainerOverride[];
        /**
         * The CPU override for the task.
         */
        cpu?: string;
        /**
         * Amazon Resource Name (ARN) of the task execution role override for the task.
         */
        executionRoleArn?: string;
        /**
         * Elastic Inference accelerator override for the task. See below.
         */
        inferenceAcceleratorOverrides?: outputs.ecs.GetTaskExecutionOverridesInferenceAcceleratorOverride[];
        /**
         * The memory override for the task.
         */
        memory?: string;
        /**
         * Amazon Resource Name (ARN) of the role that containers in this task can assume.
         */
        taskRoleArn?: string;
    }

    export interface GetTaskExecutionOverridesContainerOverride {
        /**
         * The command to send to the container that overrides the default command from the Docker image or the task definition.
         */
        commands?: string[];
        /**
         * The number of cpu units reserved for the container, instead of the default value from the task definition.
         */
        cpu?: number;
        /**
         * The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. See below.
         */
        environments?: outputs.ecs.GetTaskExecutionOverridesContainerOverrideEnvironment[];
        /**
         * The hard limit (in MiB) of memory to present to the container, instead of the default value from the task definition. If your container attempts to exceed the memory specified here, the container is killed.
         */
        memory?: number;
        /**
         * The soft limit (in MiB) of memory to reserve for the container, instead of the default value from the task definition.
         */
        memoryReservation?: number;
        /**
         * The name of the container that receives the override. This parameter is required if any override is specified.
         */
        name: string;
        /**
         * The type and amount of a resource to assign to a container, instead of the default value from the task definition. The only supported resource is a GPU. See below.
         */
        resourceRequirements?: outputs.ecs.GetTaskExecutionOverridesContainerOverrideResourceRequirement[];
    }

    export interface GetTaskExecutionOverridesContainerOverrideEnvironment {
        /**
         * The name of the key-value pair. For environment variables, this is the name of the environment variable.
         */
        key: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }

    export interface GetTaskExecutionOverridesContainerOverrideResourceRequirement {
        /**
         * The type of resource to assign to a container. Valid values are `GPU` or `InferenceAccelerator`.
         */
        type: string;
        /**
         * The value for the specified resource type. If the `GPU` type is used, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. The number of GPUs that's reserved for all containers in a task can't exceed the number of available GPUs on the container instance that the task is launched on. If the `InferenceAccelerator` type is used, the value matches the `deviceName` for an InferenceAccelerator specified in a task definition.
         */
        value: string;
    }

    export interface GetTaskExecutionOverridesInferenceAcceleratorOverride {
        /**
         * The Elastic Inference accelerator device name to override for the task. This parameter must match a deviceName specified in the task definition.
         */
        deviceName?: string;
        /**
         * The Elastic Inference accelerator type to use.
         */
        deviceType?: string;
    }

    export interface GetTaskExecutionPlacementConstraint {
        /**
         * A cluster query language expression to apply to the constraint. The expression can have a maximum length of 2000 characters. You can't specify an expression if the constraint type is `distinctInstance`.
         */
        expression?: string;
        /**
         * The type of constraint. Valid values are `distinctInstance` or `memberOf`. Use `distinctInstance` to ensure that each task in a particular group is running on a different container instance. Use `memberOf` to restrict the selection to a group of valid candidates.
         */
        type: string;
    }

    export interface GetTaskExecutionPlacementStrategy {
        /**
         * The field to apply the placement strategy against.
         */
        field?: string;
        /**
         * The type of placement strategy. Valid values are `random`, `spread`, and `binpack`.
         *
         * For more information, see the [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html) documentation.
         */
        type: string;
    }

    export interface ServiceAlarms {
        /**
         * One or more CloudWatch alarm names.
         */
        alarmNames: string[];
        /**
         * Determines whether to use the CloudWatch alarm option in the service deployment process.
         */
        enable: boolean;
        /**
         * Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
         */
        rollback: boolean;
    }

    export interface ServiceCapacityProviderStrategy {
        /**
         * Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * Relative percentage of the total number of launched tasks that should use the specified capacity provider.
         */
        weight?: number;
    }

    export interface ServiceDeploymentCircuitBreaker {
        /**
         * Whether to enable the deployment circuit breaker logic for the service.
         */
        enable: boolean;
        /**
         * Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
         */
        rollback: boolean;
    }

    export interface ServiceDeploymentController {
        /**
         * Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`, `EXTERNAL`. Default: `ECS`.
         */
        type?: string;
    }

    export interface ServiceLoadBalancer {
        /**
         * Name of the container to associate with the load balancer (as it appears in a container definition).
         */
        containerName: string;
        /**
         * Port on the container to associate with the load balancer.
         *
         * > **Version note:** Multiple `loadBalancer` configuration block support was added in version 2.22.0 of the provider. This allows configuration of [ECS service support for multiple target groups](https://aws.amazon.com/about-aws/whats-new/2019/07/amazon-ecs-services-now-support-multiple-load-balancer-target-groups/).
         */
        containerPort: number;
        /**
         * Name of the ELB (Classic) to associate with the service.
         */
        elbName?: string;
        /**
         * ARN of the Load Balancer target group to associate with the service.
         */
        targetGroupArn?: string;
    }

    export interface ServiceNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
         */
        assignPublicIp?: boolean;
        /**
         * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * Subnets associated with the task or service.
         */
        subnets: string[];
    }

    export interface ServiceOrderedPlacementStrategy {
        /**
         * For the `spread` placement strategy, valid values are `instanceId` (or `host`,
         * which has the same effect), or any platform or custom attribute that is applied to a container instance.
         * For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
         * needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
         *
         * > **Note:** for `spread`, `host` and `instanceId` will be normalized, by AWS, to be `instanceId`. This means the statefile will show `instanceId` but your config will differ if you use `host`.
         */
        field?: string;
        /**
         * Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
         */
        type: string;
    }

    export interface ServicePlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
         */
        type: string;
    }

    export interface ServiceServiceConnectConfiguration {
        /**
         * Specifies whether to use Service Connect with this service.
         */
        enabled: boolean;
        /**
         * The log configuration for the container. See below.
         */
        logConfiguration?: outputs.ecs.ServiceServiceConnectConfigurationLogConfiguration;
        /**
         * The namespace name or ARN of the `aws.servicediscovery.HttpNamespace` for use with Service Connect.
         */
        namespace?: string;
        /**
         * The list of Service Connect service objects. See below.
         */
        services?: outputs.ecs.ServiceServiceConnectConfigurationService[];
    }

    export interface ServiceServiceConnectConfigurationLogConfiguration {
        /**
         * The log driver to use for the container.
         */
        logDriver: string;
        /**
         * The configuration options to send to the log driver.
         */
        options: {[key: string]: string};
        /**
         * The secrets to pass to the log configuration. See below.
         */
        secretOptions?: outputs.ecs.ServiceServiceConnectConfigurationLogConfigurationSecretOption[];
    }

    export interface ServiceServiceConnectConfigurationLogConfigurationSecretOption {
        /**
         * The name of the secret.
         */
        name: string;
        /**
         * The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
         */
        valueFrom: string;
    }

    export interface ServiceServiceConnectConfigurationService {
        /**
         * The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
         */
        clientAlias?: outputs.ecs.ServiceServiceConnectConfigurationServiceClientAlias[];
        /**
         * The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
         */
        discoveryName?: string;
        /**
         * The port number for the Service Connect proxy to listen on.
         */
        ingressPortOverride?: number;
        /**
         * The name of one of the `portMappings` from all the containers in the task definition of this Amazon ECS service.
         */
        portName: string;
    }

    export interface ServiceServiceConnectConfigurationServiceClientAlias {
        /**
         * The name that you use in the applications of client tasks to connect to this service.
         */
        dnsName?: string;
        /**
         * The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
         */
        port: number;
    }

    export interface ServiceServiceRegistries {
        /**
         * Container name value, already specified in the task definition, to be used for your service discovery service.
         */
        containerName?: string;
        /**
         * Port value, already specified in the task definition, to be used for your service discovery service.
         */
        containerPort?: number;
        /**
         * Port value used if your Service Discovery service specified an SRV record.
         */
        port?: number;
        /**
         * ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
         */
        registryArn: string;
    }

    export interface TaskDefinitionEphemeralStorage {
        /**
         * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is `21` GiB and the maximum supported value is `200` GiB.
         */
        sizeInGib: number;
    }

    export interface TaskDefinitionInferenceAccelerator {
        /**
         * Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
         */
        deviceName: string;
        /**
         * Elastic Inference accelerator type to use.
         */
        deviceType: string;
    }

    export interface TaskDefinitionPlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. Use `memberOf` to restrict selection to a group of valid candidates. Note that `distinctInstance` is not supported in task definitions.
         */
        type: string;
    }

    export interface TaskDefinitionProxyConfiguration {
        /**
         * Name of the container that will serve as the App Mesh proxy.
         */
        containerName: string;
        /**
         * Set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
         */
        properties?: {[key: string]: string};
        /**
         * Proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
         */
        type?: string;
    }

    export interface TaskDefinitionRuntimePlatform {
        /**
         * Must be set to either `X86_64` or `ARM64`; see [cpu architecture](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform)
         */
        cpuArchitecture?: string;
        /**
         * If the `requiresCompatibilities` is `FARGATE` this field is required; must be set to a valid option from the [operating system family in the runtime platform](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform) setting
         */
        operatingSystemFamily?: string;
    }

    export interface TaskDefinitionVolume {
        /**
         * Configuration block to configure a docker volume. Detailed below.
         */
        dockerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeDockerVolumeConfiguration;
        /**
         * Configuration block for an EFS volume. Detailed below.
         */
        efsVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfiguration;
        /**
         * Configuration block for an FSX Windows File Server volume. Detailed below.
         */
        fsxWindowsFileServerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration;
        /**
         * Path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
         */
        hostPath?: string;
        /**
         * Name of the volume. This name is referenced in the `sourceVolume`
         * parameter of container definition in the `mountPoints` section.
         */
        name: string;
    }

    export interface TaskDefinitionVolumeDockerVolumeConfiguration {
        /**
         * If this value is `true`, the Docker volume is created if it does not already exist. *Note*: This field is only used if the scope is `shared`.
         */
        autoprovision?: boolean;
        /**
         * Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
         */
        driver?: string;
        /**
         * Map of Docker driver specific options.
         */
        driverOpts?: {[key: string]: string};
        /**
         * Map of custom metadata to add to your Docker volume.
         */
        labels?: {[key: string]: string};
        /**
         * Scope for the Docker volume, which determines its lifecycle, either `task` or `shared`.  Docker volumes that are scoped to a `task` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as `shared` persist after the task stops.
         */
        scope: string;
    }

    export interface TaskDefinitionVolumeEfsVolumeConfiguration {
        /**
         * Configuration block for authorization for the Amazon EFS file system. Detailed below.
         */
        authorizationConfig?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig;
        /**
         * ID of the EFS File System.
         */
        fileSystemId: string;
        /**
         * Directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using `authorizationConfig`.
         */
        rootDirectory?: string;
        /**
         * Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
         */
        transitEncryption?: string;
        /**
         * Port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
         */
        transitEncryptionPort?: number;
    }

    export interface TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig {
        /**
         * Access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
         */
        accessPointId?: string;
        /**
         * Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
         */
        iam?: string;
    }

    export interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration {
        /**
         * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
         */
        authorizationConfig: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig;
        /**
         * The Amazon FSx for Windows File Server file system ID to use.
         */
        fileSystemId: string;
        /**
         * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
         */
        rootDirectory: string;
    }

    export interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
        /**
         * The authorization credential option to use. The authorization credential options can be provided using either the Amazon Resource Name (ARN) of an AWS Secrets Manager secret or AWS Systems Manager Parameter Store parameter. The ARNs refer to the stored credentials.
         */
        credentialsParameter: string;
        /**
         * A fully qualified domain name hosted by an AWS Directory Service Managed Microsoft AD (Active Directory) or self-hosted AD on Amazon EC2.
         */
        domain: string;
    }

    export interface TaskSetCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
         */
        base?: number;
        /**
         * The short name or full Amazon Resource Name (ARN) of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
         */
        weight: number;
    }

    export interface TaskSetLoadBalancer {
        /**
         * The name of the container to associate with the load balancer (as it appears in a container definition).
         */
        containerName: string;
        /**
         * The port on the container to associate with the load balancer. Defaults to `0` if not specified.
         *
         * > **Note:** Specifying multiple `loadBalancer` configurations is still not supported by AWS for ECS task set.
         */
        containerPort?: number;
        /**
         * The name of the ELB (Classic) to associate with the service.
         */
        loadBalancerName?: string;
        /**
         * The ARN of the Load Balancer target group to associate with the service.
         */
        targetGroupArn?: string;
    }

    export interface TaskSetNetworkConfiguration {
        /**
         * Whether to assign a public IP address to the ENI (`FARGATE` launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html).
         */
        assignPublicIp?: boolean;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. Maximum of 5.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service. Maximum of 16.
         */
        subnets: string[];
    }

    export interface TaskSetScale {
        /**
         * The unit of measure for the scale value. Default: `PERCENT`.
         */
        unit?: string;
        /**
         * The value, specified as a percent total of a service's `desiredCount`, to scale the task set. Defaults to `0` if not specified. Accepted values are numbers between 0.0 and 100.0.
         */
        value?: number;
    }

    export interface TaskSetServiceRegistries {
        /**
         * The container name value, already specified in the task definition, to be used for your service discovery service.
         */
        containerName?: string;
        /**
         * The port value, already specified in the task definition, to be used for your service discovery service.
         */
        containerPort?: number;
        /**
         * The port value used if your Service Discovery service specified an SRV record.
         */
        port?: number;
        /**
         * The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service` resource). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html).
         */
        registryArn: string;
    }

}

export namespace efs {
    export interface AccessPointPosixUser {
        /**
         * POSIX group ID used for all file system operations using this access point.
         */
        gid: number;
        /**
         * Secondary POSIX group IDs used for all file system operations using this access point.
         */
        secondaryGids?: number[];
        /**
         * POSIX user ID used for all file system operations using this access point.
         */
        uid: number;
    }

    export interface AccessPointRootDirectory {
        /**
         * POSIX IDs and permissions to apply to the access point's Root Directory. See Creation Info below.
         */
        creationInfo: outputs.efs.AccessPointRootDirectoryCreationInfo;
        /**
         * Path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide `creationInfo`.
         */
        path: string;
    }

    export interface AccessPointRootDirectoryCreationInfo {
        /**
         * POSIX group ID to apply to the `rootDirectory`.
         */
        ownerGid: number;
        /**
         * POSIX user ID to apply to the `rootDirectory`.
         */
        ownerUid: number;
        /**
         * POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
         */
        permissions: string;
    }

    export interface BackupPolicyBackupPolicy {
        /**
         * A status of the backup policy. Valid values: `ENABLED`, `DISABLED`.
         */
        status: string;
    }

    export interface FileSystemLifecyclePolicy {
        /**
         * Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`.
         */
        transitionToIa?: string;
        /**
         * Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`.
         */
        transitionToPrimaryStorageClass?: string;
    }

    export interface FileSystemSizeInByte {
        /**
         * The latest known metered size (in bytes) of data stored in the file system.
         */
        value: number;
        /**
         * The latest known metered size (in bytes) of data stored in the Infrequent Access storage class.
         */
        valueInIa: number;
        /**
         * The latest known metered size (in bytes) of data stored in the Standard storage class.
         */
        valueInStandard: number;
    }

    export interface GetAccessPointPosixUser {
        /**
         * Group ID
         */
        gid: number;
        /**
         * Secondary group IDs
         */
        secondaryGids: number[];
        /**
         * User Id
         */
        uid: number;
    }

    export interface GetAccessPointRootDirectory {
        /**
         * Single element list containing information on the creation permissions of the directory
         */
        creationInfos: outputs.efs.GetAccessPointRootDirectoryCreationInfo[];
        /**
         * Path exposed as the root directory
         */
        path: string;
    }

    export interface GetAccessPointRootDirectoryCreationInfo {
        /**
         * POSIX owner group ID
         */
        ownerGid: number;
        /**
         * POSIX owner user ID
         */
        ownerUid: number;
        /**
         * POSIX permissions mode
         */
        permissions: string;
    }

    export interface GetFileSystemLifecyclePolicy {
        transitionToIa: string;
        transitionToPrimaryStorageClass: string;
    }

    export interface ReplicationConfigurationDestination {
        /**
         * The availability zone in which the replica should be created. If specified, the replica will be created with One Zone storage. If omitted, regional storage will be used.
         */
        availabilityZoneName?: string;
        fileSystemId: string;
        /**
         * The Key ID, ARN, alias, or alias ARN of the KMS key that should be used to encrypt the replica file system. If omitted, the default KMS key for EFS `/aws/elasticfilesystem` will be used.
         */
        kmsKeyId?: string;
        /**
         * The region in which the replica should be created.
         */
        region: string;
        status: string;
    }

}

export namespace eks {
    export interface ClusterCertificateAuthority {
        /**
         * Base64 encoded certificate data required to communicate with your cluster. Add this to the `certificate-authority-data` section of the `kubeconfig` file for your cluster.
         */
        data: string;
    }

    export interface ClusterEncryptionConfig {
        /**
         * Configuration block with provider for encryption. Detailed below.
         */
        provider: outputs.eks.ClusterEncryptionConfigProvider;
        /**
         * List of strings with resources to be encrypted. Valid values: `secrets`.
         */
        resources: string[];
    }

    export interface ClusterEncryptionConfigProvider {
        /**
         * ARN of the Key Management Service (KMS) customer master key (CMK). The CMK must be symmetric, created in the same region as the cluster, and if the CMK was created in a different account, the user must have access to the CMK. For more information, see [Allowing Users in Other Accounts to Use a CMK in the AWS Key Management Service Developer Guide](https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html).
         */
        keyArn: string;
    }

    export interface ClusterIdentity {
        /**
         * Nested block containing [OpenID Connect](https://openid.net/connect/) identity provider information for the cluster. Detailed below.
         */
        oidcs: outputs.eks.ClusterIdentityOidc[];
    }

    export interface ClusterIdentityOidc {
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuer: string;
    }

    export interface ClusterKubernetesNetworkConfig {
        /**
         * The IP family used to assign Kubernetes pod and service addresses. Valid values are `ipv4` (default) and `ipv6`. You can only specify an IP family when you create a cluster, changing this value will force a new cluster to be created.
         */
        ipFamily: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. You can only specify a custom CIDR block when you create a cluster, changing this value will force a new cluster to be created. The block must meet the following requirements:
         *
         * * Within one of the following private IP address blocks: 10.0.0.0/8, 172.16.0.0/12, or 192.168.0.0/16.
         *
         * * Doesn't overlap with any CIDR block assigned to the VPC that you selected for VPC.
         *
         * * Between /24 and /12.
         */
        serviceIpv4Cidr: string;
        serviceIpv6Cidr: string;
    }

    export interface ClusterOutpostConfig {
        /**
         * The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. Choose an instance type based on the number of nodes that your cluster will have. If your cluster will have:
         *
         * * 1–20 nodes, then we recommend specifying a large instance type.
         *
         * * 21–100 nodes, then we recommend specifying an xlarge instance type.
         *
         * * 101–250 nodes, then we recommend specifying a 2xlarge instance type.
         *
         * For a list of the available Amazon EC2 instance types, see Compute and storage in AWS Outposts rack features  The control plane is not automatically scaled by Amazon EKS.
         */
        controlPlaneInstanceType: string;
        /**
         * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost.
         * The following arguments are supported in the `controlPlanePlacement` configuration block:
         */
        controlPlanePlacement?: outputs.eks.ClusterOutpostConfigControlPlanePlacement;
        /**
         * The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. This argument is a list of arns, but only a single Outpost ARN is supported currently.
         */
        outpostArns: string[];
    }

    export interface ClusterOutpostConfigControlPlanePlacement {
        /**
         * The name of the placement group for the Kubernetes control plane instances. This setting can't be changed after cluster creation.
         */
        groupName: string;
    }

    export interface ClusterVpcConfig {
        /**
         * Cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.
         */
        clusterSecurityGroupId: string;
        /**
         * Whether the Amazon EKS private API server endpoint is enabled. Default is `false`.
         */
        endpointPrivateAccess?: boolean;
        /**
         * Whether the Amazon EKS public API server endpoint is enabled. Default is `true`.
         */
        endpointPublicAccess?: boolean;
        /**
         * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with `0.0.0.0/0`. The provider will only perform drift detection of its value when present in a configuration.
         */
        publicAccessCidrs: string[];
        /**
         * List of security group IDs for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane.
         */
        securityGroupIds?: string[];
        /**
         * List of subnet IDs. Must be in at least two different availability zones. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your worker nodes and the Kubernetes control plane.
         */
        subnetIds: string[];
        /**
         * ID of the VPC associated with your cluster.
         */
        vpcId: string;
    }

    export interface FargateProfileSelector {
        /**
         * Key-value map of Kubernetes labels for selection.
         */
        labels?: {[key: string]: string};
        /**
         * Kubernetes namespace for selection.
         *
         * The following arguments are optional:
         */
        namespace: string;
    }

    export interface GetClusterCertificateAuthority {
        /**
         * The base64 encoded certificate data required to communicate with your cluster. Add this to the `certificate-authority-data` section of the `kubeconfig` file for your cluster.
         */
        data: string;
    }

    export interface GetClusterIdentity {
        /**
         * Nested attribute containing [OpenID Connect](https://openid.net/connect/) identity provider information for the cluster.
         */
        oidcs: outputs.eks.GetClusterIdentityOidc[];
    }

    export interface GetClusterIdentityOidc {
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuer: string;
    }

    export interface GetClusterKubernetesNetworkConfig {
        /**
         * `ipv4` or `ipv6`.
         */
        ipFamily: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from if `ipv4` was specified when the cluster was created.
         */
        serviceIpv4Cidr: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from if `ipv6` was specified when the cluster was created. Kubernetes assigns service addresses from the unique local address range (fc00::/7) because you can't specify a custom IPv6 CIDR block when you create the cluster.
         */
        serviceIpv6Cidr: string;
    }

    export interface GetClusterOutpostConfig {
        /**
         * The Amazon EC2 instance type for all Kubernetes control plane instances.
         */
        controlPlaneInstanceType: string;
        /**
         * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost.
         */
        controlPlanePlacements: outputs.eks.GetClusterOutpostConfigControlPlanePlacement[];
        /**
         * List of ARNs of the Outposts hosting the EKS cluster. Only a single ARN is supported currently.
         */
        outpostArns: string[];
    }

    export interface GetClusterOutpostConfigControlPlanePlacement {
        /**
         * The name of the placement group for the Kubernetes control plane instances.
         */
        groupName: string;
    }

    export interface GetClusterVpcConfig {
        /**
         * The cluster security group that was created by Amazon EKS for the cluster.
         */
        clusterSecurityGroupId: string;
        /**
         * Indicates whether or not the Amazon EKS private API server endpoint is enabled.
         */
        endpointPrivateAccess: boolean;
        /**
         * Indicates whether or not the Amazon EKS public API server endpoint is enabled.
         */
        endpointPublicAccess: boolean;
        /**
         * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint.
         */
        publicAccessCidrs: string[];
        /**
         * List of security group IDs
         */
        securityGroupIds: string[];
        /**
         * List of subnet IDs
         */
        subnetIds: string[];
        /**
         * The VPC associated with your cluster.
         */
        vpcId: string;
    }

    export interface GetNodeGroupLaunchTemplate {
        /**
         * The ID of the launch template.
         */
        id: string;
        /**
         * Name of the AutoScaling Group.
         */
        name: string;
        /**
         * Kubernetes version.
         */
        version: string;
    }

    export interface GetNodeGroupRemoteAccess {
        /**
         * EC2 Key Pair name that provides access for SSH communication with the worker nodes in the EKS Node Group.
         */
        ec2SshKey: string;
        /**
         * Set of EC2 Security Group IDs to allow SSH access (port 22) from on the worker nodes.
         */
        sourceSecurityGroupIds: string[];
    }

    export interface GetNodeGroupResource {
        /**
         * List of objects containing information about AutoScaling Groups.
         */
        autoscalingGroups: outputs.eks.GetNodeGroupResourceAutoscalingGroup[];
        /**
         * Identifier of the remote access EC2 Security Group.
         */
        remoteAccessSecurityGroupId: string;
    }

    export interface GetNodeGroupResourceAutoscalingGroup {
        /**
         * Name of the AutoScaling Group.
         */
        name: string;
    }

    export interface GetNodeGroupScalingConfig {
        /**
         * Desired number of worker nodes.
         */
        desiredSize: number;
        /**
         * Maximum number of worker nodes.
         */
        maxSize: number;
        /**
         * Minimum number of worker nodes.
         */
        minSize: number;
    }

    export interface GetNodeGroupTaint {
        /**
         * The effect of the taint.
         */
        effect: string;
        /**
         * The key of the taint.
         */
        key: string;
        /**
         * The value of the taint.
         */
        value: string;
    }

    export interface IdentityProviderConfigOidc {
        /**
         * Client ID for the OpenID Connect identity provider.
         */
        clientId: string;
        /**
         * The JWT claim that the provider will use to return groups.
         */
        groupsClaim?: string;
        /**
         * A prefix that is prepended to group claims e.g., `oidc:`.
         */
        groupsPrefix?: string;
        /**
         * The name of the identity provider config.
         */
        identityProviderConfigName: string;
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuerUrl: string;
        /**
         * The key value pairs that describe required claims in the identity token.
         */
        requiredClaims?: {[key: string]: string};
        /**
         * The JWT claim that the provider will use as the username.
         */
        usernameClaim?: string;
        /**
         * A prefix that is prepended to username claims.
         */
        usernamePrefix?: string;
    }

    export interface NodeGroupLaunchTemplate {
        /**
         * Identifier of the EC2 Launch Template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the EC2 Launch Template. Conflicts with `id`.
         */
        name: string;
        /**
         * EC2 Launch Template version number. While the API accepts values like `$Default` and `$Latest`, the API will convert the value to the associated version number (e.g., `1`) on read and the provider will show a difference on next plan. Using the `defaultVersion` or `latestVersion` attribute of the `aws.ec2.LaunchTemplate` resource or data source is recommended for this argument.
         */
        version: string;
    }

    export interface NodeGroupRemoteAccess {
        /**
         * EC2 Key Pair name that provides access for remote communication with the worker nodes in the EKS Node Group. If you specify this configuration, but do not specify `sourceSecurityGroupIds` when you create an EKS Node Group, either port 3389 for Windows, or port 22 for all other operating systems is opened on the worker nodes to the Internet (0.0.0.0/0). For Windows nodes, this will allow you to use RDP, for all others this allows you to SSH into the worker nodes.
         */
        ec2SshKey?: string;
        /**
         * Set of EC2 Security Group IDs to allow SSH access (port 22) from on the worker nodes. If you specify `ec2SshKey`, but do not specify this configuration when you create an EKS Node Group, port 22 on the worker nodes is opened to the Internet (0.0.0.0/0).
         */
        sourceSecurityGroupIds?: string[];
    }

    export interface NodeGroupResource {
        /**
         * List of objects containing information about AutoScaling Groups.
         */
        autoscalingGroups: outputs.eks.NodeGroupResourceAutoscalingGroup[];
        /**
         * Identifier of the remote access EC2 Security Group.
         */
        remoteAccessSecurityGroupId: string;
    }

    export interface NodeGroupResourceAutoscalingGroup {
        /**
         * Name of the EC2 Launch Template. Conflicts with `id`.
         */
        name: string;
    }

    export interface NodeGroupScalingConfig {
        /**
         * Desired number of worker nodes.
         */
        desiredSize: number;
        /**
         * Maximum number of worker nodes.
         */
        maxSize: number;
        /**
         * Minimum number of worker nodes.
         */
        minSize: number;
    }

    export interface NodeGroupTaint {
        /**
         * The effect of the taint. Valid values: `NO_SCHEDULE`, `NO_EXECUTE`, `PREFER_NO_SCHEDULE`.
         */
        effect: string;
        /**
         * The key of the taint. Maximum length of 63.
         */
        key: string;
        /**
         * The value of the taint. Maximum length of 63.
         */
        value?: string;
    }

    export interface NodeGroupUpdateConfig {
        /**
         * Desired max number of unavailable worker nodes during node group update.
         */
        maxUnavailable?: number;
        /**
         * Desired max percentage of unavailable worker nodes during node group update.
         */
        maxUnavailablePercentage?: number;
    }

}

export namespace elasticache {
    export interface ClusterCacheNode {
        address: string;
        /**
         * Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use `preferredAvailabilityZones` instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
         */
        availabilityZone: string;
        id: string;
        outpostArn: string;
        /**
         * The port number on which each of the cache nodes will accept connections. For Memcached the default is 11211, and for Redis the default port is 6379. Cannot be provided with `replicationGroupId`. Changing this value will re-create the resource.
         */
        port: number;
    }

    export interface ClusterLogDeliveryConfiguration {
        /**
         * Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
         */
        destination: string;
        /**
         * For CloudWatch Logs use `cloudwatch-logs` or for Kinesis Data Firehose use `kinesis-firehose`.
         */
        destinationType: string;
        /**
         * Valid values are `json` or `text`
         */
        logFormat: string;
        /**
         * Valid values are  `slow-log` or `engine-log`. Max 1 of each.
         */
        logType: string;
    }

    export interface GetClusterCacheNode {
        address: string;
        /**
         * Availability Zone for the cache cluster.
         */
        availabilityZone: string;
        id: string;
        outpostArn: string;
        /**
         * The port number on which each of the cache nodes will
         * accept connections.
         */
        port: number;
    }

    export interface GetClusterLogDeliveryConfiguration {
        destination: string;
        destinationType: string;
        logFormat: string;
        logType: string;
    }

    export interface GetReplicationGroupLogDeliveryConfiguration {
        destination: string;
        destinationType: string;
        logFormat: string;
        logType: string;
    }

    export interface GetUserAuthenticationMode {
        passwordCount?: number;
        type?: string;
    }

    export interface GlobalReplicationGroupGlobalNodeGroup {
        /**
         * The ID of the global node group.
         */
        globalNodeGroupId: string;
        /**
         * The keyspace for this node group.
         */
        slots: string;
    }

    export interface ParameterGroupParameter {
        /**
         * The name of the ElastiCache parameter.
         */
        name: string;
        /**
         * The value of the ElastiCache parameter.
         */
        value: string;
    }

    export interface ReplicationGroupLogDeliveryConfiguration {
        /**
         * Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
         */
        destination: string;
        /**
         * For CloudWatch Logs use `cloudwatch-logs` or for Kinesis Data Firehose use `kinesis-firehose`.
         */
        destinationType: string;
        /**
         * Valid values are `json` or `text`
         */
        logFormat: string;
        /**
         * Valid values are  `slow-log` or `engine-log`. Max 1 of each.
         */
        logType: string;
    }

    export interface UserAuthenticationMode {
        passwordCount: number;
        /**
         * Specifies the passwords to use for authentication if `type` is set to `password`.
         */
        passwords?: string[];
        /**
         * Specifies the authentication type. Possible options are: `password`, `no-password-required` or `iam`.
         */
        type: string;
    }

}

export namespace elasticbeanstalk {
    export interface ApplicationAppversionLifecycle {
        /**
         * Set to `true` to delete a version's source bundle from S3 when the application version is deleted.
         */
        deleteSourceFromS3?: boolean;
        /**
         * The number of days to retain an application version ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
         */
        maxAgeInDays?: number;
        /**
         * The maximum number of application versions to retain ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
         */
        maxCount?: number;
        /**
         * The ARN of an IAM service role under which the application version is deleted.  Elastic Beanstalk must have permission to assume this role.
         */
        serviceRole: string;
    }

    export interface ConfigurationTemplateSetting {
        /**
         * A unique name for this Template.
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }

    export interface EnvironmentAllSetting {
        /**
         * A unique name for this Environment. This name is used
         * in the application URL
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }

    export interface EnvironmentSetting {
        /**
         * A unique name for this Environment. This name is used
         * in the application URL
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }

    export interface GetApplicationAppversionLifecycle {
        /**
         * Specifies whether delete a version's source bundle from S3 when the application version is deleted.
         */
        deleteSourceFromS3: boolean;
        /**
         * Number of days to retain an application version.
         */
        maxAgeInDays: number;
        /**
         * Maximum number of application versions to retain.
         */
        maxCount: number;
        /**
         * ARN of an IAM service role under which the application version is deleted.  Elastic Beanstalk must have permission to assume this role.
         */
        serviceRole: string;
    }

}

export namespace elasticsearch {
    export interface DomainAdvancedSecurityOptions {
        /**
         * Whether advanced security is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled. If not set, defaults to `false` by the AWS API.
         */
        internalUserDatabaseEnabled?: boolean;
        /**
         * Configuration block for the main user. Detailed below.
         */
        masterUserOptions?: outputs.elasticsearch.DomainAdvancedSecurityOptionsMasterUserOptions;
    }

    export interface DomainAdvancedSecurityOptionsMasterUserOptions {
        /**
         * ARN for the main user. Only specify if `internalUserDatabaseEnabled` is not set or set to `false`.
         */
        masterUserArn?: string;
        /**
         * Main user's username, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserName?: string;
        /**
         * Main user's password, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserPassword?: string;
    }

    export interface DomainAutoTuneOptions {
        /**
         * The Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
         */
        desiredState: string;
        /**
         * Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
         */
        maintenanceSchedules: outputs.elasticsearch.DomainAutoTuneOptionsMaintenanceSchedule[];
        /**
         * Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
         */
        rollbackOnDisable: string;
    }

    export interface DomainAutoTuneOptionsMaintenanceSchedule {
        /**
         * A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
         */
        duration: outputs.elasticsearch.DomainAutoTuneOptionsMaintenanceScheduleDuration;
        /**
         * Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }

    export interface DomainAutoTuneOptionsMaintenanceScheduleDuration {
        /**
         * The unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
         */
        unit: string;
        /**
         * An integer specifying the value of the duration of an Auto-Tune maintenance window.
         */
        value: number;
    }

    export interface DomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration. Detailed below.
         */
        coldStorageOptions: outputs.elasticsearch.DomainClusterConfigColdStorageOptions;
        /**
         * Number of dedicated main nodes in the cluster.
         */
        dedicatedMasterCount?: number;
        /**
         * Whether dedicated main nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled?: boolean;
        /**
         * Instance type of the dedicated main nodes in the cluster.
         */
        dedicatedMasterType?: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount?: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType?: string;
        /**
         * Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warmCount` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmCount?: number;
        /**
         * Whether to enable warm storage.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the Elasticsearch cluster's warm nodes. Valid values are `ultrawarm1.medium.elasticsearch`, `ultrawarm1.large.elasticsearch` and `ultrawarm1.xlarge.elasticsearch`. `warmType` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmType?: string;
        /**
         * Configuration block containing zone awareness settings. Detailed below.
         */
        zoneAwarenessConfig?: outputs.elasticsearch.DomainClusterConfigZoneAwarenessConfig;
        /**
         * Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availabilityZoneCount` within the `zoneAwarenessConfig` must be set to `3`.
         */
        zoneAwarenessEnabled?: boolean;
    }

    export interface DomainClusterConfigColdStorageOptions {
        /**
         * Boolean to enable cold storage for an Elasticsearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
         */
        enabled: boolean;
    }

    export interface DomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of Availability Zones for the domain to use with `zoneAwarenessEnabled`. Defaults to `2`. Valid values: `2` or `3`.
         */
        availabilityZoneCount?: number;
    }

    export interface DomainCognitoOptions {
        /**
         * Whether Amazon Cognito authentication with Kibana is enabled or not.
         */
        enabled?: boolean;
        /**
         * ID of the Cognito Identity Pool to use.
         */
        identityPoolId: string;
        /**
         * ARN of the IAM role that has the AmazonESCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * ID of the Cognito User Pool to use.
         */
        userPoolId: string;
    }

    export interface DomainDomainEndpointOptions {
        /**
         * Fully qualified domain for your custom endpoint.
         */
        customEndpoint?: string;
        /**
         * ACM certificate ARN for your custom endpoint.
         */
        customEndpointCertificateArn?: string;
        /**
         * Whether to enable custom endpoint for the Elasticsearch domain.
         */
        customEndpointEnabled?: boolean;
        /**
         * Whether or not to require HTTPS. Defaults to `true`.
         */
        enforceHttps?: boolean;
        /**
         * Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
         */
        tlsSecurityPolicy: string;
    }

    export interface DomainEbsOptions {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
         */
        iops: number;
        /**
         * Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GiB).
         */
        volumeSize?: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }

    export interface DomainEncryptAtRest {
        /**
         * Whether to enable encryption at rest. If the `encryptAtRest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires `elasticsearchVersion` 5.1 or greater.
         */
        enabled: boolean;
        /**
         * KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
         */
        kmsKeyId: string;
    }

    export interface DomainLogPublishingOption {
        /**
         * ARN of the Cloudwatch log group to which log needs to be published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether given log publishing option is enabled or not.
         */
        enabled?: boolean;
        /**
         * Type of Elasticsearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
         */
        logType: string;
    }

    export interface DomainNodeToNodeEncryption {
        /**
         * Whether to enable node-to-node encryption. If the `nodeToNodeEncryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `elasticsearchVersion` of `6.0` or greater.
         */
        enabled: boolean;
    }

    export interface DomainSamlOptionsSamlOptions {
        /**
         * Whether SAML authentication is enabled.
         */
        enabled?: boolean;
        /**
         * Information from your identity provider.
         */
        idp?: outputs.elasticsearch.DomainSamlOptionsSamlOptionsIdp;
        /**
         * This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterBackendRole?: string;
        /**
         * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterUserName?: string;
        /**
         * Element of the SAML assertion to use for backend roles. Default is roles.
         */
        rolesKey?: string;
        /**
         * Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
         */
        sessionTimeoutMinutes?: number;
        /**
         * Custom SAML attribute to use for user names. Default is an empty string - `""`. This will cause Elasticsearch to use the `NameID` element of the `Subject`, which is the default location for name identifiers in the SAML specification.
         */
        subjectKey?: string;
    }

    export interface DomainSamlOptionsSamlOptionsIdp {
        /**
         * The unique Entity ID of the application in SAML Identity Provider.
         */
        entityId: string;
        /**
         * The Metadata of the SAML application in xml format.
         */
        metadataContent: string;
    }

    export interface DomainSnapshotOptions {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }

    export interface DomainVpcOptions {
        availabilityZones: string[];
        /**
         * List of VPC Security Group IDs to be applied to the Elasticsearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
         */
        securityGroupIds?: string[];
        /**
         * List of VPC Subnet IDs for the Elasticsearch domain endpoints to be created in.
         */
        subnetIds?: string[];
        vpcId: string;
    }

    export interface GetDomainAdvancedSecurityOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled.
         */
        internalUserDatabaseEnabled: boolean;
    }

    export interface GetDomainAutoTuneOption {
        /**
         * The Auto-Tune desired state for the domain.
         */
        desiredState: string;
        /**
         * A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
         */
        maintenanceSchedules: outputs.elasticsearch.GetDomainAutoTuneOptionMaintenanceSchedule[];
        /**
         * Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
         */
        rollbackOnDisable: string;
    }

    export interface GetDomainAutoTuneOptionMaintenanceSchedule {
        /**
         * Cron expression for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window.
         */
        durations: outputs.elasticsearch.GetDomainAutoTuneOptionMaintenanceScheduleDuration[];
        /**
         * Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }

    export interface GetDomainAutoTuneOptionMaintenanceScheduleDuration {
        /**
         * Unit of time.
         */
        unit: string;
        /**
         * Duration of an Auto-Tune maintenance window.
         */
        value: number;
    }

    export interface GetDomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration.
         */
        coldStorageOptions: outputs.elasticsearch.GetDomainClusterConfigColdStorageOption[];
        /**
         * Number of dedicated master nodes in the cluster.
         */
        dedicatedMasterCount: number;
        /**
         * Indicates whether dedicated master nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled: boolean;
        /**
         * Instance type of the dedicated master nodes in the cluster.
         */
        dedicatedMasterType: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType: string;
        /**
         * The number of warm nodes in the cluster.
         */
        warmCount: number;
        /**
         * Warm storage is enabled.
         */
        warmEnabled: boolean;
        /**
         * The instance type for the Elasticsearch cluster's warm nodes.
         */
        warmType: string;
        /**
         * Configuration block containing zone awareness settings.
         */
        zoneAwarenessConfigs: outputs.elasticsearch.GetDomainClusterConfigZoneAwarenessConfig[];
        /**
         * Indicates whether zone awareness is enabled.
         */
        zoneAwarenessEnabled: boolean;
    }

    export interface GetDomainClusterConfigColdStorageOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
    }

    export interface GetDomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of availability zones used.
         */
        availabilityZoneCount: number;
    }

    export interface GetDomainCognitoOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The Cognito Identity pool used by the domain.
         */
        identityPoolId: string;
        /**
         * The IAM Role with the AmazonESCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * The Cognito User pool used by the domain.
         */
        userPoolId: string;
    }

    export interface GetDomainEbsOption {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * The baseline input/output (I/O) performance of EBS volumes attached to data nodes.
         */
        iops: number;
        /**
         * The throughput (in MiB/s) of the EBS volumes attached to data nodes.
         */
        throughput: number;
        /**
         * The size of EBS volumes attached to data nodes (in GB).
         */
        volumeSize: number;
        /**
         * The type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }

    export interface GetDomainEncryptionAtRest {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The KMS key id used to encrypt data at rest.
         */
        kmsKeyId: string;
    }

    export interface GetDomainLogPublishingOption {
        /**
         * The CloudWatch Log Group where the logs are published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The type of Elasticsearch log being published.
         */
        logType: string;
    }

    export interface GetDomainNodeToNodeEncryption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
    }

    export interface GetDomainSnapshotOption {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }

    export interface GetDomainVpcOption {
        /**
         * The availability zones used by the domain.
         */
        availabilityZones: string[];
        /**
         * The security groups used by the domain.
         */
        securityGroupIds: string[];
        /**
         * The subnets used by the domain.
         */
        subnetIds: string[];
        /**
         * The VPC used by the domain.
         */
        vpcId: string;
    }

}

export namespace elastictranscoder {
    export interface PipelineContentConfig {
        /**
         * The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists.
         */
        bucket: string;
        /**
         * The Amazon S3 storage class, `Standard` or `ReducedRedundancy`, that you want Elastic Transcoder to assign to the files and playlists that it stores in your Amazon S3 bucket.
         */
        storageClass?: string;
    }

    export interface PipelineContentConfigPermission {
        /**
         * The permission that you want to give to the AWS user that you specified in `content_config_permissions.grantee`. Valid values are `Read`, `ReadAcp`, `WriteAcp` or `FullControl`.
         */
        accesses?: string[];
        /**
         * The AWS user or group that you want to have access to transcoded files and playlists.
         */
        grantee?: string;
        /**
         * Specify the type of value that appears in the `content_config_permissions.grantee` object. Valid values are `Canonical`, `Email` or `Group`.
         */
        granteeType?: string;
    }

    export interface PipelineNotifications {
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder has finished processing a job in this pipeline.
         */
        completed?: string;
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters an error condition while processing a job in this pipeline.
         */
        error?: string;
        /**
         * The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify when Elastic Transcoder has started to process a job in this pipeline.
         */
        progressing?: string;
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters a warning condition while processing a job in this pipeline.
         *
         * The `thumbnailConfig` object specifies information about the Amazon S3 bucket in
         * which you want Elastic Transcoder to save thumbnail files: which bucket to use,
         * which users you want to have access to the files, the type of access you want
         * users to have, and the storage class that you want to assign to the files. If
         * you specify values for `contentConfig`, you must also specify values for
         * `thumbnailConfig` even if you don't want to create thumbnails. (You control
         * whether to create thumbnails when you create a job. For more information, see
         * ThumbnailPattern in the topic Create Job.) If you specify values for
         * `contentConfig` and `thumbnailConfig`, omit the OutputBucket object.
         */
        warning?: string;
    }

    export interface PipelineThumbnailConfig {
        /**
         * The Amazon S3 bucket in which you want Elastic Transcoder to save thumbnail files.
         */
        bucket: string;
        /**
         * The Amazon S3 storage class, Standard or ReducedRedundancy, that you want Elastic Transcoder to assign to the thumbnails that it stores in your Amazon S3 bucket.
         */
        storageClass?: string;
    }

    export interface PipelineThumbnailConfigPermission {
        /**
         * The permission that you want to give to the AWS user that you specified in `thumbnail_config_permissions.grantee`. Valid values are `Read`, `ReadAcp`, `WriteAcp` or `FullControl`.
         */
        accesses?: string[];
        /**
         * The AWS user or group that you want to have access to thumbnail files.
         */
        grantee?: string;
        /**
         * Specify the type of value that appears in the `thumbnail_config_permissions.grantee` object. Valid values are `Canonical`, `Email` or `Group`.
         */
        granteeType?: string;
    }

    export interface PresetAudio {
        /**
         * The method of organizing audio channels and tracks. Use Audio:Channels to specify the number of channels in your output, and Audio:AudioPackingMode to specify the number of tracks and their relation to the channels. If you do not specify an Audio:AudioPackingMode, Elastic Transcoder uses SingleTrack.
         */
        audioPackingMode?: string;
        /**
         * The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer between 64 and 320, inclusive.
         */
        bitRate: string;
        /**
         * The number of audio channels in the output file
         */
        channels?: string;
        /**
         * The audio codec for the output file. Valid values are `AAC`, `flac`, `mp2`, `mp3`, `pcm`, and `vorbis`.
         */
        codec?: string;
        /**
         * The sample rate of the audio stream in the output file, in hertz. Valid values are: `auto`, `22050`, `32000`, `44100`, `48000`, `96000`
         */
        sampleRate?: string;
    }

    export interface PresetAudioCodecOptions {
        /**
         * The bit depth of a sample is how many bits of information are included in the audio samples. Valid values are `16` and `24`. (FLAC/PCM Only)
         */
        bitDepth: string;
        /**
         * The order the bits of a PCM sample are stored in. The supported value is LittleEndian. (PCM Only)
         */
        bitOrder: string;
        /**
         * If you specified AAC for Audio:Codec, choose the AAC profile for the output file.
         */
        profile: string;
        /**
         * Whether audio samples are represented with negative and positive numbers (signed) or only positive numbers (unsigned). The supported value is Signed. (PCM Only)
         */
        signed: string;
    }

    export interface PresetThumbnails {
        /**
         * The aspect ratio of thumbnails. The following values are valid: auto, 1:1, 4:3, 3:2, 16:9
         */
        aspectRatio?: string;
        /**
         * The format of thumbnails, if any. Valid formats are jpg and png.
         */
        format?: string;
        /**
         * The approximate number of seconds between thumbnails. The value must be an integer. The actual interval can vary by several seconds from one thumbnail to the next.
         */
        interval?: string;
        /**
         * The maximum height of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 3072, inclusive.
         */
        maxHeight?: string;
        /**
         * The maximum width of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 4096, inclusive.
         */
        maxWidth?: string;
        /**
         * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of thumbnails to make the total size of the thumbnails match the values that you specified for thumbnail MaxWidth and MaxHeight settings.
         */
        paddingPolicy?: string;
        /**
         * The width and height of thumbnail files in pixels, in the format WidthxHeight, where both values are even integers. The values cannot exceed the width and height that you specified in the Video:Resolution object. (To better control resolution and aspect ratio of thumbnails, we recommend that you use the thumbnail values `maxWidth`, `maxHeight`, `sizingPolicy`, and `paddingPolicy` instead of `resolution` and `aspectRatio`. The two groups of settings are mutually exclusive. Do not use them together)
         */
        resolution?: string;
        /**
         * A value that controls scaling of thumbnails. Valid values are: `Fit`, `Fill`, `Stretch`, `Keep`, `ShrinkToFit`, and `ShrinkToFill`.
         */
        sizingPolicy?: string;
    }

    export interface PresetVideo {
        /**
         * The display aspect ratio of the video in the output file. Valid values are: `auto`, `1:1`, `4:3`, `3:2`, `16:9`. (Note; to better control resolution and aspect ratio of output videos, we recommend that you use the values `maxWidth`, `maxHeight`, `sizingPolicy`, `paddingPolicy`, and `displayAspectRatio` instead of `resolution` and `aspectRatio`.)
         */
        aspectRatio?: string;
        /**
         * The bit rate of the video stream in the output file, in kilobits/second. You can configure variable bit rate or constant bit rate encoding.
         */
        bitRate: string;
        /**
         * The video codec for the output file. Valid values are `gif`, `H.264`, `mpeg2`, `vp8`, and `vp9`.
         */
        codec?: string;
        /**
         * The value that Elastic Transcoder adds to the metadata in the output file. If you set DisplayAspectRatio to auto, Elastic Transcoder chooses an aspect ratio that ensures square pixels. If you specify another option, Elastic Transcoder sets that value in the output file.
         */
        displayAspectRatio?: string;
        /**
         * Whether to use a fixed value for Video:FixedGOP. Not applicable for containers of type gif. Valid values are true and false. Also known as, Fixed Number of Frames Between Keyframes.
         */
        fixedGop?: string;
        /**
         * The frames per second for the video stream in the output file. The following values are valid: `auto`, `10`, `15`, `23.97`, `24`, `25`, `29.97`, `30`, `50`, `60`.
         */
        frameRate?: string;
        /**
         * The maximum number of frames between key frames. Not applicable for containers of type gif.
         */
        keyframesMaxDist?: string;
        /**
         * If you specify auto for FrameRate, Elastic Transcoder uses the frame rate of the input video for the frame rate of the output video, up to the maximum frame rate. If you do not specify a MaxFrameRate, Elastic Transcoder will use a default of 30.
         */
        maxFrameRate: string;
        /**
         * The maximum height of the output video in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 96 and 3072, inclusive.
         */
        maxHeight?: string;
        /**
         * The maximum width of the output video in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 128 and 4096, inclusive.
         */
        maxWidth?: string;
        /**
         * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of the output video to make the total size of the output video match the values that you specified for `maxWidth` and `maxHeight`.
         */
        paddingPolicy?: string;
        /**
         * The width and height of the video in the output file, in pixels. Valid values are `auto` and `widthxheight`. (see note for `aspectRatio`)
         */
        resolution?: string;
        /**
         * A value that controls scaling of the output video. Valid values are: `Fit`, `Fill`, `Stretch`, `Keep`, `ShrinkToFit`, `ShrinkToFill`.
         */
        sizingPolicy?: string;
    }

    export interface PresetVideoWatermark {
        /**
         * The horizontal position of the watermark unless you specify a nonzero value for `horzontalOffset`.
         */
        horizontalAlign?: string;
        /**
         * The amount by which you want the horizontal position of the watermark to be offset from the position specified by `horizontalAlign`.
         */
        horizontalOffset?: string;
        /**
         * A unique identifier for the settings for one watermark. The value of Id can be up to 40 characters long. You can specify settings for up to four watermarks.
         */
        id?: string;
        /**
         * The maximum height of the watermark.
         */
        maxHeight?: string;
        /**
         * The maximum width of the watermark.
         */
        maxWidth?: string;
        /**
         * A percentage that indicates how much you want a watermark to obscure the video in the location where it appears.
         */
        opacity?: string;
        /**
         * A value that controls scaling of the watermark. Valid values are: `Fit`, `Stretch`, `ShrinkToFit`
         */
        sizingPolicy?: string;
        /**
         * A value that determines how Elastic Transcoder interprets values that you specified for `video_watermarks.horizontal_offset`, `video_watermarks.vertical_offset`, `video_watermarks.max_width`, and `video_watermarks.max_height`. Valid values are `Content` and `Frame`.
         */
        target?: string;
        /**
         * The vertical position of the watermark unless you specify a nonzero value for `verticalAlign`. Valid values are `Top`, `Bottom`, `Center`.
         */
        verticalAlign?: string;
        /**
         * The amount by which you want the vertical position of the watermark to be offset from the position specified by `verticalAlign`
         */
        verticalOffset?: string;
    }

}

export namespace elb {
    export interface GetLoadBalancerAccessLogs {
        bucket: string;
        bucketPrefix: string;
        enabled: boolean;
        interval: number;
    }

    export interface GetLoadBalancerHealthCheck {
        healthyThreshold: number;
        interval: number;
        target: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface GetLoadBalancerListener {
        instancePort: number;
        instanceProtocol: string;
        lbPort: number;
        lbProtocol: string;
        sslCertificateId: string;
    }

    export interface LoadBalancerAccessLogs {
        /**
         * The S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * The S3 bucket prefix. Logs are stored in the root if not configured.
         */
        bucketPrefix?: string;
        /**
         * Boolean to enable / disable `accessLogs`. Default is `true`
         */
        enabled?: boolean;
        /**
         * The publishing interval in minutes. Valid values: `5` and `60`. Default: `60`
         */
        interval?: number;
    }

    export interface LoadBalancerHealthCheck {
        /**
         * The number of checks before the instance is declared healthy.
         */
        healthyThreshold: number;
        /**
         * The interval between checks.
         */
        interval: number;
        /**
         * The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL
         * values are:
         */
        target: string;
        /**
         * The length of time before the check times out.
         */
        timeout: number;
        /**
         * The number of checks before the instance is declared unhealthy.
         */
        unhealthyThreshold: number;
    }

    export interface LoadBalancerListener {
        /**
         * The port on the instance to route to
         */
        instancePort: number;
        /**
         * The protocol to use to the instance. Valid
         * values are `HTTP`, `HTTPS`, `TCP`, or `SSL`
         */
        instanceProtocol: string;
        /**
         * The port to listen on for the load balancer
         */
        lbPort: number;
        /**
         * The protocol to listen on. Valid values are `HTTP`,
         * `HTTPS`, `TCP`, or `SSL`
         */
        lbProtocol: string;
        /**
         * The ARN of an SSL certificate you have
         * uploaded to AWS IAM. **Note ECDSA-specific restrictions below.  Only valid when `lbProtocol` is either HTTPS or SSL**
         */
        sslCertificateId?: string;
    }

    export interface LoadBalancerPolicyPolicyAttribute {
        name?: string;
        value?: string;
    }

    export interface SslNegotiationPolicyAttribute {
        /**
         * The name of the attribute
         */
        name: string;
        /**
         * The value of the attribute
         */
        value: string;
    }

}

export namespace emr {
    export interface BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRange {
        /**
         * The final port in the range of TCP ports.
         */
        maxRange: number;
        /**
         * The first port in the range of TCP ports.
         */
        minRange: number;
    }

    export interface ClusterAutoTerminationPolicy {
        /**
         * Specifies the amount of idle time in seconds after which the cluster automatically terminates. You can specify a minimum of `60` seconds and a maximum of `604800` seconds (seven days).
         */
        idleTimeout?: number;
    }

    export interface ClusterBootstrapAction {
        /**
         * List of command line arguments to pass to the bootstrap action script.
         */
        args?: string[];
        /**
         * Name of the bootstrap action.
         */
        name: string;
        /**
         * Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system.
         */
        path: string;
    }

    export interface ClusterCoreInstanceFleet {
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Configuration block for instance fleet.
         */
        instanceTypeConfigs?: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfig[];
        /**
         * Configuration block for launch specification.
         */
        launchSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecifications;
        /**
         * Friendly name given to the instance fleet.
         */
        name?: string;
        provisionedOnDemandCapacity: number;
        provisionedSpotCapacity: number;
        /**
         * The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
         */
        targetOnDemandCapacity?: number;
        /**
         * Target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
         */
        targetSpotCapacity?: number;
    }

    export interface ClusterCoreInstanceFleetInstanceTypeConfig {
        /**
         * Bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * Bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * Number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }

    export interface ClusterCoreInstanceFleetInstanceTypeConfigConfiguration {
        /**
         * Classification within a configuration.
         */
        classification?: string;
        /**
         * Map of properties specified within a configuration classification.
         */
        properties?: {[key: string]: string};
    }

    export interface ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }

    export interface ClusterCoreInstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications.
         */
        onDemandSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications.
         */
        spotSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification[];
    }

    export interface ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies the strategy to use in launching On-Demand instance fleets. Currently, the only option is `lowest-price` (the default), which launches the lowest price first.
         */
        allocationStrategy: string;
    }

    export interface ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Valid values include `capacity-optimized`, `diversified`, `lowest-price`, `price-capacity-optimized`. See the [AWS documentation](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html#emr-instance-fleet-allocation-strategy) for details on each strategy type.
         */
        allocationStrategy: string;
        /**
         * Defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * Action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * Spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }

    export interface ClusterCoreInstanceGroup {
        /**
         * String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
         */
        autoscalingPolicy?: string;
        /**
         * Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
         */
        bidPrice?: string;
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterCoreInstanceGroupEbsConfig[];
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Target number of instances for the instance group. Must be at least 1. Defaults to 1.
         */
        instanceCount?: number;
        /**
         * EC2 instance type for all instances in the instance group.
         */
        instanceType: string;
        /**
         * Friendly name given to the instance group.
         */
        name?: string;
    }

    export interface ClusterCoreInstanceGroupEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The throughput, in mebibyte per second (MiB/s).
         */
        throughput?: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }

    export interface ClusterEc2Attributes {
        /**
         * String containing a comma separated list of additional Amazon EC2 security group IDs for the master node.
         */
        additionalMasterSecurityGroups?: string;
        /**
         * String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string.
         */
        additionalSlaveSecurityGroups?: string;
        /**
         * Identifier of the Amazon EC2 EMR-Managed security group for the master node.
         */
        emrManagedMasterSecurityGroup: string;
        /**
         * Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes.
         */
        emrManagedSlaveSecurityGroup: string;
        /**
         * Instance Profile for EC2 instances of the cluster assume this role.
         */
        instanceProfile: string;
        /**
         * Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`.
         */
        keyName?: string;
        /**
         * Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet.
         */
        serviceAccessSecurityGroup: string;
        /**
         * VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in an Amazon VPC.
         */
        subnetId: string;
        /**
         * List of VPC subnet id-s where you want the job flow to launch.  Amazon EMR identifies the best Availability Zone to launch instances according to your fleet specifications.
         *
         * > **NOTE on EMR-Managed security groups:** These security groups will have any missing inbound or outbound access rules added and maintained by AWS, to ensure proper communication between instances in a cluster. The EMR service will maintain these rules for groups provided in `emrManagedMasterSecurityGroup` and `emrManagedSlaveSecurityGroup`; attempts to remove the required rules may succeed, only for the EMR service to re-add them in a matter of minutes. This may cause this provider to fail to destroy an environment that contains an EMR cluster, because the EMR service does not revoke rules added on deletion, leaving a cyclic dependency between the security groups that prevents their deletion. To avoid this, use the `revokeRulesOnDelete` optional attribute for any Security Group used in `emrManagedMasterSecurityGroup` and `emrManagedSlaveSecurityGroup`. See [Amazon EMR-Managed Security Groups](http://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-man-sec-groups.html) for more information about the EMR-managed security group rules.
         */
        subnetIds: string[];
    }

    export interface ClusterKerberosAttributes {
        /**
         * Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
         */
        adDomainJoinPassword?: string;
        /**
         * Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
         */
        adDomainJoinUser?: string;
        /**
         * Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
         */
        crossRealmTrustPrincipalPassword?: string;
        /**
         * Password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
         */
        kdcAdminPassword: string;
        /**
         * Name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
         */
        realm: string;
    }

    export interface ClusterMasterInstanceFleet {
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Configuration block for instance fleet.
         */
        instanceTypeConfigs?: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfig[];
        /**
         * Configuration block for launch specification.
         */
        launchSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecifications;
        /**
         * Friendly name given to the instance fleet.
         */
        name?: string;
        provisionedOnDemandCapacity: number;
        provisionedSpotCapacity: number;
        /**
         * Target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
         */
        targetOnDemandCapacity?: number;
        /**
         * Target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
         */
        targetSpotCapacity?: number;
    }

    export interface ClusterMasterInstanceFleetInstanceTypeConfig {
        /**
         * Bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * Bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * Number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }

    export interface ClusterMasterInstanceFleetInstanceTypeConfigConfiguration {
        /**
         * Classification within a configuration.
         */
        classification?: string;
        /**
         * Map of properties specified within a configuration classification.
         */
        properties?: {[key: string]: string};
    }

    export interface ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }

    export interface ClusterMasterInstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications.
         */
        onDemandSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications.
         */
        spotSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification[];
    }

    export interface ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies the strategy to use in launching On-Demand instance fleets. Currently, the only option is `lowest-price` (the default), which launches the lowest price first.
         */
        allocationStrategy: string;
    }

    export interface ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Valid values include `capacity-optimized`, `diversified`, `lowest-price`, `price-capacity-optimized`. See the [AWS documentation](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html#emr-instance-fleet-allocation-strategy) for details on each strategy type.
         */
        allocationStrategy: string;
        /**
         * Defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * Action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * Spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }

    export interface ClusterMasterInstanceGroup {
        /**
         * Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
         */
        bidPrice?: string;
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterMasterInstanceGroupEbsConfig[];
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have map public IP on launch enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
         */
        instanceCount?: number;
        /**
         * EC2 instance type for all instances in the instance group.
         */
        instanceType: string;
        /**
         * Friendly name given to the instance group.
         */
        name?: string;
    }

    export interface ClusterMasterInstanceGroupEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The throughput, in mebibyte per second (MiB/s).
         */
        throughput?: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }

    export interface ClusterPlacementGroupConfig {
        /**
         * Role of the instance in the cluster. Valid Values: `MASTER`, `CORE`, `TASK`.
         */
        instanceRole: string;
        /**
         * EC2 Placement Group strategy associated with instance role. Valid Values: `SPREAD`, `PARTITION`, `CLUSTER`, `NONE`.
         */
        placementStrategy: string;
    }

    export interface ClusterStep {
        /**
         * Action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
         */
        actionOnFailure: string;
        /**
         * JAR file used for the step. See below.
         */
        hadoopJarStep: outputs.emr.ClusterStepHadoopJarStep;
        /**
         * Name of the step.
         */
        name: string;
    }

    export interface ClusterStepHadoopJarStep {
        /**
         * List of command line arguments passed to the JAR file's main function when executed.
         */
        args?: string[];
        /**
         * Path to a JAR file run during the step.
         */
        jar: string;
        /**
         * Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
         */
        mainClass?: string;
        /**
         * Key-Value map of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function.
         */
        properties?: {[key: string]: string};
    }

    export interface GetReleaseLabelsFilters {
        /**
         * Optional release label application filter. For example, `Spark@2.1.0` or `Spark`.
         */
        application?: string;
        /**
         * Optional release label version prefix filter. For example, `emr-5`.
         */
        prefix?: string;
    }

    export interface InstanceFleetInstanceTypeConfig {
        /**
         * The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.InstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.InstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * An EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }

    export interface InstanceFleetInstanceTypeConfigConfiguration {
        /**
         * The classification within a configuration.
         */
        classification?: string;
        /**
         * A map of properties specified within a configuration classification
         */
        properties?: {[key: string]: string};
    }

    export interface InstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * The number of I/O operations per second (IOPS) that the volume supports
         */
        iops?: number;
        /**
         * The volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
         */
        volumesPerInstance?: number;
    }

    export interface InstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications
         */
        onDemandSpecifications?: outputs.emr.InstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications
         */
        spotSpecifications?: outputs.emr.InstanceFleetLaunchSpecificationsSpotSpecification[];
    }

    export interface InstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
         */
        allocationStrategy: string;
    }

    export interface InstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
         */
        allocationStrategy: string;
        /**
         * The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }

    export interface InstanceGroupEbsConfig {
        /**
         * The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
         */
        size: number;
        /**
         * The volume type. Valid options are 'gp2', 'io1' and 'standard'.
         */
        type: string;
        /**
         * The number of EBS Volumes to attach per instance.
         */
        volumesPerInstance?: number;
    }

    export interface ManagedScalingPolicyComputeLimit {
        /**
         * The upper boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
         */
        maximumCapacityUnits: number;
        /**
         * The upper boundary of EC2 units for core node type in a cluster. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The core units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between core and task nodes.
         */
        maximumCoreCapacityUnits?: number;
        /**
         * The upper boundary of On-Demand EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The On-Demand units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between On-Demand and Spot instances.
         */
        maximumOndemandCapacityUnits?: number;
        /**
         * The lower boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
         */
        minimumCapacityUnits: number;
        /**
         * The unit type used for specifying a managed scaling policy. Valid Values: `InstanceFleetUnits` | `Instances` | `VCPU`
         */
        unitType: string;
    }

}

export namespace emrcontainers {
    export interface GetVirtualClusterContainerProvider {
        /**
         * The name of the container provider that is running your EMR Containers cluster
         */
        id: string;
        /**
         * Nested list containing information about the configuration of the container provider
         */
        infos: outputs.emrcontainers.GetVirtualClusterContainerProviderInfo[];
        /**
         * The type of the container provider
         */
        type: string;
    }

    export interface GetVirtualClusterContainerProviderInfo {
        /**
         * Nested list containing EKS-specific information about the cluster where the EMR Containers cluster is running
         */
        eksInfos: outputs.emrcontainers.GetVirtualClusterContainerProviderInfoEksInfo[];
    }

    export interface GetVirtualClusterContainerProviderInfoEksInfo {
        /**
         * The namespace where the EMR Containers cluster is running
         */
        namespace: string;
    }

    export interface JobTemplateJobTemplateData {
        /**
         * The configuration settings that are used to override defaults configuration.
         */
        configurationOverrides?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverrides;
        /**
         * The execution role ARN of the job run.
         */
        executionRoleArn: string;
        /**
         * Specify the driver that the job runs on. Exactly one of the two available job drivers is required, either sparkSqlJobDriver or sparkSubmitJobDriver.
         */
        jobDriver: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriver;
        /**
         * The tags assigned to jobs started using the job template.
         */
        jobTags?: {[key: string]: string};
        /**
         * The release version of Amazon EMR.
         */
        releaseLabel: string;
    }

    export interface JobTemplateJobTemplateDataConfigurationOverrides {
        /**
         * The configurations for the application running by the job run.
         */
        applicationConfigurations?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesApplicationConfiguration[];
        /**
         * The configurations for monitoring.
         */
        monitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfiguration;
    }

    export interface JobTemplateJobTemplateDataConfigurationOverridesApplicationConfiguration {
        /**
         * The classification within a configuration.
         */
        classification: string;
        /**
         * A list of additional configurations to apply within a configuration object.
         */
        configurations?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesApplicationConfigurationConfiguration[];
        /**
         * A set of properties specified within a configuration classification.
         */
        properties?: {[key: string]: string};
    }

    export interface JobTemplateJobTemplateDataConfigurationOverridesApplicationConfigurationConfiguration {
        /**
         * The classification within a configuration.
         */
        classification?: string;
        /**
         * A set of properties specified within a configuration classification.
         */
        properties?: {[key: string]: string};
    }

    export interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfiguration {
        /**
         * Monitoring configurations for CloudWatch.
         */
        cloudWatchMonitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationCloudWatchMonitoringConfiguration;
        /**
         * Monitoring configurations for the persistent application UI.
         */
        persistentAppUi?: string;
        /**
         * Amazon S3 configuration for monitoring log publishing.
         */
        s3MonitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationS3MonitoringConfiguration;
    }

    export interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationCloudWatchMonitoringConfiguration {
        /**
         * The name of the log group for log publishing.
         */
        logGroupName: string;
        /**
         * The specified name prefix for log streams.
         */
        logStreamNamePrefix?: string;
    }

    export interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationS3MonitoringConfiguration {
        /**
         * Amazon S3 destination URI for log publishing.
         */
        logUri: string;
    }

    export interface JobTemplateJobTemplateDataJobDriver {
        /**
         * The job driver for job type.
         */
        sparkSqlJobDriver?: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriverSparkSqlJobDriver;
        /**
         * The job driver parameters specified for spark submit.
         */
        sparkSubmitJobDriver?: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriverSparkSubmitJobDriver;
    }

    export interface JobTemplateJobTemplateDataJobDriverSparkSqlJobDriver {
        /**
         * The SQL file to be executed.
         */
        entryPoint?: string;
        /**
         * The Spark parameters to be included in the Spark SQL command.
         */
        sparkSqlParameters?: string;
    }

    export interface JobTemplateJobTemplateDataJobDriverSparkSubmitJobDriver {
        /**
         * The entry point of job application.
         */
        entryPoint: string;
        /**
         * The arguments for job application.
         */
        entryPointArguments?: string[];
        /**
         * The Spark submit parameters that are used for job runs.
         */
        sparkSubmitParameters?: string;
    }

    export interface VirtualClusterContainerProvider {
        /**
         * The name of the container provider that is running your EMR Containers cluster
         */
        id: string;
        /**
         * Nested list containing information about the configuration of the container provider
         */
        info: outputs.emrcontainers.VirtualClusterContainerProviderInfo;
        /**
         * The type of the container provider
         */
        type: string;
    }

    export interface VirtualClusterContainerProviderInfo {
        /**
         * Nested list containing EKS-specific information about the cluster where the EMR Containers cluster is running
         */
        eksInfo: outputs.emrcontainers.VirtualClusterContainerProviderInfoEksInfo;
    }

    export interface VirtualClusterContainerProviderInfoEksInfo {
        /**
         * The namespace where the EMR Containers cluster is running
         */
        namespace?: string;
    }

}

export namespace emrserverless {
    export interface ApplicationAutoStartConfiguration {
        /**
         * Enables the application to automatically start on job submission. Defaults to `true`.
         */
        enabled?: boolean;
    }

    export interface ApplicationAutoStopConfiguration {
        /**
         * Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
         */
        idleTimeoutMinutes?: number;
    }

    export interface ApplicationImageConfiguration {
        /**
         * The image URI.
         */
        imageUri: string;
    }

    export interface ApplicationInitialCapacity {
        /**
         * The initial capacity configuration per worker.
         */
        initialCapacityConfig?: outputs.emrserverless.ApplicationInitialCapacityInitialCapacityConfig;
        /**
         * The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
         */
        initialCapacityType: string;
    }

    export interface ApplicationInitialCapacityInitialCapacityConfig {
        /**
         * The resource configuration of the initial capacity configuration.
         */
        workerConfiguration?: outputs.emrserverless.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration;
        /**
         * The number of workers in the initial capacity configuration.
         */
        workerCount: number;
    }

    export interface ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration {
        /**
         * The CPU requirements for every worker instance of the worker type.
         */
        cpu: string;
        /**
         * The disk requirements for every worker instance of the worker type.
         */
        disk: string;
        /**
         * The memory requirements for every worker instance of the worker type.
         */
        memory: string;
    }

    export interface ApplicationMaximumCapacity {
        /**
         * The maximum allowed CPU for an application.
         */
        cpu: string;
        /**
         * The maximum allowed disk for an application.
         */
        disk: string;
        /**
         * The maximum allowed resources for an application.
         */
        memory: string;
    }

    export interface ApplicationNetworkConfiguration {
        /**
         * The array of security group Ids for customer VPC connectivity.
         */
        securityGroupIds?: string[];
        /**
         * The array of subnet Ids for customer VPC connectivity.
         */
        subnetIds?: string[];
    }

}

export namespace evidently {
    export interface FeatureEvaluationRule {
        /**
         * The name for the new feature. Minimum length of `1`. Maximum length of `127`.
         */
        name: string;
        /**
         * This value is `aws.evidently.splits` if this is an evaluation rule for a launch, and it is `aws.evidently.onlineab` if this is an evaluation rule for an experiment.
         */
        type: string;
    }

    export interface FeatureVariation {
        /**
         * The name of the variation. Minimum length of `1`. Maximum length of `127`.
         */
        name: string;
        /**
         * A block that specifies the value assigned to this variation. Detailed below
         */
        value: outputs.evidently.FeatureVariationValue;
    }

    export interface FeatureVariationValue {
        /**
         * If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
         */
        boolValue?: string;
        /**
         * If this feature uses the double integer variation type, this field contains the double integer value of this variation.
         */
        doubleValue?: string;
        /**
         * If this feature uses the long variation type, this field contains the long value of this variation. Minimum value of `-9007199254740991`. Maximum value of `9007199254740991`.
         */
        longValue?: string;
        /**
         * If this feature uses the string variation type, this field contains the string value of this variation. Minimum length of `0`. Maximum length of `512`.
         */
        stringValue?: string;
    }

    export interface LaunchExecution {
        /**
         * The date and time that the launch ended.
         */
        endedTime: string;
        /**
         * The date and time that the launch started.
         */
        startedTime: string;
    }

    export interface LaunchGroup {
        /**
         * Specifies the description of the launch group.
         */
        description?: string;
        /**
         * Specifies the name of the feature that the launch is using.
         */
        feature: string;
        /**
         * Specifies the name of the lahnch group.
         */
        name: string;
        /**
         * Specifies the feature variation to use for this launch group.
         */
        variation: string;
    }

    export interface LaunchMetricMonitor {
        /**
         * A block that defines the metric. Detailed below.
         */
        metricDefinition: outputs.evidently.LaunchMetricMonitorMetricDefinition;
    }

    export interface LaunchMetricMonitorMetricDefinition {
        /**
         * Specifies the entity, such as a user or session, that does an action that causes a metric value to be recorded. An example is `userDetails.userID`.
         */
        entityIdKey: string;
        /**
         * Specifies The EventBridge event pattern that defines how the metric is recorded.
         */
        eventPattern?: string;
        /**
         * Specifies the name for the metric.
         */
        name: string;
        /**
         * Specifies a label for the units that the metric is measuring.
         */
        unitLabel?: string;
        /**
         * Specifies the value that is tracked to produce the metric.
         */
        valueKey: string;
    }

    export interface LaunchScheduledSplitsConfig {
        /**
         * One or up to six blocks that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step. Detailed below.
         */
        steps: outputs.evidently.LaunchScheduledSplitsConfigStep[];
    }

    export interface LaunchScheduledSplitsConfigStep {
        /**
         * The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. For more information, refer to the [AWS documentation for ScheduledSplitConfig groupWeights](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_ScheduledSplitConfig.html).
         */
        groupWeights: {[key: string]: number};
        /**
         * One or up to six blocks that specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. Detailed below.
         */
        segmentOverrides?: outputs.evidently.LaunchScheduledSplitsConfigStepSegmentOverride[];
        /**
         * Specifies the date and time that this step of the launch starts.
         */
        startTime: string;
    }

    export interface LaunchScheduledSplitsConfigStepSegmentOverride {
        /**
         * Specifies a number indicating the order to use to evaluate segment overrides, if there are more than one. Segment overrides with lower numbers are evaluated first.
         */
        evaluationOrder: number;
        /**
         * The name or ARN of the segment to use.
         */
        segment: string;
        /**
         * The traffic allocation percentages among the feature variations to assign to this segment. This is a set of key-value pairs. The keys are variation names. The values represent the amount of traffic to allocate to that variation for this segment. This is expressed in thousandths of a percent, so a weight of 50000 represents 50% of traffic.
         */
        weights: {[key: string]: number};
    }

    export interface ProjectDataDelivery {
        /**
         * A block that defines the CloudWatch Log Group that stores the evaluation events. See below.
         */
        cloudwatchLogs?: outputs.evidently.ProjectDataDeliveryCloudwatchLogs;
        /**
         * A block that defines the S3 bucket and prefix that stores the evaluation events. See below.
         */
        s3Destination?: outputs.evidently.ProjectDataDeliveryS3Destination;
    }

    export interface ProjectDataDeliveryCloudwatchLogs {
        /**
         * The name of the log group where the project stores evaluation events.
         *
         * The `s3Destination` block supports the following arguments:
         */
        logGroup?: string;
    }

    export interface ProjectDataDeliveryS3Destination {
        /**
         * The name of the bucket in which Evidently stores evaluation events.
         */
        bucket?: string;
        /**
         * The bucket prefix in which Evidently stores evaluation events.
         */
        prefix?: string;
    }

}

export namespace finspace {
    export interface KxClusterAutoScalingConfiguration {
        /**
         * Metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all nodes in a cluster.
         */
        autoScalingMetric: string;
        /**
         * Highest number of nodes to scale. Cannot be greater than 5
         */
        maxNodeCount: number;
        /**
         * Desired value of chosen `autoScalingMetric`. When metric drops below this value, cluster will scale in. When metric goes above this value, cluster will scale out. Can be set between 0 and 100 percent.
         */
        metricTarget: number;
        /**
         * Lowest number of nodes to scale. Must be at least 1 and less than the `maxNodeCount`. If nodes in cluster belong to multiple availability zones, then `minNodeCount` must be at least 3.
         */
        minNodeCount: number;
        /**
         * Duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
         */
        scaleInCooldownSeconds: number;
        /**
         * Duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
         */
        scaleOutCooldownSeconds: number;
    }

    export interface KxClusterCacheStorageConfiguration {
        /**
         * Size of cache in Gigabytes.
         */
        size: number;
        /**
         * Type of KDB database. The following types are available:
         * * HDB - Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed KX databases mounted to the cluster.
         * * RDB - Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the `savedownStorageConfiguration` parameter.
         * * GATEWAY - A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
         */
        type: string;
    }

    export interface KxClusterCapacityConfiguration {
        /**
         * Number of instances running in a cluster. Must be at least 1 and at most 5.
         */
        nodeCount: number;
        /**
         * Determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance.
         *
         * You can only specify one of the following values:
         * * kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.
         * * kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.
         * * kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.
         * * kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.
         * * kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.
         * * kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.
         * * kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
         */
        nodeType: string;
    }

    export interface KxClusterCode {
        /**
         * Unique name for the S3 bucket.
         */
        s3Bucket: string;
        /**
         * Full S3 path (excluding bucket) to the .zip file that contains the code to be loaded onto the cluster when it’s started.
         */
        s3Key: string;
        /**
         * Version of an S3 Object.
         */
        s3ObjectVersion?: string;
    }

    export interface KxClusterDatabase {
        /**
         * Configuration details for the disk cache to increase performance reading from a KX database mounted to the cluster. See cache_configurations.
         */
        cacheConfigurations: outputs.finspace.KxClusterDatabaseCacheConfiguration[];
        /**
         * A unique identifier of the changeset that is associated with the cluster.
         */
        changesetId?: string;
        /**
         * Name of the KX database.
         */
        databaseName: string;
    }

    export interface KxClusterDatabaseCacheConfiguration {
        /**
         * Type of disk cache.
         */
        cacheType: string;
        /**
         * Paths within the database to cache.
         */
        dbPaths: string[];
    }

    export interface KxClusterSavedownStorageConfiguration {
        /**
         * Size of temporary storage in bytes.
         */
        size: number;
        /**
         * Type of writeable storage space for temporarily storing your savedown data. The valid values are:
         * * SDS01 - This type represents 3000 IOPS and io2 ebs volume type.
         */
        type: string;
    }

    export interface KxClusterVpcConfiguration {
        /**
         * IP address type for cluster network configuration parameters. The following type is available: IP_V4 - IP address version 4.
         */
        ipAddressType: string;
        /**
         * Unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
         * * `subnetIds `- (Required) Identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
         */
        securityGroupIds: string[];
        subnetIds: string[];
        /**
         * Identifier of the VPC endpoint
         */
        vpcId: string;
    }

    export interface KxEnvironmentCustomDnsConfiguration {
        /**
         * IP address of the DNS server.
         */
        customDnsServerIp: string;
        /**
         * Name of the DNS server.
         */
        customDnsServerName: string;
    }

    export interface KxEnvironmentTransitGatewayConfiguration {
        /**
         * Routing CIDR on behalf of KX environment. It could be any “/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer’s transit gateway routing table so that the traffics could be routed to KX network.
         */
        routableCidrSpace: string;
        /**
         * Identifier of the transit gateway created by the customer to connect outbound traffics from KX network to your internal network.
         */
        transitGatewayId: string;
    }

}

export namespace fis {
    export interface ExperimentTemplateAction {
        /**
         * ID of the action. To find out what actions are supported see [AWS FIS actions reference](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html).
         */
        actionId: string;
        /**
         * Description of the action.
         */
        description?: string;
        /**
         * Friendly name of the action.
         */
        name: string;
        /**
         * Parameter(s) for the action, if applicable. See below.
         */
        parameters?: outputs.fis.ExperimentTemplateActionParameter[];
        /**
         * Set of action names that must complete before this action can be executed.
         */
        startAfters?: string[];
        /**
         * Action's target, if applicable. See below.
         */
        target?: outputs.fis.ExperimentTemplateActionTarget;
    }

    export interface ExperimentTemplateActionParameter {
        /**
         * Parameter name.
         */
        key: string;
        /**
         * Parameter value.
         *
         * For a list of parameters supported by each action, see [AWS FIS actions reference](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html).
         */
        value: string;
    }

    export interface ExperimentTemplateActionTarget {
        /**
         * Target type. Valid values are `Cluster` (EKS Cluster), `Clusters` (ECS Clusters), `DBInstances` (RDS DB Instances), `Instances` (EC2 Instances), `Nodegroups` (EKS Node groups), `Roles` (IAM Roles), `SpotInstances` (EC2 Spot Instances), `Subnets` (VPC Subnets), `Volumes` (EBS Volumes) , `Pods` (EKS Pods), `Tasks` (ECS Tasks). See the [documentation](https://docs.aws.amazon.com/fis/latest/userguide/actions.html#action-targets) for more details.
         */
        key: string;
        /**
         * Target name, referencing a corresponding target.
         */
        value: string;
    }

    export interface ExperimentTemplateLogConfiguration {
        /**
         * The configuration for experiment logging to Amazon CloudWatch Logs. See below.
         */
        cloudwatchLogsConfiguration?: outputs.fis.ExperimentTemplateLogConfigurationCloudwatchLogsConfiguration;
        /**
         * The schema version. See [documentation](https://docs.aws.amazon.com/fis/latest/userguide/monitoring-logging.html#experiment-log-schema) for the list of schema versions.
         */
        logSchemaVersion: number;
        /**
         * The configuration for experiment logging to Amazon S3. See below.
         */
        s3Configuration?: outputs.fis.ExperimentTemplateLogConfigurationS3Configuration;
    }

    export interface ExperimentTemplateLogConfigurationCloudwatchLogsConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
         */
        logGroupArn: string;
    }

    export interface ExperimentTemplateLogConfigurationS3Configuration {
        /**
         * The name of the destination bucket.
         */
        bucketName: string;
        /**
         * The bucket prefix.
         */
        prefix?: string;
    }

    export interface ExperimentTemplateStopCondition {
        /**
         * Source of the condition. One of `none`, `aws:cloudwatch:alarm`.
         */
        source: string;
        /**
         * ARN of the CloudWatch alarm. Required if the source is a CloudWatch alarm.
         */
        value?: string;
    }

    export interface ExperimentTemplateTarget {
        /**
         * Filter(s) for the target. Filters can be used to select resources based on specific attributes returned by the respective describe action of the resource type. For more information, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters). See below.
         */
        filters?: outputs.fis.ExperimentTemplateTargetFilter[];
        /**
         * Friendly name given to the target.
         */
        name: string;
        /**
         * The resource type parameters.
         *
         * > **NOTE:** The `target` configuration block requires either `resourceArns` or `resourceTag`.
         */
        parameters?: {[key: string]: string};
        /**
         * Set of ARNs of the resources to target with an action. Conflicts with `resourceTag`.
         */
        resourceArns?: string[];
        /**
         * Tag(s) the resources need to have to be considered a valid target for an action. Conflicts with `resourceArns`. See below.
         */
        resourceTags?: outputs.fis.ExperimentTemplateTargetResourceTag[];
        /**
         * AWS resource type. The resource type must be supported for the specified action. To find out what resource types are supported, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#resource-types).
         */
        resourceType: string;
        /**
         * Scopes the identified resources. Valid values are `ALL` (all identified resources), `COUNT(n)` (randomly select `n` of the identified resources), `PERCENT(n)` (randomly select `n` percent of the identified resources).
         */
        selectionMode: string;
    }

    export interface ExperimentTemplateTargetFilter {
        /**
         * Attribute path for the filter.
         */
        path: string;
        /**
         * Set of attribute values for the filter.
         *
         * > **NOTE:** Values specified in a `filter` are joined with an `OR` clause, while values across multiple `filter` blocks are joined with an `AND` clause. For more information, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters).
         */
        values: string[];
    }

    export interface ExperimentTemplateTargetResourceTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

}

export namespace fms {
    export interface PolicyExcludeMap {
        /**
         * A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
         */
        accounts?: string[];
        /**
         * A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
         *
         * You can specify inclusions or exclusions, but not both. If you specify an `includeMap`, AWS Firewall Manager applies the policy to all accounts specified by the `includeMap`, and does not evaluate any `excludeMap` specifications. If you do not specify an `includeMap`, then Firewall Manager applies the policy to all accounts except for those specified by the `excludeMap`.
         */
        orgunits?: string[];
    }

    export interface PolicyIncludeMap {
        /**
         * A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
         */
        accounts?: string[];
        /**
         * A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
         *
         * You can specify inclusions or exclusions, but not both. If you specify an `includeMap`, AWS Firewall Manager applies the policy to all accounts specified by the `includeMap`, and does not evaluate any `excludeMap` specifications. If you do not specify an `includeMap`, then Firewall Manager applies the policy to all accounts except for those specified by the `excludeMap`.
         */
        orgunits?: string[];
    }

    export interface PolicySecurityServicePolicyData {
        /**
         * Details about the service that are specific to the service type, in JSON format. For service type `SHIELD_ADVANCED`, this is an empty string. Examples depending on `type` can be found in the [AWS Firewall Manager SecurityServicePolicyData API Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html).
         */
        managedServiceData?: string;
        /**
         * Contains the Network Firewall firewall policy options to configure a centralized deployment model. Documented below.
         */
        policyOption?: outputs.fms.PolicySecurityServicePolicyDataPolicyOption;
        /**
         * The service that the policy is using to protect the resources. For the current list of supported types, please refer to the [AWS Firewall Manager SecurityServicePolicyData API Type Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html#fms-Type-SecurityServicePolicyData-Type).
         */
        type: string;
    }

    export interface PolicySecurityServicePolicyDataPolicyOption {
        /**
         * Defines the deployment model to use for the firewall policy. Documented below.
         */
        networkFirewallPolicy?: outputs.fms.PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicy;
        thirdPartyFirewallPolicy?: outputs.fms.PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicy;
    }

    export interface PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicy {
        /**
         * Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
         */
        firewallDeploymentModel?: string;
    }

    export interface PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicy {
        /**
         * Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
         */
        firewallDeploymentModel?: string;
    }

}

export namespace fsx {
    export interface DataRepositoryAssociationS3 {
        /**
         * Specifies the type of updated objects that will be automatically exported from your file system to the linked S3 bucket. See the `events` configuration block.
         */
        autoExportPolicy: outputs.fsx.DataRepositoryAssociationS3AutoExportPolicy;
        /**
         * Specifies the type of updated objects that will be automatically imported from the linked S3 bucket to your file system. See the `events` configuration block.
         */
        autoImportPolicy: outputs.fsx.DataRepositoryAssociationS3AutoImportPolicy;
    }

    export interface DataRepositoryAssociationS3AutoExportPolicy {
        /**
         * A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
         */
        events: string[];
    }

    export interface DataRepositoryAssociationS3AutoImportPolicy {
        /**
         * A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
         */
        events: string[];
    }

    export interface FileCacheDataRepositoryAssociation {
        associationId: string;
        /**
         * The path to the S3 or NFS data repository that links to the cache.
         */
        dataRepositoryPath: string;
        /**
         * A list of NFS Exports that will be linked with this data repository association. The Export paths are in the format /exportpath1. To use this parameter, you must configure DataRepositoryPath as the domain name of the NFS file system. The NFS file system domain name in effect is the root of the subdirectories. Note that DataRepositorySubdirectories is not supported for S3 data repositories. Max of 500.
         */
        dataRepositorySubdirectories?: string[];
        /**
         * The system-generated, unique ID of the cache.
         */
        fileCacheId: string;
        /**
         * A path on the cache that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with DataRepositoryPath. The leading forward slash in the name is required. Two data repository associations cannot have overlapping cache paths. For example, if a data repository is associated with cache path /ns1/, then you cannot link another data repository with cache path /ns1/ns2. This path specifies where in your cache files will be exported from. This cache directory can be linked to only one data repository, and no data repository other can be linked to the directory. Note: The cache path can only be set to root (/) on an NFS DRA when DataRepositorySubdirectories is specified. If you specify root (/) as the cache path, you can create only one DRA on the cache. The cache path cannot be set to root (/) for an S3 DRA.
         */
        fileCachePath: string;
        fileSystemId: string;
        fileSystemPath: string;
        importedFileChunkSize: number;
        /**
         * (Optional) See the `nfs` configuration block.
         */
        nfs?: outputs.fsx.FileCacheDataRepositoryAssociationNf[];
        resourceArn: string;
        /**
         * A map of tags to assign to the file cache. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags: {[key: string]: string};
    }

    export interface FileCacheDataRepositoryAssociationNf {
        /**
         * A list of up to 2 IP addresses of DNS servers used to resolve the NFS file system domain name. The provided IP addresses can either be the IP addresses of a DNS forwarder or resolver that the customer manages and runs inside the customer VPC, or the IP addresses of the on-premises DNS servers.
         */
        dnsIps?: string[];
        /**
         * The version of the NFS (Network File System) protocol of the NFS data repository. The only supported value is NFS3, which indicates that the data repository must support the NFSv3 protocol. The only supported value is `NFS3`.
         */
        version: string;
    }

    export interface FileCacheLustreConfiguration {
        /**
         * Specifies the cache deployment type. The only supported value is `CACHE_1`.
         */
        deploymentType: string;
        logConfigurations: outputs.fsx.FileCacheLustreConfigurationLogConfiguration[];
        /**
         * The configuration for a Lustre MDT (Metadata Target) storage volume. See the `metadataConfiguration` block.
         */
        metadataConfigurations: outputs.fsx.FileCacheLustreConfigurationMetadataConfiguration[];
        mountName: string;
        /**
         * Provisions the amount of read and write throughput for each 1 tebibyte (TiB) of cache storage capacity, in MB/s/TiB. The only supported value is `1000`.
         */
        perUnitStorageThroughput: number;
        /**
         * A recurring weekly time, in the format `D:HH:MM`. `D` is the day of the week, for which `1` represents Monday and `7` represents Sunday. `HH` is the zero-padded hour of the day (0-23), and `MM` is the zero-padded minute of the hour. For example, 1:05:00 specifies maintenance at 5 AM Monday. See the [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date) for more information.
         */
        weeklyMaintenanceStartTime?: string;
    }

    export interface FileCacheLustreConfigurationLogConfiguration {
        destination: string;
        level: string;
    }

    export interface FileCacheLustreConfigurationMetadataConfiguration {
        /**
         * The storage capacity of the cache in gibibytes (GiB). Valid values are `1200` GiB, `2400` GiB, and increments of `2400` GiB.
         */
        storageCapacity: number;
    }

    export interface GetOpenZfsSnapshotFilter {
        /**
         * Name of the snapshot.
         */
        name: string;
        values: string[];
    }

    export interface GetWindowsFileSystemAuditLogConfiguration {
        auditLogDestination: string;
        fileAccessAuditLogLevel: string;
        fileShareAccessAuditLogLevel: string;
    }

    export interface LustreFileSystemLogConfiguration {
        /**
         * The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs `/aws/fsx/lustre` log group.
         */
        destination: string;
        /**
         * Sets which data repository events are logged by Amazon FSx. Valid values are `WARN_ONLY`, `FAILURE_ONLY`, `ERROR_ONLY`, `WARN_ERROR` and `DISABLED`. Default value is `DISABLED`.
         */
        level?: string;
    }

    export interface LustreFileSystemRootSquashConfiguration {
        /**
         * When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the client’s IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
         */
        noSquashNids?: string[];
        /**
         * You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
         */
        rootSquash?: string;
    }

    export interface OntapFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
         */
        mode?: string;
    }

    export interface OntapFileSystemEndpoint {
        /**
         * An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
         */
        interclusters: outputs.fsx.OntapFileSystemEndpointIntercluster[];
        /**
         * An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
         */
        managements: outputs.fsx.OntapFileSystemEndpointManagement[];
    }

    export interface OntapFileSystemEndpointIntercluster {
        /**
         * The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the file system endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapFileSystemEndpointManagement {
        /**
         * The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the file system endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapStorageVirtualMachineActiveDirectoryConfiguration {
        /**
         * The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
         */
        netbiosName?: string;
        selfManagedActiveDirectoryConfiguration?: outputs.fsx.OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration;
    }

    export interface OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration {
        /**
         * A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
         */
        dnsIps: string[];
        /**
         * The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
         */
        domainName: string;
        /**
         * The name of the domain group whose members are granted administrative privileges for the SVM. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
         */
        fileSystemAdministratorsGroup?: string;
        /**
         * The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the SVM. If none is provided, the SVM is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
         */
        organizationalUnitDistinguishedName?: string;
        /**
         * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        password: string;
        /**
         * The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        username: string;
    }

    export interface OntapStorageVirtualMachineEndpoint {
        /**
         * An endpoint for accessing data on your storage virtual machine via iSCSI protocol. See Endpoint.
         */
        iscsis: outputs.fsx.OntapStorageVirtualMachineEndpointIscsi[];
        /**
         * An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
         */
        managements: outputs.fsx.OntapStorageVirtualMachineEndpointManagement[];
        /**
         * An endpoint for accessing data on your storage virtual machine via NFS protocol. See Endpoint.
         */
        nfs: outputs.fsx.OntapStorageVirtualMachineEndpointNf[];
        /**
         * An endpoint for accessing data on your storage virtual machine via SMB protocol. This is only set if an activeDirectoryConfiguration has been set. See Endpoint.
         */
        smbs: outputs.fsx.OntapStorageVirtualMachineEndpointSmb[];
    }

    export interface OntapStorageVirtualMachineEndpointIscsi {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapStorageVirtualMachineEndpointManagement {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapStorageVirtualMachineEndpointNf {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapStorageVirtualMachineEndpointSmb {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }

    export interface OntapVolumeTieringPolicy {
        /**
         * Specifies the number of days that user data in a volume must remain inactive before it is considered "cold" and moved to the capacity pool. Used with `AUTO` and `SNAPSHOT_ONLY` tiering policies only. Valid values are whole numbers between 2 and 183. Default values are 31 days for `AUTO` and 2 days for `SNAPSHOT_ONLY`.
         */
        coolingPeriod?: number;
        /**
         * Specifies the tiering policy for the ONTAP volume for moving data to the capacity pool storage. Valid values are `SNAPSHOT_ONLY`, `AUTO`, `ALL`, `NONE`. Default value is `SNAPSHOT_ONLY`.
         */
        name: string;
    }

    export interface OpenZfsFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
         */
        mode?: string;
    }

    export interface OpenZfsFileSystemRootVolumeConfiguration {
        /**
         * A boolean flag indicating whether tags for the file system should be copied to snapshots. The default value is false.
         */
        copyTagsToSnapshots?: boolean;
        /**
         * Method used to compress the data on the volume. Valid values are `LZ4`, `NONE` or `ZSTD`. Child volumes that don't specify compression option will inherit from parent volume. This option on file system applies to the root volume.
         */
        dataCompressionType?: string;
        /**
         * NFS export configuration for the root volume. Exactly 1 item. See NFS Exports Below.
         */
        nfsExports?: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationNfsExports;
        /**
         * specifies whether the volume is read-only. Default is false.
         */
        readOnly: boolean;
        /**
         * Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are `4`, `8`, `16`, `32`, `64`, `128`, `256`, `512`, or `1024` KiB. The default is `128` KiB.
         */
        recordSizeKib?: number;
        /**
         * Specify how much storage users or groups can use on the volume. Maximum of 100 items. See User and Group Quotas Below.
         */
        userAndGroupQuotas: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota[];
    }

    export interface OpenZfsFileSystemRootVolumeConfigurationNfsExports {
        /**
         * A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
         */
        clientConfigurations: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration[];
    }

    export interface OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration {
        /**
         * A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
         */
        clients: string;
        /**
         * The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
         */
        options: string[];
    }

    export interface OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota {
        /**
         * The ID of the user or group. Valid values between `0` and `2147483647`
         */
        id: number;
        /**
         * The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
         */
        storageCapacityQuotaGib: number;
        /**
         * A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
         */
        type: string;
    }

    export interface OpenZfsVolumeNfsExports {
        /**
         * A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
         */
        clientConfigurations: outputs.fsx.OpenZfsVolumeNfsExportsClientConfiguration[];
    }

    export interface OpenZfsVolumeNfsExportsClientConfiguration {
        /**
         * A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
         */
        clients: string;
        /**
         * The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
         */
        options: string[];
    }

    export interface OpenZfsVolumeOriginSnapshot {
        copyStrategy: string;
        snapshotArn: string;
    }

    export interface OpenZfsVolumeUserAndGroupQuota {
        /**
         * The ID of the user or group. Valid values between `0` and `2147483647`
         */
        id: number;
        /**
         * The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
         */
        storageCapacityQuotaGib: number;
        type: string;
    }

    export interface WindowsFileSystemAuditLogConfiguration {
        /**
         * The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when `fileAccessAuditLogLevel` and `fileShareAccessAuditLogLevel` are not set to `DISABLED`. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the `aws-fsx` prefix. If you do not provide a destination in `auditLogDestionation`, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
         */
        auditLogDestination: string;
        /**
         * Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
         */
        fileAccessAuditLogLevel?: string;
        /**
         * Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
         */
        fileShareAccessAuditLogLevel?: string;
    }

    export interface WindowsFileSystemSelfManagedActiveDirectory {
        /**
         * A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in [RFC 1918](https://tools.ietf.org/html/rfc1918).
         */
        dnsIps: string[];
        /**
         * The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
         */
        domainName: string;
        /**
         * The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
         */
        fileSystemAdministratorsGroup?: string;
        /**
         * The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
         */
        organizationalUnitDistinguishedName?: string;
        /**
         * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        password: string;
        /**
         * The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        username: string;
    }

}

export namespace gamelift {
    export interface AliasRoutingStrategy {
        /**
         * ID of the GameLift Fleet to point the alias to.
         */
        fleetId?: string;
        /**
         * Message text to be used with the `TERMINAL` routing strategy.
         */
        message?: string;
        /**
         * Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
         */
        type: string;
    }

    export interface BuildStorageLocation {
        /**
         * Name of your S3 bucket.
         */
        bucket: string;
        /**
         * Name of the zip file containing your build files.
         */
        key: string;
        /**
         * A specific version of the file. If not set, the latest version of the file is retrieved.
         */
        objectVersion?: string;
        /**
         * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
         */
        roleArn: string;
    }

    export interface FleetCertificateConfiguration {
        /**
         * Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
         */
        certificateType?: string;
    }

    export interface FleetEc2InboundPermission {
        /**
         * Starting value for a range of allowed port numbers.
         */
        fromPort: number;
        /**
         * Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
         */
        ipRange: string;
        /**
         * Network communication protocol used by the fleetE.g., `TCP` or `UDP`
         */
        protocol: string;
        /**
         * Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
         */
        toPort: number;
    }

    export interface FleetResourceCreationLimitPolicy {
        /**
         * Maximum number of game sessions that an individual can create during the policy period.
         */
        newGameSessionsPerCreator?: number;
        /**
         * Time span used in evaluating the resource creation limit policy.
         */
        policyPeriodInMinutes?: number;
    }

    export interface FleetRuntimeConfiguration {
        /**
         * Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
         */
        gameSessionActivationTimeoutSeconds?: number;
        /**
         * Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
         */
        maxConcurrentGameSessionActivations?: number;
        /**
         * Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
         */
        serverProcesses?: outputs.gamelift.FleetRuntimeConfigurationServerProcess[];
    }

    export interface FleetRuntimeConfigurationServerProcess {
        /**
         * Number of server processes using this configuration to run concurrently on an instance.
         */
        concurrentExecutions: number;
        /**
         * Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
         */
        launchPath: string;
        /**
         * Optional list of parameters to pass to the server executable on launch.
         */
        parameters?: string;
    }

    export interface GameServerGroupAutoScalingPolicy {
        /**
         * Length of time, in seconds, it takes for a new instance to start
         * new game server processes and register with GameLift FleetIQ.
         * Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
         * because it avoids prematurely starting new instances. Defaults to `60`.
         */
        estimatedInstanceWarmup: number;
        targetTrackingConfiguration: outputs.gamelift.GameServerGroupAutoScalingPolicyTargetTrackingConfiguration;
    }

    export interface GameServerGroupAutoScalingPolicyTargetTrackingConfiguration {
        /**
         * Desired value to use with a game server group target-based scaling policy.
         */
        targetValue: number;
    }

    export interface GameServerGroupInstanceDefinition {
        /**
         * An EC2 instance type.
         */
        instanceType: string;
        /**
         * Instance weighting that indicates how much this instance type contributes
         * to the total capacity of a game server group.
         * Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
         * the most cost-effective options.
         */
        weightedCapacity?: string;
    }

    export interface GameServerGroupLaunchTemplate {
        /**
         * A unique identifier for an existing EC2 launch template.
         */
        id: string;
        /**
         * A readable identifier for an existing EC2 launch template.
         */
        name: string;
        /**
         * The version of the EC2 launch template to use. If none is set, the default is the first version created.
         */
        version?: string;
    }

    export interface GameSessionQueuePlayerLatencyPolicy {
        /**
         * Maximum latency value that is allowed for any player.
         */
        maximumIndividualPlayerLatencyMilliseconds: number;
        /**
         * Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
         */
        policyDurationSeconds?: number;
    }

    export interface MatchmakingConfigurationGameProperty {
        /**
         * A game property key
         */
        key: string;
        /**
         * A game property value.
         */
        value: string;
    }

    export interface ScriptStorageLocation {
        /**
         * Name of your S3 bucket.
         */
        bucket: string;
        /**
         * Name of the zip file containing your script files.
         */
        key: string;
        /**
         * A specific version of the file. If not set, the latest version of the file is retrieved.
         */
        objectVersion?: string;
        /**
         * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
         */
        roleArn: string;
    }

}

export namespace glacier {
    export interface VaultNotification {
        /**
         * You can configure a vault to publish a notification for `ArchiveRetrievalCompleted` and `InventoryRetrievalCompleted` events.
         */
        events: string[];
        /**
         * The SNS Topic ARN.
         */
        snsTopic: string;
    }

}

export namespace globalaccelerator {
    export interface AcceleratorAttributes {
        /**
         * Indicates whether flow logs are enabled. Defaults to `false`. Valid values: `true`, `false`.
         */
        flowLogsEnabled?: boolean;
        /**
         * The name of the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Bucket?: string;
        /**
         * The prefix for the location in the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Prefix?: string;
    }

    export interface AcceleratorIpSet {
        /**
         * The IP addresses to use for BYOIP accelerators. If not specified, the service assigns IP addresses. Valid values: 1 or 2 IPv4 addresses.
         */
        ipAddresses: string[];
        /**
         * The type of IP addresses included in this IP set.
         */
        ipFamily: string;
    }

    export interface CustomRoutingAcceleratorAttributes {
        /**
         * Indicates whether flow logs are enabled. Defaults to `false`. Valid values: `true`, `false`.
         */
        flowLogsEnabled?: boolean;
        /**
         * The name of the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Bucket?: string;
        /**
         * The prefix for the location in the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Prefix?: string;
    }

    export interface CustomRoutingAcceleratorIpSet {
        /**
         * The IP addresses to use for BYOIP accelerators. If not specified, the service assigns IP addresses. Valid values: 1 or 2 IPv4 addresses.
         */
        ipAddresses: string[];
        /**
         * The type of IP addresses included in this IP set.
         */
        ipFamily: string;
    }

    export interface CustomRoutingEndpointGroupDestinationConfiguration {
        /**
         * The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
         */
        fromPort: number;
        /**
         * The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either `"TCP"` or `"UDP"`.
         */
        protocols: string[];
        /**
         * The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
         *
         * **endpoint_configuration** supports the following attributes:
         */
        toPort: number;
    }

    export interface CustomRoutingEndpointGroupEndpointConfiguration {
        /**
         * An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
         */
        endpointId?: string;
    }

    export interface CustomRoutingListenerPortRange {
        /**
         * The first port in the range of ports, inclusive.
         */
        fromPort?: number;
        /**
         * The last port in the range of ports, inclusive.
         */
        toPort?: number;
    }

    export interface EndpointGroupEndpointConfiguration {
        /**
         * Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint. See the [AWS documentation](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) for more details. The default value is `false`.
         * **Note:** When client IP address preservation is enabled, the Global Accelerator service creates an EC2 Security Group in the VPC named `GlobalAccelerator` that must be deleted (potentially outside of the provider) before the VPC will successfully delete. If this EC2 Security Group is not deleted, the provider will retry the VPC deletion for a few minutes before reporting a `DependencyViolation` error. This cannot be resolved by re-running the provider.
         */
        clientIpPreservationEnabled: boolean;
        /**
         * An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID.
         */
        endpointId?: string;
        /**
         * The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic based on proportions that you specify.
         *
         * **port_override** supports the following attributes:
         */
        weight?: number;
    }

    export interface EndpointGroupPortOverride {
        /**
         * The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
         */
        endpointPort: number;
        /**
         * The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
         */
        listenerPort: number;
    }

    export interface GetAcceleratorAttribute {
        flowLogsEnabled: boolean;
        flowLogsS3Bucket: string;
        flowLogsS3Prefix: string;
    }

    export interface GetAcceleratorIpSet {
        ipAddresses: string[];
        ipFamily: string;
    }

    export interface GetCustomRoutingAcceleratorAttribute {
        flowLogsEnabled: boolean;
        flowLogsS3Bucket: string;
        flowLogsS3Prefix: string;
    }

    export interface GetCustomRoutingAcceleratorIpSet {
        ipAddresses: string[];
        ipFamily: string;
    }

    export interface ListenerPortRange {
        /**
         * The first port in the range of ports, inclusive.
         */
        fromPort?: number;
        /**
         * The last port in the range of ports, inclusive.
         */
        toPort?: number;
    }

}

export namespace glue {
    export interface CatalogDatabaseCreateTableDefaultPermission {
        /**
         * The permissions that are granted to the principal.
         */
        permissions?: string[];
        /**
         * The principal who is granted permissions.. See `principal` below.
         */
        principal?: outputs.glue.CatalogDatabaseCreateTableDefaultPermissionPrincipal;
    }

    export interface CatalogDatabaseCreateTableDefaultPermissionPrincipal {
        /**
         * An identifier for the Lake Formation principal.
         */
        dataLakePrincipalIdentifier?: string;
    }

    export interface CatalogDatabaseTargetDatabase {
        /**
         * ID of the Data Catalog in which the database resides.
         */
        catalogId: string;
        /**
         * Name of the catalog database.
         */
        databaseName: string;
        /**
         * Region of the target database.
         */
        region?: string;
    }

    export interface CatalogTablePartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys: string[];
    }

    export interface CatalogTablePartitionKey {
        /**
         * Free-form text comment.
         */
        comment?: string;
        /**
         * Name of the Partition Key.
         */
        name: string;
        /**
         * Datatype of data in the Partition Key.
         */
        type?: string;
    }

    export interface CatalogTableStorageDescriptor {
        /**
         * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns?: string[];
        /**
         * Configuration block for columns in the table. See `columns` below.
         */
        columns: outputs.glue.CatalogTableStorageDescriptorColumn[];
        /**
         * Whether the data in the table is compressed.
         */
        compressed?: boolean;
        /**
         * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat?: string;
        /**
         * Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location?: string;
        /**
         * Must be specified if the table contains any dimension columns.
         */
        numberOfBuckets?: number;
        /**
         * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat?: string;
        /**
         * User-supplied properties in key-value form.
         */
        parameters?: {[key: string]: string};
        /**
         * Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
         */
        schemaReference?: outputs.glue.CatalogTableStorageDescriptorSchemaReference;
        /**
         * Configuration block for serialization and deserialization ("SerDe") information. See `serDeInfo` below.
         */
        serDeInfo?: outputs.glue.CatalogTableStorageDescriptorSerDeInfo;
        /**
         * Configuration block with information about values that appear very frequently in a column (skewed values). See `skewedInfo` below.
         */
        skewedInfo?: outputs.glue.CatalogTableStorageDescriptorSkewedInfo;
        /**
         * Configuration block for the sort order of each bucket in the table. See `sortColumns` below.
         */
        sortColumns?: outputs.glue.CatalogTableStorageDescriptorSortColumn[];
        /**
         * Whether the table data is stored in subdirectories.
         */
        storedAsSubDirectories?: boolean;
    }

    export interface CatalogTableStorageDescriptorColumn {
        /**
         * Free-form text comment.
         */
        comment?: string;
        /**
         * Name of the Column.
         */
        name: string;
        /**
         * Key-value pairs defining properties associated with the column.
         */
        parameters?: {[key: string]: string};
        /**
         * Datatype of data in the Column.
         */
        type?: string;
    }

    export interface CatalogTableStorageDescriptorSchemaReference {
        /**
         * Configuration block that contains schema identity fields. Either this or the `schemaVersionId` has to be provided. See `schemaId` below.
         */
        schemaId?: outputs.glue.CatalogTableStorageDescriptorSchemaReferenceSchemaId;
        /**
         * Unique ID assigned to a version of the schema. Either this or the `schemaId` has to be provided.
         */
        schemaVersionId?: string;
        /**
         * Version number of the schema.
         */
        schemaVersionNumber: number;
    }

    export interface CatalogTableStorageDescriptorSchemaReferenceSchemaId {
        /**
         * Name of the schema registry that contains the schema. Must be provided when `schemaName` is specified and conflicts with `schemaArn`.
         */
        registryName?: string;
        /**
         * ARN of the schema. One of `schemaArn` or `schemaName` has to be provided.
         */
        schemaArn?: string;
        /**
         * Name of the schema. One of `schemaArn` or `schemaName` has to be provided.
         */
        schemaName?: string;
    }

    export interface CatalogTableStorageDescriptorSerDeInfo {
        /**
         * Name of the SerDe.
         */
        name?: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters?: {[key: string]: string};
        /**
         * Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
         */
        serializationLibrary?: string;
    }

    export interface CatalogTableStorageDescriptorSkewedInfo {
        /**
         * List of names of columns that contain skewed values.
         */
        skewedColumnNames?: string[];
        /**
         * List of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps?: {[key: string]: string};
        /**
         * Map of skewed values to the columns that contain them.
         */
        skewedColumnValues?: string[];
    }

    export interface CatalogTableStorageDescriptorSortColumn {
        /**
         * Name of the column.
         */
        column: string;
        /**
         * Whether the column is sorted in ascending (`1`) or descending order (`0`).
         */
        sortOrder: number;
    }

    export interface CatalogTableTargetTable {
        /**
         * ID of the Data Catalog in which the table resides.
         */
        catalogId: string;
        /**
         * Name of the catalog database that contains the target table.
         */
        databaseName: string;
        /**
         * Name of the target table.
         */
        name: string;
    }

    export interface ClassifierCsvClassifier {
        /**
         * Enables the processing of files that contain only one column.
         */
        allowSingleColumn?: boolean;
        /**
         * Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
         */
        containsHeader?: string;
        /**
         * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
         */
        customDatatypeConfigured?: boolean;
        /**
         * A list of supported custom datatypes. Valid values are `BINARY`, `BOOLEAN`, `DATE`, `DECIMAL`, `DOUBLE`, `FLOAT`, `INT`, `LONG`, `SHORT`, `STRING`, `TIMESTAMP`.
         */
        customDatatypes?: string[];
        /**
         * The delimiter used in the Csv to separate columns.
         */
        delimiter?: string;
        /**
         * Specifies whether to trim column values.
         */
        disableValueTrimming?: boolean;
        /**
         * A list of strings representing column names.
         */
        headers?: string[];
        /**
         * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
         */
        quoteSymbol?: string;
    }

    export interface ClassifierGrokClassifier {
        /**
         * An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
         */
        classification: string;
        /**
         * Custom grok patterns used by this classifier.
         */
        customPatterns?: string;
        /**
         * The grok pattern used by this classifier.
         */
        grokPattern: string;
    }

    export interface ClassifierJsonClassifier {
        /**
         * A `JsonPath` string defining the JSON data for the classifier to classify. AWS Glue supports a subset of `JsonPath`, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
         */
        jsonPath: string;
    }

    export interface ClassifierXmlClassifier {
        /**
         * An identifier of the data format that the classifier matches.
         */
        classification: string;
        /**
         * The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by `/>`). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, `<row item_a="A" item_b="B"></row>` is okay, but `<row item_a="A" item_b="B" />` is not).
         */
        rowTag: string;
    }

    export interface ConnectionPhysicalConnectionRequirements {
        /**
         * The availability zone of the connection. This field is redundant and implied by `subnetId`, but is currently an api requirement.
         */
        availabilityZone?: string;
        /**
         * The security group ID list used by the connection.
         */
        securityGroupIdLists?: string[];
        /**
         * The subnet ID used by the connection.
         */
        subnetId?: string;
    }

    export interface CrawlerCatalogTarget {
        /**
         * The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
         */
        connectionName?: string;
        /**
         * The name of the Glue database to be synchronized.
         */
        databaseName: string;
        /**
         * A valid Amazon SQS ARN.
         *
         * > **Note:** `deletionBehavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.
         *
         * > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
         */
        dlqEventQueueArn?: string;
        /**
         * A valid Amazon SQS ARN.
         */
        eventQueueArn?: string;
        /**
         * A list of catalog tables to be synchronized.
         */
        tables: string[];
    }

    export interface CrawlerDeltaTarget {
        /**
         * The name of the connection to use to connect to the Delta table target.
         */
        connectionName?: string;
        /**
         * Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
         */
        createNativeDeltaTable?: boolean;
        /**
         * A list of the Amazon S3 paths to the Delta tables.
         */
        deltaTables: string[];
        /**
         * Specifies whether to write the manifest files to the Delta table path.
         */
        writeManifest: boolean;
    }

    export interface CrawlerDynamodbTarget {
        /**
         * The name of the DynamoDB table to crawl.
         */
        path: string;
        /**
         * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to `true`.
         */
        scanAll?: boolean;
        /**
         * The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
         */
        scanRate?: number;
    }

    export interface CrawlerIcebergTarget {
        /**
         * The name of the connection to use to connect to the Iceberg target.
         */
        connectionName?: string;
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
         */
        maximumTraversalDepth: number;
        /**
         * One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
         */
        paths: string[];
    }

    export interface CrawlerJdbcTarget {
        /**
         * The name of the connection to use to connect to the JDBC target.
         */
        connectionName: string;
        /**
         * Specify a value of `RAWTYPES` or `COMMENTS` to enable additional metadata intable responses. `RAWTYPES` provides the native-level datatype. `COMMENTS` provides comments associated with a column or table in the database.
         */
        enableAdditionalMetadatas?: string[];
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The path of the JDBC target.
         */
        path: string;
    }

    export interface CrawlerLakeFormationConfiguration {
        /**
         * Required for cross account crawls. For same account crawls as the target data, this can omitted.
         */
        accountId: string;
        /**
         * Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
         */
        useLakeFormationCredentials?: boolean;
    }

    export interface CrawlerLineageConfiguration {
        /**
         * Specifies whether data lineage is enabled for the crawler. Valid values are: `ENABLE` and `DISABLE`. Default value is `DISABLE`.
         */
        crawlerLineageSettings?: string;
    }

    export interface CrawlerMongodbTarget {
        /**
         * The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
         */
        connectionName: string;
        /**
         * The path of the Amazon DocumentDB or MongoDB target (database/collection).
         */
        path: string;
        /**
         * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. Default value is `true`.
         */
        scanAll?: boolean;
    }

    export interface CrawlerRecrawlPolicy {
        /**
         * Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: `CRAWL_EVENT_MODE`, `CRAWL_EVERYTHING` and `CRAWL_NEW_FOLDERS_ONLY`. Default value is `CRAWL_EVERYTHING`.
         */
        recrawlBehavior?: string;
    }

    export interface CrawlerS3Target {
        /**
         * The name of the connection to use to connect to the JDBC target.
         */
        connectionName?: string;
        /**
         * The ARN of the dead-letter SQS queue.
         *
         * > **Note:** `deletionBehavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.
         *
         * > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
         */
        dlqEventQueueArn?: string;
        /**
         * The ARN of the SQS queue to receive S3 notifications from.
         */
        eventQueueArn?: string;
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The name of the DynamoDB table to crawl.
         */
        path: string;
        /**
         * Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
         */
        sampleSize?: number;
    }

    export interface CrawlerSchemaChangePolicy {
        /**
         * The deletion behavior when the crawler finds a deleted object. Valid values: `LOG`, `DELETE_FROM_DATABASE`, or `DEPRECATE_IN_DATABASE`. Defaults to `DEPRECATE_IN_DATABASE`.
         */
        deleteBehavior?: string;
        /**
         * The update behavior when the crawler finds a changed schema. Valid values: `LOG` or `UPDATE_IN_DATABASE`. Defaults to `UPDATE_IN_DATABASE`.
         */
        updateBehavior?: string;
    }

    export interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettings {
        /**
         * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
         */
        connectionPasswordEncryption: outputs.glue.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption;
        /**
         * Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
         */
        encryptionAtRest: outputs.glue.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest;
    }

    export interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption {
        /**
         * A KMS key ARN that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least `kms:Encrypt` permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.
         */
        awsKmsKeyId?: string;
        /**
         * When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
         */
        returnConnectionPasswordEncrypted: boolean;
    }

    export interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest {
        /**
         * The encryption-at-rest mode for encrypting Data Catalog data. Valid values are `DISABLED` and `SSE-KMS`.
         */
        catalogEncryptionMode: string;
        /**
         * The ARN of the AWS KMS key to use for encryption at rest.
         */
        sseAwsKmsKeyId?: string;
    }

    export interface DataQualityRulesetTargetTable {
        /**
         * The catalog id where the AWS Glue table exists.
         */
        catalogId?: string;
        /**
         * Name of the database where the AWS Glue table exists.
         */
        databaseName: string;
        /**
         * Name of the AWS Glue table.
         */
        tableName: string;
    }

    export interface GetCatalogTablePartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys: string[];
    }

    export interface GetCatalogTablePartitionKey {
        /**
         * Free-form text comment.
         */
        comment: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Datatype of data in the Column.
         */
        type: string;
    }

    export interface GetCatalogTableStorageDescriptor {
        /**
         * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns: string[];
        /**
         * Configuration block for columns in the table. See `columns` below.
         */
        columns: outputs.glue.GetCatalogTableStorageDescriptorColumn[];
        /**
         * Whether the data in the table is compressed.
         */
        compressed: boolean;
        /**
         * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat: string;
        /**
         * Physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location: string;
        /**
         * Is if the table contains any dimension columns.
         */
        numberOfBuckets: number;
        /**
         * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {[key: string]: string};
        /**
         * Object that references a schema stored in the AWS Glue Schema Registry. See `schemaReference` below.
         */
        schemaReferences: outputs.glue.GetCatalogTableStorageDescriptorSchemaReference[];
        /**
         * Configuration block for serialization and deserialization ("SerDe") information. See `serDeInfo` below.
         */
        serDeInfos: outputs.glue.GetCatalogTableStorageDescriptorSerDeInfo[];
        /**
         * Configuration block with information about values that appear very frequently in a column (skewed values). See `skewedInfo` below.
         */
        skewedInfos: outputs.glue.GetCatalogTableStorageDescriptorSkewedInfo[];
        /**
         * Configuration block for the sort order of each bucket in the table. See `sortColumns` below.
         */
        sortColumns: outputs.glue.GetCatalogTableStorageDescriptorSortColumn[];
        /**
         * Whether the table data is stored in subdirectories.
         */
        storedAsSubDirectories: boolean;
    }

    export interface GetCatalogTableStorageDescriptorColumn {
        /**
         * Free-form text comment.
         */
        comment: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {[key: string]: string};
        /**
         * Datatype of data in the Column.
         */
        type: string;
    }

    export interface GetCatalogTableStorageDescriptorSchemaReference {
        /**
         * Configuration block that contains schema identity fields. See `schemaId` below.
         */
        schemaIds: outputs.glue.GetCatalogTableStorageDescriptorSchemaReferenceSchemaId[];
        /**
         * Unique ID assigned to a version of the schema.
         */
        schemaVersionId: string;
        /**
         * Version number of the schema.
         */
        schemaVersionNumber: number;
    }

    export interface GetCatalogTableStorageDescriptorSchemaReferenceSchemaId {
        /**
         * Name of the schema registry that contains the schema.
         */
        registryName: string;
        /**
         * ARN of the schema.
         */
        schemaArn: string;
        /**
         * Name of the schema.
         */
        schemaName: string;
    }

    export interface GetCatalogTableStorageDescriptorSerDeInfo {
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {[key: string]: string};
        /**
         * Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
         */
        serializationLibrary: string;
    }

    export interface GetCatalogTableStorageDescriptorSkewedInfo {
        /**
         * List of names of columns that contain skewed values.
         */
        skewedColumnNames: string[];
        /**
         * List of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps: {[key: string]: string};
        /**
         * Map of skewed values to the columns that contain them.
         */
        skewedColumnValues: string[];
    }

    export interface GetCatalogTableStorageDescriptorSortColumn {
        /**
         * Name of the column.
         */
        column: string;
        /**
         * Whether the column is sorted in ascending (`1`) or descending order (`0`).
         */
        sortOrder: number;
    }

    export interface GetCatalogTableTargetTable {
        /**
         * ID of the Glue Catalog and database where the table metadata resides. If omitted, this defaults to the current AWS Account ID.
         */
        catalogId: string;
        /**
         * Name of the metadata database where the table metadata resides.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
    }

    export interface GetConnectionPhysicalConnectionRequirement {
        availabilityZone: string;
        securityGroupIdLists: string[];
        subnetId: string;
    }

    export interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSetting {
        /**
         * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
         */
        connectionPasswordEncryptions: outputs.glue.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryption[];
        /**
         * Encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
         */
        encryptionAtRests: outputs.glue.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRest[];
    }

    export interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryption {
        /**
         * KMS key ARN that is used to encrypt the connection password.
         */
        awsKmsKeyId: string;
        /**
         * When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
         */
        returnConnectionPasswordEncrypted: boolean;
    }

    export interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRest {
        /**
         * The encryption-at-rest mode for encrypting Data Catalog data.
         */
        catalogEncryptionMode: string;
        /**
         * ARN of the AWS KMS key to use for encryption at rest.
         */
        sseAwsKmsKeyId: string;
    }

    export interface GetScriptDagEdge {
        /**
         * ID of the node at which the edge starts.
         */
        source: string;
        /**
         * ID of the node at which the edge ends.
         */
        target: string;
        /**
         * Target of the edge.
         */
        targetParameter?: string;
    }

    export interface GetScriptDagNode {
        /**
         * Nested configuration an argument or property of a node. Defined below.
         */
        args: outputs.glue.GetScriptDagNodeArg[];
        /**
         * Node identifier that is unique within the node's graph.
         */
        id: string;
        /**
         * Line number of the node.
         */
        lineNumber?: number;
        /**
         * Type of node this is.
         */
        nodeType: string;
    }

    export interface GetScriptDagNodeArg {
        /**
         * Name of the argument or property.
         */
        name: string;
        /**
         * Boolean if the value is used as a parameter. Defaults to `false`.
         */
        param?: boolean;
        /**
         * Value of the argument or property.
         */
        value: string;
    }

    export interface JobCommand {
        /**
         * The name of the job command. Defaults to `glueetl`. Use `pythonshell` for Python Shell Job Type, or `gluestreaming` for Streaming Job Type. `maxCapacity` needs to be set if `pythonshell` is chosen.
         */
        name?: string;
        /**
         * The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
         */
        pythonVersion: string;
        /**
         * Specifies the S3 path to a script that executes a job.
         */
        scriptLocation: string;
    }

    export interface JobExecutionProperty {
        /**
         * The maximum number of concurrent runs allowed for a job. The default is 1.
         */
        maxConcurrentRuns?: number;
    }

    export interface JobNotificationProperty {
        /**
         * After a job run starts, the number of minutes to wait before sending a job run delay notification.
         */
        notifyDelayAfter?: number;
    }

    export interface MLTransformInputRecordTable {
        /**
         * A unique identifier for the AWS Glue Data Catalog.
         */
        catalogId?: string;
        /**
         * The name of the connection to the AWS Glue Data Catalog.
         */
        connectionName?: string;
        /**
         * A database name in the AWS Glue Data Catalog.
         */
        databaseName: string;
        /**
         * A table name in the AWS Glue Data Catalog.
         */
        tableName: string;
    }

    export interface MLTransformParameters {
        /**
         * The parameters for the find matches algorithm. see Find Matches Parameters.
         */
        findMatchesParameters: outputs.glue.MLTransformParametersFindMatchesParameters;
        /**
         * The type of machine learning transform. For information about the types of machine learning transforms, see [Creating Machine Learning Transforms](http://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html).
         */
        transformType: string;
    }

    export interface MLTransformParametersFindMatchesParameters {
        /**
         * The value that is selected when tuning your transform for a balance between accuracy and cost.
         */
        accuracyCostTradeOff?: number;
        /**
         * The value to switch on or off to force the output to match the provided labels from users.
         */
        enforceProvidedLabels?: boolean;
        /**
         * The value selected when tuning your transform for a balance between precision and recall.
         */
        precisionRecallTradeOff?: number;
        /**
         * The name of a column that uniquely identifies rows in the source table.
         */
        primaryKeyColumnName?: string;
    }

    export interface MLTransformSchema {
        /**
         * The type of data in the column.
         */
        dataType: string;
        /**
         * The name you assign to this ML Transform. It must be unique in your account.
         */
        name: string;
    }

    export interface PartitionIndexPartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName?: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys?: string[];
    }

    export interface PartitionStorageDescriptor {
        /**
         * A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns?: string[];
        /**
         * A list of the Columns in the table.
         */
        columns?: outputs.glue.PartitionStorageDescriptorColumn[];
        /**
         * True if the data in the table is compressed, or False if not.
         */
        compressed?: boolean;
        /**
         * The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat?: string;
        /**
         * The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location?: string;
        /**
         * Must be specified if the table contains any dimension columns.
         */
        numberOfBuckets?: number;
        /**
         * The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat?: string;
        /**
         * User-supplied properties in key-value form.
         */
        parameters?: {[key: string]: string};
        /**
         * Serialization/deserialization (SerDe) information.
         */
        serDeInfo?: outputs.glue.PartitionStorageDescriptorSerDeInfo;
        /**
         * Information about values that appear very frequently in a column (skewed values).
         */
        skewedInfo?: outputs.glue.PartitionStorageDescriptorSkewedInfo;
        /**
         * A list of Order objects specifying the sort order of each bucket in the table.
         */
        sortColumns?: outputs.glue.PartitionStorageDescriptorSortColumn[];
        /**
         * True if the table data is stored in subdirectories, or False if not.
         */
        storedAsSubDirectories?: boolean;
    }

    export interface PartitionStorageDescriptorColumn {
        /**
         * Free-form text comment.
         */
        comment?: string;
        /**
         * The name of the Column.
         */
        name: string;
        /**
         * The datatype of data in the Column.
         */
        type?: string;
    }

    export interface PartitionStorageDescriptorSerDeInfo {
        /**
         * Name of the SerDe.
         */
        name?: string;
        /**
         * A map of initialization parameters for the SerDe, in key-value form.
         */
        parameters?: {[key: string]: string};
        /**
         * Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
         */
        serializationLibrary?: string;
    }

    export interface PartitionStorageDescriptorSkewedInfo {
        /**
         * A list of names of columns that contain skewed values.
         */
        skewedColumnNames?: string[];
        /**
         * A list of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps?: {[key: string]: string};
        /**
         * A map of skewed values to the columns that contain them.
         */
        skewedColumnValues?: string[];
    }

    export interface PartitionStorageDescriptorSortColumn {
        /**
         * The name of the column.
         */
        column: string;
        /**
         * Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
         */
        sortOrder: number;
    }

    export interface SecurityConfigurationEncryptionConfiguration {
        cloudwatchEncryption: outputs.glue.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption;
        jobBookmarksEncryption: outputs.glue.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption;
        /**
         * A `s3Encryption ` block as described below, which contains encryption configuration for S3 data.
         */
        s3Encryption: outputs.glue.SecurityConfigurationEncryptionConfigurationS3Encryption;
    }

    export interface SecurityConfigurationEncryptionConfigurationCloudwatchEncryption {
        /**
         * Encryption mode to use for CloudWatch data. Valid values: `DISABLED`, `SSE-KMS`. Default value: `DISABLED`.
         */
        cloudwatchEncryptionMode?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
    }

    export interface SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption {
        /**
         * Encryption mode to use for job bookmarks data. Valid values: `CSE-KMS`, `DISABLED`. Default value: `DISABLED`.
         */
        jobBookmarksEncryptionMode?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
    }

    export interface SecurityConfigurationEncryptionConfigurationS3Encryption {
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
        /**
         * Encryption mode to use for S3 data. Valid values: `DISABLED`, `SSE-KMS`, `SSE-S3`. Default value: `DISABLED`.
         */
        s3EncryptionMode?: string;
    }

    export interface TriggerAction {
        /**
         * Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
         */
        arguments?: {[key: string]: string};
        /**
         * The name of the crawler to be executed. Conflicts with `jobName`.
         */
        crawlerName?: string;
        /**
         * The name of a job to be executed. Conflicts with `crawlerName`.
         */
        jobName?: string;
        /**
         * Specifies configuration properties of a job run notification. See Notification Property details below.
         */
        notificationProperty?: outputs.glue.TriggerActionNotificationProperty;
        /**
         * The name of the Security Configuration structure to be used with this action.
         */
        securityConfiguration?: string;
        /**
         * The job run timeout in minutes. It overrides the timeout value of the job.
         */
        timeout?: number;
    }

    export interface TriggerActionNotificationProperty {
        /**
         * After a job run starts, the number of minutes to wait before sending a job run delay notification.
         */
        notifyDelayAfter?: number;
    }

    export interface TriggerEventBatchingCondition {
        /**
         * Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
         */
        batchSize: number;
        /**
         * Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is `900`.
         */
        batchWindow?: number;
    }

    export interface TriggerPredicate {
        /**
         * A list of the conditions that determine when the trigger will fire. See Conditions.
         */
        conditions: outputs.glue.TriggerPredicateCondition[];
        /**
         * How to handle multiple conditions. Defaults to `AND`. Valid values are `AND` or `ANY`.
         */
        logical?: string;
    }

    export interface TriggerPredicateCondition {
        /**
         * The condition crawl state. Currently, the values supported are `RUNNING`, `SUCCEEDED`, `CANCELLED`, and `FAILED`. If this is specified, `crawlerName` must also be specified. Conflicts with `state`.
         */
        crawlState?: string;
        /**
         * The name of the crawler to watch. If this is specified, `crawlState` must also be specified. Conflicts with `jobName`.
         */
        crawlerName?: string;
        /**
         * The name of the job to watch. If this is specified, `state` must also be specified. Conflicts with `crawlerName`.
         */
        jobName?: string;
        /**
         * A logical operator. Defaults to `EQUALS`.
         */
        logicalOperator?: string;
        /**
         * The condition job state. Currently, the values supported are `SUCCEEDED`, `STOPPED`, `TIMEOUT` and `FAILED`. If this is specified, `jobName` must also be specified. Conflicts with `crawlerState`.
         */
        state?: string;
    }

    export interface UserDefinedFunctionResourceUri {
        /**
         * The type of the resource. can be one of `JAR`, `FILE`, and `ARCHIVE`.
         */
        resourceType: string;
        /**
         * The URI for accessing the resource.
         */
        uri: string;
    }

}

export namespace grafana {
    export interface WorkspaceNetworkAccessControl {
        /**
         * An array of prefix list IDs.
         */
        prefixListIds: string[];
        /**
         * An array of Amazon VPC endpoint IDs for the workspace. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints will be ignored.
         */
        vpceIds: string[];
    }

    export interface WorkspaceVpcConfiguration {
        /**
         * The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect.
         */
        securityGroupIds: string[];
        /**
         * The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect.
         */
        subnetIds: string[];
    }

}

export namespace guardduty {
    export interface DetectorDatasources {
        /**
         * Configures [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes and Kubernetes Audit Logs below for more details.
         */
        kubernetes: outputs.guardduty.DetectorDatasourcesKubernetes;
        /**
         * Configures [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html).
         * See Malware Protection, Scan EC2 instance with findings and EBS volumes below for more details.
         */
        malwareProtection: outputs.guardduty.DetectorDatasourcesMalwareProtection;
        /**
         * Configures [S3 protection](https://docs.aws.amazon.com/guardduty/latest/ug/s3-protection.html).
         * See S3 Logs below for more details.
         */
        s3Logs: outputs.guardduty.DetectorDatasourcesS3Logs;
    }

    export interface DetectorDatasourcesKubernetes {
        /**
         * Configures Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes Audit Logs below for more details.
         */
        auditLogs: outputs.guardduty.DetectorDatasourcesKubernetesAuditLogs;
    }

    export interface DetectorDatasourcesKubernetesAuditLogs {
        /**
         * If true, enables Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * Defaults to `true`.
         */
        enable: boolean;
    }

    export interface DetectorDatasourcesMalwareProtection {
        /**
         * Configure whether [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) is enabled as data source for EC2 instances with findings for the detector.
         * See Scan EC2 instance with findings below for more details.
         */
        scanEc2InstanceWithFindings: outputs.guardduty.DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindings;
    }

    export interface DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindings {
        /**
         * Configure whether scanning EBS volumes is enabled as data source for the detector for instances with findings.
         * See EBS volumes below for more details.
         */
        ebsVolumes: outputs.guardduty.DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes;
    }

    export interface DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes {
        /**
         * If true, enables [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) as data source for the detector.
         * Defaults to `true`.
         */
        enable: boolean;
    }

    export interface DetectorDatasourcesS3Logs {
        /**
         * Enable monitoring and feedback reporting. Setting to `false` is equivalent to "suspending" GuardDuty. Defaults to `true`.
         */
        enable: boolean;
    }

    export interface FilterFindingCriteria {
        criterions: outputs.guardduty.FilterFindingCriteriaCriterion[];
    }

    export interface FilterFindingCriteriaCriterion {
        /**
         * List of string values to be evaluated.
         */
        equals?: string[];
        /**
         * The name of the field to be evaluated. The full list of field names can be found in [AWS documentation](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_filter-findings.html#filter_criteria).
         */
        field: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        greaterThan?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        greaterThanOrEqual?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        lessThan?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        lessThanOrEqual?: string;
        /**
         * List of string values to be evaluated.
         */
        notEquals?: string[];
    }

    export interface OrganizationConfigurationDatasources {
        /**
         * Enable Kubernetes Audit Logs Monitoring automatically for new member accounts.
         */
        kubernetes: outputs.guardduty.OrganizationConfigurationDatasourcesKubernetes;
        /**
         * Enable Malware Protection automatically for new member accounts.
         */
        malwareProtection: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtection;
        /**
         * Enable S3 Protection automatically for new member accounts.
         */
        s3Logs: outputs.guardduty.OrganizationConfigurationDatasourcesS3Logs;
    }

    export interface OrganizationConfigurationDatasourcesKubernetes {
        /**
         * Enable Kubernetes Audit Logs Monitoring automatically for new member accounts. [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes Audit Logs below for more details.
         */
        auditLogs: outputs.guardduty.OrganizationConfigurationDatasourcesKubernetesAuditLogs;
    }

    export interface OrganizationConfigurationDatasourcesKubernetesAuditLogs {
        /**
         * If true, enables Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * Defaults to `true`.
         */
        enable: boolean;
    }

    export interface OrganizationConfigurationDatasourcesMalwareProtection {
        /**
         * Configure whether [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) for EC2 instances with findings should be auto-enabled for new members joining the organization.
         * See Scan EC2 instance with findings below for more details.
         */
        scanEc2InstanceWithFindings: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindings;
    }

    export interface OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindings {
        /**
         * Configure whether scanning EBS volumes should be auto-enabled for new members joining the organization
         * See EBS volumes below for more details.
         */
        ebsVolumes: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes;
    }

    export interface OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes {
        /**
         * If true, enables [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) for all new accounts joining the organization.
         * Defaults to `true`.
         */
        autoEnable: boolean;
    }

    export interface OrganizationConfigurationDatasourcesS3Logs {
        /**
         * *Deprecated:* Use `autoEnableOrganizationMembers` instead. When this setting is enabled, all new accounts that are created in, or added to, the organization are added as a member accounts of the organization’s GuardDuty delegated administrator and GuardDuty is enabled in that AWS Region.
         */
        autoEnable: boolean;
    }

}

export namespace iam {
    export interface GetAccessKeysAccessKey {
        /**
         * Access key ID.
         */
        accessKeyId: string;
        /**
         * Date and time in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) that the access key was created.
         */
        createDate: string;
        /**
         * Access key status. Possible values are `Active` and `Inactive`.
         */
        status: string;
    }

    export interface GetGroupUser {
        /**
         * User ARN.
         */
        arn: string;
        /**
         * Path to the IAM user.
         */
        path: string;
        /**
         * Stable and unique string identifying the IAM user.
         */
        userId: string;
        /**
         * Name of the IAM user.
         */
        userName: string;
    }

    export interface GetPolicyDocumentStatement {
        /**
         * List of actions that this statement either allows or denies. For example, `["ec2:RunInstances", "s3:*"]`.
         */
        actions?: string[];
        /**
         * Configuration block for a condition. Detailed below.
         */
        conditions?: outputs.iam.GetPolicyDocumentStatementCondition[];
        /**
         * Whether this statement allows or denies the given actions. Valid values are `Allow` and `Deny`. Defaults to `Allow`.
         */
        effect?: string;
        /**
         * List of actions that this statement does *not* apply to. Use to apply a policy statement to all actions *except* those listed.
         */
        notActions?: string[];
        /**
         * Like `principals` except these are principals that the statement does *not* apply to.
         */
        notPrincipals?: outputs.iam.GetPolicyDocumentStatementNotPrincipal[];
        /**
         * List of resource ARNs that this statement does *not* apply to. Use to apply a policy statement to all resources *except* those listed. Conflicts with `resources`.
         */
        notResources?: string[];
        /**
         * Configuration block for principals. Detailed below.
         */
        principals?: outputs.iam.GetPolicyDocumentStatementPrincipal[];
        /**
         * List of resource ARNs that this statement applies to. This is required by AWS if used for an IAM policy. Conflicts with `notResources`.
         */
        resources?: string[];
        /**
         * Sid (statement ID) is an identifier for a policy statement.
         */
        sid?: string;
    }

    export interface GetPolicyDocumentStatementCondition {
        /**
         * Name of the [IAM condition operator](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html) to evaluate.
         */
        test: string;
        /**
         * Values to evaluate the condition against. If multiple values are provided, the condition matches if at least one of them applies. That is, AWS evaluates multiple values as though using an "OR" boolean operation.
         */
        values: string[];
        /**
         * Name of a [Context Variable](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#AvailableKeys) to apply the condition to. Context variables may either be standard AWS variables starting with `aws:` or service-specific variables prefixed with the service name.
         */
        variable: string;
    }

    export interface GetPolicyDocumentStatementNotPrincipal {
        /**
         * List of identifiers for principals. When `type` is `AWS`, these are IAM principal ARNs, e.g., `arn:aws:iam::12345678901:role/yak-role`.  When `type` is `Service`, these are AWS Service roles, e.g., `lambda.amazonaws.com`. When `type` is `Federated`, these are web identity users or SAML provider ARNs, e.g., `accounts.google.com` or `arn:aws:iam::12345678901:saml-provider/yak-saml-provider`. When `type` is `CanonicalUser`, these are [canonical user IDs](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId), e.g., `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`.
         */
        identifiers: string[];
        /**
         * Type of principal. Valid values include `AWS`, `Service`, `Federated`, `CanonicalUser` and `*`.
         */
        type: string;
    }

    export interface GetPolicyDocumentStatementPrincipal {
        /**
         * List of identifiers for principals. When `type` is `AWS`, these are IAM principal ARNs, e.g., `arn:aws:iam::12345678901:role/yak-role`.  When `type` is `Service`, these are AWS Service roles, e.g., `lambda.amazonaws.com`. When `type` is `Federated`, these are web identity users or SAML provider ARNs, e.g., `accounts.google.com` or `arn:aws:iam::12345678901:saml-provider/yak-saml-provider`. When `type` is `CanonicalUser`, these are [canonical user IDs](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId), e.g., `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`.
         */
        identifiers: string[];
        /**
         * Type of principal. Valid values include `AWS`, `Service`, `Federated`, `CanonicalUser` and `*`.
         */
        type: string;
    }

    export interface GetPrincipalPolicySimulationContext {
        /**
         * The context _condition key_ to set.
         *
         * If you have policies containing `Condition` elements or using dynamic interpolations then you will need to provide suitable values for each condition key your policies use. See [Actions, resources, and condition keys for AWS services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) to find the various condition keys that are normally provided for real requests to each action of each AWS service.
         */
        key: string;
        /**
         * An IAM value type that determines how the policy simulator will interpret the strings given in `values`.
         *
         * For more information, see the `ContextKeyType` field of [`iam.ContextEntry`](https://docs.aws.amazon.com/IAM/latest/APIReference/API_ContextEntry.html) in the underlying API.
         */
        type: string;
        /**
         * A set of one or more values for this context entry.
         */
        values: string[];
    }

    export interface GetPrincipalPolicySimulationResult {
        /**
         * The name of the single IAM action used for this particular request.
         */
        actionName: string;
        /**
         * `true` if `decision` is "allowed", and `false` otherwise.
         */
        allowed: boolean;
        /**
         * The raw decision determined from all of the policies in scope; either "allowed", "explicitDeny", or "implicitDeny".
         */
        decision: string;
        /**
         * A map of arbitrary metadata entries returned by the policy simulator for this request.
         */
        decisionDetails: {[key: string]: string};
        /**
         * A nested set of objects describing which policies contained statements that were relevant to this simulation request. Each object has attributes `sourcePolicyId` and `sourcePolicyType` to identify one of the policies.
         */
        matchedStatements: outputs.iam.GetPrincipalPolicySimulationResultMatchedStatement[];
        /**
         * A set of context keys (or condition keys) that were needed by some of the policies contributing to this result but not specified using a `context` block in the configuration. Missing or incorrect context keys will typically cause a simulated request to be disallowed.
         */
        missingContextKeys: string[];
        /**
         * ARN of the resource that was used for this particular request. When you specify multiple actions and multiple resource ARNs, that causes a separate policy request for each combination of unique action and resource.
         */
        resourceArn: string;
    }

    export interface GetPrincipalPolicySimulationResultMatchedStatement {
        sourcePolicyId: string;
        sourcePolicyType: string;
    }

    export interface GetRoleRoleLastUsed {
        /**
         * The date and time, in RFC 3339 format, that the role was last used.
         */
        lastUsedDate: string;
        /**
         * The name of the AWS Region in which the role was last used.
         */
        region: string;
    }

    export interface RoleInlinePolicy {
        /**
         * Name of the role policy.
         */
        name?: string;
        /**
         * Policy document as a JSON formatted string.
         */
        policy?: string;
    }

}

export namespace identitystore {
    export interface GetGroupAlternateIdentifier {
        /**
         * Configuration block for filtering by the identifier issued by an external identity provider. Detailed below.
         */
        externalId?: outputs.identitystore.GetGroupAlternateIdentifierExternalId;
        /**
         * An entity attribute that's unique to a specific entity. Detailed below.
         *
         * > Exactly one of the above arguments must be provided.
         */
        uniqueAttribute?: outputs.identitystore.GetGroupAlternateIdentifierUniqueAttribute;
    }

    export interface GetGroupAlternateIdentifierExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface GetGroupAlternateIdentifierUniqueAttribute {
        /**
         * Attribute path that is used to specify which attribute name to search. For example: `DisplayName`. Refer to the [Group data type](https://docs.aws.amazon.com/singlesignon/latest/IdentityStoreAPIReference/API_Group.html).
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }

    export interface GetGroupExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface GetUserAddress {
        /**
         * The country that this address is in.
         */
        country: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted: string;
        /**
         * The address locality.
         */
        locality: string;
        /**
         * The postal code of the address.
         */
        postalCode: string;
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The region of the address.
         */
        region: string;
        /**
         * The street of the address.
         */
        streetAddress: string;
        /**
         * The type of phone number.
         */
        type: string;
    }

    export interface GetUserAlternateIdentifier {
        /**
         * Configuration block for filtering by the identifier issued by an external identity provider. Detailed below.
         */
        externalId?: outputs.identitystore.GetUserAlternateIdentifierExternalId;
        /**
         * An entity attribute that's unique to a specific entity. Detailed below.
         *
         * > Exactly one of the above arguments must be provided.
         */
        uniqueAttribute?: outputs.identitystore.GetUserAlternateIdentifierUniqueAttribute;
    }

    export interface GetUserAlternateIdentifierExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface GetUserAlternateIdentifierUniqueAttribute {
        /**
         * Attribute path that is used to specify which attribute name to search. For example: `UserName`. Refer to the [User data type](https://docs.aws.amazon.com/singlesignon/latest/IdentityStoreAPIReference/API_User.html).
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }

    export interface GetUserEmail {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The type of phone number.
         */
        type: string;
        /**
         * The user's phone number.
         */
        value: string;
    }

    export interface GetUserExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface GetUserName {
        /**
         * The family name of the user.
         */
        familyName: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted: string;
        /**
         * The given name of the user.
         */
        givenName: string;
        /**
         * The honorific prefix of the user.
         */
        honorificPrefix: string;
        /**
         * The honorific suffix of the user.
         */
        honorificSuffix: string;
        /**
         * The middle name of the user.
         */
        middleName: string;
    }

    export interface GetUserPhoneNumber {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The type of phone number.
         */
        type: string;
        /**
         * The user's phone number.
         */
        value: string;
    }

    export interface GroupExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface UserAddresses {
        /**
         * The country that this address is in.
         */
        country?: string;
        /**
         * The name that is typically displayed when the address is shown for display.
         */
        formatted?: string;
        /**
         * The address locality.
         */
        locality?: string;
        /**
         * The postal code of the address.
         */
        postalCode?: string;
        /**
         * When `true`, this is the primary address associated with the user.
         */
        primary?: boolean;
        /**
         * The region of the address.
         */
        region?: string;
        /**
         * The street of the address.
         */
        streetAddress?: string;
        /**
         * The type of address.
         */
        type?: string;
    }

    export interface UserEmails {
        /**
         * When `true`, this is the primary email associated with the user.
         */
        primary?: boolean;
        /**
         * The type of email.
         */
        type?: string;
        /**
         * The email address. This value must be unique across the identity store.
         */
        value?: string;
    }

    export interface UserExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }

    export interface UserName {
        /**
         * The family name of the user.
         */
        familyName: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted?: string;
        /**
         * The given name of the user.
         *
         * The following arguments are optional:
         */
        givenName: string;
        /**
         * The honorific prefix of the user.
         */
        honorificPrefix?: string;
        /**
         * The honorific suffix of the user.
         */
        honorificSuffix?: string;
        /**
         * The middle name of the user.
         */
        middleName?: string;
    }

    export interface UserPhoneNumbers {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary?: boolean;
        /**
         * The type of phone number.
         */
        type?: string;
        /**
         * The user's phone number.
         */
        value?: string;
    }

}

export namespace imagebuilder {
    export interface ContainerRecipeComponent {
        /**
         * Amazon Resource Name (ARN) of the Image Builder Component to associate.
         */
        componentArn: string;
        /**
         * Configuration block(s) for parameters to configure the component. Detailed below.
         */
        parameters?: outputs.imagebuilder.ContainerRecipeComponentParameter[];
    }

    export interface ContainerRecipeComponentParameter {
        /**
         * The name of the component parameter.
         */
        name: string;
        /**
         * The value for the named component parameter.
         */
        value: string;
    }

    export interface ContainerRecipeInstanceConfiguration {
        /**
         * Configuration block(s) with block device mappings for the container recipe. Detailed below.
         */
        blockDeviceMappings?: outputs.imagebuilder.ContainerRecipeInstanceConfigurationBlockDeviceMapping[];
        /**
         * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
         */
        image?: string;
    }

    export interface ContainerRecipeInstanceConfigurationBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName?: string;
        /**
         * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
         */
        ebs?: outputs.imagebuilder.ContainerRecipeInstanceConfigurationBlockDeviceMappingEbs;
        /**
         * Set to `true` to remove a mapping from the parent image.
         */
        noDevice?: boolean;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName?: string;
    }

    export interface ContainerRecipeInstanceConfigurationBlockDeviceMappingEbs {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination?: string;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted?: string;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops?: number;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId?: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize?: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType?: string;
    }

    export interface ContainerRecipeTargetRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * The service in which this image is registered. Valid values: `ECR`.
         */
        service: string;
    }

    export interface DistributionConfigurationDistribution {
        /**
         * Configuration block with Amazon Machine Image (AMI) distribution settings. Detailed below.
         */
        amiDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfiguration;
        /**
         * Configuration block with container distribution settings. Detailed below.
         */
        containerDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionContainerDistributionConfiguration;
        /**
         * Set of Windows faster-launching configurations to use for AMI distribution. Detailed below.
         */
        fastLaunchConfigurations?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfiguration[];
        /**
         * Set of launch template configuration settings that apply to image distribution. Detailed below.
         */
        launchTemplateConfigurations?: outputs.imagebuilder.DistributionConfigurationDistributionLaunchTemplateConfiguration[];
        /**
         * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
         */
        licenseConfigurationArns?: string[];
        /**
         * AWS Region for the distribution.
         *
         * The following arguments are optional:
         */
        region: string;
    }

    export interface DistributionConfigurationDistributionAmiDistributionConfiguration {
        /**
         * Key-value map of tags to apply to the distributed AMI.
         */
        amiTags?: {[key: string]: string};
        /**
         * Description to apply to the distributed AMI.
         */
        description?: string;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key to encrypt the distributed AMI.
         */
        kmsKeyId?: string;
        /**
         * Configuration block of EC2 launch permissions to apply to the distributed AMI. Detailed below.
         */
        launchPermission?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission;
        /**
         * Name to apply to the distributed AMI.
         */
        name?: string;
        /**
         * Set of AWS Account identifiers to distribute the AMI.
         */
        targetAccountIds?: string[];
    }

    export interface DistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission {
        /**
         * Set of AWS Organization ARNs to assign.
         */
        organizationArns?: string[];
        /**
         * Set of AWS Organizational Unit ARNs to assign.
         */
        organizationalUnitArns?: string[];
        /**
         * Set of EC2 launch permission user groups to assign. Use `all` to distribute a public AMI.
         */
        userGroups?: string[];
        /**
         * Set of AWS Account identifiers to assign.
         */
        userIds?: string[];
    }

    export interface DistributionConfigurationDistributionContainerDistributionConfiguration {
        /**
         * Set of tags that are attached to the container distribution configuration.
         */
        containerTags?: string[];
        /**
         * Description of the container distribution configuration.
         */
        description?: string;
        /**
         * Configuration block with the destination repository for the container distribution configuration.
         */
        targetRepository: outputs.imagebuilder.DistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository;
    }

    export interface DistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * The service in which this image is registered. Valid values: `ECR`.
         */
        service: string;
    }

    export interface DistributionConfigurationDistributionFastLaunchConfiguration {
        /**
         * The owner account ID for the fast-launch enabled Windows AMI.
         */
        accountId: string;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI. Set to `true` to start using Windows faster launching, or `false` to stop using it.
         */
        enabled: boolean;
        /**
         * Configuration block for the launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots. Detailed below.
         */
        launchTemplate?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate;
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches?: number;
        /**
         * Configuration block for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled. Detailed below.
         */
        snapshotConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration;
    }

    export interface DistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate {
        /**
         * The ID of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateId?: string;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName?: string;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion?: string;
    }

    export interface DistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount?: number;
    }

    export interface DistributionConfigurationDistributionLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId?: string;
        /**
         * Indicates whether to set the specified Amazon EC2 launch template as the default launch template. Defaults to `true`.
         */
        default?: boolean;
        /**
         * The ID of the Amazon EC2 launch template to use.
         */
        launchTemplateId: string;
    }

    export interface GetComponentsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListComponents API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListComponents.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetContainerRecipeComponent {
        /**
         * ARN of the Image Builder Component.
         */
        componentArn: string;
        /**
         * Set of parameters that are used to configure the component.
         */
        parameters: outputs.imagebuilder.GetContainerRecipeComponentParameter[];
    }

    export interface GetContainerRecipeComponentParameter {
        /**
         * Name of the container recipe.
         */
        name: string;
        /**
         * Value of the component parameter.
         */
        value: string;
    }

    export interface GetContainerRecipeInstanceConfiguration {
        /**
         * Set of objects with block device mappings for the instance configuration.
         */
        blockDeviceMappings: outputs.imagebuilder.GetContainerRecipeInstanceConfigurationBlockDeviceMapping[];
        /**
         * AMI ID of the base image for container build and test instance.
         */
        image: string;
    }

    export interface GetContainerRecipeInstanceConfigurationBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName: string;
        /**
         * Single list of object with Elastic Block Storage (EBS) block device mapping settings.
         */
        ebs: outputs.imagebuilder.GetContainerRecipeInstanceConfigurationBlockDeviceMappingEb[];
        /**
         * Whether to remove a mapping from the parent image.
         */
        noDevice: string;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName: string;
    }

    export interface GetContainerRecipeInstanceConfigurationBlockDeviceMappingEb {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination: boolean;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted: boolean;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops: number;
        /**
         * KMS key used to encrypt the container image.
         */
        kmsKeyId: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType: string;
    }

    export interface GetContainerRecipeTargetRepository {
        /**
         * Name of the container repository where the output container image is stored. The name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * Service in which this image is registered.
         */
        service: string;
    }

    export interface GetContainerRecipesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListContainerRecipes API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListContainerRecipes.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetDistributionConfigurationDistribution {
        /**
         * Nested list of AMI distribution configuration.
         */
        amiDistributionConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionAmiDistributionConfiguration[];
        /**
         * Nested list of container distribution configurations.
         */
        containerDistributionConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionContainerDistributionConfiguration[];
        /**
         * Nested list of Windows faster-launching configurations to use for AMI distribution.
         */
        fastLaunchConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfiguration[];
        /**
         * Nested list of launch template configurations.
         */
        launchTemplateConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionLaunchTemplateConfiguration[];
        /**
         * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
         */
        licenseConfigurationArns: string[];
        /**
         * AWS Region of distribution.
         */
        region: string;
    }

    export interface GetDistributionConfigurationDistributionAmiDistributionConfiguration {
        /**
         * Key-value map of tags to apply to distributed AMI.
         */
        amiTags: {[key: string]: string};
        /**
         * Description of the container distribution configuration.
         */
        description: string;
        /**
         * ARN of Key Management Service (KMS) Key to encrypt AMI.
         */
        kmsKeyId: string;
        /**
         * Nested list of EC2 launch permissions.
         */
        launchPermissions: outputs.imagebuilder.GetDistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission[];
        /**
         * Name of the distribution configuration.
         */
        name: string;
        /**
         * Set of target AWS Account identifiers.
         */
        targetAccountIds: string[];
    }

    export interface GetDistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission {
        /**
         * Set of AWS Organization ARNs.
         */
        organizationArns: string[];
        /**
         * Set of AWS Organizational Unit ARNs.
         */
        organizationalUnitArns: string[];
        /**
         * Set of EC2 launch permission user groups.
         */
        userGroups: string[];
        /**
         * Set of AWS Account identifiers.
         */
        userIds: string[];
    }

    export interface GetDistributionConfigurationDistributionContainerDistributionConfiguration {
        /**
         * Set of tags that are attached to the container distribution configuration.
         */
        containerTags: string[];
        /**
         * Description of the container distribution configuration.
         */
        description: string;
        /**
         * Set of destination repositories for the container distribution configuration.
         */
        targetRepositories: outputs.imagebuilder.GetDistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository[];
    }

    export interface GetDistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository {
        /**
         * Name of the container repository where the output container image is stored.
         */
        repositoryName: string;
        /**
         * Service in which the image is registered.
         */
        service: string;
    }

    export interface GetDistributionConfigurationDistributionFastLaunchConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId: string;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI.
         */
        enabled: boolean;
        /**
         * Nested list of launch templates that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
         */
        launchTemplates: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate[];
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches: number;
        /**
         * Nested list of configurations for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
         */
        snapshotConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration[];
    }

    export interface GetDistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate {
        /**
         * ID of the Amazon EC2 launch template.
         */
        launchTemplateId: string;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName: string;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion: string;
    }

    export interface GetDistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount: number;
    }

    export interface GetDistributionConfigurationDistributionLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId: string;
        /**
         * Whether the specified Amazon EC2 launch template is set as the default launch template.
         */
        default: boolean;
        /**
         * ID of the Amazon EC2 launch template.
         */
        launchTemplateId: string;
    }

    export interface GetDistributionConfigurationsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListDistributionConfigurations API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListDistributionConfigurations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetImageImageTestsConfiguration {
        /**
         * Whether image tests are enabled.
         */
        imageTestsEnabled: boolean;
        /**
         * Number of minutes before image tests time out.
         */
        timeoutMinutes: number;
    }

    export interface GetImageOutputResource {
        /**
         * Set of objects with each Amazon Machine Image (AMI) created.
         */
        amis: outputs.imagebuilder.GetImageOutputResourceAmi[];
        /**
         * Set of objects with each container image created and stored in the output repository.
         */
        containers: outputs.imagebuilder.GetImageOutputResourceContainer[];
    }

    export interface GetImageOutputResourceAmi {
        /**
         * Account identifier of the AMI.
         */
        accountId: string;
        /**
         * Description of the AMI.
         */
        description: string;
        /**
         * Identifier of the AMI.
         */
        image: string;
        /**
         * Name of the AMI.
         */
        name: string;
        /**
         * Region of the container image.
         */
        region: string;
    }

    export interface GetImageOutputResourceContainer {
        /**
         * Set of URIs for created containers.
         */
        imageUris: string[];
        /**
         * Region of the container image.
         */
        region: string;
    }

    export interface GetImagePipelineImageTestsConfiguration {
        /**
         * Whether image tests are enabled.
         */
        imageTestsEnabled: boolean;
        /**
         * Number of minutes before image tests time out.
         */
        timeoutMinutes: number;
    }

    export interface GetImagePipelineSchedule {
        /**
         * Condition when the pipeline should trigger a new image build.
         */
        pipelineExecutionStartCondition: string;
        /**
         * Cron expression of how often the pipeline start condition is evaluated.
         */
        scheduleExpression: string;
    }

    export interface GetImagePipelinesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListImagePipelines API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListImagePipelines.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetImageRecipeBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName: string;
        /**
         * Single list of object with Elastic Block Storage (EBS) block device mapping settings.
         */
        ebs: outputs.imagebuilder.GetImageRecipeBlockDeviceMappingEb[];
        /**
         * Whether to remove a mapping from the parent image.
         */
        noDevice: string;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName: string;
    }

    export interface GetImageRecipeBlockDeviceMappingEb {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination: boolean;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted: boolean;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops: number;
        /**
         * ARN of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType: string;
    }

    export interface GetImageRecipeComponent {
        /**
         * ARN of the Image Builder Component.
         */
        componentArn: string;
        /**
         * Set of parameters that are used to configure the component.
         */
        parameters: outputs.imagebuilder.GetImageRecipeComponentParameter[];
    }

    export interface GetImageRecipeComponentParameter {
        /**
         * Name of the image recipe.
         */
        name: string;
        /**
         * Value of the component parameter.
         */
        value: string;
    }

    export interface GetImageRecipesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListImageRecipes API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListImageRecipes.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetInfrastructureConfigurationInstanceMetadataOption {
        /**
         * Number of hops that an instance can traverse to reach its destonation.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether a signed token is required for instance metadata retrieval requests.
         */
        httpTokens: string;
    }

    export interface GetInfrastructureConfigurationLogging {
        /**
         * Nested list of S3 logs settings.
         */
        s3Logs: outputs.imagebuilder.GetInfrastructureConfigurationLoggingS3Log[];
    }

    export interface GetInfrastructureConfigurationLoggingS3Log {
        /**
         * Name of the S3 Bucket for logging.
         */
        s3BucketName: string;
        /**
         * Key prefix for S3 Bucket logging.
         */
        s3KeyPrefix: string;
    }

    export interface GetInfrastructureConfigurationsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListInfrastructureConfigurations API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListInfrastructureConfigurations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface ImageImageTestsConfiguration {
        /**
         * Whether image tests are enabled. Defaults to `true`.
         */
        imageTestsEnabled?: boolean;
        /**
         * Number of minutes before image tests time out. Valid values are between `60` and `1440`. Defaults to `720`.
         */
        timeoutMinutes?: number;
    }

    export interface ImageOutputResource {
        /**
         * Set of objects with each Amazon Machine Image (AMI) created.
         */
        amis: outputs.imagebuilder.ImageOutputResourceAmi[];
        /**
         * Set of objects with each container image created and stored in the output repository.
         */
        containers: outputs.imagebuilder.ImageOutputResourceContainer[];
    }

    export interface ImageOutputResourceAmi {
        /**
         * Account identifier of the AMI.
         */
        accountId: string;
        /**
         * Description of the AMI.
         */
        description: string;
        /**
         * Identifier of the AMI.
         */
        image: string;
        /**
         * Name of the AMI.
         */
        name: string;
        /**
         * Region of the container image.
         */
        region: string;
    }

    export interface ImageOutputResourceContainer {
        /**
         * Set of URIs for created containers.
         */
        imageUris: string[];
        /**
         * Region of the container image.
         */
        region: string;
    }

    export interface ImagePipelineImageTestsConfiguration {
        /**
         * Whether image tests are enabled. Defaults to `true`.
         */
        imageTestsEnabled?: boolean;
        /**
         * Number of minutes before image tests time out. Valid values are between `60` and `1440`. Defaults to `720`.
         */
        timeoutMinutes?: number;
    }

    export interface ImagePipelineSchedule {
        /**
         * Condition when the pipeline should trigger a new image build. Valid values are `EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE` and `EXPRESSION_MATCH_ONLY`. Defaults to `EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE`.
         */
        pipelineExecutionStartCondition?: string;
        /**
         * Cron expression of how often the pipeline start condition is evaluated. For example, `cron(0 0 * * ? *)` is evaluated every day at midnight UTC. Configurations using the five field syntax that was previously accepted by the API, such as `cron(0 0 * * *)`, must be updated to the six field syntax. For more information, see the [Image Builder User Guide](https://docs.aws.amazon.com/imagebuilder/latest/userguide/cron-expressions.html).
         *
         * The following arguments are optional:
         */
        scheduleExpression: string;
        /**
         * The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the [IANA timezone format](https://www.joda.org/joda-time/timezones.html). If not specified this defaults to UTC.
         */
        timezone: string;
    }

    export interface ImageRecipeBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName?: string;
        /**
         * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
         */
        ebs?: outputs.imagebuilder.ImageRecipeBlockDeviceMappingEbs;
        /**
         * Set to `true` to remove a mapping from the parent image.
         */
        noDevice?: boolean;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName?: string;
    }

    export interface ImageRecipeBlockDeviceMappingEbs {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination?: string;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted?: string;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops?: number;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId?: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize?: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType?: string;
    }

    export interface ImageRecipeComponent {
        /**
         * Amazon Resource Name (ARN) of the Image Builder Component to associate.
         */
        componentArn: string;
        /**
         * Configuration block(s) for parameters to configure the component. Detailed below.
         */
        parameters?: outputs.imagebuilder.ImageRecipeComponentParameter[];
    }

    export interface ImageRecipeComponentParameter {
        /**
         * The name of the component parameter.
         */
        name: string;
        /**
         * The value for the named component parameter.
         */
        value: string;
    }

    export interface ImageRecipeSystemsManagerAgent {
        /**
         * Whether to remove the Systems Manager Agent after the image has been built. Defaults to `false`.
         */
        uninstallAfterBuild: boolean;
    }

    export interface InfrastructureConfigurationInstanceMetadataOptions {
        /**
         * The number of hops that an instance can traverse to reach its destonation.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Whether a signed token is required for instance metadata retrieval requests. Valid values: `required`, `optional`.
         */
        httpTokens?: string;
    }

    export interface InfrastructureConfigurationLogging {
        /**
         * Configuration block with S3 logging settings. Detailed below.
         */
        s3Logs: outputs.imagebuilder.InfrastructureConfigurationLoggingS3Logs;
    }

    export interface InfrastructureConfigurationLoggingS3Logs {
        /**
         * Name of the S3 Bucket.
         *
         * The following arguments are optional:
         */
        s3BucketName: string;
        /**
         * Prefix to use for S3 logs. Defaults to `/`.
         */
        s3KeyPrefix?: string;
    }

}

export namespace inspector {
    export interface AssessmentTemplateEventSubscription {
        /**
         * The event for which you want to receive SNS notifications. Valid values are `ASSESSMENT_RUN_STARTED`, `ASSESSMENT_RUN_COMPLETED`, `ASSESSMENT_RUN_STATE_CHANGED`, and `FINDING_REPORTED`.
         */
        event: string;
        /**
         * The ARN of the SNS topic to which notifications are sent.
         */
        topicArn: string;
    }

}

export namespace inspector2 {
    export interface OrganizationConfigurationAutoEnable {
        /**
         * Whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        ec2: boolean;
        /**
         * Whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        ecr: boolean;
        /**
         * Whether Lambda Function scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        lambda?: boolean;
    }

}

export namespace iot {
    export interface IndexingConfigurationThingGroupIndexingConfiguration {
        /**
         * A list of thing group fields to index. This list cannot contain any managed fields. See below.
         */
        customFields?: outputs.iot.IndexingConfigurationThingGroupIndexingConfigurationCustomField[];
        /**
         * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
         */
        managedFields: outputs.iot.IndexingConfigurationThingGroupIndexingConfigurationManagedField[];
        /**
         * Thing group indexing mode. Valid values: `OFF`, `ON`.
         */
        thingGroupIndexingMode: string;
    }

    export interface IndexingConfigurationThingGroupIndexingConfigurationCustomField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }

    export interface IndexingConfigurationThingGroupIndexingConfigurationManagedField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }

    export interface IndexingConfigurationThingIndexingConfiguration {
        /**
         * Contains custom field names and their data type. See below.
         */
        customFields?: outputs.iot.IndexingConfigurationThingIndexingConfigurationCustomField[];
        /**
         * Device Defender indexing mode. Valid values: `VIOLATIONS`, `OFF`. Default: `OFF`.
         */
        deviceDefenderIndexingMode?: string;
        /**
         * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
         */
        managedFields: outputs.iot.IndexingConfigurationThingIndexingConfigurationManagedField[];
        /**
         * [Named shadow](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html) indexing mode. Valid values: `ON`, `OFF`. Default: `OFF`.
         */
        namedShadowIndexingMode?: string;
        /**
         * Thing connectivity indexing mode. Valid values: `STATUS`, `OFF`. Default: `OFF`.
         */
        thingConnectivityIndexingMode?: string;
        /**
         * Thing indexing mode. Valid values: `REGISTRY`, `REGISTRY_AND_SHADOW`, `OFF`.
         */
        thingIndexingMode: string;
    }

    export interface IndexingConfigurationThingIndexingConfigurationCustomField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }

    export interface IndexingConfigurationThingIndexingConfigurationManagedField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }

    export interface ProvisioningTemplatePreProvisioningHook {
        /**
         * The version of the payload that was sent to the target function. The only valid (and the default) payload version is `"2020-04-01"`.
         */
        payloadVersion?: string;
        /**
         * The ARN of the target function.
         */
        targetArn: string;
    }

    export interface ThingGroupMetadata {
        creationDate: string;
        /**
         * The name of the parent Thing Group.
         */
        parentGroupName: string;
        rootToParentGroups: outputs.iot.ThingGroupMetadataRootToParentGroup[];
    }

    export interface ThingGroupMetadataRootToParentGroup {
        groupArn: string;
        groupName: string;
    }

    export interface ThingGroupProperties {
        /**
         * The Thing Group attributes. Defined below.
         */
        attributePayload?: outputs.iot.ThingGroupPropertiesAttributePayload;
        /**
         * A description of the Thing Group.
         */
        description?: string;
    }

    export interface ThingGroupPropertiesAttributePayload {
        /**
         * Key-value map.
         */
        attributes?: {[key: string]: string};
    }

    export interface ThingTypeProperties {
        /**
         * The description of the thing type.
         */
        description?: string;
        /**
         * A list of searchable thing attribute names.
         */
        searchableAttributes: string[];
    }

    export interface TopicRuleCloudwatchAlarm {
        /**
         * The CloudWatch alarm name.
         */
        alarmName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
        /**
         * The reason for the alarm change.
         */
        stateReason: string;
        /**
         * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
         */
        stateValue: string;
    }

    export interface TopicRuleCloudwatchLog {
        /**
         * The CloudWatch log group name.
         */
        logGroupName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleCloudwatchMetric {
        /**
         * The CloudWatch metric name.
         */
        metricName: string;
        /**
         * The CloudWatch metric namespace name.
         */
        metricNamespace: string;
        /**
         * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
         */
        metricTimestamp?: string;
        /**
         * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
         */
        metricUnit: string;
        /**
         * The CloudWatch metric value.
         */
        metricValue: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch metric.
         */
        roleArn: string;
    }

    export interface TopicRuleDestinationVpcConfiguration {
        /**
         * The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
         */
        roleArn: string;
        /**
         * The security groups of the VPC destination.
         */
        securityGroups?: string[];
        /**
         * The subnet IDs of the VPC destination.
         */
        subnetIds: string[];
        /**
         * The ID of the VPC.
         */
        vpcId: string;
    }

    export interface TopicRuleDynamodb {
        /**
         * The hash key name.
         */
        hashKeyField: string;
        /**
         * The hash key type. Valid values are "STRING" or "NUMBER".
         */
        hashKeyType?: string;
        /**
         * The hash key value.
         */
        hashKeyValue: string;
        /**
         * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
         */
        operation?: string;
        /**
         * The action payload.
         */
        payloadField?: string;
        /**
         * The range key name.
         */
        rangeKeyField?: string;
        /**
         * The range key type. Valid values are "STRING" or "NUMBER".
         */
        rangeKeyType?: string;
        /**
         * The range key value.
         */
        rangeKeyValue?: string;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }

    export interface TopicRuleDynamodbv2 {
        /**
         * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
         */
        putItem?: outputs.iot.TopicRuleDynamodbv2PutItem;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleDynamodbv2PutItem {
        /**
         * The name of the DynamoDB table.
         *
         * The `dynamodbv2` object takes the following arguments:
         */
        tableName: string;
    }

    export interface TopicRuleElasticsearch {
        /**
         * The endpoint of your Elasticsearch domain.
         */
        endpoint: string;
        /**
         * The unique identifier for the document you are storing.
         */
        id: string;
        /**
         * The Elasticsearch index where you want to store your data.
         */
        index: string;
        /**
         * The IAM role ARN that has access to Elasticsearch.
         */
        roleArn: string;
        /**
         * The type of document you are storing.
         */
        type: string;
    }

    export interface TopicRuleErrorAction {
        cloudwatchAlarm?: outputs.iot.TopicRuleErrorActionCloudwatchAlarm;
        cloudwatchLogs?: outputs.iot.TopicRuleErrorActionCloudwatchLogs;
        cloudwatchMetric?: outputs.iot.TopicRuleErrorActionCloudwatchMetric;
        dynamodb?: outputs.iot.TopicRuleErrorActionDynamodb;
        dynamodbv2?: outputs.iot.TopicRuleErrorActionDynamodbv2;
        elasticsearch?: outputs.iot.TopicRuleErrorActionElasticsearch;
        firehose?: outputs.iot.TopicRuleErrorActionFirehose;
        http?: outputs.iot.TopicRuleErrorActionHttp;
        iotAnalytics?: outputs.iot.TopicRuleErrorActionIotAnalytics;
        iotEvents?: outputs.iot.TopicRuleErrorActionIotEvents;
        kafka?: outputs.iot.TopicRuleErrorActionKafka;
        kinesis?: outputs.iot.TopicRuleErrorActionKinesis;
        lambda?: outputs.iot.TopicRuleErrorActionLambda;
        republish?: outputs.iot.TopicRuleErrorActionRepublish;
        s3?: outputs.iot.TopicRuleErrorActionS3;
        sns?: outputs.iot.TopicRuleErrorActionSns;
        sqs?: outputs.iot.TopicRuleErrorActionSqs;
        stepFunctions?: outputs.iot.TopicRuleErrorActionStepFunctions;
        timestream?: outputs.iot.TopicRuleErrorActionTimestream;
    }

    export interface TopicRuleErrorActionCloudwatchAlarm {
        /**
         * The CloudWatch alarm name.
         */
        alarmName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
        /**
         * The reason for the alarm change.
         */
        stateReason: string;
        /**
         * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
         */
        stateValue: string;
    }

    export interface TopicRuleErrorActionCloudwatchLogs {
        /**
         * The CloudWatch log group name.
         */
        logGroupName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionCloudwatchMetric {
        /**
         * The CloudWatch metric name.
         */
        metricName: string;
        /**
         * The CloudWatch metric namespace name.
         */
        metricNamespace: string;
        /**
         * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
         */
        metricTimestamp?: string;
        /**
         * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
         */
        metricUnit: string;
        /**
         * The CloudWatch metric value.
         */
        metricValue: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch metric.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionDynamodb {
        /**
         * The hash key name.
         */
        hashKeyField: string;
        /**
         * The hash key type. Valid values are "STRING" or "NUMBER".
         */
        hashKeyType?: string;
        /**
         * The hash key value.
         */
        hashKeyValue: string;
        /**
         * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
         */
        operation?: string;
        /**
         * The action payload.
         */
        payloadField?: string;
        /**
         * The range key name.
         */
        rangeKeyField?: string;
        /**
         * The range key type. Valid values are "STRING" or "NUMBER".
         */
        rangeKeyType?: string;
        /**
         * The range key value.
         */
        rangeKeyValue?: string;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }

    export interface TopicRuleErrorActionDynamodbv2 {
        /**
         * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
         */
        putItem?: outputs.iot.TopicRuleErrorActionDynamodbv2PutItem;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionDynamodbv2PutItem {
        /**
         * The name of the DynamoDB table.
         *
         * The `dynamodbv2` object takes the following arguments:
         */
        tableName: string;
    }

    export interface TopicRuleErrorActionElasticsearch {
        /**
         * The endpoint of your Elasticsearch domain.
         */
        endpoint: string;
        /**
         * The unique identifier for the document you are storing.
         */
        id: string;
        /**
         * The Elasticsearch index where you want to store your data.
         */
        index: string;
        /**
         * The IAM role ARN that has access to Elasticsearch.
         */
        roleArn: string;
        /**
         * The type of document you are storing.
         */
        type: string;
    }

    export interface TopicRuleErrorActionFirehose {
        /**
         * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
         */
        batchMode?: boolean;
        /**
         * The delivery stream name.
         */
        deliveryStreamName: string;
        /**
         * The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
         */
        roleArn: string;
        /**
         * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }

    export interface TopicRuleErrorActionHttp {
        /**
         * The HTTPS URL used to verify ownership of `url`.
         */
        confirmationUrl?: string;
        /**
         * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
         */
        httpHeaders?: outputs.iot.TopicRuleErrorActionHttpHttpHeader[];
        /**
         * The HTTPS URL.
         */
        url: string;
    }

    export interface TopicRuleErrorActionHttpHttpHeader {
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface TopicRuleErrorActionIotAnalytics {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
         */
        batchMode?: boolean;
        /**
         * Name of AWS IOT Analytics channel.
         */
        channelName: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionIotEvents {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
         */
        batchMode?: boolean;
        /**
         * The name of the AWS IoT Events input.
         */
        inputName: string;
        /**
         * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
         */
        messageId?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionKafka {
        /**
         * Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
         */
        clientProperties: {[key: string]: string};
        /**
         * The ARN of Kafka action's VPC `aws.iot.TopicRuleDestination` .
         */
        destinationArn: string;
        /**
         * The Kafka message key.
         */
        key?: string;
        /**
         * The Kafka message partition.
         */
        partition?: string;
        /**
         * The Kafka topic for messages to be sent to the Kafka broker.
         */
        topic: string;
    }

    export interface TopicRuleErrorActionKinesis {
        /**
         * The partition key.
         */
        partitionKey?: string;
        /**
         * The ARN of the IAM role that grants access to the Amazon Kinesis stream.
         */
        roleArn: string;
        /**
         * The name of the Amazon Kinesis stream.
         */
        streamName: string;
    }

    export interface TopicRuleErrorActionLambda {
        /**
         * The ARN of the Lambda function.
         */
        functionArn: string;
    }

    export interface TopicRuleErrorActionRepublish {
        /**
         * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
         *
         * The `s3` object takes the following arguments:
         */
        qos?: number;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The name of the MQTT topic the message should be republished to.
         */
        topic: string;
    }

    export interface TopicRuleErrorActionS3 {
        /**
         * The Amazon S3 bucket name.
         */
        bucketName: string;
        /**
         * The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
         */
        cannedAcl?: string;
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleErrorActionSns {
        /**
         * The message format of the message to publish. Accepted values are "JSON" and "RAW".
         */
        messageFormat?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The ARN of the SNS topic.
         */
        targetArn: string;
    }

    export interface TopicRuleErrorActionSqs {
        /**
         * The URL of the Amazon SQS queue.
         */
        queueUrl: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * Specifies whether to use Base64 encoding.
         */
        useBase64: boolean;
    }

    export interface TopicRuleErrorActionStepFunctions {
        /**
         * The prefix used to generate, along with a UUID, the unique state machine execution name.
         */
        executionNamePrefix?: string;
        /**
         * The ARN of the IAM role that grants access to start execution of the state machine.
         */
        roleArn: string;
        /**
         * The name of the Step Functions state machine whose execution will be started.
         */
        stateMachineName: string;
    }

    export interface TopicRuleErrorActionTimestream {
        /**
         * The name of an Amazon Timestream database.
         */
        databaseName: string;
        /**
         * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
         */
        dimensions: outputs.iot.TopicRuleErrorActionTimestreamDimension[];
        /**
         * The ARN of the role that grants permission to write to the Amazon Timestream database table.
         */
        roleArn: string;
        /**
         * The name of the database table into which to write the measure records.
         */
        tableName: string;
        /**
         * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
         */
        timestamp?: outputs.iot.TopicRuleErrorActionTimestreamTimestamp;
    }

    export interface TopicRuleErrorActionTimestreamDimension {
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface TopicRuleErrorActionTimestreamTimestamp {
        /**
         * The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
         */
        unit: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface TopicRuleFirehose {
        /**
         * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
         */
        batchMode?: boolean;
        /**
         * The delivery stream name.
         */
        deliveryStreamName: string;
        /**
         * The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
         */
        roleArn: string;
        /**
         * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }

    export interface TopicRuleHttp {
        /**
         * The HTTPS URL used to verify ownership of `url`.
         */
        confirmationUrl?: string;
        /**
         * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
         */
        httpHeaders?: outputs.iot.TopicRuleHttpHttpHeader[];
        /**
         * The HTTPS URL.
         */
        url: string;
    }

    export interface TopicRuleHttpHttpHeader {
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface TopicRuleIotAnalytic {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
         */
        batchMode?: boolean;
        /**
         * Name of AWS IOT Analytics channel.
         */
        channelName: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }

    export interface TopicRuleIotEvent {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
         */
        batchMode?: boolean;
        /**
         * The name of the AWS IoT Events input.
         */
        inputName: string;
        /**
         * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
         */
        messageId?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }

    export interface TopicRuleKafka {
        /**
         * Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
         */
        clientProperties: {[key: string]: string};
        /**
         * The ARN of Kafka action's VPC `aws.iot.TopicRuleDestination` .
         */
        destinationArn: string;
        /**
         * The Kafka message key.
         */
        key?: string;
        /**
         * The Kafka message partition.
         */
        partition?: string;
        /**
         * The Kafka topic for messages to be sent to the Kafka broker.
         */
        topic: string;
    }

    export interface TopicRuleKinesis {
        /**
         * The partition key.
         */
        partitionKey?: string;
        /**
         * The ARN of the IAM role that grants access to the Amazon Kinesis stream.
         */
        roleArn: string;
        /**
         * The name of the Amazon Kinesis stream.
         */
        streamName: string;
    }

    export interface TopicRuleLambda {
        /**
         * The ARN of the Lambda function.
         */
        functionArn: string;
    }

    export interface TopicRuleRepublish {
        /**
         * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
         *
         * The `s3` object takes the following arguments:
         */
        qos?: number;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The name of the MQTT topic the message should be republished to.
         */
        topic: string;
    }

    export interface TopicRuleS3 {
        /**
         * The Amazon S3 bucket name.
         */
        bucketName: string;
        /**
         * The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
         */
        cannedAcl?: string;
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }

    export interface TopicRuleSns {
        /**
         * The message format of the message to publish. Accepted values are "JSON" and "RAW".
         */
        messageFormat?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The ARN of the SNS topic.
         */
        targetArn: string;
    }

    export interface TopicRuleSqs {
        /**
         * The URL of the Amazon SQS queue.
         */
        queueUrl: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * Specifies whether to use Base64 encoding.
         */
        useBase64: boolean;
    }

    export interface TopicRuleStepFunction {
        /**
         * The prefix used to generate, along with a UUID, the unique state machine execution name.
         */
        executionNamePrefix?: string;
        /**
         * The ARN of the IAM role that grants access to start execution of the state machine.
         */
        roleArn: string;
        /**
         * The name of the Step Functions state machine whose execution will be started.
         */
        stateMachineName: string;
    }

    export interface TopicRuleTimestream {
        /**
         * The name of an Amazon Timestream database.
         */
        databaseName: string;
        /**
         * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
         */
        dimensions: outputs.iot.TopicRuleTimestreamDimension[];
        /**
         * The ARN of the role that grants permission to write to the Amazon Timestream database table.
         */
        roleArn: string;
        /**
         * The name of the database table into which to write the measure records.
         */
        tableName: string;
        /**
         * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
         */
        timestamp?: outputs.iot.TopicRuleTimestreamTimestamp;
    }

    export interface TopicRuleTimestreamDimension {
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface TopicRuleTimestreamTimestamp {
        /**
         * The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
         */
        unit: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

}

export namespace ivs {
    export interface RecordingConfigurationDestinationConfiguration {
        /**
         * S3 destination configuration where recorded videos will be stored.
         */
        s3: outputs.ivs.RecordingConfigurationDestinationConfigurationS3;
    }

    export interface RecordingConfigurationDestinationConfigurationS3 {
        /**
         * S3 bucket name where recorded videos will be stored.
         *
         * The following arguments are optional:
         */
        bucketName: string;
    }

    export interface RecordingConfigurationThumbnailConfiguration {
        /**
         * Thumbnail recording mode. Valid values: `DISABLED`, `INTERVAL`.
         */
        recordingMode: string;
        /**
         * The targeted thumbnail-generation interval in seconds.
         */
        targetIntervalSeconds: number;
    }

}

export namespace ivschat {
    export interface LoggingConfigurationDestinationConfiguration {
        /**
         * An Amazon CloudWatch Logs destination configuration where chat activity will be logged.
         */
        cloudwatchLogs?: outputs.ivschat.LoggingConfigurationDestinationConfigurationCloudwatchLogs;
        /**
         * An Amazon Kinesis Data Firehose destination configuration where chat activity will be logged.
         */
        firehose?: outputs.ivschat.LoggingConfigurationDestinationConfigurationFirehose;
        /**
         * An Amazon S3 destination configuration where chat activity will be logged.
         */
        s3?: outputs.ivschat.LoggingConfigurationDestinationConfigurationS3;
    }

    export interface LoggingConfigurationDestinationConfigurationCloudwatchLogs {
        /**
         * Name of the Amazon Cloudwatch Logs destination where chat activity will be logged.
         */
        logGroupName: string;
    }

    export interface LoggingConfigurationDestinationConfigurationFirehose {
        /**
         * Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
         */
        deliveryStreamName: string;
    }

    export interface LoggingConfigurationDestinationConfigurationS3 {
        /**
         * Name of the Amazon S3 bucket where chat activity will be logged.
         *
         * The following arguments are optional:
         */
        bucketName: string;
    }

    export interface RoomMessageReviewHandler {
        /**
         * The fallback behavior (whether the message
         * is allowed or denied) if the handler does not return a valid response,
         * encounters an error, or times out. Valid values: `ALLOW`, `DENY`.
         */
        fallbackResult: string;
        /**
         * ARN of the lambda message review handler function.
         */
        uri?: string;
    }

}

export namespace kendra {
    export interface DataSourceConfiguration {
        /**
         * A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
         */
        s3Configuration?: outputs.kendra.DataSourceConfigurationS3Configuration;
        /**
         * A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
         */
        webCrawlerConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfiguration;
    }

    export interface DataSourceConfigurationS3Configuration {
        /**
         * A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see [Access control for S3 data sources](https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html). Detailed below.
         */
        accessControlListConfiguration?: outputs.kendra.DataSourceConfigurationS3ConfigurationAccessControlListConfiguration;
        /**
         * The name of the bucket that contains the documents.
         */
        bucketName: string;
        /**
         * A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
         */
        documentsMetadataConfiguration?: outputs.kendra.DataSourceConfigurationS3ConfigurationDocumentsMetadataConfiguration;
        /**
         * A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to [Exclusion Patterns for more examples](https://docs.aws.amazon.com/kendra/latest/dg/API_S3DataSourceConfiguration.html#Kendra-Type-S3DataSourceConfiguration-ExclusionPatterns).
         */
        exclusionPatterns?: string[];
        /**
         * A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to [Inclusion Patterns for more examples](https://docs.aws.amazon.com/kendra/latest/dg/API_S3DataSourceConfiguration.html#Kendra-Type-S3DataSourceConfiguration-InclusionPatterns).
         */
        inclusionPatterns?: string[];
        /**
         * A list of S3 prefixes for the documents that should be included in the index.
         */
        inclusionPrefixes?: string[];
    }

    export interface DataSourceConfigurationS3ConfigurationAccessControlListConfiguration {
        /**
         * Path to the AWS S3 bucket that contains the ACL files.
         */
        keyPath?: string;
    }

    export interface DataSourceConfigurationS3ConfigurationDocumentsMetadataConfiguration {
        /**
         * A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use `s3Prefix` to include only the desired metadata files.
         */
        s3Prefix?: string;
    }

    export interface DataSourceConfigurationWebCrawlerConfiguration {
        /**
         * A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"` and the port is `443`, the standard port for HTTPS. Detailed below.
         */
        authenticationConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfiguration;
        /**
         * Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to `2`. Minimum value of `0`. Maximum value of `10`.
         */
        crawlDepth?: number;
        /**
         * The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to `50` MB. Minimum value of `1.0e-06`. Maximum value of `50`.
         */
        maxContentSizePerPageInMegaBytes?: number;
        /**
         * The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is `100`. Minimum value of `1`. Maximum value of `1000`.
         */
        maxLinksPerPage?: number;
        /**
         * The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is `300`. Minimum value of `1`. Maximum value of `300`.
         */
        maxUrlsPerMinuteCrawlRate?: number;
        /**
         * Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"` and the port is `443`, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html). Detailed below.
         */
        proxyConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationProxyConfiguration;
        /**
         * A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `150`.
         */
        urlExclusionPatterns?: string[];
        /**
         * A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `150`.
         */
        urlInclusionPatterns?: string[];
        /**
         * A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to `100` seed URLs and up to `3` sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the [Amazon Acceptable Use Policy](https://aws.amazon.com/aup/) and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
         */
        urls: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrls;
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
        /**
         * The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
         */
        basicAuthentications?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication[];
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication {
        /**
         * Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
         */
        credentials: string;
        /**
         * The name of the website host you want to connect to using authentication credentials. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"`.
         */
        host: string;
        /**
         * The port number of the website host you want to connect to using authentication credentials. For example, the port for `https://a.example.com/page1.html` is `443`, the standard port for HTTPS.
         */
        port: number;
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationProxyConfiguration {
        /**
         * Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.
         */
        credentials?: string;
        /**
         * The name of the website host you want to connect to via a web proxy server. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"`.
         */
        host: string;
        /**
         * The port number of the website host you want to connect to via a web proxy server. For example, the port for `https://a.example.com/page1.html` is `443`, the standard port for HTTPS.
         */
        port: number;
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationUrls {
        /**
         * A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to `100` seed URLs. Detailed below.
         */
        seedUrlConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration;
        /**
         * A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to `3` sitemap URLs. Detailed below.
         */
        siteMapsConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration;
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
        /**
         * The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of `100` seed URLs. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `2048`.
         */
        seedUrls: string[];
        /**
         * The default mode is set to `HOST_ONLY`. You can choose one of the following modes:
         */
        webCrawlerMode?: string;
    }

    export interface DataSourceConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
        /**
         * The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of `3` sitemap URLs.
         */
        siteMaps: string[];
    }

    export interface DataSourceCustomDocumentEnrichmentConfiguration {
        /**
         * Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of `0` items. Maximum number of `100` items. Detailed below.
         */
        inlineConfigurations?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfiguration[];
        /**
         * A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation). Detailed below.
         */
        postExtractionHookConfiguration?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration;
        /**
         * Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation). Detailed below.
         */
        preExtractionHookConfiguration?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration;
        /**
         * The Amazon Resource Name (ARN) of a role with permission to run `preExtractionHookConfiguration` and `postExtractionHookConfiguration` for altering document metadata and content during the document ingestion process. For more information, see [IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html).
         */
        roleArn?: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfiguration {
        /**
         * Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
         */
        condition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationCondition;
        /**
         * `TRUE` to delete content if the condition used for the target attribute is met.
         */
        documentContentDeletion?: boolean;
        /**
         * Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
         */
        target?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTarget;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTarget {
        /**
         * The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
         */
        targetDocumentAttributeKey?: string;
        /**
         * The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
         */
        targetDocumentAttributeValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTargetTargetDocumentAttributeValue;
        /**
         * `TRUE` to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to `TRUE`. To create a target value (`TargetDocumentAttributeValue`), set this to `FALSE`.
         */
        targetDocumentAttributeValueDeletion?: boolean;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTargetTargetDocumentAttributeValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
        /**
         * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
         */
        invocationCondition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition;
        /**
         * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
         */
        lambdaArn: string;
        /**
         * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda).
         */
        s3Bucket: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
        /**
         * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
         */
        invocationCondition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition;
        /**
         * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
         */
        lambdaArn: string;
        /**
         * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda).
         */
        s3Bucket: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }

    export interface ExperienceConfiguration {
        /**
         * The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the `BatchPutDocument API`. The provider will only perform drift detection of its value when present in a configuration. Detailed below.
         */
        contentSourceConfiguration: outputs.kendra.ExperienceConfigurationContentSourceConfiguration;
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails. Detailed below.
         */
        userIdentityConfiguration?: outputs.kendra.ExperienceConfigurationUserIdentityConfiguration;
    }

    export interface ExperienceConfigurationContentSourceConfiguration {
        /**
         * The identifiers of the data sources you want to use for your Amazon Kendra experience. Maximum number of 100 items.
         */
        dataSourceIds?: string[];
        /**
         * Whether to use documents you indexed directly using the `BatchPutDocument API`. Defaults to `false`.
         */
        directPutContent?: boolean;
        /**
         * The identifier of the FAQs that you want to use for your Amazon Kendra experience. Maximum number of 100 items.
         */
        faqIds?: string[];
    }

    export interface ExperienceConfigurationUserIdentityConfiguration {
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails.
         */
        identityAttributeName: string;
    }

    export interface ExperienceEndpoint {
        /**
         * The endpoint of your Amazon Kendra experience.
         */
        endpoint: string;
        /**
         * The type of endpoint for your Amazon Kendra experience.
         */
        endpointType: string;
    }

    export interface FaqS3Path {
        /**
         * The name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * The name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }

    export interface GetExperienceConfiguration {
        /**
         * The identifiers of your data sources and FAQs. This is the content you want to use for your Amazon Kendra Experience. Documented below.
         */
        contentSourceConfigurations: outputs.kendra.GetExperienceConfigurationContentSourceConfiguration[];
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails. Documented below.
         */
        userIdentityConfigurations: outputs.kendra.GetExperienceConfigurationUserIdentityConfiguration[];
    }

    export interface GetExperienceConfigurationContentSourceConfiguration {
        /**
         * Identifiers of the data sources you want to use for your Amazon Kendra Experience.
         */
        dataSourceIds: string[];
        /**
         * Whether to use documents you indexed directly using the `BatchPutDocument API`.
         */
        directPutContent: boolean;
        /**
         * Identifier of the FAQs that you want to use for your Amazon Kendra Experience.
         */
        faqIds: string[];
    }

    export interface GetExperienceConfigurationUserIdentityConfiguration {
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails.
         */
        identityAttributeName: string;
    }

    export interface GetExperienceEndpoint {
        /**
         * Endpoint of your Amazon Kendra Experience.
         */
        endpoint: string;
        /**
         * Type of endpoint for your Amazon Kendra Experience.
         */
        endpointType: string;
    }

    export interface GetFaqS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }

    export interface GetIndexCapacityUnit {
        /**
         * The amount of extra query capacity for an index and GetQuerySuggestions capacity. For more information, refer to [QueryCapacityUnits](https://docs.aws.amazon.com/kendra/latest/APIReference/API_CapacityUnitsConfiguration.html#Kendra-Type-CapacityUnitsConfiguration-QueryCapacityUnits).
         */
        queryCapacityUnits: number;
        /**
         * The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. Minimum value of 0.
         */
        storageCapacityUnits: number;
    }

    export interface GetIndexDocumentMetadataConfigurationUpdate {
        /**
         * Name of the index field. Minimum length of 1. Maximum length of 30.
         */
        name: string;
        /**
         * Block that provides manual tuning parameters to determine how the field affects the search results. Documented below.
         */
        relevances: outputs.kendra.GetIndexDocumentMetadataConfigurationUpdateRelevance[];
        /**
         * Block that provides information about how the field is used during a search. Documented below.
         */
        searches: outputs.kendra.GetIndexDocumentMetadataConfigurationUpdateSearch[];
        /**
         * Data type of the index field. Valid values are `STRING_VALUE`, `STRING_LIST_VALUE`, `LONG_VALUE`, `DATE_VALUE`.
         */
        type: string;
    }

    export interface GetIndexDocumentMetadataConfigurationUpdateRelevance {
        /**
         * Time period that the boost applies to. For more information, refer to [Duration](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-Duration).
         */
        duration: string;
        /**
         * How "fresh" a document is. For more information, refer to [Freshness](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-Freshness).
         */
        freshness: boolean;
        /**
         * Relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers. Minimum value of 1. Maximum value of 10.
         */
        importance: number;
        /**
         * Determines how values should be interpreted. For more information, refer to [RankOrder](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-RankOrder).
         */
        rankOrder: string;
        /**
         * A list of values that should be given a different boost when they appear in the result list. For more information, refer to [ValueImportanceMap](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-ValueImportanceMap).
         */
        valuesImportanceMap: {[key: string]: number};
    }

    export interface GetIndexDocumentMetadataConfigurationUpdateSearch {
        /**
         * Determines whether the field is returned in the query response. The default is `true`.
         */
        displayable: boolean;
        /**
         * Whether the field can be used to create search facets, a count of results for each value in the field. The default is `false`.
         */
        facetable: boolean;
        /**
         * Determines whether the field is used in the search. If the Searchable field is true, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is `true` for `string` fields and `false` for `number` and `date` fields.
         */
        searchable: boolean;
        /**
         * Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have Sortable set to true, Amazon Kendra returns an exception. The default is `false`.
         */
        sortable: boolean;
    }

    export interface GetIndexIndexStatistic {
        /**
         * Block that specifies the number of question and answer topics in the index. Documented below.
         */
        faqStatistics: outputs.kendra.GetIndexIndexStatisticFaqStatistic[];
        /**
         * A block that specifies the number of text documents indexed.
         */
        textDocumentStatistics: outputs.kendra.GetIndexIndexStatisticTextDocumentStatistic[];
    }

    export interface GetIndexIndexStatisticFaqStatistic {
        /**
         * The total number of FAQ questions and answers contained in the index.
         */
        indexedQuestionAnswersCount: number;
    }

    export interface GetIndexIndexStatisticTextDocumentStatistic {
        /**
         * Total size, in bytes, of the indexed documents.
         */
        indexedTextBytes: number;
        /**
         * The number of text documents indexed.
         */
        indexedTextDocumentsCount: number;
    }

    export interface GetIndexServerSideEncryptionConfiguration {
        /**
         * Identifier of the AWS KMScustomer master key (CMK). Amazon Kendra doesn't support asymmetric CMKs.
         */
        kmsKeyId: string;
    }

    export interface GetIndexUserGroupResolutionConfiguration {
        /**
         * The identity store provider (mode) you want to use to fetch access levels of groups and users. AWS Single Sign-On is currently the only available mode. Your users and groups must exist in an AWS SSO identity source in order to use this mode. Valid Values are `AWS_SSO` or `NONE`.
         */
        userGroupResolutionMode: string;
    }

    export interface GetIndexUserTokenConfiguration {
        /**
         * A block that specifies the information about the JSON token type configuration.
         */
        jsonTokenTypeConfigurations: outputs.kendra.GetIndexUserTokenConfigurationJsonTokenTypeConfiguration[];
        /**
         * A block that specifies the information about the JWT token type configuration.
         */
        jwtTokenTypeConfigurations: outputs.kendra.GetIndexUserTokenConfigurationJwtTokenTypeConfiguration[];
    }

    export interface GetIndexUserTokenConfigurationJsonTokenTypeConfiguration {
        /**
         * The group attribute field.
         */
        groupAttributeField: string;
        /**
         * The user name attribute field.
         */
        userNameAttributeField: string;
    }

    export interface GetIndexUserTokenConfigurationJwtTokenTypeConfiguration {
        /**
         * Regular expression that identifies the claim.
         */
        claimRegex: string;
        /**
         * The group attribute field.
         */
        groupAttributeField: string;
        /**
         * Issuer of the token.
         */
        issuer: string;
        /**
         * Location of the key. Valid values are `URL` or `SECRET_MANAGER`
         */
        keyLocation: string;
        /**
         * ARN of the secret.
         */
        secretsManagerArn: string;
        /**
         * Signing key URL.
         */
        url: string;
        /**
         * The user name attribute field.
         */
        userNameAttributeField: string;
    }

    export interface GetQuerySuggestionsBlockListSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }

    export interface GetThesaurusSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }

    export interface IndexCapacityUnits {
        /**
         * The amount of extra query capacity for an index and GetQuerySuggestions capacity. For more information, refer to [QueryCapacityUnits](https://docs.aws.amazon.com/kendra/latest/dg/API_CapacityUnitsConfiguration.html#Kendra-Type-CapacityUnitsConfiguration-QueryCapacityUnits).
         */
        queryCapacityUnits: number;
        /**
         * The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. Minimum value of 0.
         */
        storageCapacityUnits: number;
    }

    export interface IndexDocumentMetadataConfigurationUpdate {
        /**
         * The name of the index field. Minimum length of 1. Maximum length of 30.
         */
        name: string;
        /**
         * A block that provides manual tuning parameters to determine how the field affects the search results. Detailed below
         */
        relevance: outputs.kendra.IndexDocumentMetadataConfigurationUpdateRelevance;
        /**
         * A block that provides information about how the field is used during a search. Documented below. Detailed below
         */
        search: outputs.kendra.IndexDocumentMetadataConfigurationUpdateSearch;
        /**
         * The data type of the index field. Valid values are `STRING_VALUE`, `STRING_LIST_VALUE`, `LONG_VALUE`, `DATE_VALUE`.
         */
        type: string;
    }

    export interface IndexDocumentMetadataConfigurationUpdateRelevance {
        /**
         * Specifies the time period that the boost applies to. For more information, refer to [Duration](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-Duration).
         */
        duration: string;
        /**
         * Indicates that this field determines how "fresh" a document is. For more information, refer to [Freshness](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-Freshness).
         */
        freshness: boolean;
        /**
         * The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers. Minimum value of 1. Maximum value of 10.
         */
        importance: number;
        /**
         * Determines how values should be interpreted. For more information, refer to [RankOrder](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-RankOrder).
         */
        rankOrder: string;
        /**
         * A list of values that should be given a different boost when they appear in the result list. For more information, refer to [ValueImportanceMap](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-ValueImportanceMap).
         */
        valuesImportanceMap: {[key: string]: number};
    }

    export interface IndexDocumentMetadataConfigurationUpdateSearch {
        /**
         * Determines whether the field is returned in the query response. The default is `true`.
         */
        displayable: boolean;
        /**
         * Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is `false`.
         */
        facetable: boolean;
        /**
         * Determines whether the field is used in the search. If the Searchable field is true, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is `true` for `string` fields and `false` for `number` and `date` fields.
         */
        searchable: boolean;
        /**
         * Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have Sortable set to true, Amazon Kendra returns an exception. The default is `false`.
         */
        sortable: boolean;
    }

    export interface IndexIndexStatistic {
        /**
         * A block that specifies the number of question and answer topics in the index. Detailed below.
         */
        faqStatistics: outputs.kendra.IndexIndexStatisticFaqStatistic[];
        /**
         * A block that specifies the number of text documents indexed. Detailed below.
         */
        textDocumentStatistics: outputs.kendra.IndexIndexStatisticTextDocumentStatistic[];
    }

    export interface IndexIndexStatisticFaqStatistic {
        /**
         * The total number of FAQ questions and answers contained in the index.
         */
        indexedQuestionAnswersCount: number;
    }

    export interface IndexIndexStatisticTextDocumentStatistic {
        /**
         * The total size, in bytes, of the indexed documents.
         */
        indexedTextBytes: number;
        /**
         * The number of text documents indexed.
         */
        indexedTextDocumentsCount: number;
    }

    export interface IndexServerSideEncryptionConfiguration {
        /**
         * The identifier of the AWS KMScustomer master key (CMK). Amazon Kendra doesn't support asymmetric CMKs.
         */
        kmsKeyId?: string;
    }

    export interface IndexUserGroupResolutionConfiguration {
        /**
         * The identity store provider (mode) you want to use to fetch access levels of groups and users. AWS Single Sign-On is currently the only available mode. Your users and groups must exist in an AWS SSO identity source in order to use this mode. Valid Values are `AWS_SSO` or `NONE`.
         */
        userGroupResolutionMode: string;
    }

    export interface IndexUserTokenConfigurations {
        /**
         * A block that specifies the information about the JSON token type configuration. Detailed below.
         */
        jsonTokenTypeConfiguration?: outputs.kendra.IndexUserTokenConfigurationsJsonTokenTypeConfiguration;
        /**
         * A block that specifies the information about the JWT token type configuration. Detailed below.
         */
        jwtTokenTypeConfiguration?: outputs.kendra.IndexUserTokenConfigurationsJwtTokenTypeConfiguration;
    }

    export interface IndexUserTokenConfigurationsJsonTokenTypeConfiguration {
        /**
         * The group attribute field. Minimum length of 1. Maximum length of 2048.
         */
        groupAttributeField: string;
        /**
         * The user name attribute field. Minimum length of 1. Maximum length of 2048.
         */
        userNameAttributeField: string;
    }

    export interface IndexUserTokenConfigurationsJwtTokenTypeConfiguration {
        /**
         * The regular expression that identifies the claim. Minimum length of 1. Maximum length of 100.
         */
        claimRegex?: string;
        /**
         * The group attribute field. Minimum length of 1. Maximum length of 100.
         */
        groupAttributeField?: string;
        /**
         * The issuer of the token. Minimum length of 1. Maximum length of 65.
         */
        issuer?: string;
        /**
         * The location of the key. Valid values are `URL` or `SECRET_MANAGER`
         */
        keyLocation: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretsManagerArn?: string;
        /**
         * The signing key URL. Valid pattern is `^(https?|ftp|file):\/\/([^\s]*)`
         */
        url?: string;
        /**
         * The user name attribute field. Minimum length of 1. Maximum length of 100.
         */
        userNameAttributeField?: string;
    }

    export interface QuerySuggestionsBlockListSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }

    export interface ThesaurusSourceS3Path {
        /**
         * The name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * The name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }

}

export namespace keyspaces {
    export interface TableCapacitySpecification {
        /**
         * The throughput capacity specified for read operations defined in read capacity units (RCUs).
         */
        readCapacityUnits?: number;
        /**
         * The read/write throughput capacity mode for a table. Valid values: `PAY_PER_REQUEST`, `PROVISIONED`. The default value is `PAY_PER_REQUEST`.
         */
        throughputMode: string;
        /**
         * The throughput capacity specified for write operations defined in write capacity units (WCUs).
         */
        writeCapacityUnits?: number;
    }

    export interface TableClientSideTimestamps {
        /**
         * Shows how to enable client-side timestamps settings for the specified table. Valid values: `ENABLED`.
         */
        status: string;
    }

    export interface TableComment {
        /**
         * A description of the table.
         */
        message: string;
    }

    export interface TableEncryptionSpecification {
        /**
         * The Amazon Resource Name (ARN) of the customer managed KMS key.
         */
        kmsKeyIdentifier?: string;
        /**
         * The encryption option specified for the table. Valid values: `AWS_OWNED_KMS_KEY`, `CUSTOMER_MANAGED_KMS_KEY`. The default value is `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }

    export interface TablePointInTimeRecovery {
        /**
         * Valid values: `ENABLED`, `DISABLED`. The default value is `DISABLED`.
         */
        status: string;
    }

    export interface TableSchemaDefinition {
        /**
         * The columns that are part of the clustering key of the table.
         */
        clusteringKeys?: outputs.keyspaces.TableSchemaDefinitionClusteringKey[];
        /**
         * The regular columns of the table.
         */
        columns: outputs.keyspaces.TableSchemaDefinitionColumn[];
        /**
         * The columns that are part of the partition key of the table .
         */
        partitionKeys: outputs.keyspaces.TableSchemaDefinitionPartitionKey[];
        /**
         * The columns that have been defined as `STATIC`. Static columns store values that are shared by all rows in the same partition.
         */
        staticColumns?: outputs.keyspaces.TableSchemaDefinitionStaticColumn[];
    }

    export interface TableSchemaDefinitionClusteringKey {
        /**
         * The name of the clustering key column.
         */
        name: string;
        /**
         * The order modifier. Valid values: `ASC`, `DESC`.
         */
        orderBy: string;
    }

    export interface TableSchemaDefinitionColumn {
        /**
         * The name of the column.
         */
        name: string;
        /**
         * The data type of the column. See the [Developer Guide](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) for a list of available data types.
         */
        type: string;
    }

    export interface TableSchemaDefinitionPartitionKey {
        /**
         * The name of the partition key column.
         */
        name: string;
    }

    export interface TableSchemaDefinitionStaticColumn {
        /**
         * The name of the static column.
         */
        name: string;
    }

    export interface TableTtl {
        /**
         * Valid values: `ENABLED`.
         */
        status: string;
    }

}

export namespace kinesis {
    export interface AnalyticsApplicationCloudwatchLoggingOptions {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The ARN of the CloudWatch Log Stream.
         */
        logStreamArn: string;
        /**
         * The ARN of the IAM Role used to send application messages.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationInputs {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The Kinesis Firehose configuration for the streaming source. Conflicts with `kinesisStream`.
         * See Kinesis Firehose below for more details.
         */
        kinesisFirehose?: outputs.kinesis.AnalyticsApplicationInputsKinesisFirehose;
        /**
         * The Kinesis Stream configuration for the streaming source. Conflicts with `kinesisFirehose`.
         * See Kinesis Stream below for more details.
         */
        kinesisStream?: outputs.kinesis.AnalyticsApplicationInputsKinesisStream;
        /**
         * The Name Prefix to use when creating an in-application stream.
         */
        namePrefix: string;
        /**
         * The number of Parallel in-application streams to create.
         * See Parallelism below for more details.
         */
        parallelism: outputs.kinesis.AnalyticsApplicationInputsParallelism;
        /**
         * The Processing Configuration to transform records as they are received from the stream.
         * See Processing Configuration below for more details.
         */
        processingConfiguration?: outputs.kinesis.AnalyticsApplicationInputsProcessingConfiguration;
        /**
         * The Schema format of the data in the streaming source. See Source Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationInputsSchema;
        /**
         * The point at which the application starts processing records from the streaming source.
         * See Starting Position Configuration below for more details.
         */
        startingPositionConfigurations: outputs.kinesis.AnalyticsApplicationInputsStartingPositionConfiguration[];
        streamNames: string[];
    }

    export interface AnalyticsApplicationInputsKinesisFirehose {
        /**
         * The ARN of the Kinesis Firehose delivery stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationInputsKinesisStream {
        /**
         * The ARN of the Kinesis Stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationInputsParallelism {
        /**
         * The Count of streams.
         */
        count: number;
    }

    export interface AnalyticsApplicationInputsProcessingConfiguration {
        /**
         * The Lambda function configuration. See Lambda below for more details.
         */
        lambda: outputs.kinesis.AnalyticsApplicationInputsProcessingConfigurationLambda;
    }

    export interface AnalyticsApplicationInputsProcessingConfigurationLambda {
        /**
         * The ARN of the Lambda function.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the Lambda function.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationInputsSchema {
        /**
         * The Record Column mapping for the streaming source data element.
         * See Record Columns below for more details.
         */
        recordColumns: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordColumn[];
        /**
         * The Encoding of the record in the streaming source.
         */
        recordEncoding?: string;
        /**
         * The Record Format and mapping information to schematize a record.
         * See Record Format below for more details.
         */
        recordFormat: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormat;
    }

    export interface AnalyticsApplicationInputsSchemaRecordColumn {
        /**
         * The Mapping reference to the data element.
         */
        mapping?: string;
        /**
         * Name of the column.
         */
        name: string;
        /**
         * The SQL Type of the column.
         */
        sqlType: string;
    }

    export interface AnalyticsApplicationInputsSchemaRecordFormat {
        /**
         * The Mapping Information for the record format.
         * See Mapping Parameters below for more details.
         */
        mappingParameters?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParameters;
        /**
         * The type of Record Format. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }

    export interface AnalyticsApplicationInputsSchemaRecordFormatMappingParameters {
        /**
         * Mapping information when the record format uses delimiters.
         * See CSV Mapping Parameters below for more details.
         */
        csv?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParametersCsv;
        /**
         * Mapping information when JSON is the record format on the streaming source.
         * See JSON Mapping Parameters below for more details.
         */
        json?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParametersJson;
    }

    export interface AnalyticsApplicationInputsSchemaRecordFormatMappingParametersCsv {
        /**
         * The Column Delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The Row Delimiter.
         */
        recordRowDelimiter: string;
    }

    export interface AnalyticsApplicationInputsSchemaRecordFormatMappingParametersJson {
        /**
         * Path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }

    export interface AnalyticsApplicationInputsStartingPositionConfiguration {
        /**
         * The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
         */
        startingPosition: string;
    }

    export interface AnalyticsApplicationOutput {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The Kinesis Firehose configuration for the destination stream. Conflicts with `kinesisStream`.
         * See Kinesis Firehose below for more details.
         */
        kinesisFirehose?: outputs.kinesis.AnalyticsApplicationOutputKinesisFirehose;
        /**
         * The Kinesis Stream configuration for the destination stream. Conflicts with `kinesisFirehose`.
         * See Kinesis Stream below for more details.
         */
        kinesisStream?: outputs.kinesis.AnalyticsApplicationOutputKinesisStream;
        /**
         * The Lambda function destination. See Lambda below for more details.
         */
        lambda?: outputs.kinesis.AnalyticsApplicationOutputLambda;
        /**
         * The Name of the in-application stream.
         */
        name: string;
        /**
         * The Schema format of the data written to the destination. See Destination Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationOutputSchema;
    }

    export interface AnalyticsApplicationOutputKinesisFirehose {
        /**
         * The ARN of the Kinesis Firehose delivery stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationOutputKinesisStream {
        /**
         * The ARN of the Kinesis Stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationOutputLambda {
        /**
         * The ARN of the Lambda function.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the Lambda function.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationOutputSchema {
        /**
         * The Format Type of the records on the output stream. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }

    export interface AnalyticsApplicationReferenceDataSources {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The S3 configuration for the reference data source. See S3 Reference below for more details.
         */
        s3: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesS3;
        /**
         * The Schema format of the data in the streaming source. See Source Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchema;
        /**
         * The in-application Table Name.
         */
        tableName: string;
    }

    export interface AnalyticsApplicationReferenceDataSourcesS3 {
        /**
         * The S3 Bucket ARN.
         */
        bucketArn: string;
        /**
         * The File Key name containing reference data.
         */
        fileKey: string;
        /**
         * The ARN of the IAM Role used to send application messages.
         */
        roleArn: string;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchema {
        /**
         * The Record Column mapping for the streaming source data element.
         * See Record Columns below for more details.
         */
        recordColumns: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordColumn[];
        /**
         * The Encoding of the record in the streaming source.
         */
        recordEncoding?: string;
        /**
         * The Record Format and mapping information to schematize a record.
         * See Record Format below for more details.
         */
        recordFormat: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormat;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchemaRecordColumn {
        /**
         * The Mapping reference to the data element.
         */
        mapping?: string;
        /**
         * Name of the column.
         */
        name: string;
        /**
         * The SQL Type of the column.
         */
        sqlType: string;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormat {
        /**
         * The Mapping Information for the record format.
         * See Mapping Parameters below for more details.
         */
        mappingParameters?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParameters;
        /**
         * The type of Record Format. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParameters {
        /**
         * Mapping information when the record format uses delimiters.
         * See CSV Mapping Parameters below for more details.
         */
        csv?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersCsv;
        /**
         * Mapping information when JSON is the record format on the streaming source.
         * See JSON Mapping Parameters below for more details.
         */
        json?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersJson;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersCsv {
        /**
         * The Column Delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The Row Delimiter.
         */
        recordRowDelimiter: string;
    }

    export interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersJson {
        /**
         * Path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationCloudwatchLoggingOptions;
        /**
         * The endpoint to use when communicating with the cluster. Conflicts with `domainArn`.
         */
        clusterEndpoint?: string;
        /**
         * The ARN of the Amazon ES domain.  The pattern needs to be `arn:.*`.  Conflicts with `clusterEndpoint`.
         */
        domainArn?: string;
        /**
         * The Elasticsearch index name.
         */
        indexName: string;
        /**
         * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are `NoRotation`, `OneHour`, `OneDay`, `OneWeek`, and `OneMonth`.  The default value is `OneDay`.
         */
        indexRotationPeriod?: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Amazon Elasticsearch, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon ES Configuration API and for indexing documents.  The IAM role must have permission for `DescribeElasticsearchDomain`, `DescribeElasticsearchDomains`, and `DescribeElasticsearchDomainConfig`.  The pattern needs to be `arn:.*`.
         */
        roleArn: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDocumentsOnly` and `AllDocuments`.  Default value is `FailedDocumentsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration for more details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationS3Configuration;
        /**
         * The Elasticsearch type name with maximum length of 100 characters.
         */
        typeName?: string;
        /**
         * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. More details are given below
         */
        vpcConfig?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationVpcConfig;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamElasticsearchConfigurationVpcConfig {
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon EC2 configuration API and for creating network interfaces. Make sure role has necessary [IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-es-vpc)
         */
        roleArn: string;
        /**
         * A list of security group IDs to associate with Kinesis Firehose.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs to associate with Kinesis Firehose.
         */
        subnetIds: string[];
        vpcId: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Nested argument for the serializer, deserializer, and schema for converting data from the JSON format to the Parquet or ORC format before writing it to Amazon S3. More details given below.
         */
        dataFormatConversionConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfiguration;
        /**
         * The configuration for dynamic partitioning. See Dynamic Partitioning Configuration below for more details. Required when using dynamic partitioning.
         */
        dynamicPartitioningConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDynamicPartitioningConfiguration;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfiguration;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
        /**
         * The configuration for backup in Amazon S3. Required if `s3BackupMode` is `Enabled`. Supports the same fields as `s3Configuration` object.
         */
        s3BackupConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfiguration;
        /**
         * The Amazon S3 backup mode.  Valid values are `Disabled` and `Enabled`.  Default value is `Disabled`.
         */
        s3BackupMode?: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfiguration {
        /**
         * Defaults to `true`. Set it to `false` if you want to disable format conversion while preserving the configuration details.
         */
        enabled?: boolean;
        /**
         * Nested argument that specifies the deserializer that you want Kinesis Data Firehose to use to convert the format of your data from JSON. More details below.
         */
        inputFormatConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration;
        /**
         * Nested argument that specifies the serializer that you want Kinesis Data Firehose to use to convert the format of your data to the Parquet or ORC format. More details below.
         */
        outputFormatConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration;
        /**
         * Nested argument that specifies the AWS Glue Data Catalog table that contains the column information. More details below.
         */
        schemaConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration {
        /**
         * Nested argument that specifies which deserializer to use. You can choose either the Apache Hive JSON SerDe or the OpenX JSON SerDe. More details below.
         */
        deserializer: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer {
        /**
         * Nested argument that specifies the native Hive / HCatalog JsonSerDe. More details below.
         */
        hiveJsonSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe;
        /**
         * Nested argument that specifies the OpenX SerDe. More details below.
         */
        openXJsonSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe {
        /**
         * A list of how you want Kinesis Data Firehose to parse the date and time stamps that may be present in your input data JSON. To specify these format strings, follow the pattern syntax of JodaTime's DateTimeFormat format strings. For more information, see [Class DateTimeFormat](https://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html). You can also use the special value millis to parse time stamps in epoch milliseconds. If you don't specify a format, Kinesis Data Firehose uses java.sql.Timestamp::valueOf by default.
         */
        timestampFormats?: string[];
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe {
        /**
         * When set to true, which is the default, Kinesis Data Firehose converts JSON keys to lowercase before deserializing them.
         */
        caseInsensitive?: boolean;
        /**
         * A map of column names to JSON keys that aren't identical to the column names. This is useful when the JSON contains keys that are Hive keywords. For example, timestamp is a Hive keyword. If you have a JSON key named timestamp, set this parameter to `{ ts = "timestamp" }` to map this key to a column named ts.
         */
        columnToJsonKeyMappings?: {[key: string]: string};
        /**
         * When set to `true`, specifies that the names of the keys include dots and that you want Kinesis Data Firehose to replace them with underscores. This is useful because Apache Hive does not allow dots in column names. For example, if the JSON contains a key whose name is "a.b", you can define the column name to be "aB" when using this option. Defaults to `false`.
         */
        convertDotsInJsonKeysToUnderscores?: boolean;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration {
        /**
         * Nested argument that specifies which serializer to use. You can choose either the ORC SerDe or the Parquet SerDe. More details below.
         */
        serializer: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer {
        /**
         * Nested argument that specifies converting data to the ORC format before storing it in Amazon S3. For more information, see [Apache ORC](https://orc.apache.org/docs/). More details below.
         */
        orcSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe;
        /**
         * Nested argument that specifies converting data to the Parquet format before storing it in Amazon S3. For more information, see [Apache Parquet](https://parquet.apache.org/documentation/latest/). More details below.
         */
        parquetSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe {
        /**
         * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
         */
        blockSizeBytes?: number;
        /**
         * A list of column names for which you want Kinesis Data Firehose to create bloom filters.
         */
        bloomFilterColumns?: string[];
        /**
         * The Bloom filter false positive probability (FPP). The lower the FPP, the bigger the Bloom filter. The default value is `0.05`, the minimum is `0`, and the maximum is `1`.
         */
        bloomFilterFalsePositiveProbability?: number;
        /**
         * The compression code to use over data blocks. The default is `SNAPPY`.
         */
        compression?: string;
        /**
         * A float that represents the fraction of the total number of non-null rows. To turn off dictionary encoding, set this fraction to a number that is less than the number of distinct keys in a dictionary. To always use dictionary encoding, set this threshold to `1`.
         */
        dictionaryKeyThreshold?: number;
        /**
         * Set this to `true` to indicate that you want stripes to be padded to the HDFS block boundaries. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is `false`.
         */
        enablePadding?: boolean;
        /**
         * The version of the file to write. The possible values are `V0_11` and `V0_12`. The default is `V0_12`.
         */
        formatVersion?: string;
        /**
         * A float between 0 and 1 that defines the tolerance for block padding as a decimal fraction of stripe size. The default value is `0.05`, which means 5 percent of stripe size. For the default values of 64 MiB ORC stripes and 256 MiB HDFS blocks, the default block padding tolerance of 5 percent reserves a maximum of 3.2 MiB for padding within the 256 MiB block. In such a case, if the available size within the block is more than 3.2 MiB, a new, smaller stripe is inserted to fit within that space. This ensures that no stripe crosses block boundaries and causes remote reads within a node-local task. Kinesis Data Firehose ignores this parameter when `enablePadding` is `false`.
         */
        paddingTolerance?: number;
        /**
         * The number of rows between index entries. The default is `10000` and the minimum is `1000`.
         */
        rowIndexStride?: number;
        /**
         * The number of bytes in each stripe. The default is 64 MiB and the minimum is 8 MiB.
         */
        stripeSizeBytes?: number;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe {
        /**
         * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
         */
        blockSizeBytes?: number;
        /**
         * The compression code to use over data blocks. The possible values are `UNCOMPRESSED`, `SNAPPY`, and `GZIP`, with the default being `SNAPPY`. Use `SNAPPY` for higher decompression speed. Use `GZIP` if the compression ratio is more important than speed.
         */
        compression?: string;
        /**
         * Indicates whether to enable dictionary compression.
         */
        enableDictionaryCompression?: boolean;
        /**
         * The maximum amount of padding to apply. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is `0`.
         */
        maxPaddingBytes?: number;
        /**
         * The Parquet page size. Column chunks are divided into pages. A page is conceptually an indivisible unit (in terms of compression and encoding). The minimum value is 64 KiB and the default is 1 MiB.
         */
        pageSizeBytes?: number;
        /**
         * Indicates the version of row format to output. The possible values are `V1` and `V2`. The default is `V1`.
         */
        writerVersion?: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration {
        /**
         * The ID of the AWS Glue Data Catalog. If you don't supply this, the AWS account ID is used by default.
         */
        catalogId: string;
        /**
         * Specifies the name of the AWS Glue database that contains the schema for the output data.
         */
        databaseName: string;
        /**
         * If you don't specify an AWS Region, the default is the current region.
         */
        region: string;
        /**
         * The role that Kinesis Data Firehose can use to access AWS Glue. This role must be in the same account you use for Kinesis Data Firehose. Cross-account roles aren't allowed.
         */
        roleArn: string;
        /**
         * Specifies the AWS Glue table that contains the column information that constitutes your data schema.
         */
        tableName: string;
        /**
         * Specifies the table version for the output data schema. Defaults to `LATEST`.
         */
        versionId?: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationDynamicPartitioningConfiguration {
        /**
         * Enables or disables dynamic partitioning. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * Total amount of seconds Firehose spends on retries. Valid values between 0 and 7200. Default is 300.
         *
         * > **NOTE:** You can enable dynamic partitioning only when you create a new delivery stream. Once you enable dynamic partitioning on a delivery stream, it cannot be disabled on this delivery stream. Therefore, the provider will recreate the resource whenever dynamic partitioning is enabled or disabled.
         */
        retryDuration?: number;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfiguration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfiguration {
        /**
         * The access key required for Kinesis Firehose to authenticate with the HTTP endpoint selected as the destination.
         */
        accessKey?: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300 (5 minutes).
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationCloudwatchLoggingOptions;
        /**
         * The HTTP endpoint name.
         */
        name?: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfiguration;
        /**
         * The request configuration.  More details are given below.
         */
        requestConfiguration: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfiguration;
        /**
         * Total amount of seconds Firehose spends on retries. This duration starts after the initial attempt fails, It does not include the time periods during which Firehose waits for acknowledgment from the specified destination after each attempt. Valid values between `0` and `7200`. Default is `300`.
         */
        retryDuration?: number;
        /**
         * Kinesis Data Firehose uses this IAM role for all the permissions that the delivery stream needs. The pattern needs to be `arn:.*`.
         */
        roleArn?: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDataOnly` and `AllData`.  Default value is `FailedDataOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration for more details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationS3Configuration;
        /**
         * The HTTP endpoint URL to which Kinesis Firehose sends your data.
         */
        url: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfiguration {
        /**
         * Describes the metadata sent to the HTTP endpoint destination. More details are given below
         */
        commonAttributes?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttribute[];
        /**
         * Kinesis Data Firehose uses the content encoding to compress the body of a request before sending the request to the destination. Valid values are `NONE` and `GZIP`.  Default value is `NONE`.
         */
        contentEncoding?: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttribute {
        /**
         * The name of the HTTP endpoint common attribute.
         */
        name: string;
        /**
         * The value of the HTTP endpoint common attribute.
         */
        value: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamHttpEndpointConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamKinesisSourceConfiguration {
        /**
         * The kinesis stream used as the source of the firehose delivery stream.
         */
        kinesisStreamArn: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationCloudwatchLoggingOptions;
        /**
         * The endpoint to use when communicating with the cluster. Conflicts with `domainArn`.
         */
        clusterEndpoint?: string;
        /**
         * The ARN of the Amazon ES domain.  The pattern needs to be `arn:.*`.  Conflicts with `clusterEndpoint`.
         */
        domainArn?: string;
        /**
         * The Opensearch index name.
         */
        indexName: string;
        /**
         * The Opensearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are `NoRotation`, `OneHour`, `OneDay`, `OneWeek`, and `OneMonth`.  The default value is `OneDay`.
         */
        indexRotationPeriod?: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Amazon OpenSearch, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon ES Configuration API and for indexing documents.  The IAM role must have permission for `DescribeDomain`, `DescribeDomains`, and `DescribeDomainConfig`.  The pattern needs to be `arn:.*`.
         */
        roleArn: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDocumentsOnly` and `AllDocuments`.  Default value is `FailedDocumentsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration for more details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationS3Configuration;
        /**
         * The Elasticsearch type name with maximum length of 100 characters. Types are deprecated in OpenSearch_1.1. TypeName must be empty.
         */
        typeName?: string;
        /**
         * The VPC configuration for the delivery stream to connect to OpenSearch associated with the VPC. More details are given below
         */
        vpcConfig?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationVpcConfig;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamOpensearchConfigurationVpcConfig {
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon EC2 configuration API and for creating network interfaces. Make sure role has necessary [IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-es-vpc)
         */
        roleArn: string;
        /**
         * A list of security group IDs to associate with Kinesis Firehose.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs to associate with Kinesis Firehose.
         */
        subnetIds: string[];
        vpcId: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfiguration {
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationCloudwatchLoggingOptions;
        /**
         * The jdbcurl of the redshift cluster.
         */
        clusterJdbcurl: string;
        /**
         * Copy options for copying the data from the s3 intermediate bucket into redshift, for example to change the default delimiter. For valid values, see the [AWS documentation](http://docs.aws.amazon.com/firehose/latest/APIReference/API_CopyCommand.html)
         */
        copyOptions?: string;
        /**
         * The data table columns that will be targeted by the copy command.
         */
        dataTableColumns?: string;
        /**
         * The name of the table in the redshift cluster that the s3 bucket will copy to.
         */
        dataTableName: string;
        /**
         * The password for the username above.
         */
        password: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfiguration;
        /**
         * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
         */
        retryDuration?: number;
        /**
         * The arn of the role the stream assumes.
         */
        roleArn: string;
        /**
         * The configuration for backup in Amazon S3. Required if `s3BackupMode` is `Enabled`. Supports the same fields as `s3Configuration` object.
         */
        s3BackupConfiguration?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfiguration;
        /**
         * The Amazon S3 backup mode.  Valid values are `Disabled` and `Enabled`.  Default value is `Disabled`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration for more details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3Configuration;
        /**
         * The username that the firehose delivery stream will assume. It is strongly recommended that the username and password provided is used exclusively for Amazon Kinesis Firehose purposes, and that the permissions for the account are restricted for Amazon Redshift INSERT permissions.
         */
        username: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfiguration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamRedshiftConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamServerSideEncryption {
        /**
         * Whether to enable encryption at rest. Default is `false`.
         */
        enabled?: boolean;
        /**
         * Amazon Resource Name (ARN) of the encryption key. Required when `keyType` is `CUSTOMER_MANAGED_CMK`.
         *
         * The `extendedS3Configuration` object supports the same fields from s3Configuration as well as the following:
         */
        keyArn?: string;
        /**
         * Type of encryption key. Default is `AWS_OWNED_CMK`. Valid values are `AWS_OWNED_CMK` and `CUSTOMER_MANAGED_CMK`
         */
        keyType?: string;
    }

    export interface FirehoseDeliveryStreamSplunkConfiguration {
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationCloudwatchLoggingOptions;
        /**
         * The amount of time, in seconds between 180 and 600, that Kinesis Firehose waits to receive an acknowledgment from Splunk after it sends it data.
         */
        hecAcknowledgmentTimeout?: number;
        /**
         * The HTTP Event Collector (HEC) endpoint to which Kinesis Firehose sends your data.
         */
        hecEndpoint: string;
        /**
         * The HEC endpoint type. Valid values are `Raw` or `Event`. The default value is `Raw`.
         */
        hecEndpointType?: string;
        /**
         * The GUID that you obtain from your Splunk cluster when you create a new HEC endpoint.
         */
        hecToken: string;
        /**
         * The data processing configuration.  More details are given below.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Splunk, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedEventsOnly` and `AllEvents`.  Default value is `FailedEventsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration for more details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationS3Configuration;
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Array of data processors. More details are given below
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessor[];
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessor {
        /**
         * Array of processor parameters. More details are given below
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. More details are given below
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }

    export interface FirehoseDeliveryStreamSplunkConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }

    export interface GetStreamStreamModeDetail {
        /**
         * Capacity mode of the stream. Either `ON_DEMAND` or `PROVISIONED`.
         */
        streamMode: string;
    }

    export interface StreamStreamModeDetails {
        /**
         * Specifies the capacity mode of the stream. Must be either `PROVISIONED` or `ON_DEMAND`.
         */
        streamMode: string;
    }

}

export namespace kinesisanalyticsv2 {
    export interface ApplicationApplicationConfiguration {
        /**
         * The code location and type parameters for the application.
         */
        applicationCodeConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfiguration;
        /**
         * Describes whether snapshots are enabled for a Flink-based application.
         */
        applicationSnapshotConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationSnapshotConfiguration;
        /**
         * Describes execution properties for a Flink-based application.
         */
        environmentProperties?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationEnvironmentProperties;
        /**
         * The configuration of a Flink-based application.
         */
        flinkApplicationConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfiguration;
        /**
         * Describes the starting properties for a Flink-based application.
         */
        runConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfiguration;
        /**
         * The configuration of a SQL-based application.
         */
        sqlApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfiguration;
        /**
         * The VPC configuration of a Flink-based application.
         */
        vpcConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationVpcConfiguration;
    }

    export interface ApplicationApplicationConfigurationApplicationCodeConfiguration {
        /**
         * The location and type of the application code.
         */
        codeContent?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent;
        /**
         * Specifies whether the code content is in text or zip format. Valid values: `PLAINTEXT`, `ZIPFILE`.
         */
        codeContentType: string;
    }

    export interface ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent {
        /**
         * Information about the Amazon S3 bucket containing the application code.
         */
        s3ContentLocation?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation;
        /**
         * The text-format code for the application.
         *
         * The `s3ContentLocation` object supports the following:
         */
        textContent?: string;
    }

    export interface ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
        /**
         * The ARN for the S3 bucket containing the application code.
         */
        bucketArn: string;
        /**
         * The file key for the object containing the application code.
         */
        fileKey: string;
        /**
         * The version of the object containing the application code.
         */
        objectVersion?: string;
    }

    export interface ApplicationApplicationConfigurationApplicationSnapshotConfiguration {
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        snapshotsEnabled: boolean;
    }

    export interface ApplicationApplicationConfigurationEnvironmentProperties {
        /**
         * Describes the execution property groups.
         */
        propertyGroups: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup[];
    }

    export interface ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup {
        /**
         * The key of the application execution property key-value map.
         */
        propertyGroupId: string;
        /**
         * Application execution property key-value map.
         */
        propertyMap: {[key: string]: string};
    }

    export interface ApplicationApplicationConfigurationFlinkApplicationConfiguration {
        /**
         * Describes an application's checkpointing configuration.
         */
        checkpointConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration;
        /**
         * Describes configuration parameters for CloudWatch logging for an application.
         */
        monitoringConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration;
        /**
         * Describes parameters for how an application executes multiple tasks simultaneously.
         */
        parallelismConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration;
    }

    export interface ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration {
        /**
         * Describes the interval in milliseconds between checkpoint operations.
         */
        checkpointInterval: number;
        /**
         * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
         */
        checkpointingEnabled: boolean;
        /**
         * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `checkpointingEnabled`, `checkpointInterval`, or `minPauseBetweenCheckpoints` attribute values to be effective. If this attribute is set to `DEFAULT`, the application will always use the following values:
         * * `checkpointingEnabled = true`
         * * `checkpointInterval = 60000`
         * * `minPauseBetweenCheckpoints = 5000`
         */
        configurationType: string;
        /**
         * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
         */
        minPauseBetweenCheckpoints: number;
    }

    export interface ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration {
        /**
         * Describes whether to use the default CloudWatch logging configuration for an application. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `logLevel` or `metricsLevel` attribute values to be effective.
         */
        configurationType: string;
        /**
         * Describes the verbosity of the CloudWatch Logs for an application. Valid values: `DEBUG`, `ERROR`, `INFO`, `WARN`.
         */
        logLevel: string;
        /**
         * Describes the granularity of the CloudWatch Logs for an application. Valid values: `APPLICATION`, `OPERATOR`, `PARALLELISM`, `TASK`.
         */
        metricsLevel: string;
    }

    export interface ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration {
        /**
         * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
         */
        autoScalingEnabled: boolean;
        /**
         * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `autoScalingEnabled`, `parallelism`, or `parallelismPerKpu` attribute values to be effective.
         */
        configurationType: string;
        /**
         * Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
         */
        parallelism: number;
        /**
         * Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
         */
        parallelismPerKpu: number;
    }

    export interface ApplicationApplicationConfigurationRunConfiguration {
        /**
         * The restore behavior of a restarting application.
         */
        applicationRestoreConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration;
        /**
         * The starting parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkRunConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration;
    }

    export interface ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration {
        /**
         * Specifies how the application should be restored. Valid values: `RESTORE_FROM_CUSTOM_SNAPSHOT`, `RESTORE_FROM_LATEST_SNAPSHOT`, `SKIP_RESTORE_FROM_SNAPSHOT`.
         */
        applicationRestoreType: string;
        /**
         * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if `RESTORE_FROM_CUSTOM_SNAPSHOT` is specified for `applicationRestoreType`.
         */
        snapshotName?: string;
    }

    export interface ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration {
        /**
         * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is `false`.
         */
        allowNonRestoredState: boolean;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfiguration {
        /**
         * The input stream used by the application.
         */
        input?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInput;
        /**
         * The destination streams used by the application.
         */
        outputs?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutput[];
        /**
         * The reference data source used by the application.
         */
        referenceDataSource?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInput {
        inAppStreamNames: string[];
        inputId: string;
        /**
         * Describes the number of in-application streams to create.
         */
        inputParallelism: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism;
        /**
         * The input processing configuration for the input.
         * An input processor transforms records as they are received from the stream, before the application's SQL code executes.
         */
        inputProcessingConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
         */
        inputSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema;
        /**
         * The point at which the application starts processing records from the streaming source.
         */
        inputStartingPositionConfigurations: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration[];
        /**
         * If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
         */
        kinesisFirehoseInput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput;
        /**
         * If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
         */
        kinesisStreamsInput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput;
        /**
         * The name prefix to use when creating an in-application stream.
         */
        namePrefix: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism {
        /**
         * The number of in-application streams to create.
         */
        count: number;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
        /**
         * Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
         */
        inputLambdaProcessor: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor {
        /**
         * The ARN of the Lambda function that operates on records in the stream.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
        /**
         * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
         */
        recordColumns: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn[];
        /**
         * Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
         */
        recordEncoding?: string;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: string;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: string;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
        /**
         * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters;
        /**
         * The type of record format. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        csvMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jsonMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters {
        /**
         * The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The row delimiter. For example, in a CSV format, `\n` is the typical row delimiter.
         */
        recordRowDelimiter: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration {
        /**
         * The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
         */
        inputStartingPosition: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput {
        /**
         * The ARN of the delivery stream.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput {
        /**
         * The ARN of the input Kinesis data stream to read.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutput {
        /**
         * Describes the data format when records are written to the destination.
         */
        destinationSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema;
        /**
         * Identifies a Kinesis Data Firehose delivery stream as the destination.
         */
        kinesisFirehoseOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput;
        /**
         * Identifies a Kinesis data stream as the destination.
         */
        kinesisStreamsOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput;
        /**
         * Identifies a Lambda function as the destination.
         */
        lambdaOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput;
        /**
         * The name of the in-application stream.
         */
        name: string;
        outputId: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema {
        /**
         * Specifies the format of the records on the output stream. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput {
        /**
         * The ARN of the destination delivery stream to write to.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput {
        /**
         * The ARN of the destination Kinesis data stream to write to.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput {
        /**
         * The ARN of the destination Lambda function to write to.
         */
        resourceArn: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
        referenceId: string;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
         */
        referenceSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema;
        /**
         * Identifies the S3 bucket and object that contains the reference data.
         */
        s3ReferenceDataSource: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource;
        /**
         * The name of the in-application table to create.
         */
        tableName: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
        /**
         * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
         */
        recordColumns: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn[];
        /**
         * Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
         *
         * The `s3ReferenceDataSource` object supports the following:
         */
        recordEncoding?: string;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: string;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: string;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
        /**
         * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters;
        /**
         * The type of record format. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        csvMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jsonMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters {
        /**
         * The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The row delimiter. For example, in a CSV format, `\n` is the typical row delimiter.
         */
        recordRowDelimiter: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }

    export interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
        /**
         * The ARN for the S3 bucket containing the application code.
         */
        bucketArn: string;
        /**
         * The file key for the object containing the application code.
         */
        fileKey: string;
    }

    export interface ApplicationApplicationConfigurationVpcConfiguration {
        /**
         * The Security Group IDs used by the VPC configuration.
         */
        securityGroupIds: string[];
        /**
         * The Subnet IDs used by the VPC configuration.
         */
        subnetIds: string[];
        vpcConfigurationId: string;
        vpcId: string;
    }

    export interface ApplicationCloudwatchLoggingOptions {
        cloudwatchLoggingOptionId: string;
        /**
         * The ARN of the CloudWatch log stream to receive application messages.
         */
        logStreamArn: string;
    }

}

export namespace kms {
    export interface GetKeyMultiRegionConfiguration {
        /**
         * Indicates whether the KMS key is a `PRIMARY` or `REPLICA` key.
         */
        multiRegionKeyType: string;
        /**
         * The key ARN and Region of the primary key. This is the current KMS key if it is the primary key.
         */
        primaryKeys: outputs.kms.GetKeyMultiRegionConfigurationPrimaryKey[];
        /**
         * The key ARNs and Regions of all replica keys. Includes the current KMS key if it is a replica key.
         */
        replicaKeys: outputs.kms.GetKeyMultiRegionConfigurationReplicaKey[];
    }

    export interface GetKeyMultiRegionConfigurationPrimaryKey {
        /**
         * The key ARN of a primary or replica key of a multi-Region key.
         */
        arn: string;
        /**
         * The AWS Region of a primary or replica key in a multi-Region key.
         */
        region: string;
    }

    export interface GetKeyMultiRegionConfigurationReplicaKey {
        /**
         * The key ARN of a primary or replica key of a multi-Region key.
         */
        arn: string;
        /**
         * The AWS Region of a primary or replica key in a multi-Region key.
         */
        region: string;
    }

    export interface GetKeyXksKeyConfiguration {
        /**
         * The globally unique identifier for the key
         */
        id: string;
    }

    export interface GetSecretSecret {
        context?: {[key: string]: string};
        grantTokens?: string[];
        name: string;
        payload: string;
    }

    export interface GetSecretsSecret {
        /**
         * An optional mapping that makes up the Encryption Context for the secret.
         */
        context?: {[key: string]: string};
        /**
         * The encryption algorithm that will be used to decrypt the ciphertext. This parameter is required only when the ciphertext was encrypted under an asymmetric KMS key. Valid Values: SYMMETRIC_DEFAULT | RSAES_OAEP_SHA_1 | RSAES_OAEP_SHA_256 | SM2PKE
         */
        encryptionAlgorithm?: string;
        /**
         * An optional list of Grant Tokens for the secret.
         */
        grantTokens?: string[];
        /**
         * Specifies the KMS key that AWS KMS uses to decrypt the ciphertext. This parameter is required only when the ciphertext was encrypted under an asymmetric KMS key.
         *
         * For more information on `context` and `grantTokens` see the [KMS
         * Concepts](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html)
         */
        keyId?: string;
        /**
         * Name to export this secret under in the attributes.
         */
        name: string;
        /**
         * Base64 encoded payload, as returned from a KMS encrypt operation.
         */
        payload: string;
    }

    export interface GrantConstraint {
        /**
         * A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with `encryptionContextSubset`.
         */
        encryptionContextEquals?: {[key: string]: string};
        /**
         * A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with `encryptionContextEquals`.
         */
        encryptionContextSubset?: {[key: string]: string};
    }

}

export namespace lakeformation {
    export interface DataLakeSettingsCreateDatabaseDefaultPermission {
        /**
         * List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
         */
        permissions: string[];
        /**
         * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
         */
        principal: string;
    }

    export interface DataLakeSettingsCreateTableDefaultPermission {
        /**
         * List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
         */
        permissions: string[];
        /**
         * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
         */
        principal: string;
    }

    export interface GetDataLakeSettingsCreateDatabaseDefaultPermission {
        /**
         * List of permissions granted to the principal.
         */
        permissions: string[];
        /**
         * Principal who is granted permissions.
         */
        principal: string;
    }

    export interface GetDataLakeSettingsCreateTableDefaultPermission {
        /**
         * List of permissions granted to the principal.
         */
        permissions: string[];
        /**
         * Principal who is granted permissions.
         */
        principal: string;
    }

    export interface GetPermissionsDataLocation {
        /**
         * ARN that uniquely identifies the data location resource.
         *
         * The following argument is optional:
         */
        arn: string;
        /**
         * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
         */
        catalogId: string;
    }

    export interface GetPermissionsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }

    export interface GetPermissionsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Key-name for the tag.
         */
        key: string;
        /**
         * List of possible values an attribute can take.
         *
         * The following argument is optional:
         */
        values: string[];
    }

    export interface GetPermissionsLfTagPolicy {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
         *
         * The following argument is optional:
         */
        expressions: outputs.lakeformation.GetPermissionsLfTagPolicyExpression[];
        /**
         * Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
         */
        resourceType: string;
    }

    export interface GetPermissionsLfTagPolicyExpression {
        /**
         * Key-name of an LF-Tag.
         */
        key: string;
        /**
         * List of possible values of an LF-Tag.
         */
        values: string[];
    }

    export interface GetPermissionsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         *
         * The following arguments are optional:
         */
        databaseName: string;
        /**
         * Name of the table. At least one of `name` or `wildcard` is required.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
         */
        wildcard?: boolean;
    }

    export interface GetPermissionsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table. At least one of `columnNames` or `excludedColumnNames` is required.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. At least one of `columnNames` or `excludedColumnNames` is required.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         *
         * The following arguments are optional:
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
         */
        wildcard?: boolean;
    }

    export interface PermissionsDataLocation {
        /**
         * Amazon Resource Name (ARN) that uniquely identifies the data location resource.
         *
         * The following argument is optional:
         */
        arn: string;
        /**
         * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
         */
        catalogId: string;
    }

    export interface PermissionsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }

    export interface PermissionsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * The key-name for the tag.
         */
        key: string;
        /**
         * A list of possible values an attribute can take.
         *
         * The following argument is optional:
         */
        values: string[];
    }

    export interface PermissionsLfTagPolicy {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
         *
         * The following argument is optional:
         */
        expressions: outputs.lakeformation.PermissionsLfTagPolicyExpression[];
        /**
         * The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
         */
        resourceType: string;
    }

    export interface PermissionsLfTagPolicyExpression {
        /**
         * The key-name of an LF-Tag.
         */
        key: string;
        /**
         * A list of possible values of an LF-Tag.
         */
        values: string[];
    }

    export interface PermissionsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. Defaults to `false`.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }

    export interface PermissionsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         */
        name: string;
        /**
         * Whether to use a column wildcard. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }

    export interface ResourceLfTagsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }

    export interface ResourceLfTagsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Key name for an existing LF-tag.
         */
        key: string;
        /**
         * Value from the possible values for the LF-tag.
         *
         * The following argument is optional:
         */
        value: string;
    }

    export interface ResourceLfTagsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. Defaults to `false`.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }

    export interface ResourceLfTagsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         */
        name: string;
        /**
         * Whether to use a column wildcard. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }

}

export namespace lambda {
    export interface AliasRoutingConfig {
        /**
         * A map that defines the proportion of events that should be sent to different versions of a lambda function.
         */
        additionalVersionWeights?: {[key: string]: number};
    }

    export interface CodeSigningConfigAllowedPublishers {
        /**
         * The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
         */
        signingProfileVersionArns: string[];
    }

    export interface CodeSigningConfigPolicies {
        /**
         * Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
         */
        untrustedArtifactOnDeployment: string;
    }

    export interface EventSourceMappingAmazonManagedKafkaEventSourceConfig {
        /**
         * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
         */
        consumerGroupId: string;
    }

    export interface EventSourceMappingDestinationConfig {
        /**
         * The destination configuration for failed invocations. Detailed below.
         */
        onFailure?: outputs.lambda.EventSourceMappingDestinationConfigOnFailure;
    }

    export interface EventSourceMappingDestinationConfigOnFailure {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destinationArn: string;
    }

    export interface EventSourceMappingDocumentDbEventSourceConfig {
        /**
         * The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
         */
        collectionName?: string;
        /**
         * The name of the database to consume within the DocumentDB cluster.
         */
        databaseName: string;
        /**
         * Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
         */
        fullDocument?: string;
    }

    export interface EventSourceMappingFilterCriteria {
        /**
         * A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
         */
        filters?: outputs.lambda.EventSourceMappingFilterCriteriaFilter[];
    }

    export interface EventSourceMappingFilterCriteriaFilter {
        /**
         * A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
         */
        pattern?: string;
    }

    export interface EventSourceMappingScalingConfig {
        /**
         * Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between `2` and `1000`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
         */
        maximumConcurrency?: number;
    }

    export interface EventSourceMappingSelfManagedEventSource {
        /**
         * A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
         */
        endpoints: {[key: string]: string};
    }

    export interface EventSourceMappingSelfManagedKafkaEventSourceConfig {
        /**
         * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
         */
        consumerGroupId: string;
    }

    export interface EventSourceMappingSourceAccessConfiguration {
        /**
         * The type of this configuration.  For Self Managed Kafka you will need to supply blocks for type `VPC_SUBNET` and `VPC_SECURITY_GROUP`.
         */
        type: string;
        /**
         * The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnetId` is the value you would find in an aws.ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `securityGroupId` is the value you would find in an aws.ec2.SecurityGroup resource's id attribute.
         */
        uri: string;
    }

    export interface FunctionDeadLetterConfig {
        /**
         * ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
         */
        targetArn: string;
    }

    export interface FunctionEnvironment {
        /**
         * Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
         */
        variables?: {[key: string]: string};
    }

    export interface FunctionEphemeralStorage {
        /**
         * The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeralStorage` value defaults to `512`MB and the maximum supported value is `10240`MB.
         */
        size: number;
    }

    export interface FunctionEventInvokeConfigDestinationConfig {
        /**
         * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
         */
        onFailure?: outputs.lambda.FunctionEventInvokeConfigDestinationConfigOnFailure;
        /**
         * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
         */
        onSuccess?: outputs.lambda.FunctionEventInvokeConfigDestinationConfigOnSuccess;
    }

    export interface FunctionEventInvokeConfigDestinationConfigOnFailure {
        /**
         * Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
         */
        destination: string;
    }

    export interface FunctionEventInvokeConfigDestinationConfigOnSuccess {
        /**
         * Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
         */
        destination: string;
    }

    export interface FunctionFileSystemConfig {
        /**
         * Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
         */
        arn: string;
        /**
         * Path where the function can access the file system, starting with /mnt/.
         */
        localMountPath: string;
    }

    export interface FunctionImageConfig {
        /**
         * Parameters that you want to pass in with `entryPoint`.
         */
        commands?: string[];
        /**
         * Entry point to your application, which is typically the location of the runtime executable.
         */
        entryPoints?: string[];
        /**
         * Working directory.
         */
        workingDirectory?: string;
    }

    export interface FunctionSnapStart {
        /**
         * Conditions where snap start is enabled. Valid values are `PublishedVersions`.
         */
        applyOn: string;
        optimizationStatus: string;
    }

    export interface FunctionTracingConfig {
        /**
         * Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
         */
        mode: string;
    }

    export interface FunctionUrlCors {
        /**
         * Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
         */
        allowCredentials?: boolean;
        /**
         * The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
         */
        allowHeaders?: string[];
        /**
         * The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
         */
        allowMethods?: string[];
        /**
         * The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
         */
        allowOrigins?: string[];
        /**
         * The HTTP headers in your function response that you want to expose to origins that call the function URL.
         */
        exposeHeaders?: string[];
        /**
         * The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
         */
        maxAge?: number;
    }

    export interface FunctionVpcConfig {
        /**
         * List of security group IDs associated with the Lambda function.
         */
        securityGroupIds: string[];
        /**
         * List of subnet IDs associated with the Lambda function.
         */
        subnetIds: string[];
        vpcId: string;
    }

    export interface GetCodeSigningConfigAllowedPublisher {
        /**
         * The ARN for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
         */
        signingProfileVersionArns: string[];
    }

    export interface GetCodeSigningConfigPolicy {
        /**
         * Code signing configuration policy for deployment validation failure.
         */
        untrustedArtifactOnDeployment: string;
    }

    export interface GetFunctionDeadLetterConfig {
        targetArn: string;
    }

    export interface GetFunctionEnvironment {
        variables: {[key: string]: string};
    }

    export interface GetFunctionEphemeralStorage {
        size: number;
    }

    export interface GetFunctionFileSystemConfig {
        /**
         * Unqualified (no `:QUALIFIER` or `:VERSION` suffix) ARN identifying your Lambda Function. See also `qualifiedArn`.
         */
        arn: string;
        localMountPath: string;
    }

    export interface GetFunctionTracingConfig {
        mode: string;
    }

    export interface GetFunctionUrlCor {
        allowCredentials: boolean;
        allowHeaders: string[];
        allowMethods: string[];
        allowOrigins: string[];
        exposeHeaders: string[];
        maxAge: number;
    }

    export interface GetFunctionVpcConfig {
        securityGroupIds: string[];
        subnetIds: string[];
        vpcId: string;
    }

}

export namespace lb {
    export interface GetListenerDefaultAction {
        authenticateCognitos: outputs.lb.GetListenerDefaultActionAuthenticateCognito[];
        authenticateOidcs: outputs.lb.GetListenerDefaultActionAuthenticateOidc[];
        fixedResponses: outputs.lb.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.lb.GetListenerDefaultActionForward[];
        order: number;
        redirects: outputs.lb.GetListenerDefaultActionRedirect[];
        targetGroupArn: string;
        type: string;
    }

    export interface GetListenerDefaultActionAuthenticateCognito {
        authenticationRequestExtraParams: {[key: string]: string};
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }

    export interface GetListenerDefaultActionAuthenticateOidc {
        authenticationRequestExtraParams: {[key: string]: string};
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        tokenEndpoint: string;
        userInfoEndpoint: string;
    }

    export interface GetListenerDefaultActionFixedResponse {
        contentType: string;
        messageBody: string;
        statusCode: string;
    }

    export interface GetListenerDefaultActionForward {
        stickinesses: outputs.lb.GetListenerDefaultActionForwardStickiness[];
        targetGroups: outputs.lb.GetListenerDefaultActionForwardTargetGroup[];
    }

    export interface GetListenerDefaultActionForwardStickiness {
        duration: number;
        enabled: boolean;
    }

    export interface GetListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the listener. Required if `loadBalancerArn` and `port` is not set.
         */
        arn: string;
        weight: number;
    }

    export interface GetListenerDefaultActionRedirect {
        host: string;
        path: string;
        /**
         * Port of the listener. Required if `arn` is not set.
         */
        port: string;
        protocol: string;
        query: string;
        statusCode: string;
    }

    export interface GetLoadBalancerAccessLogs {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }

    export interface GetLoadBalancerSubnetMapping {
        allocationId: string;
        ipv6Address: string;
        outpostId: string;
        privateIpv4Address: string;
        subnetId: string;
    }

    export interface GetTargetGroupHealthCheck {
        enabled: boolean;
        healthyThreshold: number;
        interval: number;
        matcher: string;
        path: string;
        port: string;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface GetTargetGroupStickiness {
        cookieDuration: number;
        cookieName: string;
        enabled: boolean;
        type: string;
    }

    export interface ListenerDefaultAction {
        /**
         * Configuration block for using Amazon Cognito to authenticate users. Specify only when `type` is `authenticate-cognito`. Detailed below.
         */
        authenticateCognito?: outputs.lb.ListenerDefaultActionAuthenticateCognito;
        /**
         * Configuration block for an identity provider that is compliant with OpenID Connect (OIDC). Specify only when `type` is `authenticate-oidc`. Detailed below.
         */
        authenticateOidc?: outputs.lb.ListenerDefaultActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.lb.ListenerDefaultActionFixedResponse;
        /**
         * Configuration block for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`. Detailed below.
         */
        forward?: outputs.lb.ListenerDefaultActionForward;
        /**
         * Order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first. Valid values are between `1` and `50000`.
         */
        order: number;
        /**
         * Configuration block for creating a redirect action. Required if `type` is `redirect`. Detailed below.
         */
        redirect?: outputs.lb.ListenerDefaultActionRedirect;
        /**
         * ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * Type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         *
         * The following arguments are optional:
         */
        type: string;
    }

    export interface ListenerDefaultActionAuthenticateCognito {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10. Detailed below.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * Behavior if the user is not authenticated. Valid values are `deny`, `allow` and `authenticate`.
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * Domain prefix or fully-qualified domain name of the Cognito user pool.
         *
         * The following arguments are optional:
         */
        userPoolDomain: string;
    }

    export interface ListenerDefaultActionAuthenticateOidc {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * Authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * Behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * Token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * User info endpoint of the IdP.
         *
         * The following arguments are optional:
         */
        userInfoEndpoint: string;
    }

    export interface ListenerDefaultActionFixedResponse {
        /**
         * Content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         *
         * The following arguments are optional:
         */
        contentType: string;
        /**
         * Message body.
         */
        messageBody?: string;
        /**
         * HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }

    export interface ListenerDefaultActionForward {
        /**
         * Configuration block for target group stickiness for the rule. Detailed below.
         */
        stickiness?: outputs.lb.ListenerDefaultActionForwardStickiness;
        /**
         * Set of 1-5 target group blocks. Detailed below.
         *
         * The following arguments are optional:
         */
        targetGroups: outputs.lb.ListenerDefaultActionForwardTargetGroup[];
    }

    export interface ListenerDefaultActionForwardStickiness {
        /**
         * Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         *
         * The following arguments are optional:
         */
        duration: number;
        /**
         * Whether target group stickiness is enabled. Default is `false`.
         */
        enabled?: boolean;
    }

    export interface ListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the target group.
         *
         * The following arguments are optional:
         */
        arn: string;
        /**
         * Weight. The range is 0 to 999.
         */
        weight?: number;
    }

    export interface ListenerDefaultActionRedirect {
        /**
         * Hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * Port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * Protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         *
         * The following arguments are optional:
         */
        statusCode: string;
    }

    export interface ListenerRuleAction {
        /**
         * Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
         */
        authenticateCognito?: outputs.lb.ListenerRuleActionAuthenticateCognito;
        /**
         * Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
         */
        authenticateOidc?: outputs.lb.ListenerRuleActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.lb.ListenerRuleActionFixedResponse;
        /**
         * Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`.
         */
        forward?: outputs.lb.ListenerRuleActionForward;
        order: number;
        /**
         * Information for creating a redirect action. Required if `type` is `redirect`.
         */
        redirect?: outputs.lb.ListenerRuleActionRedirect;
        /**
         * The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         */
        type: string;
    }

    export interface ListenerRuleActionAuthenticateCognito {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * The ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * The domain prefix or fully-qualified domain name of the Cognito user pool.
         */
        userPoolDomain: string;
    }

    export interface ListenerRuleActionAuthenticateOidc {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {[key: string]: string};
        /**
         * The authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * The OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * The OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * The user info endpoint of the IdP.
         */
        userInfoEndpoint: string;
    }

    export interface ListenerRuleActionFixedResponse {
        /**
         * The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         */
        contentType: string;
        /**
         * The message body.
         */
        messageBody?: string;
        /**
         * The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }

    export interface ListenerRuleActionForward {
        /**
         * The target group stickiness for the rule.
         */
        stickiness?: outputs.lb.ListenerRuleActionForwardStickiness;
        /**
         * One or more target groups block.
         */
        targetGroups: outputs.lb.ListenerRuleActionForwardTargetGroup[];
    }

    export interface ListenerRuleActionForwardStickiness {
        /**
         * The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         */
        duration: number;
        /**
         * Indicates whether target group stickiness is enabled.
         */
        enabled?: boolean;
    }

    export interface ListenerRuleActionForwardTargetGroup {
        /**
         * The Amazon Resource Name (ARN) of the target group.
         */
        arn: string;
        /**
         * The weight. The range is 0 to 999.
         */
        weight?: number;
    }

    export interface ListenerRuleActionRedirect {
        /**
         * The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         */
        statusCode: string;
    }

    export interface ListenerRuleCondition {
        /**
         * Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
         */
        hostHeader?: outputs.lb.ListenerRuleConditionHostHeader;
        /**
         * HTTP headers to match. HTTP Header block fields documented below.
         */
        httpHeader?: outputs.lb.ListenerRuleConditionHttpHeader;
        /**
         * Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         */
        httpRequestMethod?: outputs.lb.ListenerRuleConditionHttpRequestMethod;
        /**
         * Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `queryString` condition.
         */
        pathPattern?: outputs.lb.ListenerRuleConditionPathPattern;
        /**
         * Query strings to match. Query String block fields documented below.
         */
        queryStrings?: outputs.lb.ListenerRuleConditionQueryString[];
        /**
         * Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         *
         * > **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         */
        sourceIp?: outputs.lb.ListenerRuleConditionSourceIp;
    }

    export interface ListenerRuleConditionHostHeader {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionHttpHeader {
        /**
         * Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
         */
        httpHeaderName: string;
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         */
        values: string[];
    }

    export interface ListenerRuleConditionHttpRequestMethod {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionPathPattern {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface ListenerRuleConditionQueryString {
        /**
         * Query string key pattern to match.
         */
        key?: string;
        /**
         * Query string value pattern to match.
         */
        value: string;
    }

    export interface ListenerRuleConditionSourceIp {
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         *
         *
         * Query String Value Blocks (for `query_string.values`) support the following:
         */
        values: string[];
    }

    export interface LoadBalancerAccessLogs {
        /**
         * The S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `accessLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * The S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }

    export interface LoadBalancerSubnetMapping {
        /**
         * The allocation ID of the Elastic IP address for an internet-facing load balancer.
         */
        allocationId?: string;
        /**
         * The IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
         */
        ipv6Address?: string;
        outpostId: string;
        /**
         * The private IPv4 address for an internal load balancer.
         */
        privateIpv4Address?: string;
        /**
         * ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
         */
        subnetId: string;
    }

    export interface TargetGroupHealthCheck {
        /**
         * Whether health checks are enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
         */
        healthyThreshold?: number;
        /**
         * Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For `lambda` target groups, it needs to be greater than the timeout of the underlying `lambda`. Defaults to 30.
         */
        interval?: number;
        /**
         * Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s) or "0,12" for GRPC) or a range of values (for example, "200-299" or "0-99"). Required for HTTP/HTTPS/GRPC ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS/GRPC) not Network Load Balancers (i.e., TCP).
         */
        matcher: string;
        /**
         * Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
         */
        path: string;
        /**
         * The port the load balancer uses when performing health checks on targets. Default is traffic-port.
         */
        port?: string;
        /**
         * Protocol the load balancer uses when performing health checks on targets. Must be either `TCP`, `HTTP`, or `HTTPS`. The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS. Defaults to HTTP.
         */
        protocol?: string;
        /**
         * Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
         */
        timeout: number;
        /**
         * Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
         */
        unhealthyThreshold?: number;
    }

    export interface TargetGroupStickiness {
        /**
         * Only used when the type is `lbCookie`. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
         */
        cookieDuration?: number;
        /**
         * Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is `appCookie`.
         */
        cookieName?: string;
        /**
         * Boolean to enable / disable `stickiness`. Default is `true`.
         */
        enabled?: boolean;
        /**
         * The type of sticky sessions. The only current possible values are `lbCookie`, `appCookie` for ALBs, `sourceIp` for NLBs, and `sourceIpDestIp`, `sourceIpDestIpProto` for GWLBs.
         */
        type: string;
    }

    export interface TargetGroupTargetFailover {
        /**
         * Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onUnhealthy`. Default: `noRebalance`.
         */
        onDeregistration: string;
        /**
         * Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onDeregistration`. Default: `noRebalance`.
         */
        onUnhealthy: string;
    }

}

export namespace lex {
    export interface BotAbortStatement {
        messages: outputs.lex.BotAbortStatementMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html).
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html).
         */
        responseCard?: string;
    }

    export interface BotAbortStatementMessage {
        /**
         * The text of the message.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response.
         */
        groupNumber?: number;
    }

    export interface BotAliasConversationLogs {
        /**
         * The Amazon Resource Name (ARN) of the IAM role used to write your logs to CloudWatch Logs or an S3 bucket. Must be between 20 and 2048 characters in length.
         */
        iamRoleArn: string;
        /**
         * The settings for your conversation logs. You can log text, audio, or both. Attributes are documented under log_settings.
         */
        logSettings?: outputs.lex.BotAliasConversationLogsLogSetting[];
    }

    export interface BotAliasConversationLogsLogSetting {
        /**
         * The destination where logs are delivered. Options are `CLOUDWATCH_LOGS` or `S3`.
         */
        destination: string;
        /**
         * The Amazon Resource Name (ARN) of the key used to encrypt audio logs in an S3 bucket. This can only be specified when `destination` is set to `S3`. Must be between 20 and 2048 characters in length.
         */
        kmsKeyArn?: string;
        /**
         * The type of logging that is enabled. Options are `AUDIO` or `TEXT`.
         */
        logType: string;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or S3 bucket where the logs are delivered. Must be less than or equal to 2048 characters in length.
         */
        resourceArn: string;
        /**
         * The prefix of the S3 object key for `AUDIO` logs or the log stream name for `TEXT` logs.
         */
        resourcePrefix: string;
    }

    export interface BotClarificationPrompt {
        /**
         * The number of times to prompt the user for information.
         */
        maxAttempts: number;
        messages: outputs.lex.BotClarificationPromptMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html).
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html).
         */
        responseCard?: string;
    }

    export interface BotClarificationPromptMessage {
        /**
         * The text of the message.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response.
         */
        groupNumber?: number;
    }

    export interface BotIntent {
        /**
         * The name of the intent. Must be less than or equal to 100 characters in length.
         */
        intentName: string;
        /**
         * The version of the intent. Must be less than or equal to 64 characters in length.
         */
        intentVersion: string;
    }

    export interface GetSlotTypeEnumerationValue {
        synonyms: string[];
        value: string;
    }

    export interface IntentConclusionStatement {
        messages: outputs.lex.IntentConclusionStatementMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentConclusionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface IntentConfirmationPrompt {
        /**
         * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
         */
        maxAttempts: number;
        messages: outputs.lex.IntentConfirmationPromptMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentConfirmationPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface IntentDialogCodeHook {
        /**
         * The version of the request-response that you want Amazon Lex to use
         * to invoke your Lambda function. For more information, see
         * [Using Lambda Functions](https://docs.aws.amazon.com/lex/latest/dg/using-lambda.html). Must be less than or equal to 5 characters in length.
         */
        messageVersion: string;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function.
         */
        uri: string;
    }

    export interface IntentFollowUpPrompt {
        /**
         * Prompts for information from the user. Attributes are documented under prompt.
         */
        prompt: outputs.lex.IntentFollowUpPromptPrompt;
        /**
         * If the user answers "no" to the question defined in the prompt field,
         * Amazon Lex responds with this statement to acknowledge that the intent was canceled. Attributes are
         * documented below under statement.
         */
        rejectionStatement: outputs.lex.IntentFollowUpPromptRejectionStatement;
    }

    export interface IntentFollowUpPromptPrompt {
        /**
         * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
         */
        maxAttempts: number;
        /**
         * A set of messages, each of which provides a message string and its type.
         * You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).
         * Attributes are documented under message. Must contain between 1 and 15 messages.
         */
        messages: outputs.lex.IntentFollowUpPromptPromptMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentFollowUpPromptPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface IntentFollowUpPromptRejectionStatement {
        messages: outputs.lex.IntentFollowUpPromptRejectionStatementMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentFollowUpPromptRejectionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface IntentFulfillmentActivity {
        /**
         * A description of the Lambda function that is run to fulfill the intent.
         * Required if type is CodeHook. Attributes are documented under code_hook.
         */
        codeHook?: outputs.lex.IntentFulfillmentActivityCodeHook;
        /**
         * How the intent should be fulfilled, either by running a Lambda function or by
         * returning the slot data to the client application. Type can be either `ReturnIntent` or `CodeHook`, as documented [here](https://docs.aws.amazon.com/lex/latest/dg/API_FulfillmentActivity.html).
         */
        type: string;
    }

    export interface IntentFulfillmentActivityCodeHook {
        /**
         * The version of the request-response that you want Amazon Lex to use
         * to invoke your Lambda function. For more information, see
         * [Using Lambda Functions](https://docs.aws.amazon.com/lex/latest/dg/using-lambda.html). Must be less than or equal to 5 characters in length.
         */
        messageVersion: string;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function.
         */
        uri: string;
    }

    export interface IntentRejectionStatement {
        messages: outputs.lex.IntentRejectionStatementMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentRejectionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface IntentSlot {
        /**
         * A description of the bot. Must be less than or equal to 200 characters in length.
         */
        description?: string;
        /**
         * The name of the intent slot that you want to create. The name is case sensitive. Must be less than or equal to 100 characters in length.
         */
        name: string;
        /**
         * Directs Lex the order in which to elicit this slot value from the user.
         * For example, if the intent has two slots with priorities 1 and 2, AWS Lex first elicits a value for
         * the slot with priority 1. If multiple slots share the same priority, the order in which Lex elicits
         * values is arbitrary. Must be between 1 and 100.
         */
        priority?: number;
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
        /**
         * If you know a specific pattern with which users might respond to
         * an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This
         * is optional. In most cases, Amazon Lex is capable of understanding user utterances. Must have between 1 and 10 items in the list, and each item must be less than or equal to 200 characters in length.
         */
        sampleUtterances?: string[];
        /**
         * Specifies whether the slot is required or optional.
         */
        slotConstraint: string;
        /**
         * The type of the slot, either a custom slot type that you defined or one of
         * the built-in slot types. Must be less than or equal to 100 characters in length.
         */
        slotType: string;
        /**
         * The version of the slot type. Must be less than or equal to 64 characters in length.
         */
        slotTypeVersion?: string;
        /**
         * The prompt that Amazon Lex uses to elicit the slot value
         * from the user. Attributes are documented under prompt.
         */
        valueElicitationPrompt?: outputs.lex.IntentSlotValueElicitationPrompt;
    }

    export interface IntentSlotValueElicitationPrompt {
        /**
         * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
         */
        maxAttempts: number;
        messages: outputs.lex.IntentSlotValueElicitationPromptMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }

    export interface IntentSlotValueElicitationPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }

    export interface SlotTypeEnumerationValue {
        /**
         * Additional values related to the slot type value. Each item must be less than or equal to 140 characters in length.
         */
        synonyms?: string[];
        /**
         * The value of the slot type. Must be less than or equal to 140 characters in length.
         */
        value: string;
    }

}

export namespace licensemanager {
    export interface GetLicenseGrantsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/license-manager/latest/APIReference/API_ListReceivedGrants.html#API_ListReceivedGrants_RequestSyntax).
         * For example, if filtering using `ProductSKU`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.licensemanager.getLicenseGrants({
         *     filters: [{
         *         name: "ProductSKU",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }

    export interface GetReceivedLicenseConsumptionConfiguration {
        /**
         * Details about a borrow configuration. Detailed below
         */
        borrowConfigurations: outputs.licensemanager.GetReceivedLicenseConsumptionConfigurationBorrowConfiguration[];
        /**
         * Details about a provisional configuration. Detailed below
         */
        provisionalConfigurations: outputs.licensemanager.GetReceivedLicenseConsumptionConfigurationProvisionalConfiguration[];
        renewType: string;
    }

    export interface GetReceivedLicenseConsumptionConfigurationBorrowConfiguration {
        /**
         * Indicates whether early check-ins are allowed.
         */
        allowEarlyCheckIn: boolean;
        /**
         * Maximum time for the provisional configuration, in minutes.
         */
        maxTimeToLiveInMinutes: number;
    }

    export interface GetReceivedLicenseConsumptionConfigurationProvisionalConfiguration {
        /**
         * Maximum time for the provisional configuration, in minutes.
         */
        maxTimeToLiveInMinutes: number;
    }

    export interface GetReceivedLicenseEntitlement {
        /**
         * Indicates whether check-ins are allowed.
         */
        allowCheckIn: boolean;
        /**
         * Maximum entitlement count. Use if the unit is not None.
         */
        maxCount: number;
        /**
         * The key name.
         */
        name: string;
        /**
         * Entitlement unit.
         */
        unit: string;
        /**
         * The value.
         */
        value: string;
    }

    export interface GetReceivedLicenseIssuer {
        /**
         * Issuer key fingerprint.
         */
        keyFingerprint: string;
        /**
         * The key name.
         */
        name: string;
        /**
         * Asymmetric KMS key from AWS Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
         */
        signKey: string;
    }

    export interface GetReceivedLicenseLicenseMetadata {
        /**
         * The key name.
         */
        name: string;
        /**
         * The value.
         */
        value: string;
    }

    export interface GetReceivedLicenseReceivedMetadata {
        /**
         * A list of allowed operations.
         */
        allowedOperations: string[];
        /**
         * Received status.
         */
        receivedStatus: string;
        /**
         * Received status reason.
         */
        receivedStatusReason: string;
    }

    export interface GetReceivedLicenseValidity {
        /**
         * Start of the validity time range.
         */
        begin: string;
        /**
         * End of the validity time range.
         */
        end: string;
    }

    export interface GetReceivedLicensesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/license-manager/latest/APIReference/API_ListReceivedLicenses.html#API_ListReceivedLicenses_RequestSyntax).
         * For example, if filtering using `ProductSKU`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.licensemanager.getReceivedLicenses({
         *     filters: [{
         *         name: "ProductSKU",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }

}

export namespace lightsail {
    export interface CertificateDomainValidationOption {
        /**
         * A domain name for which the certificate should be issued.
         */
        domainName: string;
        resourceRecordName: string;
        resourceRecordType: string;
        resourceRecordValue: string;
    }

    export interface ContainerServiceDeploymentVersionContainer {
        /**
         * The launch command for the container. A list of string.
         */
        commands?: string[];
        /**
         * The name for the container.
         */
        containerName: string;
        /**
         * A key-value map of the environment variables of the container.
         */
        environment?: {[key: string]: string};
        /**
         * The name of the image used for the container. Container images sourced from your Lightsail container service, that are registered and stored on your service, start with a colon (`:`). For example, `:container-service-1.mystaticwebsite.1`. Container images sourced from a public registry like Docker Hub don't start with a colon. For example, `nginx:latest` or `nginx`.
         */
        image: string;
        /**
         * A key-value map of the open firewall ports of the container. Valid values: `HTTP`, `HTTPS`, `TCP`, `UDP`.
         */
        ports?: {[key: string]: string};
    }

    export interface ContainerServiceDeploymentVersionPublicEndpoint {
        /**
         * The name of the container for the endpoint.
         */
        containerName: string;
        /**
         * The port of the container to which traffic is forwarded to.
         */
        containerPort: number;
        /**
         * A configuration block that describes the health check configuration of the container. Detailed below.
         */
        healthCheck: outputs.lightsail.ContainerServiceDeploymentVersionPublicEndpointHealthCheck;
    }

    export interface ContainerServiceDeploymentVersionPublicEndpointHealthCheck {
        /**
         * The number of consecutive health checks successes required before moving the container to the Healthy state. Defaults to 2.
         */
        healthyThreshold?: number;
        /**
         * The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. Defaults to 5.
         */
        intervalSeconds?: number;
        /**
         * The path on the container on which to perform the health check. Defaults to "/".
         */
        path?: string;
        /**
         * The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. Defaults to "200-499".
         */
        successCodes?: string;
        /**
         * The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. Defaults to 2.
         */
        timeoutSeconds?: number;
        /**
         * The number of consecutive health checks failures required before moving the container to the Unhealthy state. Defaults to 2.
         */
        unhealthyThreshold?: number;
    }

    export interface ContainerServicePrivateRegistryAccess {
        /**
         * Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
         */
        ecrImagePullerRole: outputs.lightsail.ContainerServicePrivateRegistryAccessEcrImagePullerRole;
    }

    export interface ContainerServicePrivateRegistryAccessEcrImagePullerRole {
        /**
         * A Boolean value that indicates whether to activate the role. The default is `false`.
         */
        isActive?: boolean;
        /**
         * The principal ARN of the container service. The principal ARN can be used to create a trust
         * relationship between your standard AWS account and your Lightsail container service. This allows you to give your
         * service permission to access resources in your standard AWS account.
         */
        principalArn: string;
    }

    export interface ContainerServicePublicDomainNames {
        certificates: outputs.lightsail.ContainerServicePublicDomainNamesCertificate[];
    }

    export interface ContainerServicePublicDomainNamesCertificate {
        certificateName: string;
        domainNames: string[];
    }

    export interface DistributionCacheBehavior {
        /**
         * The cache behavior for the specified path.
         */
        behavior: string;
        /**
         * The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/\*), and file types (\*.html, \*jpg, \*js). Directories and file paths are case-sensitive.
         */
        path: string;
    }

    export interface DistributionCacheBehaviorSettings {
        /**
         * The HTTP methods that are processed and forwarded to the distribution's origin.
         */
        allowedHttpMethods?: string;
        /**
         * The HTTP method responses that are cached by your distribution.
         */
        cachedHttpMethods?: string;
        /**
         * The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
         */
        defaultTtl?: number;
        /**
         * An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded. Detailed below
         */
        forwardedCookies?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedCookies;
        /**
         * An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded. Detailed below
         */
        forwardedHeaders?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedHeaders;
        /**
         * An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded. Detailed below
         */
        forwardedQueryStrings?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedQueryStrings;
        /**
         * The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        maximumTtl?: number;
        /**
         * The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        minimumTtl?: number;
    }

    export interface DistributionCacheBehaviorSettingsForwardedCookies {
        /**
         * The specific cookies to forward to your distribution's origin.
         */
        cookiesAllowLists?: string[];
        /**
         * Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
         */
        option?: string;
    }

    export interface DistributionCacheBehaviorSettingsForwardedHeaders {
        /**
         * The specific headers to forward to your distribution's origin.
         */
        headersAllowLists?: string[];
        /**
         * The headers that you want your distribution to forward to your origin and base caching on.
         */
        option?: string;
    }

    export interface DistributionCacheBehaviorSettingsForwardedQueryStrings {
        /**
         * Indicates whether the distribution forwards and caches based on query strings.
         */
        option?: boolean;
        /**
         * The specific query strings that the distribution forwards to the origin.
         */
        queryStringsAllowedLists?: string[];
    }

    export interface DistributionDefaultCacheBehavior {
        /**
         * The cache behavior of the distribution. Valid values: `cache` and `dont-cache`.
         */
        behavior: string;
    }

    export interface DistributionLocation {
        /**
         * The Availability Zone. Follows the format us-east-2a (case-sensitive).
         */
        availabilityZone: string;
        /**
         * The AWS Region name of the origin resource.
         */
        regionName: string;
    }

    export interface DistributionOrigin {
        /**
         * The name of the origin resource. Your origin can be an instance with an attached static IP, a bucket, or a load balancer that has at least one instance attached to it.
         */
        name: string;
        /**
         * The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
         */
        protocolPolicy?: string;
        /**
         * The AWS Region name of the origin resource.
         */
        regionName: string;
        /**
         * The resource type of the origin resource (e.g., Instance).
         */
        resourceType: string;
    }

    export interface InstanceAddOn {
        /**
         * The daily time when an automatic snapshot will be created. Must be in HH:00 format, and in an hourly increment and specified in Coordinated Universal Time (UTC). The snapshot will be automatically created between the time specified and up to 45 minutes after.
         */
        snapshotTime: string;
        /**
         * The status of the add on. Valid Values: `Enabled`, `Disabled`.
         */
        status: string;
        /**
         * The add-on type. There is currently only one valid type `AutoSnapshot`.
         */
        type: string;
    }

    export interface InstancePublicPortsPortInfo {
        /**
         * Set of CIDR aliases that define access for a preconfigured range of IP addresses.
         */
        cidrListAliases: string[];
        /**
         * Set of CIDR blocks.
         */
        cidrs: string[];
        /**
         * First port in a range of open ports on an instance.
         */
        fromPort: number;
        ipv6Cidrs: string[];
        /**
         * IP protocol name. Valid values are `tcp`, `all`, `udp`, and `icmp`.
         */
        protocol: string;
        /**
         * Last port in a range of open ports on an instance.
         *
         * The following arguments are optional:
         */
        toPort: number;
    }

    export interface LbCertificateDomainValidationRecord {
        /**
         * The domain name (e.g., example.com) for your SSL/TLS certificate.
         */
        domainName: string;
        resourceRecordName: string;
        resourceRecordType: string;
        resourceRecordValue: string;
    }

}

export namespace location {
    export interface GetMapConfiguration {
        /**
         * The map style selected from an available data provider.
         */
        style: string;
    }

    export interface GetPlaceIndexDataSourceConfiguration {
        intendedUse: string;
    }

    export interface MapConfiguration {
        /**
         * Specifies the map style selected from an available data provider. Valid values can be found in the [Location Service CreateMap API Reference](https://docs.aws.amazon.com/location/latest/APIReference/API_CreateMap.html).
         */
        style: string;
    }

    export interface PlaceIndexDataSourceConfiguration {
        /**
         * Specifies how the results of an operation will be stored by the caller. Valid values: `SingleUse`, `Storage`. Default: `SingleUse`.
         */
        intendedUse?: string;
    }

}

export namespace macie {
    export interface FindingsFilterFindingCriteria {
        /**
         * A condition that specifies the property, operator, and one or more values to use to filter the results.  (documented below)
         */
        criterions?: outputs.macie.FindingsFilterFindingCriteriaCriterion[];
    }

    export interface FindingsFilterFindingCriteriaCriterion {
        /**
         * The value for the property exclusively matches (equals an exact match for) all the specified values. If you specify multiple values, Amazon Macie uses AND logic to join the values.
         */
        eqExactMatches?: string[];
        /**
         * The value for the property matches (equals) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
         */
        eqs?: string[];
        /**
         * The name of the field to be evaluated.
         */
        field: string;
        /**
         * The value for the property is greater than the specified value.
         */
        gt?: string;
        /**
         * The value for the property is greater than or equal to the specified value.
         */
        gte?: string;
        /**
         * The value for the property is less than the specified value.
         */
        lt?: string;
        /**
         * The value for the property is less than or equal to the specified value.
         */
        lte?: string;
        /**
         * The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
         */
        neqs?: string[];
    }

}

export namespace macie2 {
    export interface ClassificationExportConfigurationS3Destination {
        /**
         * The Amazon S3 bucket name in which Amazon Macie exports the data classification results.
         */
        bucketName: string;
        /**
         * The object key for the bucket in which Amazon Macie exports the data classification results.
         */
        keyPrefix?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         *
         * Additional information can be found in the [Storing and retaining sensitive data discovery results with Amazon Macie for AWS Macie documentation](https://docs.aws.amazon.com/macie/latest/user/discovery-results-repository-s3.html).
         */
        kmsKeyArn: string;
    }

    export interface ClassificationJobS3JobDefinition {
        /**
         * The property- and tag-based conditions that determine which S3 buckets to include or exclude from the analysis. Conflicts with `bucketDefinitions`. (documented below)
         */
        bucketCriteria: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteria;
        /**
         * An array of objects, one for each AWS account that owns buckets to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for the account. Conflicts with `bucketCriteria`. (documented below)
         */
        bucketDefinitions?: outputs.macie2.ClassificationJobS3JobDefinitionBucketDefinition[];
        /**
         * The property- and tag-based conditions that determine which objects to include or exclude from the analysis. (documented below)
         */
        scoping: outputs.macie2.ClassificationJobS3JobDefinitionScoping;
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteria {
        /**
         * The property- or tag-based conditions that determine which S3 buckets to exclude from the analysis. (documented below)
         */
        excludes: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludes;
        /**
         * The property- or tag-based conditions that determine which S3 buckets to include in the analysis. (documented below)
         */
        includes: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludes;
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaExcludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAnd[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
         */
        simpleCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
         */
        tagCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterion;
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion {
        /**
         * The operator to use in a condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The object property to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionkeyforjob)
         */
        key: string;
        /**
         * An array that lists the values to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionforjob)
         */
        values: string[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterion {
        /**
         * The operator to use in the condition. Valid combination and values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The  tag key and value pairs to use in the condition. One or more blocks are allowed. (documented below)
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValue[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaIncludes {
        /**
         * An array of conditions, one for each condition that determines which S3 buckets to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAnd[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
         */
        simpleCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
         */
        tagCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterion;
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion {
        /**
         * The operator to use in a condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The object property to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionkeyforjob)
         */
        key: string;
        /**
         * An array that lists the values to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionforjob)
         */
        values: string[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterion {
        /**
         * The operator to use in the condition. Valid combination and values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The  tag key and value pairs to use in the condition. One or more blocks are allowed. (documented below)
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValue[];
    }

    export interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface ClassificationJobS3JobDefinitionBucketDefinition {
        /**
         * The unique identifier for the AWS account that owns the buckets.
         */
        accountId: string;
        /**
         * An array that lists the names of the buckets.
         */
        buckets: string[];
    }

    export interface ClassificationJobS3JobDefinitionScoping {
        /**
         * The property- or tag-based conditions that determine which objects to exclude from the analysis. (documented below)
         */
        excludes: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludes;
        /**
         * The property- or tag-based conditions that determine which objects to include in the analysis. (documented below)
         */
        includes: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludes;
    }

    export interface ClassificationJobS3JobDefinitionScopingExcludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAnd[];
    }

    export interface ClassificationJobS3JobDefinitionScopingExcludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
         */
        simpleScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndSimpleScopeTerm;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
         */
        tagScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTerm;
    }

    export interface ClassificationJobS3JobDefinitionScopingExcludesAndSimpleScopeTerm {
        /**
         * The operator to use in a condition. Valid values are: `EQ`, `GT`, `GTE`, `LT`, `LTE`, `NE`, `CONTAINS`, `STARTS_WITH`
         */
        comparator: string;
        /**
         * The object property to use in the condition.
         */
        key: string;
        /**
         * An array that lists the values to use in the condition.
         */
        values: string[];
    }

    export interface ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTerm {
        /**
         * The operator to use in the condition.
         */
        comparator: string;
        /**
         * The tag key to use in the condition. The only valid value is `TAG`.
         */
        key: string;
        /**
         * The tag keys or tag key and value pairs to use in the condition.
         */
        tagValues: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTermTagValue[];
        /**
         * The type of object to apply the condition to. The only valid value is `S3_OBJECT`.
         */
        target: string;
    }

    export interface ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTermTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface ClassificationJobS3JobDefinitionScopingIncludes {
        /**
         * An array of conditions, one for each condition that determines which S3 buckets to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAnd[];
    }

    export interface ClassificationJobS3JobDefinitionScopingIncludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
         */
        simpleScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndSimpleScopeTerm;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
         */
        tagScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTerm;
    }

    export interface ClassificationJobS3JobDefinitionScopingIncludesAndSimpleScopeTerm {
        /**
         * The operator to use in a condition. Valid values are: `EQ`, `GT`, `GTE`, `LT`, `LTE`, `NE`, `CONTAINS`, `STARTS_WITH`
         */
        comparator: string;
        /**
         * The object property to use in the condition.
         */
        key: string;
        /**
         * An array that lists the values to use in the condition.
         */
        values: string[];
    }

    export interface ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTerm {
        /**
         * The operator to use in the condition.
         */
        comparator: string;
        /**
         * The tag key to use in the condition. The only valid value is `TAG`.
         */
        key: string;
        /**
         * The tag keys or tag key and value pairs to use in the condition.
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTermTagValue[];
        /**
         * The type of object to apply the condition to. The only valid value is `S3_OBJECT`.
         */
        target: string;
    }

    export interface ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTermTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface ClassificationJobScheduleFrequency {
        /**
         * Specifies a daily recurrence pattern for running the job.
         */
        dailySchedule?: boolean;
        /**
         * Specifies a monthly recurrence pattern for running the job.
         *
         * The `s3JobDefinition` object supports the following:
         */
        monthlySchedule: number;
        /**
         * Specifies a weekly recurrence pattern for running the job.
         */
        weeklySchedule: string;
    }

    export interface ClassificationJobUserPausedDetail {
        jobExpiresAt: string;
        jobImminentExpirationHealthEventArn: string;
        jobPausedAt: string;
    }

}

export namespace mediaconvert {
    export interface QueueReservationPlanSettings {
        /**
         * The length of the term of your reserved queue pricing plan commitment. Valid value is `ONE_YEAR`.
         */
        commitment: string;
        /**
         * Specifies whether the term of your reserved queue pricing plan. Valid values are `AUTO_RENEW` or `EXPIRE`.
         */
        renewalType: string;
        /**
         * Specifies the number of reserved transcode slots (RTS) for queue.
         */
        reservedSlots: number;
    }

}

export namespace medialive {
    export interface ChannelCdiInputSpecification {
        /**
         * Maximum CDI input resolution.
         */
        resolution: string;
    }

    export interface ChannelDestination {
        /**
         * User-specified id. Ths is used in an output group or an output.
         */
        id: string;
        /**
         * Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
         */
        mediaPackageSettings?: outputs.medialive.ChannelDestinationMediaPackageSetting[];
        /**
         * Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
         */
        multiplexSettings?: outputs.medialive.ChannelDestinationMultiplexSettings;
        /**
         * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
         */
        settings?: outputs.medialive.ChannelDestinationSetting[];
    }

    export interface ChannelDestinationMediaPackageSetting {
        /**
         * ID of the channel in MediaPackage that is the destination for this output group.
         */
        channelId: string;
    }

    export interface ChannelDestinationMultiplexSettings {
        /**
         * The ID of the Multiplex that the encoder is providing output to.
         */
        multiplexId: string;
        /**
         * The program name of the Multiplex program that the encoder is providing output to.
         */
        programName: string;
    }

    export interface ChannelDestinationSetting {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam?: string;
        /**
         * Stream name RTMP destinations (URLs of type rtmp://)
         */
        streamName?: string;
        /**
         * A URL specifying a destination.
         */
        url?: string;
        /**
         * Username for destination.
         */
        username?: string;
    }

    export interface ChannelEncoderSettings {
        /**
         * Audio descriptions for the channel. See Audio Descriptions for more details.
         */
        audioDescriptions?: outputs.medialive.ChannelEncoderSettingsAudioDescription[];
        /**
         * Settings for ad avail blanking. See Avail Blanking for more details.
         */
        availBlanking: outputs.medialive.ChannelEncoderSettingsAvailBlanking;
        /**
         * Output groups for the channel. See Output Groups for more details.
         */
        outputGroups: outputs.medialive.ChannelEncoderSettingsOutputGroup[];
        /**
         * Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
         */
        timecodeConfig: outputs.medialive.ChannelEncoderSettingsTimecodeConfig;
        /**
         * Video Descriptions. See Video Descriptions for more details.
         */
        videoDescriptions: outputs.medialive.ChannelEncoderSettingsVideoDescription[];
    }

    export interface ChannelEncoderSettingsAudioDescription {
        /**
         * Advanced audio normalization settings. See Audio Normalization Settings for more details.
         */
        audioNormalizationSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings;
        /**
         * The name of the audio selector used as the source for this AudioDescription.
         */
        audioSelectorName: string;
        /**
         * Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
         */
        audioType: string;
        /**
         * Determined how audio type is determined.
         */
        audioTypeControl: string;
        /**
         * Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
         */
        audioWatermarkSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings;
        /**
         * Audio codec settings. See Audio Codec Settings for more details.
         */
        codecSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettings;
        /**
         * When specified this field indicates the three letter language code of the caption track to extract from the source.
         */
        languageCode: string;
        languageCodeControl: string;
        /**
         * The name of this audio description.
         */
        name: string;
        remixSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettings;
        /**
         * Stream name RTMP destinations (URLs of type rtmp://)
         */
        streamName: string;
    }

    export interface ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings {
        /**
         * Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
         */
        algorithm: string;
        /**
         * Algorithm control for the audio description.
         */
        algorithmControl: string;
        /**
         * Target LKFS (loudness) to adjust volume to.
         */
        targetLkfs: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings {
        nielsenWatermarksSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings;
    }

    export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings {
        /**
         * Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
         */
        nielsenCbetSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings;
        /**
         * Distribution types to assign to the watermarks. Options are `PROGRAM_CONTENT` and `FINAL_DISTRIBUTOR`.
         */
        nielsenDistributionType: string;
        /**
         * Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
         */
        nielsenNaesIiNwSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting[];
    }

    export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings {
        cbetCheckDigitString: string;
        /**
         * Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
         */
        cbetStepaside: string;
        /**
         * CBET source ID to use in the watermark.
         */
        csid: string;
    }

    export interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting {
        checkDigitString: string;
        /**
         * The Nielsen Source ID to include in the watermark.
         */
        sid: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettings {
        /**
         * Aac Settings. See AAC Settings for more details.
         */
        aacSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings;
        /**
         * Ac3 Settings. See AC3 Settings for more details.
         */
        ac3Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings;
        /**
         * Eac3 Atmos Settings. See EAC3 Atmos Settings
         */
        eac3AtmosSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings;
        /**
         * Eac3 Settings. See EAC3 Settings
         */
        eac3Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings;
        mp2Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings;
        passThroughSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings;
        wavSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
         */
        inputType: string;
        /**
         * AAC profile.
         */
        profile: string;
        /**
         * The rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets LATM/LOAS AAC output for raw containers.
         */
        rawFormat: string;
        /**
         * Sample rate in Hz.
         */
        sampleRate: number;
        /**
         * Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
         */
        spec: string;
        /**
         * VBR Quality Level - Only used if rateControlMode is VBR.
         */
        vbrQuality: string;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
         */
        bitstreamMode: string;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Sets the dialnorm of the output.
         */
        dialnorm: number;
        /**
         * If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
         */
        drcProfile: string;
        /**
         * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
         */
        lfeFilter: string;
        /**
         * Metadata control.
         */
        metadataControl: string;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Sets the dialnorm of the output.
         */
        dialnorm: number;
        /**
         * Sets the Dolby dynamic range compression profile.
         */
        drcLine: string;
        /**
         * Sets the profile for heavy Dolby dynamic range compression.
         */
        drcRf: string;
        /**
         * Height dimensional trim.
         */
        heightTrim: number;
        /**
         * Surround dimensional trim.
         */
        surroundTrim: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings {
        /**
         * Sets the attenuation control.
         */
        attenuationControl: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
         */
        bitstreamMode: string;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        dcFilter: string;
        /**
         * Sets the dialnorm of the output.
         */
        dialnorm: number;
        /**
         * Sets the Dolby dynamic range compression profile.
         */
        drcLine: string;
        /**
         * Sets the profile for heavy Dolby dynamic range compression.
         */
        drcRf: string;
        lfeControl: string;
        /**
         * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
         */
        lfeFilter: string;
        loRoCenterMixLevel: number;
        loRoSurroundMixLevel: number;
        ltRtCenterMixLevel: number;
        ltRtSurroundMixLevel: number;
        /**
         * Metadata control.
         */
        metadataControl: string;
        passthroughControl: string;
        phaseControl: string;
        stereoDownmix: string;
        surroundExMode: string;
        surroundMode: string;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Sample rate in Hz.
         */
        sampleRate: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings {
    }

    export interface ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings {
        bitDepth: number;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Sample rate in Hz.
         */
        sampleRate: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionRemixSettings {
        channelMappings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping[];
        channelsIn: number;
        channelsOut: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping {
        inputChannelLevels: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel[];
        outputChannel: number;
    }

    export interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel {
        gain: number;
        inputChannel: number;
    }

    export interface ChannelEncoderSettingsAvailBlanking {
        /**
         * Blanking image to be used. See Avail Blanking Image for more details.
         */
        availBlankingImage?: outputs.medialive.ChannelEncoderSettingsAvailBlankingAvailBlankingImage;
        /**
         * When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
         */
        state: string;
    }

    export interface ChannelEncoderSettingsAvailBlankingAvailBlankingImage {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * . Username to be used.
         */
        username: string;
    }

    export interface ChannelEncoderSettingsOutputGroup {
        /**
         * Custom output group name defined by the user.
         */
        name?: string;
        /**
         * Settings associated with the output group. See Output Group Settings for more details.
         */
        outputGroupSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettings;
        /**
         * List of outputs. See Outputs for more details.
         */
        outputs: outputs.medialive.ChannelEncoderSettingsOutputGroupOutput[];
    }

    export interface ChannelEncoderSettingsOutputGroupOutput {
        /**
         * The names of the audio descriptions used as audio sources for the output.
         */
        audioDescriptionNames?: string[];
        /**
         * The names of the caption descriptions used as caption sources for the output.
         */
        captionDescriptionNames: string[];
        /**
         * The name used to identify an output.
         */
        outputName?: string;
        /**
         * Settings for output. See Output Settings for more details.
         */
        outputSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettings;
        /**
         * The name of the video description used as video source for the output.
         */
        videoDescriptionName?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettings {
        /**
         * Archive group settings. See Archive Group Settings for more details.
         */
        archiveGroupSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting[];
        frameCaptureGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings;
        hlsGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings;
        /**
         * Media package group settings. See Media Package Group Settings for more details.
         */
        mediaPackageGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings;
        msSmoothGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings;
        multiplexGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings;
        /**
         * RTMP group settings. See RTMP Group Settings for more details.
         */
        rtmpGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings;
        udpGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting {
        /**
         * Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
         */
        archiveCdnSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings;
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination;
        /**
         * Number of seconds to write to archive file before closing and starting a new one.
         */
        rolloverInterval?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings {
        /**
         * Archive S3 Settings. See Archive S3 Settings for more details.
         */
        archiveS3Settings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings {
        /**
         * Specify the canned ACL to apply to each S3 request.
         */
        cannedAcl?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings {
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination;
        frameCaptureCdnSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings {
        frameCaptureS3Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings {
        /**
         * Specify the canned ACL to apply to each S3 request.
         */
        cannedAcl?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings {
        /**
         * The ad marker type for this output group.
         */
        adMarkers: string[];
        baseUrlContent: string;
        baseUrlContent1: string;
        baseUrlManifest: string;
        baseUrlManifest1: string;
        captionLanguageMappings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping[];
        captionLanguageSetting: string;
        clientCache: string;
        codecSpecification: string;
        constantIv: string;
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination;
        directoryStructure: string;
        discontinuityTags: string;
        encryptionType: string;
        hlsCdnSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting[];
        hlsId3SegmentTagging: string;
        iframeOnlyPlaylists: string;
        incompleteSegmentBehavior: string;
        indexNSegments: number;
        /**
         * Controls the behavior of the RTMP group if input becomes unavailable.
         */
        inputLossAction: string;
        ivInManifest: string;
        ivSource: string;
        keepSegments: number;
        keyFormat: string;
        keyFormatVersions: string;
        keyProviderSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings;
        manifestCompression: string;
        manifestDurationFormat: string;
        minSegmentLength: number;
        mode: string;
        outputSelection: string;
        programDateTime: string;
        programDateTimeClock: string;
        programDateTimePeriod: number;
        redundantManifest: string;
        segmentLength: number;
        segmentsPerSubdirectory: number;
        streamInfResolution: string;
        /**
         * Indicates ID3 frame that has the timecode.
         */
        timedMetadataId3Frame: string;
        timedMetadataId3Period: number;
        timestampDeltaMilliseconds: number;
        tsFileMode: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping {
        captionChannel: number;
        /**
         * When specified this field indicates the three letter language code of the caption track to extract from the source.
         */
        languageCode: string;
        languageDescription: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting {
        hlsAkamaiSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings;
        hlsBasicPutSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings;
        hlsMediaStoreSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings;
        hlsS3Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings;
        hlsWebdavSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings {
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode: string;
        /**
         * Number of retry attempts.
         */
        numRetries?: number;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
        salt: string;
        token: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings {
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        /**
         * Number of retry attempts.
         */
        numRetries?: number;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings {
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        mediaStoreStorageClass: string;
        /**
         * Number of retry attempts.
         */
        numRetries?: number;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings {
        /**
         * Specify the canned ACL to apply to each S3 request.
         */
        cannedAcl?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings {
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode: string;
        /**
         * Number of retry attempts.
         */
        numRetries?: number;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings {
        staticKeySettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting[];
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting {
        keyProviderServer?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer;
        staticKeyValue: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * Username for destination.
         */
        username: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings {
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings {
        acquisitionPointId: string;
        audioOnlyTimecodeControl: string;
        /**
         * Setting to allow self signed or verified RTMP certificates.
         */
        certificateMode: string;
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval: number;
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination;
        eventId: string;
        eventIdMode: string;
        eventStopBehavior: string;
        filecacheDuration?: number;
        fragmentLength: number;
        /**
         * Controls the behavior of the RTMP group if input becomes unavailable.
         */
        inputLossAction: string;
        /**
         * Number of retry attempts.
         */
        numRetries?: number;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
        segmentationMode: string;
        sendDelayMs: number;
        sparseTrackType: string;
        streamManifestBehavior: string;
        timestampOffset: string;
        timestampOffsetMode: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings {
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings {
        /**
         * The ad marker type for this output group.
         */
        adMarkers?: string[];
        /**
         * Authentication scheme to use when connecting with CDN.
         */
        authenticationScheme: string;
        /**
         * Controls behavior when content cache fills up.
         */
        cacheFullBehavior: string;
        /**
         * Cache length in seconds, is used to calculate buffer size.
         */
        cacheLength: number;
        /**
         * Controls the types of data that passes to onCaptionInfo outputs.
         */
        captionData: string;
        /**
         * Controls the behavior of the RTMP group if input becomes unavailable.
         */
        inputLossAction: string;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings {
        /**
         * Specifies behavior of last resort when input video os lost.
         */
        inputLossAction: string;
        /**
         * Indicates ID3 frame that has the timecode.
         */
        timedMetadataId3Frame: string;
        timedMetadataId3Period: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettings {
        /**
         * Archive output settings. See Archive Output Settings for more details.
         */
        archiveOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings;
        frameCaptureOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings;
        hlsOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings;
        /**
         * Media package output settings. This can be set as an empty block.
         */
        mediaPackageOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings;
        msSmoothOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings;
        /**
         * Multiplex output settings. See Multiplex Output Settings for more details.
         */
        multiplexOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings;
        /**
         * RTMP output settings. See RTMP Output Settings for more details.
         */
        rtmpOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings;
        /**
         * UDP output settings. See UDP Output Settings for more details
         */
        udpOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings {
        /**
         * Settings specific to the container type of the file. See Container Settings for more details.
         */
        containerSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings;
        /**
         * Output file extension.
         */
        extension?: string;
        /**
         * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
         */
        nameModifier?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings {
        /**
         * M2ts Settings. See [M2ts Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
         */
        m2tsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings;
        /**
         * Raw Settings. This can be set as an empty block.
         */
        rawSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings {
        absentInputAudioBehavior: string;
        arib?: string;
        aribCaptionsPid: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids: string;
        audioStreamType?: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
        dvbSubPids: string;
        dvbTdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
        dvbTeletextPid: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid: string;
        etvSignalPid: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids: string;
        scte35Control?: string;
        /**
         * PID from which to read SCTE-35 messages.
         */
        scte35Pid: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid: string;
        transportStreamId?: number;
        videoPid: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
        networkId: number;
        networkName: string;
        repInterval?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
        repInterval?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings {
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings {
        /**
         * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
         */
        nameModifier: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings {
        h265PackagingType: string;
        hlsSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings;
        /**
         * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
         */
        nameModifier: string;
        segmentModifier: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings {
        audioOnlyHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings;
        fmp4HlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings;
        frameCaptureHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings;
        standardHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings {
        audioGroupId: string;
        audioOnlyImage?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage;
        audioTrackType: string;
        segmentType: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * Username for destination.
         */
        username: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings {
        audioRenditionSets: string;
        nielsenId3Behavior: string;
        timedMetadataBehavior: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings {
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings {
        audioRenditionSets: string;
        m3u8Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings {
        audioFramesPerPes: number;
        audioPids: string;
        ecmPid: string;
        nielsenId3Behavior: string;
        patInterval: number;
        pcrControl: string;
        pcrPeriod: number;
        pcrPid: string;
        pmtInterval: number;
        pmtPid: string;
        programNum: number;
        scte35Behavior: string;
        /**
         * PID from which to read SCTE-35 messages.
         */
        scte35Pid: string;
        timedMetadataBehavior: string;
        timedMetadataPid: string;
        transportStreamId: number;
        videoPid: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings {
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings {
        h265PackagingType: string;
        /**
         * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
         */
        nameModifier: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings {
        /**
         * Destination is a multiplex. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings {
        /**
         * Setting to allow self signed or verified RTMP certificates.
         */
        certificateMode: string;
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval: number;
        /**
         * The RTMP endpoint excluding the stream name. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination;
        /**
         * Number of retry attempts.
         */
        numRetries: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings {
        /**
         * UDP output buffering in milliseconds.
         */
        bufferMsec: number;
        /**
         * UDP container settings. See Container Settings for more details.
         */
        containerSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings;
        /**
         * Destination address and port number for RTP or UDP packets. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination;
        fecOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings {
        /**
         * M2ts Settings. See [M2ts Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
         */
        m2tsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings {
        absentInputAudioBehavior: string;
        arib?: string;
        aribCaptionsPid: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids: string;
        audioStreamType?: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
        dvbSubPids: string;
        dvbTdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
        dvbTeletextPid: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid: string;
        etvSignalPid: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids: string;
        scte35Control?: string;
        /**
         * PID from which to read SCTE-35 messages.
         */
        scte35Pid: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid: string;
        transportStreamId?: number;
        videoPid: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
        networkId: number;
        networkName: string;
        repInterval?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
        repInterval?: number;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }

    export interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings {
        /**
         * The height of the FEC protection matrix.
         */
        columnDepth: number;
        /**
         * Enables column only or column and row based FEC.
         */
        includeFec: string;
        /**
         * The width of the FEC protection matrix.
         */
        rowLength: number;
    }

    export interface ChannelEncoderSettingsTimecodeConfig {
        /**
         * The source for the timecode that will be associated with the events outputs.
         */
        source: string;
        /**
         * Threshold in frames beyond which output timecode is resynchronized to the input timecode.
         */
        syncThreshold: number;
    }

    export interface ChannelEncoderSettingsVideoDescription {
        /**
         * The video codec settings. See Video Codec Settings for more details.
         */
        codecSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettings;
        /**
         * Output video height in pixels.
         */
        height: number;
        /**
         * The name of the video description.
         */
        name: string;
        /**
         * Indicate how to respond to the AFD values that might be in the input video.
         */
        respondToAfd: string;
        /**
         * Behavior on how to scale.
         */
        scalingBehavior: string;
        /**
         * Changes the strength of the anti-alias filter used for scaling.
         */
        sharpness: number;
        /**
         * Output video width in pixels.
         */
        width: number;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettings {
        /**
         * Frame capture settings. See Frame Capture Settings for more details.
         */
        frameCaptureSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings;
        /**
         * H264 settings. See H264 Settings for more details.
         */
        h264Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings;
        h265Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings {
        /**
         * The frequency at which to capture frames for inclusion in the output.
         */
        captureInterval: number;
        /**
         * Unit for the frame capture interval.
         */
        captureIntervalUnits: string;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings {
        /**
         * Enables or disables adaptive quantization.
         */
        adaptiveQuantization: string;
        /**
         * Indicates that AFD values will be written into the output stream.
         */
        afdSignaling: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        bufFillPct: number;
        /**
         * Size of buffer in bits.
         */
        bufSize: number;
        /**
         * Includes color space metadata in the output.
         */
        colorMetadata: string;
        /**
         * Entropy encoding mode.
         */
        entropyEncoding: string;
        /**
         * Filters to apply to an encode. See H264 Filter Settings for more details.
         */
        filterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings;
        /**
         * Four bit AFD value to write on all frames of video in the output stream.
         */
        fixedAfd: string;
        flickerAq: string;
        /**
         * Controls whether coding is performed on a field basis or on a frame basis.
         */
        forceFieldPictures: string;
        /**
         * Indicates how the output video frame rate is specified.
         */
        framerateControl: string;
        /**
         * Framerate denominator.
         */
        framerateDenominator: number;
        /**
         * Framerate numerator.
         */
        framerateNumerator: number;
        /**
         * GOP-B reference.
         */
        gopBReference: string;
        /**
         * Frequency of closed GOPs.
         */
        gopClosedCadence: number;
        /**
         * Number of B-frames between reference frames.
         */
        gopNumBFrames: number;
        /**
         * GOP size in units of either frames of seconds per `gopSizeUnits`.
         */
        gopSize: number;
        /**
         * Indicates if the `gopSize` is specified in frames or seconds.
         */
        gopSizeUnits: string;
        /**
         * H264 level.
         */
        level: string;
        /**
         * Amount of lookahead.
         */
        lookAheadRateControl: string;
        /**
         * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         */
        maxBitrate: number;
        minIInterval: number;
        /**
         * Number of reference frames to use.
         */
        numRefFrames: number;
        /**
         * Indicates how the output pixel aspect ratio is specified.
         */
        parControl: string;
        /**
         * Pixel Aspect Ratio denominator.
         */
        parDenominator: number;
        /**
         * Pixel Aspect Ratio numerator.
         */
        parNumerator: number;
        /**
         * AAC profile.
         */
        profile: string;
        /**
         * Quality level.
         */
        qualityLevel: string;
        /**
         * Controls the target quality for the video encode.
         */
        qvbrQualityLevel: number;
        /**
         * The rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets the scan type of the output.
         */
        scanType: string;
        /**
         * Scene change detection.
         */
        sceneChangeDetect: string;
        /**
         * Number of slices per picture.
         */
        slices: number;
        /**
         * Softness.
         */
        softness: number;
        /**
         * Makes adjustments within each frame based on spatial variation of content complexity.
         */
        spatialAq: string;
        /**
         * Subgop length.
         */
        subgopLength: string;
        /**
         * Produces a bitstream compliant with SMPTE RP-2027.
         */
        syntax: string;
        /**
         * Makes adjustments within each frame based on temporal variation of content complexity.
         */
        temporalAq: string;
        /**
         * Determines how timecodes should be inserted into the video elementary stream.
         */
        timecodeInsertion: string;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings {
        /**
         * Temporal filter settings. See Temporal Filter Settings
         */
        temporalFilterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings {
        /**
         * Post filter sharpening.
         */
        postFilterSharpening?: string;
        /**
         * Filter strength.
         */
        strength?: string;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings {
        /**
         * Enables or disables adaptive quantization.
         */
        adaptiveQuantization: string;
        /**
         * Indicates that AFD values will be written into the output stream.
         */
        afdSignaling: string;
        /**
         * Whether or not EML should insert an Alternative Transfer Function SEI message.
         */
        alternativeTransferFunction: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Size of buffer in bits.
         */
        bufSize?: number;
        /**
         * Includes color space metadata in the output.
         */
        colorMetadata: string;
        /**
         * Define the color metadata for the output. H265 Color Space Settings for more details.
         */
        colorSpaceSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings;
        /**
         * Filters to apply to an encode. See H264 Filter Settings for more details.
         */
        filterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings;
        /**
         * Four bit AFD value to write on all frames of video in the output stream.
         */
        fixedAfd: string;
        flickerAq: string;
        /**
         * Framerate denominator.
         */
        framerateDenominator: number;
        /**
         * Framerate numerator.
         */
        framerateNumerator: number;
        /**
         * Frequency of closed GOPs.
         */
        gopClosedCadence?: number;
        /**
         * GOP size in units of either frames of seconds per `gopSizeUnits`.
         */
        gopSize?: number;
        /**
         * Indicates if the `gopSize` is specified in frames or seconds.
         */
        gopSizeUnits: string;
        /**
         * H264 level.
         */
        level: string;
        /**
         * Amount of lookahead.
         */
        lookAheadRateControl: string;
        /**
         * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         */
        maxBitrate?: number;
        minIInterval?: number;
        /**
         * Pixel Aspect Ratio denominator.
         */
        parDenominator?: number;
        /**
         * Pixel Aspect Ratio numerator.
         */
        parNumerator?: number;
        /**
         * AAC profile.
         */
        profile: string;
        /**
         * Controls the target quality for the video encode.
         */
        qvbrQualityLevel?: number;
        /**
         * The rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets the scan type of the output.
         */
        scanType: string;
        /**
         * Scene change detection.
         */
        sceneChangeDetect: string;
        /**
         * Number of slices per picture.
         */
        slices?: number;
        /**
         * Set the H265 tier in the output.
         */
        tier: string;
        /**
         * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
         */
        timecodeBurninSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings;
        /**
         * Determines how timecodes should be inserted into the video elementary stream.
         */
        timecodeInsertion: string;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings {
        /**
         * Sets the colorspace metadata to be passed through.
         */
        colorSpacePassthroughSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings;
        /**
         * Set the colorspace to Dolby Vision81.
         */
        dolbyVision81Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings;
        /**
         * Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
         */
        hdr10Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings;
        /**
         * Set the colorspace to Rec. 601.
         */
        rec601Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings;
        /**
         * Set the colorspace to Rec. 709.
         */
        rec709Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings {
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings {
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings {
        /**
         * Sets the MaxCLL value for HDR10.
         */
        maxCll?: number;
        /**
         * Sets the MaxFALL value for HDR10.
         */
        maxFall?: number;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings {
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings {
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings {
        /**
         * Temporal filter settings. See Temporal Filter Settings
         */
        temporalFilterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings {
        /**
         * Post filter sharpening.
         */
        postFilterSharpening?: string;
        /**
         * Filter strength.
         */
        strength?: string;
    }

    export interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings {
        /**
         * Set a prefix on the burned in timecode.
         */
        prefix: string;
        /**
         * Sets the size of the burned in timecode.
         */
        timecodeBurninFontSize: string;
        /**
         * Sets the position of the burned in timecode.
         */
        timecodeBurninPosition: string;
    }

    export interface ChannelInputAttachment {
        automaticInputFailoverSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettings;
        /**
         * User-specified name for the attachment.
         */
        inputAttachmentName: string;
        /**
         * The ID of the input.
         */
        inputId: string;
        /**
         * Settings of an input. See Input Settings for more details
         */
        inputSettings: outputs.medialive.ChannelInputAttachmentInputSettings;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettings {
        errorClearTimeMsec?: number;
        failoverConditions?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition[];
        inputPreference?: string;
        secondaryInputId: string;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition {
        failoverConditionSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings {
        audioSilenceSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings;
        inputLossSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings;
        videoBlackSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings {
        /**
         * The name of the audio selector used as the source for this AudioDescription.
         */
        audioSelectorName: string;
        audioSilenceThresholdMsec?: number;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings {
        inputLossThresholdMsec?: number;
    }

    export interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings {
        blackDetectThreshold?: number;
        videoBlackThresholdMsec?: number;
    }

    export interface ChannelInputAttachmentInputSettings {
        audioSelectors?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelector[];
        captionSelectors?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelector[];
        /**
         * Enable or disable the deblock filter when filtering.
         */
        deblockFilter?: string;
        /**
         * Enable or disable the denoise filter when filtering.
         */
        denoiseFilter?: string;
        /**
         * Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
         */
        filterStrength?: number;
        /**
         * Turns on the filter for the input.
         */
        inputFilter: string;
        /**
         * Input settings. See Network Input Settings for more details.
         */
        networkInputSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsNetworkInputSettings;
        /**
         * PID from which to read SCTE-35 messages.
         */
        scte35Pid?: number;
        /**
         * Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
         */
        smpte2038DataPreference?: string;
        /**
         * Loop input if it is a file.
         */
        sourceEndBehavior?: string;
        videoSelector?: outputs.medialive.ChannelInputAttachmentInputSettingsVideoSelector;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelector {
        /**
         * Name of the Channel.
         *
         * The following arguments are optional:
         */
        name: string;
        selectorSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings {
        audioHlsRenditionSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection;
        audioLanguageSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection;
        audioPidSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection;
        audioTrackSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection {
        groupId: string;
        /**
         * Name of the Channel.
         *
         * The following arguments are optional:
         */
        name: string;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection {
        /**
         * When specified this field indicates the three letter language code of the caption track to extract from the source.
         */
        languageCode: string;
        languageSelectionPolicy?: string;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection {
        pid: number;
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection {
        tracks: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack[];
    }

    export interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack {
        track: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelector {
        /**
         * When specified this field indicates the three letter language code of the caption track to extract from the source.
         */
        languageCode?: string;
        /**
         * Name of the Channel.
         *
         * The following arguments are optional:
         */
        name: string;
        selectorSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings {
        ancillarySourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings;
        dvbTdtSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings;
        embeddedSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings;
        scte20SourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings;
        scte27SourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings;
        teletextSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings {
        sourceAncillaryChannelNumber?: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings {
        ocrLanguage?: string;
        pid?: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings {
        convert608To708?: string;
        scte20Detection?: string;
        source608ChannelNumber?: number;
        source608TrackNumber?: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings {
        convert608To708?: string;
        source608ChannelNumber?: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings {
        ocrLanguage?: string;
        pid?: number;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings {
        outputRectangle?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle;
        pageNumber?: string;
    }

    export interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle {
        /**
         * Output video height in pixels.
         */
        height: number;
        leftOffset: number;
        topOffset: number;
        /**
         * Output video width in pixels.
         */
        width: number;
    }

    export interface ChannelInputAttachmentInputSettingsNetworkInputSettings {
        /**
         * Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
         */
        hlsInputSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings;
        /**
         * Check HTTPS server certificates.
         */
        serverValidation?: string;
    }

    export interface ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings {
        /**
         * The bitrate is specified in bits per second, as in an HLS manifest.
         */
        bandwidth?: number;
        /**
         * Buffer segments.
         */
        bufferSegments?: number;
        /**
         * The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
         */
        retries?: number;
        /**
         * The number of seconds between retries when an attempt to read a manifest or segment fails.
         */
        retryInterval?: number;
        scte35Source?: string;
    }

    export interface ChannelInputAttachmentInputSettingsVideoSelector {
        colorSpace?: string;
        colorSpaceUsage?: string;
    }

    export interface ChannelInputSpecification {
        codec: string;
        inputResolution: string;
        maximumBitrate: string;
    }

    export interface ChannelMaintenance {
        /**
         * The day of the week to use for maintenance.
         */
        maintenanceDay: string;
        /**
         * The hour maintenance will start.
         */
        maintenanceStartTime: string;
    }

    export interface ChannelVpc {
        availabilityZones: string[];
        publicAddressAllocationIds: string[];
        securityGroupIds: string[];
        subnetIds: string[];
    }

    export interface InputDestination {
        /**
         * A unique name for the location the RTMP stream is being pushed to.
         */
        streamName: string;
    }

    export interface InputInputDevice {
        /**
         * The unique ID for the device.
         */
        id: string;
    }

    export interface InputMediaConnectFlow {
        /**
         * The ARN of the MediaConnect Flow
         */
        flowArn: string;
    }

    export interface InputSecurityGroupWhitelistRule {
        /**
         * The IPv4 CIDR that's whitelisted.
         */
        cidr: string;
    }

    export interface InputSource {
        /**
         * The key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * The URL where the stream is pulled from.
         */
        url: string;
        /**
         * The username for the input source.
         */
        username: string;
    }

    export interface InputVpc {
        /**
         * A list of up to 5 EC2 VPC security group IDs to attach to the Input.
         */
        securityGroupIds?: string[];
        /**
         * A list of 2 VPC subnet IDs from the same VPC.
         */
        subnetIds: string[];
    }

    export interface MultiplexMultiplexSettings {
        /**
         * Maximum video buffer delay.
         */
        maximumVideoBufferDelayMilliseconds: number;
        /**
         * Transport stream bit rate.
         */
        transportStreamBitrate: number;
        /**
         * Unique ID for each multiplex.
         */
        transportStreamId: number;
        /**
         * Transport stream reserved bit rate.
         */
        transportStreamReservedBitrate: number;
    }

    export interface MultiplexProgramMultiplexProgramSettings {
        /**
         * Enum for preferred channel pipeline. Options are `CURRENTLY_ACTIVE`, `PIPELINE_0`, or `PIPELINE_1`.
         */
        preferredChannelPipeline: string;
        /**
         * Unique program number.
         */
        programNumber: number;
        /**
         * Service Descriptor. See Service Descriptor for more details.
         */
        serviceDescriptor?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsServiceDescriptor;
        /**
         * Video settings. See Video Settings for more details.
         */
        videoSettings?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsVideoSettings;
    }

    export interface MultiplexProgramMultiplexProgramSettingsServiceDescriptor {
        /**
         * Unique provider name.
         */
        providerName: string;
        /**
         * Unique service name.
         */
        serviceName: string;
    }

    export interface MultiplexProgramMultiplexProgramSettingsVideoSettings {
        /**
         * Constant bitrate value.
         */
        constantBitrate: number;
        /**
         * Statmux settings. See Statmux Settings for more details.
         */
        statmuxSettings?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings;
    }

    export interface MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
        /**
         * Maximum bitrate.
         */
        maximumBitrate: number;
        /**
         * Minimum bitrate.
         */
        minimumBitrate: number;
        /**
         * Priority value.
         */
        priority: number;
    }

}

export namespace mediapackage {
    export interface ChannelHlsIngest {
        /**
         * A list of the ingest endpoints
         */
        ingestEndpoints: outputs.mediapackage.ChannelHlsIngestIngestEndpoint[];
    }

    export interface ChannelHlsIngestIngestEndpoint {
        /**
         * The password
         */
        password: string;
        /**
         * The URL
         */
        url: string;
        /**
         * The username
         */
        username: string;
    }

}

export namespace memorydb {
    export interface ClusterClusterEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * The port number on which each of the nodes accepts connections. Defaults to `6379`.
         */
        port: number;
    }

    export interface ClusterShard {
        /**
         * Name of the cluster. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        /**
         * Set of nodes in this shard.
         */
        nodes: outputs.memorydb.ClusterShardNode[];
        /**
         * Number of individual nodes in this shard.
         */
        numNodes: number;
        /**
         * Keyspace for this shard. Example: `0-16383`.
         */
        slots: string;
    }

    export interface ClusterShardNode {
        /**
         * The Availability Zone in which the node resides.
         */
        availabilityZone: string;
        /**
         * The date and time when the node was created. Example: `2022-01-01T21:00:00Z`.
         */
        createTime: string;
        endpoints: outputs.memorydb.ClusterShardNodeEndpoint[];
        /**
         * Name of the cluster. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
    }

    export interface ClusterShardNodeEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * The port number on which each of the nodes accepts connections. Defaults to `6379`.
         */
        port: number;
    }

    export interface GetClusterClusterEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * Port number that this node is listening on.
         */
        port: number;
    }

    export interface GetClusterShard {
        /**
         * Name of the cluster.
         */
        name: string;
        /**
         * Set of nodes in this shard.
         */
        nodes: outputs.memorydb.GetClusterShardNode[];
        /**
         * Number of individual nodes in this shard.
         */
        numNodes: number;
        /**
         * Keyspace for this shard. Example: `0-16383`.
         */
        slots: string;
    }

    export interface GetClusterShardNode {
        /**
         * The Availability Zone in which the node resides.
         */
        availabilityZone: string;
        /**
         * The date and time when the node was created. Example: `2022-01-01T21:00:00Z`.
         */
        createTime: string;
        endpoints: outputs.memorydb.GetClusterShardNodeEndpoint[];
        /**
         * Name of the cluster.
         */
        name: string;
    }

    export interface GetClusterShardNodeEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * Port number that this node is listening on.
         */
        port: number;
    }

    export interface GetParameterGroupParameter {
        /**
         * Name of the parameter group.
         */
        name: string;
        /**
         * Value of the parameter.
         */
        value: string;
    }

    export interface GetSnapshotClusterConfiguration {
        /**
         * Description for the cluster.
         */
        description: string;
        /**
         * Version number of the Redis engine used by the cluster.
         */
        engineVersion: string;
        /**
         * The weekly time range during which maintenance on the cluster is performed.
         */
        maintenanceWindow: string;
        /**
         * Name of the snapshot.
         */
        name: string;
        /**
         * Compute and memory capacity of the nodes in the cluster.
         */
        nodeType: string;
        /**
         * Number of shards in the cluster.
         */
        numShards: number;
        /**
         * Name of the parameter group associated with the cluster.
         */
        parameterGroupName: string;
        /**
         * Port number on which the cluster accepts connections.
         */
        port: number;
        /**
         * Number of days for which MemoryDB retains automatic snapshots before deleting them.
         */
        snapshotRetentionLimit: number;
        /**
         * The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of the shard.
         */
        snapshotWindow: string;
        /**
         * Name of the subnet group used by the cluster.
         */
        subnetGroupName: string;
        /**
         * ARN of the SNS topic to which cluster notifications are sent.
         */
        topicArn: string;
        /**
         * The VPC in which the cluster exists.
         */
        vpcId: string;
    }

    export interface GetUserAuthenticationMode {
        /**
         * The number of passwords belonging to the user.
         */
        passwordCount: number;
        /**
         * Whether the user requires a password to authenticate.
         */
        type: string;
    }

    export interface ParameterGroupParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }

    export interface SnapshotClusterConfiguration {
        /**
         * Description for the cluster.
         */
        description: string;
        /**
         * Version number of the Redis engine used by the cluster.
         */
        engineVersion: string;
        /**
         * The weekly time range during which maintenance on the cluster is performed.
         */
        maintenanceWindow: string;
        /**
         * Name of the snapshot. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        /**
         * Compute and memory capacity of the nodes in the cluster.
         */
        nodeType: string;
        /**
         * Number of shards in the cluster.
         */
        numShards: number;
        /**
         * Name of the parameter group associated with the cluster.
         */
        parameterGroupName: string;
        /**
         * Port number on which the cluster accepts connections.
         */
        port: number;
        /**
         * Number of days for which MemoryDB retains automatic snapshots before deleting them.
         */
        snapshotRetentionLimit: number;
        /**
         * The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of the shard.
         */
        snapshotWindow: string;
        /**
         * Name of the subnet group used by the cluster.
         */
        subnetGroupName: string;
        /**
         * ARN of the SNS topic to which cluster notifications are sent.
         */
        topicArn: string;
        /**
         * The VPC in which the cluster exists.
         */
        vpcId: string;
    }

    export interface UserAuthenticationMode {
        /**
         * The number of passwords belonging to the user.
         */
        passwordCount: number;
        /**
         * The set of passwords used for authentication. You can create up to two passwords for each user.
         */
        passwords: string[];
        /**
         * Indicates whether the user requires a password to authenticate. Must be set to `password`.
         */
        type: string;
    }

}

export namespace mq {
    export interface BrokerConfiguration {
        /**
         * The Configuration ID.
         */
        id: string;
        /**
         * Revision of the Configuration.
         */
        revision: number;
    }

    export interface BrokerEncryptionOptions {
        /**
         * Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting `useAwsOwnedKey` to `false`. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
         */
        kmsKeyId: string;
        /**
         * Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to `true`. Setting to `false` without configuring `kmsKeyId` will create an AWS-managed CMK aliased to `aws/mq` in your account.
         */
        useAwsOwnedKey?: boolean;
    }

    export interface BrokerInstance {
        consoleUrl: string;
        endpoints: string[];
        ipAddress: string;
    }

    export interface BrokerLdapServerMetadata {
        /**
         * List of a fully qualified domain name of the LDAP server and an optional failover server.
         */
        hosts?: string[];
        /**
         * Fully qualified name of the directory to search for a user’s groups.
         */
        roleBase?: string;
        /**
         * Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
         */
        roleName?: string;
        /**
         * Search criteria for groups.
         */
        roleSearchMatching?: string;
        /**
         * Whether the directory search scope is the entire sub-tree.
         */
        roleSearchSubtree?: boolean;
        /**
         * Service account password.
         */
        serviceAccountPassword?: string;
        /**
         * Service account username.
         */
        serviceAccountUsername?: string;
        /**
         * Fully qualified name of the directory where you want to search for users.
         */
        userBase?: string;
        /**
         * Specifies the name of the LDAP attribute for the user group membership.
         */
        userRoleName?: string;
        /**
         * Search criteria for users.
         */
        userSearchMatching?: string;
        /**
         * Whether the directory search scope is the entire sub-tree.
         */
        userSearchSubtree?: boolean;
    }

    export interface BrokerLogs {
        /**
         * Enables audit logging. Auditing is only possible for `engineType` of `ActiveMQ`. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to `false`.
         */
        audit?: boolean;
        /**
         * Enables general logging via CloudWatch. Defaults to `false`.
         */
        general?: boolean;
    }

    export interface BrokerMaintenanceWindowStartTime {
        /**
         * Day of the week, e.g., `MONDAY`, `TUESDAY`, or `WEDNESDAY`.
         */
        dayOfWeek: string;
        /**
         * Time, in 24-hour format, e.g., `02:00`.
         */
        timeOfDay: string;
        /**
         * Time zone in either the Country/City format or the UTC offset format, e.g., `CET`.
         */
        timeZone: string;
    }

    export interface BrokerUser {
        /**
         * Whether to enable access to the [ActiveMQ Web Console](http://activemq.apache.org/web-console.html) for the user. Applies to `engineType` of `ActiveMQ` only.
         */
        consoleAccess?: boolean;
        /**
         * List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to `engineType` of `ActiveMQ` only.
         */
        groups?: string[];
        /**
         * Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
         */
        password: string;
        /**
         * Whether to set set replication user. Defaults to `false`.
         */
        replicationUser?: boolean;
        /**
         * Username of the user.
         *
         * > **NOTE:** AWS currently does not support updating RabbitMQ users. Updates to users can only be in the RabbitMQ UI.
         */
        username: string;
    }

    export interface GetBrokerConfiguration {
        id: string;
        revision: number;
    }

    export interface GetBrokerEncryptionOption {
        kmsKeyId: string;
        useAwsOwnedKey: boolean;
    }

    export interface GetBrokerInstance {
        consoleUrl: string;
        endpoints: string[];
        ipAddress: string;
    }

    export interface GetBrokerLdapServerMetadata {
        hosts: string[];
        roleBase: string;
        roleName: string;
        roleSearchMatching: string;
        roleSearchSubtree: boolean;
        serviceAccountPassword: string;
        serviceAccountUsername: string;
        userBase: string;
        userRoleName: string;
        userSearchMatching: string;
        userSearchSubtree: boolean;
    }

    export interface GetBrokerLogs {
        audit: boolean;
        general: boolean;
    }

    export interface GetBrokerMaintenanceWindowStartTime {
        dayOfWeek: string;
        timeOfDay: string;
        timeZone: string;
    }

    export interface GetBrokerUser {
        consoleAccess: boolean;
        groups: string[];
        username: string;
    }

    export interface GetInstanceTypeOfferingsBrokerInstanceOption {
        /**
         * List of available AZs. See Availability Zones. below
         */
        availabilityZones: outputs.mq.GetInstanceTypeOfferingsBrokerInstanceOptionAvailabilityZone[];
        /**
         * Filter response by engine type.
         */
        engineType: string;
        /**
         * Filter response by host instance type.
         */
        hostInstanceType: string;
        /**
         * Filter response by storage type.
         */
        storageType: string;
        /**
         * The list of supported deployment modes.
         */
        supportedDeploymentModes: string[];
        /**
         * The list of supported engine versions.
         */
        supportedEngineVersions: string[];
    }

    export interface GetInstanceTypeOfferingsBrokerInstanceOptionAvailabilityZone {
        /**
         * Name of the Availability Zone.
         */
        name: string;
    }

}

export namespace msk {
    export interface ClusterBrokerNodeGroupInfo {
        /**
         * The distribution of broker nodes across availability zones ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-model-brokerazdistribution)). Currently the only valid value is `DEFAULT`.
         */
        azDistribution?: string;
        /**
         * A list of subnets to connect to in client VPC ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-prop-brokernodegroupinfo-clientsubnets)).
         */
        clientSubnets: string[];
        /**
         * Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible ([documentation](https://docs.aws.amazon.com/msk/latest/developerguide/public-access.html)).
         */
        connectivityInfo: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfo;
        /**
         * Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. ([Pricing info](https://aws.amazon.com/msk/pricing/))
         */
        instanceType: string;
        /**
         * A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
         */
        securityGroups: string[];
        /**
         * A block that contains information about storage volumes attached to MSK broker nodes. See below.
         */
        storageInfo: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfo;
    }

    export interface ClusterBrokerNodeGroupInfoConnectivityInfo {
        /**
         * Access control settings for brokers. See below.
         */
        publicAccess: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccess;
    }

    export interface ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccess {
        /**
         * Public access type. Valida values: `DISABLED`, `SERVICE_PROVIDED_EIPS`.
         */
        type: string;
    }

    export interface ClusterBrokerNodeGroupInfoStorageInfo {
        /**
         * A block that contains EBS volume information. See below.
         */
        ebsStorageInfo?: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfo;
    }

    export interface ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
        /**
         * A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
         */
        provisionedThroughput?: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput;
        /**
         * The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of `1` and maximum value of `16384`.
         */
        volumeSize?: number;
    }

    export interface ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
        /**
         * Controls whether provisioned throughput is enabled or not. Default value: `false`.
         */
        enabled?: boolean;
        /**
         * Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is `250`. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following [documentation on throughput bottlenecks](https://docs.aws.amazon.com/msk/latest/developerguide/msk-provision-throughput.html#throughput-bottlenecks)
         */
        volumeThroughput?: number;
    }

    export interface ClusterClientAuthentication {
        /**
         * Configuration block for specifying SASL client authentication. See below.
         */
        sasl?: outputs.msk.ClusterClientAuthenticationSasl;
        /**
         * Configuration block for specifying TLS client authentication. See below.
         */
        tls?: outputs.msk.ClusterClientAuthenticationTls;
        /**
         * Enables unauthenticated access.
         */
        unauthenticated?: boolean;
    }

    export interface ClusterClientAuthenticationSasl {
        /**
         * Enables IAM client authentication. Defaults to `false`.
         */
        iam?: boolean;
        /**
         * Enables SCRAM client authentication via AWS Secrets Manager. Defaults to `false`.
         */
        scram?: boolean;
    }

    export interface ClusterClientAuthenticationTls {
        /**
         * List of ACM Certificate Authority Amazon Resource Names (ARNs).
         */
        certificateAuthorityArns?: string[];
    }

    export interface ClusterConfigurationInfo {
        /**
         * Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
         */
        arn: string;
        /**
         * Revision of the MSK Configuration to use in the cluster.
         */
        revision: number;
    }

    export interface ClusterEncryptionInfo {
        /**
         * You may specify a KMS key short ID or ARN (it will always output an ARN) to use for encrypting your data at rest.  If no key is specified, an AWS managed KMS ('aws/msk' managed service) key will be used for encrypting the data at rest.
         */
        encryptionAtRestKmsKeyArn: string;
        /**
         * Configuration block to specify encryption in transit. See below.
         */
        encryptionInTransit?: outputs.msk.ClusterEncryptionInfoEncryptionInTransit;
    }

    export interface ClusterEncryptionInfoEncryptionInTransit {
        /**
         * Encryption setting for data in transit between clients and brokers. Valid values: `TLS`, `TLS_PLAINTEXT`, and `PLAINTEXT`. Default value is `TLS`.
         */
        clientBroker?: string;
        /**
         * Whether data communication among broker nodes is encrypted. Default value: `true`.
         */
        inCluster?: boolean;
    }

    export interface ClusterLoggingInfo {
        /**
         * Configuration block for Broker Logs settings for logging info. See below.
         */
        brokerLogs: outputs.msk.ClusterLoggingInfoBrokerLogs;
    }

    export interface ClusterLoggingInfoBrokerLogs {
        cloudwatchLogs?: outputs.msk.ClusterLoggingInfoBrokerLogsCloudwatchLogs;
        firehose?: outputs.msk.ClusterLoggingInfoBrokerLogsFirehose;
        s3?: outputs.msk.ClusterLoggingInfoBrokerLogsS3;
    }

    export interface ClusterLoggingInfoBrokerLogsCloudwatchLogs {
        /**
         * Controls whether provisioned throughput is enabled or not. Default value: `false`.
         */
        enabled: boolean;
        /**
         * Name of the Cloudwatch Log Group to deliver logs to.
         */
        logGroup?: string;
    }

    export interface ClusterLoggingInfoBrokerLogsFirehose {
        /**
         * Name of the Kinesis Data Firehose delivery stream to deliver logs to.
         */
        deliveryStream?: string;
        /**
         * Controls whether provisioned throughput is enabled or not. Default value: `false`.
         */
        enabled: boolean;
    }

    export interface ClusterLoggingInfoBrokerLogsS3 {
        /**
         * Name of the S3 bucket to deliver logs to.
         */
        bucket?: string;
        /**
         * Controls whether provisioned throughput is enabled or not. Default value: `false`.
         */
        enabled: boolean;
        /**
         * Prefix to append to the folder name.
         */
        prefix?: string;
    }

    export interface ClusterOpenMonitoring {
        /**
         * Configuration block for Prometheus settings for open monitoring. See below.
         */
        prometheus: outputs.msk.ClusterOpenMonitoringPrometheus;
    }

    export interface ClusterOpenMonitoringPrometheus {
        /**
         * Configuration block for JMX Exporter. See below.
         */
        jmxExporter?: outputs.msk.ClusterOpenMonitoringPrometheusJmxExporter;
        /**
         * Configuration block for Node Exporter. See below.
         */
        nodeExporter?: outputs.msk.ClusterOpenMonitoringPrometheusNodeExporter;
    }

    export interface ClusterOpenMonitoringPrometheusJmxExporter {
        /**
         * Indicates whether you want to enable or disable the JMX Exporter.
         */
        enabledInBroker: boolean;
    }

    export interface ClusterOpenMonitoringPrometheusNodeExporter {
        /**
         * Indicates whether you want to enable or disable the JMX Exporter.
         */
        enabledInBroker: boolean;
    }

    export interface GetBrokerNodesNodeInfoList {
        /**
         * Attached elastic network interface of the broker
         */
        attachedEniId: string;
        /**
         * ID of the broker
         */
        brokerId: number;
        /**
         * Client subnet to which this broker node belongs
         */
        clientSubnet: string;
        /**
         * The client virtual private cloud (VPC) IP address
         */
        clientVpcIpAddress: string;
        /**
         * Set of endpoints for accessing the broker. This does not include ports
         */
        endpoints: string[];
        /**
         * ARN of the node
         */
        nodeArn: string;
    }

    export interface ServerlessClusterClientAuthentication {
        /**
         * Details for client authentication using SASL. See below.
         */
        sasl: outputs.msk.ServerlessClusterClientAuthenticationSasl;
    }

    export interface ServerlessClusterClientAuthenticationSasl {
        /**
         * Details for client authentication using IAM. See below.
         */
        iam: outputs.msk.ServerlessClusterClientAuthenticationSaslIam;
    }

    export interface ServerlessClusterClientAuthenticationSaslIam {
        /**
         * Whether SASL/IAM authentication is enabled or not.
         */
        enabled: boolean;
    }

    export interface ServerlessClusterVpcConfig {
        /**
         * Specifies up to five security groups that control inbound and outbound traffic for the serverless cluster.
         */
        securityGroupIds: string[];
        /**
         * A list of subnets in at least two different Availability Zones that host your client applications.
         */
        subnetIds: string[];
    }

}

export namespace mskconnect {
    export interface ConnectorCapacity {
        /**
         * Information about the auto scaling parameters for the connector. See below.
         */
        autoscaling?: outputs.mskconnect.ConnectorCapacityAutoscaling;
        /**
         * Details about a fixed capacity allocated to a connector. See below.
         */
        provisionedCapacity?: outputs.mskconnect.ConnectorCapacityProvisionedCapacity;
    }

    export interface ConnectorCapacityAutoscaling {
        /**
         * The maximum number of workers allocated to the connector.
         */
        maxWorkerCount: number;
        /**
         * The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: `1`, `2`, `4`, `8`. The default value is `1`.
         */
        mcuCount?: number;
        /**
         * The minimum number of workers allocated to the connector.
         */
        minWorkerCount: number;
        /**
         * The scale-in policy for the connector. See below.
         */
        scaleInPolicy: outputs.mskconnect.ConnectorCapacityAutoscalingScaleInPolicy;
        /**
         * The scale-out policy for the connector. See below.
         */
        scaleOutPolicy: outputs.mskconnect.ConnectorCapacityAutoscalingScaleOutPolicy;
    }

    export interface ConnectorCapacityAutoscalingScaleInPolicy {
        /**
         * Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
         */
        cpuUtilizationPercentage: number;
    }

    export interface ConnectorCapacityAutoscalingScaleOutPolicy {
        /**
         * The CPU utilization percentage threshold at which you want connector scale out to be triggered.
         */
        cpuUtilizationPercentage: number;
    }

    export interface ConnectorCapacityProvisionedCapacity {
        /**
         * The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: `1`, `2`, `4`, `8`. The default value is `1`.
         */
        mcuCount?: number;
        /**
         * The number of workers that are allocated to the connector.
         */
        workerCount: number;
    }

    export interface ConnectorKafkaCluster {
        /**
         * The Apache Kafka cluster to which the connector is connected.
         */
        apacheKafkaCluster: outputs.mskconnect.ConnectorKafkaClusterApacheKafkaCluster;
    }

    export interface ConnectorKafkaClusterApacheKafkaCluster {
        /**
         * The bootstrap servers of the cluster.
         */
        bootstrapServers: string;
        /**
         * Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
         */
        vpc: outputs.mskconnect.ConnectorKafkaClusterApacheKafkaClusterVpc;
    }

    export interface ConnectorKafkaClusterApacheKafkaClusterVpc {
        /**
         * The security groups for the connector.
         */
        securityGroups: string[];
        /**
         * The subnets for the connector.
         */
        subnets: string[];
    }

    export interface ConnectorKafkaClusterClientAuthentication {
        /**
         * The type of client authentication used to connect to the Apache Kafka cluster. Valid values: `IAM`, `NONE`. A value of `NONE` means that no client authentication is used. The default value is `NONE`.
         */
        authenticationType?: string;
    }

    export interface ConnectorKafkaClusterEncryptionInTransit {
        /**
         * The type of encryption in transit to the Apache Kafka cluster. Valid values: `PLAINTEXT`, `TLS`. The default values is `PLAINTEXT`.
         */
        encryptionType?: string;
    }

    export interface ConnectorLogDelivery {
        /**
         * The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See below.
         */
        workerLogDelivery: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDelivery;
    }

    export interface ConnectorLogDeliveryWorkerLogDelivery {
        /**
         * Details about delivering logs to Amazon CloudWatch Logs. See below.
         */
        cloudwatchLogs?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogs;
        /**
         * Details about delivering logs to Amazon Kinesis Data Firehose. See below.
         */
        firehose?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryFirehose;
        /**
         * Details about delivering logs to Amazon S3. See below.
         */
        s3?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryS3;
    }

    export interface ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogs {
        /**
         * Whether log delivery to Amazon CloudWatch Logs is enabled.
         */
        enabled: boolean;
        /**
         * The name of the CloudWatch log group that is the destination for log delivery.
         */
        logGroup?: string;
    }

    export interface ConnectorLogDeliveryWorkerLogDeliveryFirehose {
        /**
         * The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
         */
        deliveryStream?: string;
        /**
         * Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
         */
        enabled: boolean;
    }

    export interface ConnectorLogDeliveryWorkerLogDeliveryS3 {
        /**
         * The name of the S3 bucket that is the destination for log delivery.
         */
        bucket?: string;
        /**
         * Whether log delivery to Amazon CloudWatch Logs is enabled.
         */
        enabled: boolean;
        /**
         * The S3 prefix that is the destination for log delivery.
         */
        prefix?: string;
    }

    export interface ConnectorPlugin {
        /**
         * Details about a custom plugin. See below.
         */
        customPlugin: outputs.mskconnect.ConnectorPluginCustomPlugin;
    }

    export interface ConnectorPluginCustomPlugin {
        /**
         * The Amazon Resource Name (ARN) of the custom plugin.
         */
        arn: string;
        /**
         * The revision of the custom plugin.
         */
        revision: number;
    }

    export interface ConnectorWorkerConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the worker configuration.
         */
        arn: string;
        /**
         * The revision of the worker configuration.
         */
        revision: number;
    }

    export interface CustomPluginLocation {
        /**
         * Information of the plugin file stored in Amazon S3. See below.
         */
        s3: outputs.mskconnect.CustomPluginLocationS3;
    }

    export interface CustomPluginLocationS3 {
        /**
         * The Amazon Resource Name (ARN) of an S3 bucket.
         */
        bucketArn: string;
        /**
         * The file key for an object in an S3 bucket.
         */
        fileKey: string;
        /**
         * The version of an object in an S3 bucket.
         */
        objectVersion?: string;
    }

}

export namespace mwaa {
    export interface EnvironmentLastUpdated {
        /**
         * The Created At date of the MWAA Environment
         * * `logging_configuration[0].<LOG_CONFIGURATION_TYPE>[0].cloud_watch_log_group_arn` - Provides the ARN for the CloudWatch group where the logs will be published
         */
        createdAt: string;
        errors: outputs.mwaa.EnvironmentLastUpdatedError[];
        /**
         * The status of the Amazon MWAA Environment
         */
        status: string;
    }

    export interface EnvironmentLastUpdatedError {
        errorCode: string;
        errorMessage: string;
    }

    export interface EnvironmentLoggingConfiguration {
        /**
         * (Optional) Log configuration options for processing DAGs. See Module logging configuration for more information. Disabled by default.
         */
        dagProcessingLogs: outputs.mwaa.EnvironmentLoggingConfigurationDagProcessingLogs;
        /**
         * Log configuration options for the schedulers. See Module logging configuration for more information. Disabled by default.
         */
        schedulerLogs: outputs.mwaa.EnvironmentLoggingConfigurationSchedulerLogs;
        /**
         * Log configuration options for DAG tasks. See Module logging configuration for more information. Enabled by default with `INFO` log level.
         */
        taskLogs: outputs.mwaa.EnvironmentLoggingConfigurationTaskLogs;
        /**
         * Log configuration options for the webservers. See Module logging configuration for more information. Disabled by default.
         */
        webserverLogs: outputs.mwaa.EnvironmentLoggingConfigurationWebserverLogs;
        /**
         * Log configuration options for the workers. See Module logging configuration for more information. Disabled by default.
         */
        workerLogs: outputs.mwaa.EnvironmentLoggingConfigurationWorkerLogs;
    }

    export interface EnvironmentLoggingConfigurationDagProcessingLogs {
        cloudWatchLogGroupArn: string;
        /**
         * Enabling or disabling the collection of logs
         */
        enabled: boolean;
        /**
         * Logging level. Valid values: `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`. Will be `INFO` by default.
         */
        logLevel: string;
    }

    export interface EnvironmentLoggingConfigurationSchedulerLogs {
        cloudWatchLogGroupArn: string;
        /**
         * Enabling or disabling the collection of logs
         */
        enabled: boolean;
        /**
         * Logging level. Valid values: `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`. Will be `INFO` by default.
         */
        logLevel: string;
    }

    export interface EnvironmentLoggingConfigurationTaskLogs {
        cloudWatchLogGroupArn: string;
        /**
         * Enabling or disabling the collection of logs
         */
        enabled: boolean;
        /**
         * Logging level. Valid values: `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`. Will be `INFO` by default.
         */
        logLevel: string;
    }

    export interface EnvironmentLoggingConfigurationWebserverLogs {
        cloudWatchLogGroupArn: string;
        /**
         * Enabling or disabling the collection of logs
         */
        enabled: boolean;
        /**
         * Logging level. Valid values: `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`. Will be `INFO` by default.
         */
        logLevel: string;
    }

    export interface EnvironmentLoggingConfigurationWorkerLogs {
        cloudWatchLogGroupArn: string;
        /**
         * Enabling or disabling the collection of logs
         */
        enabled: boolean;
        /**
         * Logging level. Valid values: `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`. Will be `INFO` by default.
         */
        logLevel: string;
    }

    export interface EnvironmentNetworkConfiguration {
        /**
         * Security groups IDs for the environment. At least one of the security group needs to allow MWAA resources to talk to each other, otherwise MWAA cannot be provisioned.
         */
        securityGroupIds: string[];
        /**
         * The private subnet IDs in which the environment should be created. MWAA requires two subnets.
         */
        subnetIds: string[];
    }

}

export namespace neptune {
    export interface ClusterParameterGroupParameter {
        /**
         * Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the neptune parameter.
         */
        name: string;
        /**
         * The value of the neptune parameter.
         */
        value: string;
    }

    export interface ClusterServerlessV2ScalingConfiguration {
        /**
         * The maximum Neptune Capacity Units (NCUs) for this cluster. Must be lower or equal than **128**. See [AWS Documentation](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-serverless-capacity-scaling.html) for more details.
         */
        maxCapacity?: number;
        /**
         * The minimum Neptune Capacity Units (NCUs) for this cluster. Must be greater or equal than **1**. See [AWS Documentation](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-serverless-capacity-scaling.html) for more details.
         */
        minCapacity?: number;
    }

    export interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster.
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster.
         */
        isWriter: boolean;
    }

    export interface ParameterGroupParameter {
        /**
         * The apply method of the Neptune parameter. Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the Neptune parameter.
         */
        name: string;
        /**
         * The value of the Neptune parameter.
         */
        value: string;
    }

}

export namespace networkfirewall {
    export interface FirewallEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }

    export interface FirewallFirewallStatus {
        /**
         * Set of subnets configured for use by the firewall.
         */
        syncStates: outputs.networkfirewall.FirewallFirewallStatusSyncState[];
    }

    export interface FirewallFirewallStatusSyncState {
        /**
         * Nested list describing the attachment status of the firewall's association with a single VPC subnet.
         */
        attachments: outputs.networkfirewall.FirewallFirewallStatusSyncStateAttachment[];
        /**
         * The Availability Zone where the subnet is configured.
         */
        availabilityZone: string;
    }

    export interface FirewallFirewallStatusSyncStateAttachment {
        /**
         * The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
         */
        endpointId: string;
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }

    export interface FirewallPolicyEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }

    export interface FirewallPolicyFirewallPolicy {
        /**
         * Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `statefulEngineOptions` block with a `ruleOrder` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
         */
        statefulDefaultActions?: string[];
        /**
         * A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
         */
        statefulEngineOptions?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulEngineOptions;
        /**
         * Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
         */
        statefulRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulRuleGroupReference[];
        /**
         * Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `statelessDefaultActions`. See Stateless Custom Action below for details.
         */
        statelessCustomActions?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomAction[];
        /**
         * Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
         * In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
         */
        statelessDefaultActions: string[];
        /**
         * Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
         * In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
         */
        statelessFragmentDefaultActions: string[];
        /**
         * Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
         */
        statelessRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessRuleGroupReference[];
    }

    export interface FirewallPolicyFirewallPolicyStatefulEngineOptions {
        /**
         * Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
         */
        ruleOrder?: string;
        /**
         * Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
         */
        streamExceptionPolicy?: string;
    }

    export interface FirewallPolicyFirewallPolicyStatefulRuleGroupReference {
        /**
         * Configuration block for override values
         */
        override?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride;
        /**
         * An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `statefulEngineOptions` block with a `ruleOrder` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
         */
        priority?: number;
        /**
         * The Amazon Resource Name (ARN) of the stateful rule group.
         */
        resourceArn: string;
    }

    export interface FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride {
        /**
         * The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
         */
        action?: string;
    }

    export interface FirewallPolicyFirewallPolicyStatelessCustomAction {
        /**
         * A configuration block describing the custom action associated with the `actionName`. See Action Definition below for details.
         */
        actionDefinition: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition;
        /**
         * A friendly name of the custom action.
         */
        actionName: string;
    }

    export interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition {
        /**
         * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
         */
        publishMetricAction: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction;
    }

    export interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
        /**
         * Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
         */
        dimensions: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];
    }

    export interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
        /**
         * The string value to use in the custom metric dimension.
         */
        value: string;
    }

    export interface FirewallPolicyFirewallPolicyStatelessRuleGroupReference {
        /**
         * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
         */
        priority: number;
        /**
         * The Amazon Resource Name (ARN) of the stateless rule group.
         */
        resourceArn: string;
    }

    export interface FirewallSubnetMapping {
        /**
         * The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
         */
        ipAddressType: string;
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }

    export interface GetFirewallEncryptionConfiguration {
        /**
         * The ID of the AWS Key Management Service (AWS KMS) customer managed key.
         */
        keyId: string;
        /**
         * The type of the AWS Key Management Service (AWS KMS) key use by the firewall.
         */
        type: string;
    }

    export interface GetFirewallFirewallStatus {
        /**
         * Aggregated count of all resources used by reference sets in a firewall.
         */
        capacityUsageSummaries: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummary[];
        /**
         * Summary of sync states for all availability zones in which the firewall is configured.
         */
        configurationSyncStateSummary: string;
        status: string;
        /**
         * Set of subnets configured for use by the firewall.
         */
        syncStates: outputs.networkfirewall.GetFirewallFirewallStatusSyncState[];
    }

    export interface GetFirewallFirewallStatusCapacityUsageSummary {
        /**
         * Capacity usage of CIDR blocks used by IP set references in a firewall.
         */
        cidrs: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummaryCidr[];
    }

    export interface GetFirewallFirewallStatusCapacityUsageSummaryCidr {
        /**
         * Available number of CIDR blocks available for use by the IP set references in a firewall.
         */
        availableCidrCount: number;
        /**
         * The list of IP set references used by a firewall.
         */
        ipSetReferences: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReference[];
        /**
         * Number of CIDR blocks used by the IP set references in a firewall.
         */
        utilizedCidrCount: number;
    }

    export interface GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReference {
        /**
         * Total number of CIDR blocks used by the IP set references in a firewall.
         */
        resolvedCidrCount: number;
    }

    export interface GetFirewallFirewallStatusSyncState {
        /**
         * Nested list describing the attachment status of the firewall's association with a single VPC subnet.
         */
        attachments: outputs.networkfirewall.GetFirewallFirewallStatusSyncStateAttachment[];
        /**
         * The Availability Zone where the subnet is configured.
         */
        availabilityZone: string;
    }

    export interface GetFirewallFirewallStatusSyncStateAttachment {
        /**
         * The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
         */
        endpointId: string;
        status: string;
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }

    export interface GetFirewallPolicyFirewallPolicy {
        statefulDefaultActions: string[];
        statefulEngineOptions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulEngineOption[];
        statefulRuleGroupReferences: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReference[];
        statelessCustomActions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomAction[];
        statelessDefaultActions: string[];
        statelessFragmentDefaultActions: string[];
        statelessRuleGroupReferences: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessRuleGroupReference[];
    }

    export interface GetFirewallPolicyFirewallPolicyStatefulEngineOption {
        ruleOrder: string;
        streamExceptionPolicy: string;
    }

    export interface GetFirewallPolicyFirewallPolicyStatefulRuleGroupReference {
        overrides?: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride[];
        priority: number;
        resourceArn: string;
    }

    export interface GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride {
        action?: string;
    }

    export interface GetFirewallPolicyFirewallPolicyStatelessCustomAction {
        actionDefinitions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition[];
        actionName: string;
    }

    export interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition {
        publishMetricActions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction[];
    }

    export interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
        dimensions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];
    }

    export interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
        value: string;
    }

    export interface GetFirewallPolicyFirewallPolicyStatelessRuleGroupReference {
        priority: number;
        resourceArn: string;
    }

    export interface GetFirewallSubnetMapping {
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }

    export interface LoggingConfigurationLoggingConfiguration {
        /**
         * Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
         */
        logDestinationConfigs: outputs.networkfirewall.LoggingConfigurationLoggingConfigurationLogDestinationConfig[];
    }

    export interface LoggingConfigurationLoggingConfigurationLogDestinationConfig {
        /**
         * A map describing the logging destination for the chosen `logDestinationType`.
         * * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
         * * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
         * * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
         */
        logDestination: {[key: string]: string};
        /**
         * The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
         */
        logDestinationType: string;
        /**
         * The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
         */
        logType: string;
    }

    export interface RuleGroupEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }

    export interface RuleGroupRuleGroup {
        /**
         * A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `referenceSets` in a `ruleGroup`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
         */
        referenceSets?: outputs.networkfirewall.RuleGroupRuleGroupReferenceSets;
        /**
         * A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
         */
        ruleVariables?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariables;
        /**
         * A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
         */
        rulesSource: outputs.networkfirewall.RuleGroupRuleGroupRulesSource;
        /**
         * A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
         */
        statefulRuleOptions?: outputs.networkfirewall.RuleGroupRuleGroupStatefulRuleOptions;
    }

    export interface RuleGroupRuleGroupReferenceSets {
        ipSetReferences?: outputs.networkfirewall.RuleGroupRuleGroupReferenceSetsIpSetReference[];
    }

    export interface RuleGroupRuleGroupReferenceSetsIpSetReference {
        /**
         * Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
         */
        ipSetReferences: outputs.networkfirewall.RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference[];
        /**
         * A unique alphanumeric string to identify the `ipSet`.
         */
        key: string;
    }

    export interface RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference {
        /**
         * Set of Managed Prefix IP ARN(s)
         */
        referenceArn: string;
    }

    export interface RuleGroupRuleGroupRuleVariables {
        /**
         * Set of configuration blocks that define IP address information. See IP Sets below for details.
         */
        ipSets?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSet[];
        /**
         * Set of configuration blocks that define port range information. See Port Sets below for details.
         */
        portSets?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSet[];
    }

    export interface RuleGroupRuleGroupRuleVariablesIpSet {
        /**
         * A configuration block that defines a set of IP addresses. See IP Set below for details.
         */
        ipSet: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSet;
        /**
         * A unique alphanumeric string to identify the `ipSet`.
         */
        key: string;
    }

    export interface RuleGroupRuleGroupRuleVariablesIpSetIpSet {
        /**
         * Set of IP addresses and address ranges, in CIDR notation.
         */
        definitions: string[];
    }

    export interface RuleGroupRuleGroupRuleVariablesPortSet {
        /**
         * An unique alphanumeric string to identify the `portSet`.
         */
        key: string;
        /**
         * A configuration block that defines a set of port ranges. See Port Set below for details.
         */
        portSet: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetPortSet;
    }

    export interface RuleGroupRuleGroupRuleVariablesPortSetPortSet {
        /**
         * Set of port ranges.
         */
        definitions: string[];
    }

    export interface RuleGroupRuleGroupRulesSource {
        /**
         * A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
         */
        rulesSourceList?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceRulesSourceList;
        /**
         * The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
         */
        rulesString?: string;
        /**
         * Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
         */
        statefulRules?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRule[];
        /**
         * A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
         */
        statelessRulesAndCustomActions?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions;
    }

    export interface RuleGroupRuleGroupRulesSourceRulesSourceList {
        /**
         * String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
         */
        generatedRulesType: string;
        /**
         * Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
         */
        targetTypes: string[];
        /**
         * Set of domains that you want to inspect for in your traffic flows.
         */
        targets: string[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatefulRule {
        /**
         * Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP` or `PASS`.
         */
        action: string;
        /**
         * A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
         */
        header: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRuleHeader;
        /**
         * Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
         */
        ruleOptions: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatefulRuleHeader {
        /**
         * The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
         */
        destination: string;
        /**
         * The destination port to inspect for. To match with any address, specify `ANY`.
         */
        destinationPort: string;
        /**
         * The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
         */
        direction: string;
        /**
         * The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
         */
        protocol: string;
        /**
         * The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
         */
        source: string;
        /**
         * The source port to inspect for. To match with any address, specify `ANY`.
         */
        sourcePort: string;
    }

    export interface RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption {
        /**
         * Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
         * See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
         */
        keyword: string;
        /**
         * Set of strings for additional settings to use in stateful rule inspection.
         */
        settings?: string[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions {
        /**
         * Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
         */
        customActions?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction[];
        /**
         * Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
         */
        statelessRules: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction {
        /**
         * A configuration block describing the custom action associated with the `actionName`. See Action Definition below for details.
         */
        actionDefinition: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition;
        /**
         * A friendly name of the custom action.
         */
        actionName: string;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition {
        /**
         * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
         */
        publishMetricAction: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction {
        /**
         * Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
         */
        dimensions: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension {
        /**
         * The value to use in the custom metric dimension.
         */
        value: string;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule {
        /**
         * A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
         */
        priority: number;
        /**
         * A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
         */
        ruleDefinition: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition {
        /**
         * Set of actions to take on a packet that matches one of the stateless rule definition's `matchAttributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
         */
        actions: string[];
        /**
         * A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
         */
        matchAttributes: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes {
        /**
         * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
         */
        destinationPorts?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort[];
        /**
         * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
         */
        destinations?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination[];
        /**
         * Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
         */
        protocols?: number[];
        /**
         * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
         */
        sourcePorts?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort[];
        /**
         * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
         */
        sources?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource[];
        /**
         * Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
         */
        tcpFlags?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag[];
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination {
        /**
         * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
         */
        addressDefinition: string;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort {
        /**
         * The lower limit of the port range. This must be less than or equal to the `toPort`.
         */
        fromPort: number;
        /**
         * The upper limit of the port range. This must be greater than or equal to the `fromPort`.
         */
        toPort?: number;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource {
        /**
         * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
         */
        addressDefinition: string;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort {
        /**
         * The lower limit of the port range. This must be less than or equal to the `toPort`.
         */
        fromPort: number;
        /**
         * The upper limit of the port range. This must be greater than or equal to the `fromPort`.
         */
        toPort?: number;
    }

    export interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag {
        /**
         * Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
         * Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
         */
        flags: string[];
        /**
         * Set of flags to consider in the inspection. To inspect all flags, leave this empty.
         * Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
         */
        masks?: string[];
    }

    export interface RuleGroupRuleGroupStatefulRuleOptions {
        /**
         * Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
         */
        ruleOrder: string;
    }

}

export namespace networkmanager {
    export interface ConnectAttachmentOptions {
        protocol?: string;
    }

    export interface ConnectPeerBgpOptions {
        peerAsn?: number;
    }

    export interface ConnectPeerConfiguration {
        bgpConfigurations: outputs.networkmanager.ConnectPeerConfigurationBgpConfiguration[];
        /**
         * A Connect peer core network address.
         */
        coreNetworkAddress: string;
        /**
         * The inside IP addresses used for BGP peering.
         */
        insideCidrBlocks: string[];
        /**
         * The Connect peer address.
         *
         * The following arguments are optional:
         */
        peerAddress: string;
        protocol: string;
    }

    export interface ConnectPeerConfigurationBgpConfiguration {
        /**
         * A Connect peer core network address.
         */
        coreNetworkAddress: string;
        coreNetworkAsn: number;
        /**
         * The Connect peer address.
         *
         * The following arguments are optional:
         */
        peerAddress: string;
        peerAsn: number;
    }

    export interface CoreNetworkEdge {
        /**
         * ASN of a core network edge.
         */
        asn: number;
        /**
         * Region where a core network edge is located.
         */
        edgeLocation: string;
        /**
         * Inside IP addresses used for core network edges.
         */
        insideCidrBlocks: string[];
    }

    export interface CoreNetworkSegment {
        /**
         * Regions where the edges are located.
         */
        edgeLocations: string[];
        /**
         * Name of a core network segment.
         */
        name: string;
        /**
         * Shared segments of a core network.
         */
        sharedSegments: string[];
    }

    export interface DeviceAwsLocation {
        /**
         * The Amazon Resource Name (ARN) of the subnet that the device is located in.
         */
        subnetArn?: string;
        /**
         * The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
         */
        zone?: string;
    }

    export interface DeviceLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }

    export interface GetCoreNetworkPolicyDocumentAttachmentPolicy {
        /**
         * Action to take when a condition is true. Detailed Below.
         */
        action: outputs.networkmanager.GetCoreNetworkPolicyDocumentAttachmentPolicyAction;
        /**
         * Valid values include `and` or `or`. This is a mandatory parameter only if you have more than one condition. The `conditionLogic` apply to all of the conditions for a rule, which also means nested conditions of `and` or `or` are not supported. Use `or` if you want to associate the attachment with the segment by either the segment name or attachment tag value, or by the chosen conditions. Use `and` if you want to associate the attachment with the segment by either the segment name or attachment tag value and by the chosen conditions. Detailed Below.
         */
        conditionLogic?: string;
        /**
         * A block argument. Detailed Below.
         */
        conditions: outputs.networkmanager.GetCoreNetworkPolicyDocumentAttachmentPolicyCondition[];
        /**
         * A user-defined description that further helps identify the rule.
         */
        description?: string;
        /**
         * An integer from `1` to `65535` indicating the rule's order number. Rules are processed in order from the lowest numbered rule to the highest. Rules stop processing when a rule is matched. It's important to make sure that you number your rules in the exact order that you want them processed.
         */
        ruleNumber: number;
    }

    export interface GetCoreNetworkPolicyDocumentAttachmentPolicyAction {
        /**
         * Defines how a segment is mapped. Values can be `constant` or `tag`. `constant` statically defines the segment to associate the attachment to. `tag` uses the value of a tag to dynamically try to map to a segment.reference_policies_elements_condition_operators.html) to evaluate.
         */
        associationMethod: string;
        /**
         * Determines if this mapping should override the segment value for `requireAttachmentAcceptance`. You can only set this to `true`, indicating that this setting applies only to segments that have `requireAttachmentAcceptance` set to `false`. If the segment already has the default `requireAttachmentAcceptance`, you can set this to inherit segment’s acceptance value.
         */
        requireAcceptance?: boolean;
        /**
         * Name of the `segment` to share as defined in the `segments` section. This is used only when the `associationMethod` is `constant`.
         */
        segment?: string;
        /**
         * Maps the attachment to the value of a known key. This is used with the `associationMethod` is `tag`. For example a `tag` of `stage = “test”`, will map to a segment named `test`. The value must exactly match the name of a segment. This allows you to have many segments, but use only a single rule without having to define multiple nearly identical conditions. This prevents creating many similar conditions that all use the same keys to map to segments.
         */
        tagValueOfKey?: string;
    }

    export interface GetCoreNetworkPolicyDocumentAttachmentPolicyCondition {
        /**
         * string value
         */
        key?: string;
        /**
         * Valid values include: `equals`, `not-equals`, `contains`, `begins-with`.
         */
        operator?: string;
        /**
         * Valid values include: `account-id`, `any`, `tag-value`, `tag-exists`, `resource-id`, `region`, `attachment-type`.
         */
        type: string;
        /**
         * string value
         */
        value?: string;
    }

    export interface GetCoreNetworkPolicyDocumentCoreNetworkConfiguration {
        /**
         * List of strings containing Autonomous System Numbers (ASNs) to assign to Core Network Edges. By default, the core network automatically assigns an ASN for each Core Network Edge but you can optionally define the ASN in the edge-locations for each Region. The ASN uses an array of integer ranges only from `64512` to `65534` and `4200000000` to `4294967294` expressed as a string like `"64512-65534"`. No other ASN ranges can be used.
         */
        asnRanges: string[];
        /**
         * A block value of AWS Region locations where you're creating Core Network Edges. Detailed below.
         */
        edgeLocations: outputs.networkmanager.GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation[];
        /**
         * The Classless Inter-Domain Routing (CIDR) block range used to create tunnels for AWS Transit Gateway Connect. The format is standard AWS CIDR range (for example, `10.0.1.0/24`). You can optionally define the inside CIDR in the Core Network Edges section per Region. The minimum is a `/24` for IPv4 or `/64` for IPv6. You can provide multiple `/24` subnets or a larger CIDR range. If you define a larger CIDR range, new Core Network Edges will be automatically assigned `/24` and `/64` subnets from the larger CIDR. an Inside CIDR block is required for attaching Connect attachments to a Core Network Edge.
         */
        insideCidrBlocks?: string[];
        /**
         * Indicates whether the core network forwards traffic over multiple equal-cost routes using VPN. The value can be either `true` or `false`. The default is `true`.
         */
        vpnEcmpSupport?: boolean;
    }

    export interface GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation {
        /**
         * ASN of the Core Network Edge in an AWS Region. By default, the ASN will be a single integer automatically assigned from `asnRanges`
         */
        asn?: string;
        /**
         * The local CIDR blocks for this Core Network Edge for AWS Transit Gateway Connect attachments. By default, this CIDR block will be one or more optional IPv4 and IPv6 CIDR prefixes auto-assigned from `insideCidrBlocks`.
         */
        insideCidrBlocks?: string[];
        location: string;
    }

    export interface GetCoreNetworkPolicyDocumentSegment {
        /**
         * List of strings of segment names that explicitly allows only routes from the segments that are listed in the array. Use the `allowFilter` setting if a segment has a well-defined group of other segments that connectivity should be restricted to. It is applied after routes have been shared in `segmentActions`. If a segment is listed in `allowFilter`, attachments between the two segments will have routes if they are also shared in the segment-actions area. For example, you might have a segment named "video-producer" that should only ever share routes with a "video-distributor" segment, no matter how many other share statements are created.
         */
        allowFilters?: string[];
        /**
         * An array of segments that disallows routes from the segments listed in the array. It is applied only after routes have been shared in `segmentActions`. If a segment is listed in the `denyFilter`, attachments between the two segments will never have routes shared across them. For example, you might have a "financial" payment segment that should never share routes with a "development" segment, regardless of how many other share statements are created. Adding the payments segment to the deny-filter parameter prevents any shared routes from being created with other segments.
         */
        denyFilters?: string[];
        /**
         * A user-defined string describing the segment.
         */
        description?: string;
        /**
         * A list of strings of AWS Region names. Allows you to define a more restrictive set of Regions for a segment. The edge location must be a subset of the locations that are defined for `edgeLocations` in the `coreNetworkConfiguration`.
         */
        edgeLocations?: string[];
        /**
         * This Boolean setting determines whether attachments on the same segment can communicate with each other. If set to `true`, the only routes available will be either shared routes through the share actions, which are attachments in other segments, or static routes. The default value is `false`. For example, you might have a segment dedicated to "development" that should never allow VPCs to talk to each other, even if they’re on the same segment. In this example, you would keep the default parameter of `false`.
         */
        isolateAttachments?: boolean;
        /**
         * Unique name for a segment. The name is a string used in other parts of the policy document, as well as in the console for metrics and other reference points. Valid characters are a–z, and 0–9.
         */
        name: string;
        /**
         * This Boolean setting determines whether attachment requests are automatically approved or require acceptance. The default is `true`, indicating that attachment requests require acceptance. For example, you might use this setting to allow a "sandbox" segment to allow any attachment request so that a core network or attachment administrator does not need to review and approve attachment requests. In this example, `requireAttachmentAcceptance` is set to `false`.
         */
        requireAttachmentAcceptance?: boolean;
    }

    export interface GetCoreNetworkPolicyDocumentSegmentAction {
        /**
         * Action to take for the chosen segment. Valid values `create-route` or `share`.
         */
        action: string;
        /**
         * A user-defined string describing the segment action.
         */
        description?: string;
        /**
         * List of strings containing CIDRs. You can define the IPv4 and IPv6 CIDR notation for each AWS Region. For example, `10.1.0.0/16` or `2001:db8::/56`. This is an array of CIDR notation strings.
         */
        destinationCidrBlocks?: string[];
        /**
         * A list of strings. Valid values include `["blackhole"]` or a list of attachment ids.
         */
        destinations?: string[];
        /**
         * String. This mode places the attachment and return routes in each of the `shareWith` segments. Valid values include: `attachment-route`.
         */
        mode?: string;
        /**
         * Name of the segment.
         */
        segment: string;
        /**
         * A set subtraction of segments to not share with.
         */
        shareWithExcepts?: string[];
        /**
         * A list of strings to share with. Must be a substring is all segments. Valid values include: `["*"]` or `["<segment-names>"]`.
         */
        shareWiths?: string[];
    }

    export interface GetDeviceAwsLocation {
        /**
         * ARN of the subnet that the device is located in.
         */
        subnetArn: string;
        /**
         * Zone that the device is located in.
         */
        zone: string;
    }

    export interface GetDeviceLocation {
        /**
         * Physical address.
         */
        address: string;
        /**
         * Latitude.
         */
        latitude: string;
        /**
         * Longitude.
         */
        longitude: string;
    }

    export interface GetLinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed: number;
    }

    export interface GetSiteLocation {
        /**
         * Address of the location.
         */
        address: string;
        /**
         * Latitude of the location.
         */
        latitude: string;
        /**
         * Longitude of the location.
         */
        longitude: string;
    }

    export interface LinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed?: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed?: number;
    }

    export interface SiteLocation {
        /**
         * Address of the location.
         */
        address?: string;
        /**
         * Latitude of the location.
         */
        latitude?: string;
        /**
         * Longitude of the location.
         */
        longitude?: string;
    }

    export interface VpcAttachmentOptions {
        /**
         * Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
         */
        applianceModeSupport?: boolean;
        /**
         * Indicates whether IPv6 is supported.
         */
        ipv6Support?: boolean;
    }

}

export namespace opensearch {
    export interface DomainAdvancedSecurityOptions {
        /**
         * Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advancedSecurityOptions` are enabled. _Can only be enabled on an existing domain._
         */
        anonymousAuthEnabled: boolean;
        /**
         * Whether advanced security is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled. Default is `false`.
         */
        internalUserDatabaseEnabled?: boolean;
        /**
         * Configuration block for the main user. Detailed below.
         */
        masterUserOptions?: outputs.opensearch.DomainAdvancedSecurityOptionsMasterUserOptions;
    }

    export interface DomainAdvancedSecurityOptionsMasterUserOptions {
        /**
         * ARN for the main user. Only specify if `internalUserDatabaseEnabled` is not set or set to `false`.
         */
        masterUserArn?: string;
        /**
         * Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserName?: string;
        /**
         * Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserPassword?: string;
    }

    export interface DomainAutoTuneOptions {
        /**
         * Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
         */
        desiredState: string;
        /**
         * Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
         */
        maintenanceSchedules: outputs.opensearch.DomainAutoTuneOptionsMaintenanceSchedule[];
        /**
         * Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
         */
        rollbackOnDisable: string;
    }

    export interface DomainAutoTuneOptionsMaintenanceSchedule {
        /**
         * A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
         */
        duration: outputs.opensearch.DomainAutoTuneOptionsMaintenanceScheduleDuration;
        /**
         * Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }

    export interface DomainAutoTuneOptionsMaintenanceScheduleDuration {
        /**
         * Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
         */
        unit: string;
        /**
         * An integer specifying the value of the duration of an Auto-Tune maintenance window.
         */
        value: number;
    }

    export interface DomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration. Detailed below.
         */
        coldStorageOptions: outputs.opensearch.DomainClusterConfigColdStorageOptions;
        /**
         * Number of dedicated main nodes in the cluster.
         */
        dedicatedMasterCount?: number;
        /**
         * Whether dedicated main nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled?: boolean;
        /**
         * Instance type of the dedicated main nodes in the cluster.
         */
        dedicatedMasterType?: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount?: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType?: string;
        /**
         * Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warmCount` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmCount?: number;
        /**
         * Whether to enable warm storage.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warmType` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmType?: string;
        /**
         * Configuration block containing zone awareness settings. Detailed below.
         */
        zoneAwarenessConfig?: outputs.opensearch.DomainClusterConfigZoneAwarenessConfig;
        /**
         * Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availabilityZoneCount` within the `zoneAwarenessConfig` must be set to `3`.
         */
        zoneAwarenessEnabled?: boolean;
    }

    export interface DomainClusterConfigColdStorageOptions {
        /**
         * Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
         */
        enabled: boolean;
    }

    export interface DomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of Availability Zones for the domain to use with `zoneAwarenessEnabled`. Defaults to `2`. Valid values: `2` or `3`.
         */
        availabilityZoneCount?: number;
    }

    export interface DomainCognitoOptions {
        /**
         * Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
         */
        enabled?: boolean;
        /**
         * ID of the Cognito Identity Pool to use.
         */
        identityPoolId: string;
        /**
         * ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * ID of the Cognito User Pool to use.
         */
        userPoolId: string;
    }

    export interface DomainDomainEndpointOptions {
        /**
         * Fully qualified domain for your custom endpoint.
         */
        customEndpoint?: string;
        /**
         * ACM certificate ARN for your custom endpoint.
         */
        customEndpointCertificateArn?: string;
        /**
         * Whether to enable custom endpoint for the OpenSearch domain.
         */
        customEndpointEnabled?: boolean;
        /**
         * Whether or not to require HTTPS. Defaults to `true`.
         */
        enforceHttps?: boolean;
        /**
         * Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
         */
        tlsSecurityPolicy: string;
    }

    export interface DomainEbsOptions {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
         */
        iops: number;
        /**
         * Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GiB).
         */
        volumeSize?: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }

    export interface DomainEncryptAtRest {
        /**
         * Whether to enable encryption at rest. If the `encryptAtRest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engineVersion` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
         */
        enabled: boolean;
        /**
         * KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
         */
        kmsKeyId: string;
    }

    export interface DomainLogPublishingOption {
        /**
         * ARN of the Cloudwatch log group to which log needs to be published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether given log publishing option is enabled or not.
         */
        enabled?: boolean;
        /**
         * Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
         */
        logType: string;
    }

    export interface DomainNodeToNodeEncryption {
        /**
         * Whether to enable node-to-node encryption. If the `nodeToNodeEncryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engineVersion` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
         */
        enabled: boolean;
    }

    export interface DomainOffPeakWindowOptions {
        /**
         * Enabled disabled toggle for off-peak update window.
         */
        enabled: boolean;
        offPeakWindow: outputs.opensearch.DomainOffPeakWindowOptionsOffPeakWindow;
    }

    export interface DomainOffPeakWindowOptionsOffPeakWindow {
        /**
         * 10h window for updates
         */
        windowStartTime: outputs.opensearch.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime;
    }

    export interface DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime {
        /**
         * Starting hour of the 10-hour window for updates
         */
        hours: number;
        /**
         * Starting minute of the 10-hour window for updates
         */
        minutes: number;
    }

    export interface DomainSamlOptionsSamlOptions {
        /**
         * Whether SAML authentication is enabled.
         */
        enabled?: boolean;
        /**
         * Information from your identity provider.
         */
        idp?: outputs.opensearch.DomainSamlOptionsSamlOptionsIdp;
        /**
         * This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterBackendRole?: string;
        /**
         * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterUserName?: string;
        /**
         * Element of the SAML assertion to use for backend roles. Default is roles.
         */
        rolesKey?: string;
        /**
         * Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
         */
        sessionTimeoutMinutes?: number;
        /**
         * Element of the SAML assertion to use for username. Default is NameID.
         */
        subjectKey?: string;
    }

    export interface DomainSamlOptionsSamlOptionsIdp {
        /**
         * Unique Entity ID of the application in SAML Identity Provider.
         */
        entityId: string;
        /**
         * Metadata of the SAML application in xml format.
         */
        metadataContent: string;
    }

    export interface DomainSnapshotOptions {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }

    export interface DomainVpcOptions {
        availabilityZones: string[];
        /**
         * List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
         */
        securityGroupIds?: string[];
        /**
         * List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
         */
        subnetIds?: string[];
        vpcId: string;
    }

    export interface GetDomainAdvancedSecurityOption {
        anonymousAuthEnabled: boolean;
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled.
         */
        internalUserDatabaseEnabled: boolean;
    }

    export interface GetDomainAutoTuneOption {
        /**
         * Auto-Tune desired state for the domain.
         */
        desiredState: string;
        /**
         * A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
         */
        maintenanceSchedules: outputs.opensearch.GetDomainAutoTuneOptionMaintenanceSchedule[];
        /**
         * Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
         */
        rollbackOnDisable: string;
    }

    export interface GetDomainAutoTuneOptionMaintenanceSchedule {
        /**
         * Cron expression for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window.
         */
        durations: outputs.opensearch.GetDomainAutoTuneOptionMaintenanceScheduleDuration[];
        /**
         * Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }

    export interface GetDomainAutoTuneOptionMaintenanceScheduleDuration {
        /**
         * Unit of time.
         */
        unit: string;
        /**
         * Duration of an Auto-Tune maintenance window.
         */
        value: number;
    }

    export interface GetDomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration.
         */
        coldStorageOptions: outputs.opensearch.GetDomainClusterConfigColdStorageOption[];
        /**
         * Number of dedicated master nodes in the cluster.
         */
        dedicatedMasterCount: number;
        /**
         * Indicates whether dedicated master nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled: boolean;
        /**
         * Instance type of the dedicated master nodes in the cluster.
         */
        dedicatedMasterType: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType: string;
        /**
         * Number of warm nodes in the cluster.
         */
        warmCount: number;
        /**
         * Warm storage is enabled.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the OpenSearch cluster's warm nodes.
         */
        warmType: string;
        /**
         * Configuration block containing zone awareness settings.
         */
        zoneAwarenessConfigs: outputs.opensearch.GetDomainClusterConfigZoneAwarenessConfig[];
        /**
         * Indicates whether zone awareness is enabled.
         */
        zoneAwarenessEnabled: boolean;
    }

    export interface GetDomainClusterConfigColdStorageOption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
    }

    export interface GetDomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of availability zones used.
         */
        availabilityZoneCount: number;
    }

    export interface GetDomainCognitoOption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Cognito Identity pool used by the domain.
         */
        identityPoolId: string;
        /**
         * IAM Role with the AmazonOpenSearchServiceCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * Cognito User pool used by the domain.
         */
        userPoolId: string;
    }

    export interface GetDomainEbsOption {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes.
         */
        iops: number;
        /**
         * The throughput (in MiB/s) of the EBS volumes attached to data nodes.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GB).
         */
        volumeSize: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }

    export interface GetDomainEncryptionAtRest {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * KMS key id used to encrypt data at rest.
         */
        kmsKeyId: string;
    }

    export interface GetDomainLogPublishingOption {
        /**
         * CloudWatch Log Group where the logs are published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Type of OpenSearch log being published.
         */
        logType: string;
    }

    export interface GetDomainNodeToNodeEncryption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
    }

    export interface GetDomainOffPeakWindowOptions {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        offPeakWindows: outputs.opensearch.GetDomainOffPeakWindowOptionsOffPeakWindow[];
    }

    export interface GetDomainOffPeakWindowOptionsOffPeakWindow {
        /**
         * 10h window for updates
         */
        windowStartTimes: outputs.opensearch.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTime[];
    }

    export interface GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTime {
        /**
         * Starting hour of the 10-hour window for updates
         */
        hours: number;
        /**
         * Starting minute of the 10-hour window for updates
         */
        minutes: number;
    }

    export interface GetDomainSnapshotOption {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }

    export interface GetDomainVpcOption {
        /**
         * Availability zones used by the domain.
         */
        availabilityZones: string[];
        /**
         * Security groups used by the domain.
         */
        securityGroupIds: string[];
        /**
         * Subnets used by the domain.
         */
        subnetIds: string[];
        /**
         * VPC used by the domain.
         */
        vpcId: string;
    }

    export interface GetServerlessSecurityConfigSamlOptions {
        /**
         * Group attribute for this SAML integration.
         */
        groupAttribute: string;
        /**
         * The XML IdP metadata file generated from your identity provider.
         */
        metadata: string;
        /**
         * Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
         */
        sessionTimeout: number;
        /**
         * User attribute for this SAML integration.
         */
        userAttribute: string;
    }

    export interface OutboundConnectionLocalDomainInfo {
        /**
         * The name of the local domain.
         */
        domainName: string;
        /**
         * The Account ID of the owner of the local domain.
         */
        ownerId: string;
        /**
         * The region of the local domain.
         */
        region: string;
    }

    export interface OutboundConnectionRemoteDomainInfo {
        /**
         * The name of the remote domain.
         */
        domainName: string;
        /**
         * The Account ID of the owner of the remote domain.
         */
        ownerId: string;
        /**
         * The region of the remote domain.
         */
        region: string;
    }

    export interface ServerlessCollectionTimeouts {
        create?: string;
        delete?: string;
    }

    export interface ServerlessSecurityConfigSamlOptions {
        /**
         * Group attribute for this SAML integration.
         */
        groupAttribute?: string;
        /**
         * The XML IdP metadata file generated from your identity provider.
         */
        metadata: string;
        /**
         * Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
         */
        sessionTimeout: number;
        /**
         * User attribute for this SAML integration.
         */
        userAttribute?: string;
    }

    export interface ServerlessVpcEndpointTimeouts {
        create?: string;
        delete?: string;
        update?: string;
    }

}

export namespace opsworks {
    export interface ApplicationAppSource {
        /**
         * Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        password?: string;
        /**
         * For sources that are version-aware, the revision to use.
         */
        revision?: string;
        /**
         * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        sshKey?: string;
        /**
         * The type of source to use. For example, "archive".
         */
        type: string;
        /**
         * The URL where the app resource can be found.
         */
        url?: string;
        /**
         * Username to use when authenticating to the source.
         */
        username?: string;
    }

    export interface ApplicationEnvironment {
        /**
         * Variable name.
         */
        key: string;
        /**
         * Set visibility of the variable value to `true` or `false`.
         */
        secure?: boolean;
        /**
         * Variable value.
         */
        value: string;
    }

    export interface ApplicationSslConfiguration {
        /**
         * The contents of the certificate's domain.crt file.
         */
        certificate: string;
        /**
         * Can be used to specify an intermediate certificate authority key or client authentication.
         */
        chain?: string;
        /**
         * The private key; the contents of the certificate's domain.key file.
         */
        privateKey: string;
    }

    export interface CustomLayerCloudwatchConfiguration {
        enabled?: boolean;
        /**
         * A block the specifies how an opsworks logs look like. See Log Streams.
         */
        logStreams?: outputs.opsworks.CustomLayerCloudwatchConfigurationLogStream[];
    }

    export interface CustomLayerCloudwatchConfigurationLogStream {
        /**
         * Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
         */
        batchCount?: number;
        /**
         * Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
         */
        batchSize?: number;
        /**
         * Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
         */
        bufferDuration?: number;
        /**
         * Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
         */
        datetimeFormat?: string;
        /**
         * Specifies the encoding of the log file so that the file can be read correctly. The default is `utf8`.
         */
        encoding?: string;
        /**
         * Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
         */
        file: string;
        /**
         * Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
         */
        fileFingerprintLines?: string;
        /**
         * Specifies where to start to read data (`startOfFile` or `endOfFile`). The default is `startOfFile`.
         */
        initialPosition?: string;
        /**
         * Specifies the destination log group. A log group is created automatically if it doesn't already exist.
         */
        logGroupName: string;
        /**
         * Specifies the pattern for identifying the start of a log message.
         */
        multilineStartPattern?: string;
        /**
         * Specifies the time zone of log event time stamps.
         */
        timeZone?: string;
    }

    export interface CustomLayerEbsVolume {
        /**
         * Encrypt the volume.
         */
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface CustomLayerLoadBasedAutoScaling {
        /**
         * The downscaling settings, as defined below, used for load-based autoscaling
         */
        downscaling: outputs.opsworks.CustomLayerLoadBasedAutoScalingDownscaling;
        /**
         * Whether load-based auto scaling is enabled for the layer.
         */
        enable?: boolean;
        /**
         * The upscaling settings, as defined below, used for load-based autoscaling
         */
        upscaling: outputs.opsworks.CustomLayerLoadBasedAutoScalingUpscaling;
    }

    export interface CustomLayerLoadBasedAutoScalingDownscaling {
        /**
         * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
         */
        alarms?: string[];
        /**
         * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
         */
        cpuThreshold?: number;
        /**
         * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
         */
        ignoreMetricsTime?: number;
        /**
         * The number of instances to add or remove when the load exceeds a threshold.
         */
        instanceCount?: number;
        /**
         * The load threshold. A value of -1 disables the threshold.
         */
        loadThreshold?: number;
        /**
         * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
         */
        memoryThreshold?: number;
        /**
         * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
         */
        thresholdsWaitTime?: number;
    }

    export interface CustomLayerLoadBasedAutoScalingUpscaling {
        /**
         * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
         */
        alarms?: string[];
        /**
         * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
         */
        cpuThreshold?: number;
        /**
         * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
         */
        ignoreMetricsTime?: number;
        /**
         * The number of instances to add or remove when the load exceeds a threshold.
         */
        instanceCount?: number;
        /**
         * The load threshold. A value of -1 disables the threshold.
         */
        loadThreshold?: number;
        /**
         * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
         */
        memoryThreshold?: number;
        /**
         * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
         */
        thresholdsWaitTime?: number;
    }

    export interface EcsClusterLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.EcsClusterLayerCloudwatchConfigurationLogStream[];
    }

    export interface EcsClusterLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface EcsClusterLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface EcsClusterLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.EcsClusterLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.EcsClusterLayerLoadBasedAutoScalingUpscaling;
    }

    export interface EcsClusterLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface EcsClusterLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface GangliaLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.GangliaLayerCloudwatchConfigurationLogStream[];
    }

    export interface GangliaLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface GangliaLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface GangliaLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.GangliaLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.GangliaLayerLoadBasedAutoScalingUpscaling;
    }

    export interface GangliaLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface GangliaLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface HaproxyLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.HaproxyLayerCloudwatchConfigurationLogStream[];
    }

    export interface HaproxyLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface HaproxyLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface HaproxyLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.HaproxyLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.HaproxyLayerLoadBasedAutoScalingUpscaling;
    }

    export interface HaproxyLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface HaproxyLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface InstanceEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        iops: number;
        snapshotId: string;
        volumeSize: number;
        volumeType: string;
    }

    export interface InstanceEphemeralBlockDevice {
        deviceName: string;
        virtualName: string;
    }

    export interface InstanceRootBlockDevice {
        deleteOnTermination?: boolean;
        iops: number;
        volumeSize: number;
        volumeType: string;
    }

    export interface JavaAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.JavaAppLayerCloudwatchConfigurationLogStream[];
    }

    export interface JavaAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface JavaAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface JavaAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.JavaAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.JavaAppLayerLoadBasedAutoScalingUpscaling;
    }

    export interface JavaAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface JavaAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface MemcachedLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.MemcachedLayerCloudwatchConfigurationLogStream[];
    }

    export interface MemcachedLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface MemcachedLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface MemcachedLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.MemcachedLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.MemcachedLayerLoadBasedAutoScalingUpscaling;
    }

    export interface MemcachedLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface MemcachedLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface MysqlLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.MysqlLayerCloudwatchConfigurationLogStream[];
    }

    export interface MysqlLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface MysqlLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface MysqlLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.MysqlLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.MysqlLayerLoadBasedAutoScalingUpscaling;
    }

    export interface MysqlLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface MysqlLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface NodejsAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.NodejsAppLayerCloudwatchConfigurationLogStream[];
    }

    export interface NodejsAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface NodejsAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface NodejsAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.NodejsAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.NodejsAppLayerLoadBasedAutoScalingUpscaling;
    }

    export interface NodejsAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface NodejsAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface PhpAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.PhpAppLayerCloudwatchConfigurationLogStream[];
    }

    export interface PhpAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface PhpAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface PhpAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.PhpAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.PhpAppLayerLoadBasedAutoScalingUpscaling;
    }

    export interface PhpAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface PhpAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface RailsAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.RailsAppLayerCloudwatchConfigurationLogStream[];
    }

    export interface RailsAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface RailsAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface RailsAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.RailsAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.RailsAppLayerLoadBasedAutoScalingUpscaling;
    }

    export interface RailsAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface RailsAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface StackCustomCookbooksSource {
        /**
         * Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
         */
        password?: string;
        /**
         * For sources that are version-aware, the revision to use.
         */
        revision?: string;
        /**
         * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        sshKey?: string;
        /**
         * The type of source to use. For example, "archive".
         */
        type: string;
        /**
         * The URL where the cookbooks resource can be found.
         */
        url: string;
        /**
         * Username to use when authenticating to the source.
         */
        username?: string;
    }

    export interface StaticWebLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.StaticWebLayerCloudwatchConfigurationLogStream[];
    }

    export interface StaticWebLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }

    export interface StaticWebLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }

    export interface StaticWebLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.StaticWebLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.StaticWebLayerLoadBasedAutoScalingUpscaling;
    }

    export interface StaticWebLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface StaticWebLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

}

export namespace organizations {
    export interface GetDelegatedAdministratorsDelegatedAdministrator {
        /**
         * The ARN of the delegated administrator's account.
         */
        arn: string;
        /**
         * The date when the account was made a delegated administrator.
         */
        delegationEnabledDate: string;
        /**
         * The email address that is associated with the delegated administrator's AWS account.
         */
        email: string;
        /**
         * The unique identifier (ID) of the delegated administrator's account.
         */
        id: string;
        /**
         * The method by which the delegated administrator's account joined the organization.
         */
        joinedMethod: string;
        /**
         * The date when the delegated administrator's account became a part of the organization.
         */
        joinedTimestamp: string;
        /**
         * The friendly name of the delegated administrator's account.
         */
        name: string;
        /**
         * The status of the delegated administrator's account in the organization.
         */
        status: string;
    }

    export interface GetDelegatedServicesDelegatedService {
        /**
         * The date that the account became a delegated administrator for this service.
         */
        delegationEnabledDate: string;
        /**
         * The name of an AWS service that can request an operation for the specified service.
         */
        servicePrincipal: string;
    }

    export interface GetOrganizationAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }

    export interface GetOrganizationNonMasterAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }

    export interface GetOrganizationRoot {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * List of policy types enabled for this root. All elements have these attributes:
         */
        policyTypes: outputs.organizations.GetOrganizationRootPolicyType[];
    }

    export interface GetOrganizationRootPolicyType {
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
        type: string;
    }

    export interface GetOrganizationalUnitChildAccountsAccount {
        /**
         * The Amazon Resource Name (ARN) of the account.
         */
        arn: string;
        /**
         * The email address associated with the AWS account.
         */
        email: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * The friendly name of the account.
         */
        name: string;
        /**
         * The status of the account in the organization.
         */
        status: string;
    }

    export interface GetOrganizationalUnitDescendantAccountsAccount {
        /**
         * The Amazon Resource Name (ARN) of the account.
         */
        arn: string;
        /**
         * The email address associated with the AWS account.
         */
        email: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * The friendly name of the account.
         */
        name: string;
        /**
         * The status of the account in the organization.
         */
        status: string;
    }

    export interface GetOrganizationalUnitsChild {
        /**
         * ARN of the organizational unit
         */
        arn: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * Name of the organizational unit
         */
        name: string;
    }

    export interface OrganizationAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }

    export interface OrganizationNonMasterAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }

    export interface OrganizationRoot {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * List of policy types enabled for this root. All elements have these attributes:
         */
        policyTypes: outputs.organizations.OrganizationRootPolicyType[];
    }

    export interface OrganizationRootPolicyType {
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
        type: string;
    }

    export interface OrganizationalUnitAccount {
        /**
         * ARN of the organizational unit
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the organization unit
         */
        id: string;
        /**
         * The name for the organizational unit
         */
        name: string;
    }

}

export namespace pinpoint {
    export interface AppCampaignHook {
        /**
         * Lambda function name or ARN to be called for delivery. Conflicts with `webUrl`
         */
        lambdaFunctionName?: string;
        /**
         * What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
         */
        mode?: string;
        /**
         * Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambdaFunctionName`
         */
        webUrl?: string;
    }

    export interface AppLimits {
        /**
         * The maximum number of messages that the campaign can send daily.
         */
        daily?: number;
        /**
         * The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
         */
        maximumDuration?: number;
        /**
         * The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
         */
        messagesPerSecond?: number;
        /**
         * The maximum total number of messages that the campaign can send.
         */
        total?: number;
    }

    export interface AppQuietTime {
        /**
         * The default end time for quiet time in ISO 8601 format. Required if `start` is set
         */
        end?: string;
        /**
         * The default start time for quiet time in ISO 8601 format. Required if `end` is set
         */
        start?: string;
    }

}

export namespace pipes {
    export interface PipeEnrichmentParameters {
        /**
         * Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge ApiDestination. If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence. Detailed below.
         */
        httpParameters?: outputs.pipes.PipeEnrichmentParametersHttpParameters;
        /**
         * Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
         */
        inputTemplate?: string;
    }

    export interface PipeEnrichmentParametersHttpParameters {
        /**
         * Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
         */
        headerParameters?: {[key: string]: string};
        /**
         * The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
         */
        pathParameterValues?: string;
        /**
         * Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
         */
        queryStringParameters?: {[key: string]: string};
    }

    export interface PipeSourceParameters {
        /**
         * The parameters for using an Active MQ broker as a source. Detailed below.
         */
        activemqBrokerParameters: outputs.pipes.PipeSourceParametersActivemqBrokerParameters;
        /**
         * The parameters for using a DynamoDB stream as a source.  Detailed below.
         */
        dynamodbStreamParameters: outputs.pipes.PipeSourceParametersDynamodbStreamParameters;
        /**
         * The collection of event patterns used to [filter events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-event-filtering.html). Detailed below.
         */
        filterCriteria?: outputs.pipes.PipeSourceParametersFilterCriteria;
        /**
         * The parameters for using a Kinesis stream as a source. Detailed below.
         */
        kinesisStreamParameters: outputs.pipes.PipeSourceParametersKinesisStreamParameters;
        /**
         * The parameters for using an MSK stream as a source. Detailed below.
         */
        managedStreamingKafkaParameters: outputs.pipes.PipeSourceParametersManagedStreamingKafkaParameters;
        /**
         * The parameters for using a Rabbit MQ broker as a source. Detailed below.
         */
        rabbitmqBrokerParameters: outputs.pipes.PipeSourceParametersRabbitmqBrokerParameters;
        /**
         * The parameters for using a self-managed Apache Kafka stream as a source. Detailed below.
         */
        selfManagedKafkaParameters: outputs.pipes.PipeSourceParametersSelfManagedKafkaParameters;
        /**
         * The parameters for using a Amazon SQS stream as a source. Detailed below.
         */
        sqsQueueParameters: outputs.pipes.PipeSourceParametersSqsQueueParameters;
    }

    export interface PipeSourceParametersActivemqBrokerParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * The credentials needed to access the resource. Detailed below.
         */
        credentials: outputs.pipes.PipeSourceParametersActivemqBrokerParametersCredentials;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * The name of the destination queue to consume. Maximum length of 1000.
         */
        queueName: string;
    }

    export interface PipeSourceParametersActivemqBrokerParametersCredentials {
        /**
         * The ARN of the Secrets Manager secret containing the basic auth credentials.
         */
        basicAuth: string;
    }

    export interface PipeSourceParametersDynamodbStreamParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * Define the target queue to send dead-letter queue events to. Detailed below.
         */
        deadLetterConfig?: outputs.pipes.PipeSourceParametersDynamodbStreamParametersDeadLetterConfig;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
         */
        maximumRecordAgeInSeconds: number;
        /**
         * Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
         */
        maximumRetryAttempts?: number;
        /**
         * Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
         */
        onPartialBatchItemFailure?: string;
        /**
         * The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
         */
        parallelizationFactor: number;
        /**
         * The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
         */
        startingPosition: string;
    }

    export interface PipeSourceParametersDynamodbStreamParametersDeadLetterConfig {
        /**
         * The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
         */
        arn?: string;
    }

    export interface PipeSourceParametersFilterCriteria {
        /**
         * An array of up to 5 event patterns. Detailed below.
         */
        filters?: outputs.pipes.PipeSourceParametersFilterCriteriaFilter[];
    }

    export interface PipeSourceParametersFilterCriteriaFilter {
        /**
         * The event pattern. At most 4096 characters.
         */
        pattern: string;
    }

    export interface PipeSourceParametersKinesisStreamParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * Define the target queue to send dead-letter queue events to. Detailed below.
         */
        deadLetterConfig?: outputs.pipes.PipeSourceParametersKinesisStreamParametersDeadLetterConfig;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
         */
        maximumRecordAgeInSeconds: number;
        /**
         * Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
         */
        maximumRetryAttempts?: number;
        /**
         * Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
         */
        onPartialBatchItemFailure?: string;
        /**
         * The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
         */
        parallelizationFactor: number;
        /**
         * The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
         */
        startingPosition: string;
        /**
         * With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.
         */
        startingPositionTimestamp?: string;
    }

    export interface PipeSourceParametersKinesisStreamParametersDeadLetterConfig {
        /**
         * The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
         */
        arn?: string;
    }

    export interface PipeSourceParametersManagedStreamingKafkaParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * The name of the destination queue to consume. Maximum value of 200.
         */
        consumerGroupId?: string;
        /**
         * The credentials needed to access the resource. Detailed below.
         */
        credentials?: outputs.pipes.PipeSourceParametersManagedStreamingKafkaParametersCredentials;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
         */
        startingPosition?: string;
        /**
         * The name of the topic that the pipe will read from. Maximum length of 249.
         */
        topicName: string;
    }

    export interface PipeSourceParametersManagedStreamingKafkaParametersCredentials {
        /**
         * The ARN of the Secrets Manager secret containing the credentials.
         */
        clientCertificateTlsAuth?: string;
        /**
         * The ARN of the Secrets Manager secret containing the credentials.
         */
        saslScram512Auth?: string;
    }

    export interface PipeSourceParametersRabbitmqBrokerParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * The credentials needed to access the resource. Detailed below.
         */
        credentials: outputs.pipes.PipeSourceParametersRabbitmqBrokerParametersCredentials;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * The name of the destination queue to consume. Maximum length of 1000.
         */
        queueName: string;
        /**
         * The name of the virtual host associated with the source broker. Maximum length of 200.
         */
        virtualHost?: string;
    }

    export interface PipeSourceParametersRabbitmqBrokerParametersCredentials {
        /**
         * The ARN of the Secrets Manager secret containing the basic auth credentials.
         */
        basicAuth: string;
    }

    export interface PipeSourceParametersSelfManagedKafkaParameters {
        /**
         * An array of server URLs. Maximum number of 2 items, each of maximum length 300.
         */
        additionalBootstrapServers?: string[];
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * The name of the destination queue to consume. Maximum value of 200.
         */
        consumerGroupId?: string;
        /**
         * The credentials needed to access the resource. Detailed below.
         */
        credentials?: outputs.pipes.PipeSourceParametersSelfManagedKafkaParametersCredentials;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
        /**
         * The ARN of the Secrets Manager secret used for certification.
         */
        serverRootCaCertificate?: string;
        /**
         * The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
         */
        startingPosition?: string;
        /**
         * The name of the topic that the pipe will read from. Maximum length of 249.
         */
        topicName: string;
        /**
         * This structure specifies the VPC subnets and security groups for the stream, and whether a public IP address is to be used. Detailed below.
         */
        vpc?: outputs.pipes.PipeSourceParametersSelfManagedKafkaParametersVpc;
    }

    export interface PipeSourceParametersSelfManagedKafkaParametersCredentials {
        /**
         * The ARN of the Secrets Manager secret containing the basic auth credentials.
         */
        basicAuth: string;
        /**
         * The ARN of the Secrets Manager secret containing the credentials.
         */
        clientCertificateTlsAuth?: string;
        /**
         * The ARN of the Secrets Manager secret containing the credentials.
         */
        saslScram256Auth?: string;
        /**
         * The ARN of the Secrets Manager secret containing the credentials.
         */
        saslScram512Auth?: string;
    }

    export interface PipeSourceParametersSelfManagedKafkaParametersVpc {
        /**
         * List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
         */
        subnets?: string[];
    }

    export interface PipeSourceParametersSqsQueueParameters {
        /**
         * The maximum number of records to include in each batch. Maximum value of 10000.
         */
        batchSize: number;
        /**
         * The maximum length of a time to wait for events. Maximum value of 300.
         */
        maximumBatchingWindowInSeconds: number;
    }

    export interface PipeTargetParameters {
        /**
         * The parameters for using an AWS Batch job as a target. Detailed below.
         */
        batchJobParameters?: outputs.pipes.PipeTargetParametersBatchJobParameters;
        /**
         * The parameters for using an CloudWatch Logs log stream as a target. Detailed below.
         */
        cloudwatchLogsParameters?: outputs.pipes.PipeTargetParametersCloudwatchLogsParameters;
        /**
         * The parameters for using an Amazon ECS task as a target. Detailed below.
         */
        ecsTaskParameters?: outputs.pipes.PipeTargetParametersEcsTaskParameters;
        /**
         * The parameters for using an EventBridge event bus as a target. Detailed below.
         */
        eventbridgeEventBusParameters?: outputs.pipes.PipeTargetParametersEventbridgeEventBusParameters;
        /**
         * These are custom parameter to be used when the target is an API Gateway REST APIs or EventBridge ApiDestinations. Detailed below.
         */
        httpParameters?: outputs.pipes.PipeTargetParametersHttpParameters;
        /**
         * Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
         */
        inputTemplate?: string;
        /**
         * The parameters for using a Kinesis stream as a source. Detailed below.
         */
        kinesisStreamParameters?: outputs.pipes.PipeTargetParametersKinesisStreamParameters;
        /**
         * The parameters for using a Lambda function as a target. Detailed below.
         */
        lambdaFunctionParameters?: outputs.pipes.PipeTargetParametersLambdaFunctionParameters;
        /**
         * These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the Amazon Redshift Data API BatchExecuteStatement. Detailed below.
         */
        redshiftDataParameters?: outputs.pipes.PipeTargetParametersRedshiftDataParameters;
        /**
         * The parameters for using a SageMaker pipeline as a target. Detailed below.
         */
        sagemakerPipelineParameters?: outputs.pipes.PipeTargetParametersSagemakerPipelineParameters;
        /**
         * The parameters for using a Amazon SQS stream as a target. Detailed below.
         */
        sqsQueueParameters?: outputs.pipes.PipeTargetParametersSqsQueueParameters;
        /**
         * The parameters for using a Step Functions state machine as a target. Detailed below.
         */
        stepFunctionStateMachineParameters?: outputs.pipes.PipeTargetParametersStepFunctionStateMachineParameters;
    }

    export interface PipeTargetParametersBatchJobParameters {
        /**
         * The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an AWS Batch job. Detailed below.
         */
        arrayProperties?: outputs.pipes.PipeTargetParametersBatchJobParametersArrayProperties;
        /**
         * The overrides that are sent to a container. Detailed below.
         */
        containerOverrides?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverrides;
        /**
         * A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. You can specify a SEQUENTIAL type dependency without specifying a job ID for array jobs so that each child array job completes sequentially, starting at index 0. You can also specify an N_TO_N type dependency with a job ID for array jobs. In that case, each index child of this job must wait for the corresponding index child of each dependency to complete before it can begin. Detailed below.
         */
        dependsOns?: outputs.pipes.PipeTargetParametersBatchJobParametersDependsOn[];
        /**
         * The job definition used by this job. This value can be one of name, name:revision, or the Amazon Resource Name (ARN) for the job definition. If name is specified without a revision then the latest active revision is used.
         */
        jobDefinition: string;
        /**
         * The name of the job. It can be up to 128 letters long.
         */
        jobName: string;
        /**
         * Additional parameters passed to the job that replace parameter substitution placeholders that are set in the job definition. Parameters are specified as a key and value pair mapping. Parameters included here override any corresponding parameter defaults from the job definition. Detailed below.
         */
        parameters?: {[key: string]: string};
        /**
         * The retry strategy to use for failed jobs. When a retry strategy is specified here, it overrides the retry strategy defined in the job definition. Detailed below.
         */
        retryStrategy?: outputs.pipes.PipeTargetParametersBatchJobParametersRetryStrategy;
    }

    export interface PipeTargetParametersBatchJobParametersArrayProperties {
        /**
         * The size of the array, if this is an array batch job. Minimum value of 2. Maximum value of 10,000.
         */
        size?: number;
    }

    export interface PipeTargetParametersBatchJobParametersContainerOverrides {
        /**
         * List of commands to send to the container that overrides the default command from the Docker image or the task definition.
         */
        commands?: string[];
        /**
         * The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
         */
        environments?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverridesEnvironment[];
        /**
         * The instance type to use for a multi-node parallel job. This parameter isn't applicable to single-node container jobs or jobs that run on Fargate resources, and shouldn't be provided.
         */
        instanceType?: string;
        /**
         * The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
         */
        resourceRequirements?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirement[];
    }

    export interface PipeTargetParametersBatchJobParametersContainerOverridesEnvironment {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value?: string;
    }

    export interface PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirement {
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }

    export interface PipeTargetParametersBatchJobParametersDependsOn {
        /**
         * The job ID of the AWS Batch job that's associated with this dependency.
         */
        jobId?: string;
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type?: string;
    }

    export interface PipeTargetParametersBatchJobParametersRetryStrategy {
        /**
         * The number of times to move a job to the RUNNABLE status. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Maximum value of 10.
         */
        attempts?: number;
    }

    export interface PipeTargetParametersCloudwatchLogsParameters {
        /**
         * The name of the log stream.
         */
        logStreamName?: string;
        /**
         * The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. This is the JSON path to the field in the event e.g. $.detail.timestamp
         */
        timestamp?: string;
    }

    export interface PipeTargetParametersEcsTaskParameters {
        /**
         * List of capacity provider strategies to use for the task. If a capacityProviderStrategy is specified, the launchType parameter must be omitted. If no capacityProviderStrategy or launchType is specified, the defaultCapacityProviderStrategy for the cluster is used. Detailed below.
         */
        capacityProviderStrategies?: outputs.pipes.PipeTargetParametersEcsTaskParametersCapacityProviderStrategy[];
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task. Valid values: true, false.
         */
        enableEcsManagedTags?: boolean;
        /**
         * Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task. Valid values: true, false.
         */
        enableExecuteCommand?: boolean;
        /**
         * Specifies an Amazon ECS task group for the task. The maximum length is 255 characters.
         */
        group?: string;
        /**
         * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. Valid Values: EC2, FARGATE, EXTERNAL
         */
        launchType?: string;
        /**
         * Use this structure if the Amazon ECS task uses the awsvpc network mode. This structure specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. This structure is required if LaunchType is FARGATE because the awsvpc mode is required for Fargate tasks. If you specify NetworkConfiguration when the target ECS task does not use the awsvpc network mode, the task fails. Detailed below.
         */
        networkConfiguration?: outputs.pipes.PipeTargetParametersEcsTaskParametersNetworkConfiguration;
        /**
         * The overrides that are associated with a task. Detailed below.
         */
        overrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverrides;
        /**
         * An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). Detailed below.
         */
        placementConstraints?: outputs.pipes.PipeTargetParametersEcsTaskParametersPlacementConstraint[];
        /**
         * The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task. Detailed below.
         */
        placementStrategies?: outputs.pipes.PipeTargetParametersEcsTaskParametersPlacementStrategy[];
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0. This structure is used only if LaunchType is FARGATE.
         */
        platformVersion?: string;
        /**
         * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action. Valid Values: TASK_DEFINITION
         */
        propagateTags?: string;
        /**
         * The reference ID to use for the task. Maximum length of 1,024.
         */
        referenceId?: string;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {[key: string]: string};
        /**
         * The number of tasks to create based on TaskDefinition. The default is 1.
         */
        taskCount?: number;
        /**
         * The ARN of the task definition to use if the event target is an Amazon ECS task.
         */
        taskDefinitionArn: string;
    }

    export interface PipeTargetParametersEcsTaskParametersCapacityProviderStrategy {
        /**
         * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used. Maximum value of 100,000.
         */
        base?: number;
        /**
         * The short name of the capacity provider. Maximum value of 255.
         */
        capacityProvider: string;
        /**
         * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Maximum value of 1,000.
         */
        weight?: number;
    }

    export interface PipeTargetParametersEcsTaskParametersNetworkConfiguration {
        /**
         * Use this structure to specify the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode. Detailed below.
         */
        awsVpcConfiguration?: outputs.pipes.PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfiguration;
    }

    export interface PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfiguration {
        /**
         * Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE. Valid Values: ENABLED, DISABLED.
         */
        assignPublicIp?: string;
        /**
         * List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
         */
        subnets?: string[];
    }

    export interface PipeTargetParametersEcsTaskParametersOverrides {
        /**
         * One or more container overrides that are sent to a task. Detailed below.
         */
        containerOverrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverride[];
        /**
         * The cpu override for the task.
         */
        cpu?: string;
        /**
         * The ephemeral storage setting override for the task.  Detailed below.
         */
        ephemeralStorage?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesEphemeralStorage;
        /**
         * The Amazon Resource Name (ARN) of the task execution IAM role override for the task.
         */
        executionRoleArn?: string;
        /**
         * List of Elastic Inference accelerator overrides for the task. Detailed below.
         */
        inferenceAcceleratorOverrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverride[];
        /**
         * The memory override for the task.
         */
        memory?: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.
         */
        taskRoleArn?: string;
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesContainerOverride {
        /**
         * List of commands to send to the container that overrides the default command from the Docker image or the task definition.
         */
        commands?: string[];
        /**
         * The cpu override for the task.
         */
        cpu?: number;
        /**
         * A list of files containing the environment variables to pass to a container, instead of the value from the container definition. Detailed below.
         */
        environmentFiles?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFile[];
        /**
         * The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
         */
        environments?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironment[];
        /**
         * The memory override for the task.
         */
        memory?: number;
        /**
         * The soft limit (in MiB) of memory to reserve for the container, instead of the default value from the task definition. You must also specify a container name.
         */
        memoryReservation?: number;
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        /**
         * The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
         */
        resourceRequirements?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirement[];
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironment {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value?: string;
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFile {
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirement {
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesEphemeralStorage {
        /**
         * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is 21 GiB and the maximum supported value is 200 GiB.
         */
        sizeInGib: number;
    }

    export interface PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverride {
        /**
         * The Elastic Inference accelerator device name to override for the task. This parameter must match a deviceName specified in the task definition.
         */
        deviceName?: string;
        /**
         * The Elastic Inference accelerator type to use.
         */
        deviceType?: string;
    }

    export interface PipeTargetParametersEcsTaskParametersPlacementConstraint {
        /**
         * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. Maximum length of 2,000.
         */
        expression?: string;
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type?: string;
    }

    export interface PipeTargetParametersEcsTaskParametersPlacementStrategy {
        /**
         * The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used. Maximum length of 255.
         */
        field?: string;
        /**
         * The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
         */
        type?: string;
    }

    export interface PipeTargetParametersEventbridgeEventBusParameters {
        /**
         * A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
         */
        detailType?: string;
        /**
         * The URL subdomain of the endpoint. For example, if the URL for Endpoint is https://abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
         */
        endpointId?: string;
        /**
         * List of AWS resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
         */
        resources?: string[];
        /**
         * Source resource of the pipe (typically an ARN).
         */
        source?: string;
        /**
         * The time stamp of the event, per RFC3339. If no time stamp is provided, the time stamp of the PutEvents call is used. This is the JSON path to the field in the event e.g. $.detail.timestamp
         */
        time?: string;
    }

    export interface PipeTargetParametersHttpParameters {
        /**
         * Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
         */
        headerParameters?: {[key: string]: string};
        /**
         * The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
         */
        pathParameterValues?: string;
        /**
         * Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
         */
        queryStringParameters?: {[key: string]: string};
    }

    export interface PipeTargetParametersKinesisStreamParameters {
        /**
         * Determines which shard in the stream the data record is assigned to. Partition keys are Unicode strings with a maximum length limit of 256 characters for each key. Amazon Kinesis Data Streams uses the partition key as input to a hash function that maps the partition key and associated data to a specific shard. Specifically, an MD5 hash function is used to map partition keys to 128-bit integer values and to map associated data records to shards. As a result of this hashing mechanism, all data records with the same partition key map to the same shard within the stream.
         */
        partitionKey: string;
    }

    export interface PipeTargetParametersLambdaFunctionParameters {
        /**
         * Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
         */
        invocationType: string;
    }

    export interface PipeTargetParametersRedshiftDataParameters {
        /**
         * The name of the database. Required when authenticating using temporary credentials.
         */
        database: string;
        /**
         * The database user name. Required when authenticating using temporary credentials.
         */
        dbUser?: string;
        /**
         * The name or ARN of the secret that enables access to the database. Required when authenticating using Secrets Manager.
         */
        secretManagerArn?: string;
        /**
         * List of SQL statements text to run, each of maximum length of 100,000.
         */
        sqls: string[];
        /**
         * The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
         */
        statementName?: string;
        /**
         * Indicates whether to send an event back to EventBridge after the SQL statement runs.
         */
        withEvent?: boolean;
    }

    export interface PipeTargetParametersSagemakerPipelineParameters {
        /**
         * List of Parameter names and values for SageMaker Model Building Pipeline execution. Detailed below.
         */
        pipelineParameters?: outputs.pipes.PipeTargetParametersSagemakerPipelineParametersPipelineParameter[];
    }

    export interface PipeTargetParametersSagemakerPipelineParametersPipelineParameter {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }

    export interface PipeTargetParametersSqsQueueParameters {
        /**
         * This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of sent messages.
         */
        messageDeduplicationId?: string;
        /**
         * The FIFO message group ID to use as the target.
         */
        messageGroupId?: string;
    }

    export interface PipeTargetParametersStepFunctionStateMachineParameters {
        /**
         * Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
         */
        invocationType: string;
    }

}

export namespace pricing {
    export interface GetProductFilter {
        /**
         * Product attribute name that you want to filter on.
         */
        field: string;
        /**
         * Product attribute value that you want to filter on.
         */
        value: string;
    }

}

export namespace qldb {
    export interface StreamKinesisConfiguration {
        /**
         * Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the number of records sent per API call. Default: `true`.
         */
        aggregationEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.
         */
        streamArn: string;
    }

}

export namespace quicksight {
    export interface AnalysisParameters {
        /**
         * A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
         */
        dateTimeParameters?: outputs.quicksight.AnalysisParametersDateTimeParameter[];
        /**
         * A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
         */
        decimalParameters?: outputs.quicksight.AnalysisParametersDecimalParameter[];
        /**
         * A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
         */
        integerParameters?: outputs.quicksight.AnalysisParametersIntegerParameter[];
        /**
         * A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
         */
        stringParameters?: outputs.quicksight.AnalysisParametersStringParameter[];
    }

    export interface AnalysisParametersDateTimeParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }

    export interface AnalysisParametersDecimalParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: number[];
    }

    export interface AnalysisParametersIntegerParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: number[];
    }

    export interface AnalysisParametersStringParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }

    export interface AnalysisPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface AnalysisSourceEntity {
        /**
         * The source template. See source_template.
         */
        sourceTemplate?: outputs.quicksight.AnalysisSourceEntitySourceTemplate;
    }

    export interface AnalysisSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * List of dataset references. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.AnalysisSourceEntitySourceTemplateDataSetReference[];
    }

    export interface AnalysisSourceEntitySourceTemplateDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }

    export interface DashboardDashboardPublishOptions {
        /**
         * Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
         */
        adHocFilteringOption?: outputs.quicksight.DashboardDashboardPublishOptionsAdHocFilteringOption;
        /**
         * The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
         */
        dataPointDrillUpDownOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointDrillUpDownOption;
        /**
         * The data point menu label options of a dashboard. See data_point_menu_label_option.
         */
        dataPointMenuLabelOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointMenuLabelOption;
        /**
         * The data point tool tip options of a dashboard. See data_point_tooltip_option.
         */
        dataPointTooltipOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointTooltipOption;
        /**
         * Export to .csv option. See export_to_csv_option.
         */
        exportToCsvOption?: outputs.quicksight.DashboardDashboardPublishOptionsExportToCsvOption;
        /**
         * Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
         */
        exportWithHiddenFieldsOption?: outputs.quicksight.DashboardDashboardPublishOptionsExportWithHiddenFieldsOption;
        /**
         * Sheet controls option. See sheet_controls_option.
         */
        sheetControlsOption?: outputs.quicksight.DashboardDashboardPublishOptionsSheetControlsOption;
        /**
         * The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
         */
        sheetLayoutElementMaximizationOption?: outputs.quicksight.DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption;
        /**
         * The axis sort options of a dashboard. See visual_axis_sort_option.
         */
        visualAxisSortOption?: outputs.quicksight.DashboardDashboardPublishOptionsVisualAxisSortOption;
        /**
         * The menu options of a visual in a dashboard. See visual_menu_option.
         */
        visualMenuOption?: outputs.quicksight.DashboardDashboardPublishOptionsVisualMenuOption;
    }

    export interface DashboardDashboardPublishOptionsAdHocFilteringOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsDataPointDrillUpDownOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsDataPointMenuLabelOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsDataPointTooltipOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsExportToCsvOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsExportWithHiddenFieldsOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsSheetControlsOption {
        /**
         * Visibility state. Possibles values: EXPANDED, COLLAPSED.
         */
        visibilityState?: string;
    }

    export interface DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsVisualAxisSortOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardDashboardPublishOptionsVisualMenuOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }

    export interface DashboardParameters {
        /**
         * A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
         */
        dateTimeParameters?: outputs.quicksight.DashboardParametersDateTimeParameter[];
        /**
         * A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
         */
        decimalParameters?: outputs.quicksight.DashboardParametersDecimalParameter[];
        /**
         * A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
         */
        integerParameters?: outputs.quicksight.DashboardParametersIntegerParameter[];
        /**
         * A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
         */
        stringParameters?: outputs.quicksight.DashboardParametersStringParameter[];
    }

    export interface DashboardParametersDateTimeParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: string[];
    }

    export interface DashboardParametersDecimalParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: number[];
    }

    export interface DashboardParametersIntegerParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: number[];
    }

    export interface DashboardParametersStringParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: string[];
    }

    export interface DashboardPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface DashboardSourceEntity {
        /**
         * The source template. See source_template.
         */
        sourceTemplate?: outputs.quicksight.DashboardSourceEntitySourceTemplate;
    }

    export interface DashboardSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * List of dataset references. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.DashboardSourceEntitySourceTemplateDataSetReference[];
    }

    export interface DashboardSourceEntitySourceTemplateDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }

    export interface DataSetColumnGroup {
        /**
         * Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
         */
        geoSpatialColumnGroup?: outputs.quicksight.DataSetColumnGroupGeoSpatialColumnGroup;
    }

    export interface DataSetColumnGroupGeoSpatialColumnGroup {
        /**
         * Columns in this hierarchy.
         */
        columns: string[];
        /**
         * Country code. Valid values are `US`.
         */
        countryCode: string;
        /**
         * A display name for the hierarchy.
         */
        name: string;
    }

    export interface DataSetColumnLevelPermissionRule {
        /**
         * An array of column names.
         */
        columnNames?: string[];
        /**
         * An array of ARNs for Amazon QuickSight users or groups.
         */
        principals?: string[];
    }

    export interface DataSetDataSetUsageConfiguration {
        /**
         * Controls whether a child dataset of a direct query can use this dataset as a source.
         */
        disableUseAsDirectQuerySource: boolean;
        /**
         * Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
         */
        disableUseAsImportedSource: boolean;
    }

    export interface DataSetFieldFolder {
        /**
         * An array of column names to add to the folder. A column can only be in one folder.
         */
        columns?: string[];
        /**
         * Field folder description.
         */
        description?: string;
        /**
         * Key of the field folder map.
         */
        fieldFoldersId: string;
    }

    export interface DataSetLogicalTableMap {
        /**
         * A display name for the logical table.
         */
        alias: string;
        /**
         * Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
         */
        dataTransforms: outputs.quicksight.DataSetLogicalTableMapDataTransform[];
        /**
         * Key of the logical table map.
         */
        logicalTableMapId: string;
        /**
         * Source of this logical table. See source.
         */
        source: outputs.quicksight.DataSetLogicalTableMapSource;
    }

    export interface DataSetLogicalTableMapDataTransform {
        /**
         * A transform operation that casts a column to a different type. See cast_column_type_operation.
         */
        castColumnTypeOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformCastColumnTypeOperation;
        /**
         * An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
         */
        createColumnsOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformCreateColumnsOperation;
        /**
         * An operation that filters rows based on some condition. See filter_operation.
         */
        filterOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformFilterOperation;
        /**
         * An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
         */
        projectOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformProjectOperation;
        /**
         * An operation that renames a column. See rename_column_operation.
         */
        renameColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformRenameColumnOperation;
        /**
         * An operation that tags a column with additional information. See tag_column_operation.
         */
        tagColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperation;
        /**
         * A transform operation that removes tags associated with a column. See untag_column_operation.
         */
        untagColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformUntagColumnOperation;
    }

    export interface DataSetLogicalTableMapDataTransformCastColumnTypeOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
         */
        format: string;
        /**
         * New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
         */
        newColumnType: string;
    }

    export interface DataSetLogicalTableMapDataTransformCreateColumnsOperation {
        /**
         * Calculated columns to create. See columns.
         */
        columns: outputs.quicksight.DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn[];
    }

    export interface DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn {
        /**
         * A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
         */
        columnId: string;
        /**
         * Column name.
         */
        columnName: string;
        /**
         * An expression that defines the calculated column.
         */
        expression: string;
    }

    export interface DataSetLogicalTableMapDataTransformFilterOperation {
        /**
         * An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
         */
        conditionExpression: string;
    }

    export interface DataSetLogicalTableMapDataTransformProjectOperation {
        /**
         * Projected columns.
         */
        projectedColumns: string[];
    }

    export interface DataSetLogicalTableMapDataTransformRenameColumnOperation {
        /**
         * Column to be renamed.
         */
        columnName: string;
        /**
         * New name for the column.
         */
        newColumnName: string;
    }

    export interface DataSetLogicalTableMapDataTransformTagColumnOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * The dataset column tag, currently only used for geospatial type tagging. See tags.
         */
        tags: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperationTag[];
    }

    export interface DataSetLogicalTableMapDataTransformTagColumnOperationTag {
        /**
         * A description for a column. See column_description.
         */
        columnDescription: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription;
        /**
         * A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
         */
        columnGeographicRole: string;
    }

    export interface DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription {
        /**
         * The text of a description for a column.
         */
        text: string;
    }

    export interface DataSetLogicalTableMapDataTransformUntagColumnOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * The column tags to remove from this column.
         */
        tagNames: string[];
    }

    export interface DataSetLogicalTableMapSource {
        /**
         * ARN of the parent data set.
         */
        dataSetArn: string;
        /**
         * Specifies the result of a join of two logical tables. See join_instruction.
         */
        joinInstruction: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstruction;
        /**
         * Physical table ID.
         */
        physicalTableId: string;
    }

    export interface DataSetLogicalTableMapSourceJoinInstruction {
        /**
         * Join key properties of the left operand. See left_join_key_properties.
         */
        leftJoinKeyProperties: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties;
        /**
         * Operand on the left side of a join.
         */
        leftOperand: string;
        /**
         * Join instructions provided in the ON clause of a join.
         */
        onClause: string;
        /**
         * Join key properties of the right operand. See right_join_key_properties.
         */
        rightJoinKeyProperties: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties;
        /**
         * Operand on the right side of a join.
         */
        rightOperand: string;
        /**
         * Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
         */
        type: string;
    }

    export interface DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties {
        /**
         * A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
         */
        uniqueKey: boolean;
    }

    export interface DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties {
        /**
         * A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
         */
        uniqueKey: boolean;
    }

    export interface DataSetOutputColumn {
        /**
         * Field folder description.
         */
        description: string;
        /**
         * Display name for the dataset.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }

    export interface DataSetPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface DataSetPhysicalTableMap {
        /**
         * A physical table type built from the results of the custom SQL query. See custom_sql.
         */
        customSql?: outputs.quicksight.DataSetPhysicalTableMapCustomSql;
        /**
         * Key of the physical table map.
         */
        physicalTableMapId: string;
        /**
         * A physical table type for relational data sources. See relational_table.
         */
        relationalTable?: outputs.quicksight.DataSetPhysicalTableMapRelationalTable;
        /**
         * A physical table type for as S3 data source. See s3_source.
         */
        s3Source: outputs.quicksight.DataSetPhysicalTableMapS3Source;
    }

    export interface DataSetPhysicalTableMapCustomSql {
        /**
         * Column schema from the SQL query result set. See columns.
         */
        columns?: outputs.quicksight.DataSetPhysicalTableMapCustomSqlColumn[];
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Display name for the SQL query result.
         */
        name: string;
        /**
         * SQL query.
         */
        sqlQuery: string;
    }

    export interface DataSetPhysicalTableMapCustomSqlColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }

    export interface DataSetPhysicalTableMapRelationalTable {
        /**
         * Catalog associated with the table.
         */
        catalog?: string;
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Column schema of the table. See input_columns.
         */
        inputColumns: outputs.quicksight.DataSetPhysicalTableMapRelationalTableInputColumn[];
        /**
         * Name of the relational table.
         */
        name: string;
        /**
         * Schema name. This name applies to certain relational database engines.
         */
        schema?: string;
    }

    export interface DataSetPhysicalTableMapRelationalTableInputColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }

    export interface DataSetPhysicalTableMapS3Source {
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Column schema of the table. See input_columns.
         */
        inputColumns: outputs.quicksight.DataSetPhysicalTableMapS3SourceInputColumn[];
        /**
         * Information about the format for the S3 source file or files. See upload_settings.
         */
        uploadSettings: outputs.quicksight.DataSetPhysicalTableMapS3SourceUploadSettings;
    }

    export interface DataSetPhysicalTableMapS3SourceInputColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }

    export interface DataSetPhysicalTableMapS3SourceUploadSettings {
        /**
         * Whether the file has a header row, or the files each have a header row.
         */
        containsHeader: boolean;
        /**
         * Delimiter between values in the file.
         */
        delimiter: string;
        /**
         * File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
         */
        format: string;
        /**
         * A row number to start reading data from.
         */
        startFromRow: number;
        /**
         * Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
         */
        textQualifier: string;
    }

    export interface DataSetRefreshProperties {
        /**
         * The refresh configuration for the data set. See refresh_configuration.
         */
        refreshConfiguration: outputs.quicksight.DataSetRefreshPropertiesRefreshConfiguration;
    }

    export interface DataSetRefreshPropertiesRefreshConfiguration {
        /**
         * The incremental refresh for the data set. See incremental_refresh.
         */
        incrementalRefresh: outputs.quicksight.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh;
    }

    export interface DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh {
        /**
         * The lookback window setup for an incremental refresh configuration. See lookback_window.
         */
        lookbackWindow: outputs.quicksight.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow;
    }

    export interface DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow {
        /**
         * The name of the lookback window column.
         */
        columnName: string;
        /**
         * The lookback window column size.
         */
        size: number;
        /**
         * The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
         */
        sizeUnit: string;
    }

    export interface DataSetRowLevelPermissionDataSet {
        /**
         * ARN of the dataset that contains permissions for RLS.
         */
        arn: string;
        /**
         * User or group rules associated with the dataset that contains permissions for RLS.
         */
        formatVersion?: string;
        /**
         * Namespace associated with the dataset that contains permissions for RLS.
         */
        namespace?: string;
        /**
         * Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
         */
        permissionPolicy: string;
        /**
         * Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
         */
        status?: string;
    }

    export interface DataSetRowLevelPermissionTagConfiguration {
        /**
         * The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
         */
        status?: string;
        /**
         * A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
         */
        tagRules: outputs.quicksight.DataSetRowLevelPermissionTagConfigurationTagRule[];
    }

    export interface DataSetRowLevelPermissionTagConfigurationTagRule {
        /**
         * Column name that a tag key is assigned to.
         */
        columnName: string;
        /**
         * A string that you want to use to filter by all the values in a column in the dataset and don’t want to list the values one by one.
         */
        matchAllValue?: string;
        /**
         * Unique key for a tag.
         */
        tagKey: string;
        /**
         * A string that you want to use to delimit the values when you pass the values at run time.
         */
        tagMultiValueDelimiter?: string;
    }

    export interface DataSourceCredentials {
        /**
         * The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
         * When the value is not null, the `credentialPair` from the data source in the ARN is used.
         */
        copySourceArn?: string;
        /**
         * Credential pair. See Credential Pair below for more details.
         */
        credentialPair?: outputs.quicksight.DataSourceCredentialsCredentialPair;
    }

    export interface DataSourceCredentialsCredentialPair {
        /**
         * Password, maximum length of 1024 characters.
         */
        password: string;
        /**
         * User name, maximum length of 64 characters.
         */
        username: string;
    }

    export interface DataSourceParameters {
        /**
         * Parameters for connecting to Amazon Elasticsearch.
         */
        amazonElasticsearch?: outputs.quicksight.DataSourceParametersAmazonElasticsearch;
        /**
         * Parameters for connecting to Athena.
         */
        athena?: outputs.quicksight.DataSourceParametersAthena;
        /**
         * Parameters for connecting to Aurora MySQL.
         */
        aurora?: outputs.quicksight.DataSourceParametersAurora;
        /**
         * Parameters for connecting to Aurora Postgresql.
         */
        auroraPostgresql?: outputs.quicksight.DataSourceParametersAuroraPostgresql;
        /**
         * Parameters for connecting to AWS IOT Analytics.
         */
        awsIotAnalytics?: outputs.quicksight.DataSourceParametersAwsIotAnalytics;
        /**
         * Parameters for connecting to Jira.
         */
        jira?: outputs.quicksight.DataSourceParametersJira;
        /**
         * Parameters for connecting to MariaDB.
         */
        mariaDb?: outputs.quicksight.DataSourceParametersMariaDb;
        /**
         * Parameters for connecting to MySQL.
         */
        mysql?: outputs.quicksight.DataSourceParametersMysql;
        /**
         * Parameters for connecting to Oracle.
         */
        oracle?: outputs.quicksight.DataSourceParametersOracle;
        /**
         * Parameters for connecting to Postgresql.
         */
        postgresql?: outputs.quicksight.DataSourceParametersPostgresql;
        /**
         * Parameters for connecting to Presto.
         */
        presto?: outputs.quicksight.DataSourceParametersPresto;
        /**
         * Parameters for connecting to RDS.
         */
        rds?: outputs.quicksight.DataSourceParametersRds;
        /**
         * Parameters for connecting to Redshift.
         */
        redshift?: outputs.quicksight.DataSourceParametersRedshift;
        /**
         * Parameters for connecting to S3.
         */
        s3?: outputs.quicksight.DataSourceParametersS3;
        /**
         * Parameters for connecting to ServiceNow.
         */
        serviceNow?: outputs.quicksight.DataSourceParametersServiceNow;
        /**
         * Parameters for connecting to Snowflake.
         */
        snowflake?: outputs.quicksight.DataSourceParametersSnowflake;
        /**
         * Parameters for connecting to Spark.
         */
        spark?: outputs.quicksight.DataSourceParametersSpark;
        /**
         * Parameters for connecting to SQL Server.
         */
        sqlServer?: outputs.quicksight.DataSourceParametersSqlServer;
        /**
         * Parameters for connecting to Teradata.
         */
        teradata?: outputs.quicksight.DataSourceParametersTeradata;
        /**
         * Parameters for connecting to Twitter.
         */
        twitter?: outputs.quicksight.DataSourceParametersTwitter;
    }

    export interface DataSourceParametersAmazonElasticsearch {
        /**
         * The OpenSearch domain.
         */
        domain: string;
    }

    export interface DataSourceParametersAthena {
        /**
         * The work-group to which to connect.
         */
        workGroup?: string;
    }

    export interface DataSourceParametersAurora {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersAuroraPostgresql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersAwsIotAnalytics {
        /**
         * The name of the data set to which to connect.
         */
        dataSetName: string;
    }

    export interface DataSourceParametersJira {
        /**
         * The base URL of the Jira instance's site to which to connect.
         */
        siteBaseUrl: string;
    }

    export interface DataSourceParametersMariaDb {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersMysql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersOracle {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersPostgresql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersPresto {
        /**
         * The catalog to which to connect.
         */
        catalog: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersRds {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The instance ID to which to connect.
         */
        instanceId: string;
    }

    export interface DataSourceParametersRedshift {
        /**
         * The ID of the cluster to which to connect.
         */
        clusterId?: string;
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host?: string;
        /**
         * The port to which to connect.
         */
        port?: number;
    }

    export interface DataSourceParametersS3 {
        /**
         * An object containing the S3 location of the S3 manifest file.
         */
        manifestFileLocation: outputs.quicksight.DataSourceParametersS3ManifestFileLocation;
    }

    export interface DataSourceParametersS3ManifestFileLocation {
        /**
         * The name of the bucket that contains the manifest file.
         */
        bucket: string;
        /**
         * The key of the manifest file within the bucket.
         */
        key: string;
    }

    export interface DataSourceParametersServiceNow {
        /**
         * The base URL of the Jira instance's site to which to connect.
         */
        siteBaseUrl: string;
    }

    export interface DataSourceParametersSnowflake {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        warehouse: string;
    }

    export interface DataSourceParametersSpark {
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersSqlServer {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersTeradata {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }

    export interface DataSourceParametersTwitter {
        /**
         * The maximum number of rows to query.
         */
        maxRows: number;
        /**
         * The Twitter query to retrieve the data.
         */
        query: string;
    }

    export interface DataSourcePermission {
        /**
         * Set of IAM actions to grant or revoke permissions on. Max of 16 items.
         */
        actions: string[];
        /**
         * The Amazon Resource Name (ARN) of the principal.
         */
        principal: string;
    }

    export interface DataSourceSslProperties {
        /**
         * A Boolean option to control whether SSL should be disabled.
         */
        disableSsl: boolean;
    }

    export interface DataSourceVpcConnectionProperties {
        /**
         * The Amazon Resource Name (ARN) for the VPC connection.
         */
        vpcConnectionArn: string;
    }

    export interface FolderPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface GetDataSetColumnGroup {
        geoSpatialColumnGroups: outputs.quicksight.GetDataSetColumnGroupGeoSpatialColumnGroup[];
    }

    export interface GetDataSetColumnGroupGeoSpatialColumnGroup {
        columns: string[];
        countryCode: string;
        name: string;
    }

    export interface GetDataSetColumnLevelPermissionRule {
        columnNames: string[];
        principals: string[];
    }

    export interface GetDataSetDataSetUsageConfiguration {
        disableUseAsDirectQuerySource: boolean;
        disableUseAsImportedSource: boolean;
    }

    export interface GetDataSetFieldFolder {
        columns: string[];
        description: string;
        fieldFoldersId: string;
    }

    export interface GetDataSetLogicalTableMap {
        alias: string;
        dataTransforms: outputs.quicksight.GetDataSetLogicalTableMapDataTransform[];
        logicalTableMapId: string;
        sources: outputs.quicksight.GetDataSetLogicalTableMapSource[];
    }

    export interface GetDataSetLogicalTableMapDataTransform {
        castColumnTypeOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCastColumnTypeOperation[];
        createColumnsOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCreateColumnsOperation[];
        filterOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformFilterOperation[];
        projectOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformProjectOperation[];
        renameColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformRenameColumnOperation[];
        tagColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperation[];
        untagColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformUntagColumnOperation[];
    }

    export interface GetDataSetLogicalTableMapDataTransformCastColumnTypeOperation {
        columnName: string;
        format: string;
        newColumnType: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformCreateColumnsOperation {
        columns: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumn[];
    }

    export interface GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumn {
        columnId: string;
        columnName: string;
        expression: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformFilterOperation {
        conditionExpression: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformProjectOperation {
        projectedColumns: string[];
    }

    export interface GetDataSetLogicalTableMapDataTransformRenameColumnOperation {
        columnName: string;
        newColumnName: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformTagColumnOperation {
        columnName: string;
        tags: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperationTag[];
    }

    export interface GetDataSetLogicalTableMapDataTransformTagColumnOperationTag {
        columnDescriptions: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription[];
        columnGeographicRole: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription {
        text: string;
    }

    export interface GetDataSetLogicalTableMapDataTransformUntagColumnOperation {
        columnName: string;
        tagNames: string[];
    }

    export interface GetDataSetLogicalTableMapSource {
        dataSetArn: string;
        joinInstructions: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstruction[];
        physicalTableId: string;
    }

    export interface GetDataSetLogicalTableMapSourceJoinInstruction {
        leftJoinKeyProperties: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperty[];
        leftOperand: string;
        onClause: string;
        rightJoinKeyProperties: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperty[];
        rightOperand: string;
        type: string;
    }

    export interface GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperty {
        uniqueKey: boolean;
    }

    export interface GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperty {
        uniqueKey: boolean;
    }

    export interface GetDataSetPermission {
        actions: string[];
        principal: string;
    }

    export interface GetDataSetPhysicalTableMap {
        customSqls: outputs.quicksight.GetDataSetPhysicalTableMapCustomSql[];
        physicalTableMapId: string;
        relationalTables: outputs.quicksight.GetDataSetPhysicalTableMapRelationalTable[];
        s3Sources: outputs.quicksight.GetDataSetPhysicalTableMapS3Source[];
    }

    export interface GetDataSetPhysicalTableMapCustomSql {
        columns: outputs.quicksight.GetDataSetPhysicalTableMapCustomSqlColumn[];
        dataSourceArn: string;
        name: string;
        sqlQuery: string;
    }

    export interface GetDataSetPhysicalTableMapCustomSqlColumn {
        name: string;
        type: string;
    }

    export interface GetDataSetPhysicalTableMapRelationalTable {
        catalog: string;
        dataSourceArn: string;
        inputColumns: outputs.quicksight.GetDataSetPhysicalTableMapRelationalTableInputColumn[];
        name: string;
        schema: string;
    }

    export interface GetDataSetPhysicalTableMapRelationalTableInputColumn {
        name: string;
        type: string;
    }

    export interface GetDataSetPhysicalTableMapS3Source {
        dataSourceArn: string;
        inputColumns: outputs.quicksight.GetDataSetPhysicalTableMapS3SourceInputColumn[];
        uploadSettings: outputs.quicksight.GetDataSetPhysicalTableMapS3SourceUploadSetting[];
    }

    export interface GetDataSetPhysicalTableMapS3SourceInputColumn {
        name: string;
        type: string;
    }

    export interface GetDataSetPhysicalTableMapS3SourceUploadSetting {
        containsHeader: boolean;
        delimiter: string;
        format: string;
        startFromRow: number;
        textQualifier: string;
    }

    export interface GetDataSetRowLevelPermissionDataSet {
        arn: string;
        formatVersion: string;
        namespace: string;
        permissionPolicy: string;
        status: string;
    }

    export interface GetDataSetRowLevelPermissionTagConfiguration {
        status: string;
        tagRules: outputs.quicksight.GetDataSetRowLevelPermissionTagConfigurationTagRule[];
    }

    export interface GetDataSetRowLevelPermissionTagConfigurationTagRule {
        columnName: string;
        matchAllValue: string;
        tagKey: string;
        tagMultiValueDelimiter: string;
    }

    export interface GetThemeConfiguration {
        /**
         * Color properties that apply to chart data colors. See data_color_palette.
         */
        dataColorPalettes: outputs.quicksight.GetThemeConfigurationDataColorPalette[];
        /**
         * Display options related to sheets. See sheet.
         */
        sheets: outputs.quicksight.GetThemeConfigurationSheet[];
        /**
         * Determines the typography options. See typography.
         */
        typographies: outputs.quicksight.GetThemeConfigurationTypography[];
        /**
         * Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
         */
        uiColorPalettes: outputs.quicksight.GetThemeConfigurationUiColorPalette[];
    }

    export interface GetThemeConfigurationDataColorPalette {
        /**
         * List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
         */
        colors: string[];
        /**
         * The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
         */
        emptyFillColor: string;
        /**
         * The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
         */
        minMaxGradients: string[];
    }

    export interface GetThemeConfigurationSheet {
        /**
         * The layout options for tiles. See tile_layout.
         */
        tileLayouts: outputs.quicksight.GetThemeConfigurationSheetTileLayout[];
        /**
         * The display options for tiles. See tile.
         */
        tiles: outputs.quicksight.GetThemeConfigurationSheetTile[];
    }

    export interface GetThemeConfigurationSheetTile {
        /**
         * The border around a tile. See border.
         */
        borders: outputs.quicksight.GetThemeConfigurationSheetTileBorder[];
    }

    export interface GetThemeConfigurationSheetTileBorder {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }

    export interface GetThemeConfigurationSheetTileLayout {
        /**
         * The gutter settings that apply between tiles. See gutter.
         */
        gutters: outputs.quicksight.GetThemeConfigurationSheetTileLayoutGutter[];
        /**
         * The margin settings that apply around the outside edge of sheets. See margin.
         */
        margins: outputs.quicksight.GetThemeConfigurationSheetTileLayoutMargin[];
    }

    export interface GetThemeConfigurationSheetTileLayoutGutter {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }

    export interface GetThemeConfigurationSheetTileLayoutMargin {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }

    export interface GetThemeConfigurationTypography {
        /**
         * Determines the list of font families. Maximum number of 5 items. See font_families.
         */
        fontFamilies: outputs.quicksight.GetThemeConfigurationTypographyFontFamily[];
    }

    export interface GetThemeConfigurationTypographyFontFamily {
        /**
         * Font family name.
         */
        fontFamily: string;
    }

    export interface GetThemeConfigurationUiColorPalette {
        /**
         * Color (hexadecimal) that applies to selected states and buttons.
         */
        accent: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
         */
        accentForeground: string;
        /**
         * Color (hexadecimal) that applies to error messages.
         */
        danger: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the error color.
         */
        dangerForeground: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
         */
        dimension: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
         */
        dimensionForeground: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as measures.
         */
        measure: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
         */
        measureForeground: string;
        /**
         * Color (hexadecimal) that applies to visuals and other high emphasis UI.
         */
        primaryBackground: string;
        /**
         * Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
         */
        primaryForeground: string;
        /**
         * Color (hexadecimal) that applies to the sheet background and sheet controls.
         */
        secondaryBackground: string;
        /**
         * Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
         */
        secondaryForeground: string;
        /**
         * Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
         */
        success: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the success color.
         */
        successForeground: string;
        /**
         * Color (hexadecimal) that applies to warning and informational messages.
         */
        warning: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
         */
        warningForeground: string;
    }

    export interface GetThemePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface IamPolicyAssignmentIdentities {
        groups?: string[];
        /**
         * Array of Quicksight user names to assign the policy to.
         */
        users?: string[];
    }

    export interface NamespaceTimeouts {
        create?: string;
        delete?: string;
    }

    export interface RefreshScheduleSchedule {
        /**
         * The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
         */
        refreshType: string;
        /**
         * The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
         */
        scheduleFrequency?: outputs.quicksight.RefreshScheduleScheduleScheduleFrequency;
        /**
         * Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
         */
        startAfterDateTime: string;
    }

    export interface RefreshScheduleScheduleScheduleFrequency {
        /**
         * The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
         */
        interval: string;
        /**
         * The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
         */
        refreshOnDay?: outputs.quicksight.RefreshScheduleScheduleScheduleFrequencyRefreshOnDay;
        /**
         * The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
         */
        timeOfTheDay: string;
        /**
         * The timezone that you want the refresh schedule to use.
         */
        timezone: string;
    }

    export interface RefreshScheduleScheduleScheduleFrequencyRefreshOnDay {
        /**
         * The day of the month that you want to schedule refresh on.
         */
        dayOfMonth?: string;
        /**
         * The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
         */
        dayOfWeek?: string;
    }

    export interface TemplatePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface TemplateSourceEntity {
        /**
         * The source analysis, if it is based on an analysis.. Only one of `sourceAnalysis` or `sourceTemplate` should be configured. See source_analysis.
         */
        sourceAnalysis?: outputs.quicksight.TemplateSourceEntitySourceAnalysis;
        /**
         * The source template, if it is based on an template.. Only one of `sourceAnalysis` or `sourceTemplate` should be configured. See source_template.
         */
        sourceTemplate?: outputs.quicksight.TemplateSourceEntitySourceTemplate;
    }

    export interface TemplateSourceEntitySourceAnalysis {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * A list of dataset references used as placeholders in the template. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.TemplateSourceEntitySourceAnalysisDataSetReference[];
    }

    export interface TemplateSourceEntitySourceAnalysisDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }

    export interface TemplateSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
    }

    export interface ThemeConfiguration {
        /**
         * Color properties that apply to chart data colors. See data_color_palette.
         */
        dataColorPalette?: outputs.quicksight.ThemeConfigurationDataColorPalette;
        /**
         * Display options related to sheets. See sheet.
         */
        sheet?: outputs.quicksight.ThemeConfigurationSheet;
        /**
         * Determines the typography options. See typography.
         */
        typography?: outputs.quicksight.ThemeConfigurationTypography;
        /**
         * Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
         */
        uiColorPalette?: outputs.quicksight.ThemeConfigurationUiColorPalette;
    }

    export interface ThemeConfigurationDataColorPalette {
        /**
         * List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
         */
        colors?: string[];
        /**
         * The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
         */
        emptyFillColor?: string;
        /**
         * The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
         */
        minMaxGradients?: string[];
    }

    export interface ThemeConfigurationSheet {
        /**
         * The display options for tiles. See tile.
         */
        tile?: outputs.quicksight.ThemeConfigurationSheetTile;
        /**
         * The layout options for tiles. See tile_layout.
         */
        tileLayout?: outputs.quicksight.ThemeConfigurationSheetTileLayout;
    }

    export interface ThemeConfigurationSheetTile {
        /**
         * The border around a tile. See border.
         */
        border?: outputs.quicksight.ThemeConfigurationSheetTileBorder;
    }

    export interface ThemeConfigurationSheetTileBorder {
        /**
         * The option to enable display of borders for visuals.
         */
        show?: boolean;
    }

    export interface ThemeConfigurationSheetTileLayout {
        /**
         * The gutter settings that apply between tiles. See gutter.
         */
        gutter?: outputs.quicksight.ThemeConfigurationSheetTileLayoutGutter;
        /**
         * The margin settings that apply around the outside edge of sheets. See margin.
         */
        margin?: outputs.quicksight.ThemeConfigurationSheetTileLayoutMargin;
    }

    export interface ThemeConfigurationSheetTileLayoutGutter {
        /**
         * This Boolean value controls whether to display a gutter space between sheet tiles.
         */
        show?: boolean;
    }

    export interface ThemeConfigurationSheetTileLayoutMargin {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show?: boolean;
    }

    export interface ThemeConfigurationTypography {
        /**
         * Determines the list of font families. Maximum number of 5 items. See font_families.
         */
        fontFamilies?: outputs.quicksight.ThemeConfigurationTypographyFontFamily[];
    }

    export interface ThemeConfigurationTypographyFontFamily {
        /**
         * Font family name.
         */
        fontFamily?: string;
    }

    export interface ThemeConfigurationUiColorPalette {
        /**
         * Color (hexadecimal) that applies to selected states and buttons.
         */
        accent?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
         */
        accentForeground?: string;
        /**
         * Color (hexadecimal) that applies to error messages.
         */
        danger?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the error color.
         */
        dangerForeground?: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
         */
        dimension?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
         */
        dimensionForeground?: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as measures.
         */
        measure?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
         */
        measureForeground?: string;
        /**
         * Color (hexadecimal) that applies to visuals and other high emphasis UI.
         */
        primaryBackground?: string;
        /**
         * Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
         */
        primaryForeground?: string;
        /**
         * Color (hexadecimal) that applies to the sheet background and sheet controls.
         */
        secondaryBackground?: string;
        /**
         * Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
         */
        secondaryForeground?: string;
        /**
         * Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
         */
        success?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the success color.
         */
        successForeground?: string;
        /**
         * Color (hexadecimal) that applies to warning and informational messages.
         */
        warning?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
         */
        warningForeground?: string;
    }

    export interface ThemePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }

    export interface VpcConnectionTimeouts {
        create?: string;
        delete?: string;
        update?: string;
    }

}

export namespace ram {
    export interface GetResourceShareFilter {
        /**
         * Name of the tag key to filter on.
         */
        name: string;
        /**
         * Value of the tag key.
         */
        values: string[];
    }

}

export namespace rbin {
    export interface RuleLockConfiguration {
        /**
         * Information about the retention rule unlock delay. See `unlockDelay` below.
         */
        unlockDelay: outputs.rbin.RuleLockConfigurationUnlockDelay;
    }

    export interface RuleLockConfigurationUnlockDelay {
        /**
         * The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.
         */
        unlockDelayUnit: string;
        /**
         * The unlock delay period, measured in the unit specified for UnlockDelayUnit.
         */
        unlockDelayValue: number;
    }

    export interface RuleResourceTag {
        /**
         * The tag key.
         *
         * The following argument is optional:
         */
        resourceTagKey: string;
        /**
         * The tag value.
         */
        resourceTagValue?: string;
    }

    export interface RuleRetentionPeriod {
        /**
         * The unit of time in which the retention period is measured. Currently, only DAYS is supported.
         */
        retentionPeriodUnit: string;
        /**
         * The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
         */
        retentionPeriodValue: number;
    }

}

export namespace rds {
    export interface ClusterMasterUserSecret {
        /**
         * ARN for the KMS encryption key. When specifying `kmsKeyId`, `storageEncrypted` needs to be set to true.
         */
        kmsKeyId: string;
        /**
         * Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * Status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }

    export interface ClusterParameterGroupParameter {
        /**
         * "immediate" (default), or "pending-reboot". Some
         * engines can't apply some parameters without a reboot, and you will need to
         * specify "pending-reboot" here.
         */
        applyMethod?: string;
        /**
         * The name of the DB parameter.
         */
        name: string;
        /**
         * The value of the DB parameter.
         */
        value: string;
    }

    export interface ClusterRestoreToPointInTime {
        /**
         * Date and time in UTC format to restore the database cluster to. Conflicts with `useLatestRestorableTime`.
         */
        restoreToTime?: string;
        /**
         * Type of restore to be performed.
         * Valid options are `full-copy` (default) and `copy-on-write`.
         */
        restoreType?: string;
        /**
         * Identifier of the source database cluster from which to restore.
         */
        sourceClusterIdentifier: string;
        /**
         * Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with `restoreToTime`.
         */
        useLatestRestorableTime?: boolean;
    }

    export interface ClusterS3Import {
        /**
         * Bucket name where your backup is stored
         */
        bucketName: string;
        /**
         * Can be blank, but is the path to your backup
         */
        bucketPrefix?: string;
        /**
         * Role applied to load the data.
         */
        ingestionRole: string;
        /**
         * Source engine for the backup
         */
        sourceEngine: string;
        /**
         * Version of the source engine used to make the backup
         *
         * This will not recreate the resource if the S3 object changes in some way. It's only used to initialize the database. This only works currently with the aurora engine. See AWS for currently supported engines and options. See [Aurora S3 Migration Docs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AuroraMySQL.Migrating.ExtMySQL.html#AuroraMySQL.Migrating.ExtMySQL.S3).
         */
        sourceEngineVersion: string;
    }

    export interface ClusterScalingConfiguration {
        /**
         * Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to `true`.
         */
        autoPause?: boolean;
        /**
         * Maximum capacity for an Aurora DB cluster in `serverless` DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `16`.
         */
        maxCapacity?: number;
        /**
         * Minimum capacity for an Aurora DB cluster in `serverless` DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `1`.
         */
        minCapacity?: number;
        /**
         * Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are `300` through `86400`. Defaults to `300`.
         */
        secondsUntilAutoPause?: number;
        /**
         * Action to take when the timeout is reached. Valid values: `ForceApplyCapacityChange`, `RollbackCapacityChange`. Defaults to `RollbackCapacityChange`. See [documentation](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.timeout-action).
         */
        timeoutAction?: string;
    }

    export interface ClusterServerlessv2ScalingConfiguration {
        /**
         * Maximum capacity for an Aurora DB cluster in `serverless` DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `16`.
         */
        maxCapacity: number;
        /**
         * Minimum capacity for an Aurora DB cluster in `serverless` DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `1`.
         */
        minCapacity: number;
    }

    export interface ExportTaskTimeouts {
        create?: string;
        delete?: string;
    }

    export interface GetClusterMasterUserSecret {
        kmsKeyId: string;
        secretArn: string;
        secretStatus: string;
    }

    export interface GetClustersFilter {
        /**
         * Name of the filter field. Valid values can be found in the [RDS DescribeDBClusters API Reference](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetEngineVersionFilter {
        name: string;
        values: string[];
    }

    export interface GetInstanceMasterUserSecret {
        /**
         * The Amazon Web Services KMS key identifier that is used to encrypt the secret.
         */
        kmsKeyId: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * The status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }

    export interface GetInstancesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [RDS DescribeDBClusters API Reference](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetProxyAuth {
        authScheme: string;
        clientPasswordAuthType: string;
        description: string;
        iamAuth: string;
        secretArn: string;
        username: string;
    }

    export interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster
         */
        isWriter: boolean;
    }

    export interface InstanceBlueGreenUpdate {
        /**
         * Enables low-downtime updates when `true`.
         * Default is `false`.
         *
         * [instance-replication]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html
         * [instance-maintenance]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html
         * [blue-green]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/blue-green-deployments.html
         */
        enabled?: boolean;
    }

    export interface InstanceListenerEndpoint {
        /**
         * Specifies the DNS address of the DB instance.
         */
        address: string;
        /**
         * Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
         */
        hostedZoneId: string;
        /**
         * The port on which the DB accepts connections.
         */
        port: number;
    }

    export interface InstanceMasterUserSecret {
        /**
         * The ARN for the KMS encryption key. If creating an
         * encrypted replica, set this to the destination KMS ARN.
         */
        kmsKeyId: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * The status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }

    export interface InstanceRestoreToPointInTime {
        /**
         * The date and time to restore from. Value must be a time in Universal Coordinated Time (UTC) format and must be before the latest restorable time for the DB instance. Cannot be specified with `useLatestRestorableTime`.
         */
        restoreTime?: string;
        /**
         * The ARN of the automated backup from which to restore. Required if `sourceDbInstanceIdentifier` or `sourceDbiResourceId` is not specified.
         */
        sourceDbInstanceAutomatedBackupsArn?: string;
        /**
         * The identifier of the source DB instance from which to restore. Must match the identifier of an existing DB instance. Required if `sourceDbInstanceAutomatedBackupsArn` or `sourceDbiResourceId` is not specified.
         */
        sourceDbInstanceIdentifier?: string;
        /**
         * The resource ID of the source DB instance from which to restore. Required if `sourceDbInstanceIdentifier` or `sourceDbInstanceAutomatedBackupsArn` is not specified.
         */
        sourceDbiResourceId?: string;
        /**
         * A boolean value that indicates whether the DB instance is restored from the latest backup time. Defaults to `false`. Cannot be specified with `restoreTime`.
         */
        useLatestRestorableTime?: boolean;
    }

    export interface InstanceS3Import {
        /**
         * The bucket name where your backup is stored
         */
        bucketName: string;
        /**
         * Can be blank, but is the path to your backup
         */
        bucketPrefix?: string;
        /**
         * Role applied to load the data.
         */
        ingestionRole: string;
        /**
         * Source engine for the backup
         */
        sourceEngine: string;
        /**
         * Version of the source engine used to make the backup
         *
         * This will not recreate the resource if the S3 object changes in some way.  It's only used to initialize the database.
         */
        sourceEngineVersion: string;
    }

    export interface OptionGroupOption {
        /**
         * A list of DB Security Groups for which the option is enabled.
         */
        dbSecurityGroupMemberships?: string[];
        /**
         * The Name of the Option (e.g., MEMCACHED).
         */
        optionName: string;
        /**
         * A list of option settings to apply.
         */
        optionSettings?: outputs.rds.OptionGroupOptionOptionSetting[];
        /**
         * The Port number when connecting to the Option (e.g., 11211).
         */
        port?: number;
        /**
         * The version of the option (e.g., 13.1.0.0).
         */
        version?: string;
        /**
         * A list of VPC Security Groups for which the option is enabled.
         */
        vpcSecurityGroupMemberships?: string[];
    }

    export interface OptionGroupOptionOptionSetting {
        /**
         * The Name of the setting.
         */
        name: string;
        /**
         * The Value of the setting.
         */
        value: string;
    }

    export interface ParameterGroupParameter {
        /**
         * "immediate" (default), or "pending-reboot". Some
         * engines can't apply some parameters without a reboot, and you will need to
         * specify "pending-reboot" here.
         */
        applyMethod?: string;
        /**
         * The name of the DB parameter.
         */
        name: string;
        /**
         * The value of the DB parameter.
         */
        value: string;
    }

    export interface ProxyAuth {
        /**
         * The type of authentication that the proxy uses for connections from the proxy to the underlying database. One of `SECRETS`.
         */
        authScheme?: string;
        /**
         * The type of authentication the proxy uses for connections from clients. Valid values are `MYSQL_NATIVE_PASSWORD`, `POSTGRES_SCRAM_SHA_256`, `POSTGRES_MD5`, and `SQL_SERVER_AUTHENTICATION`.
         */
        clientPasswordAuthType: string;
        /**
         * A user-specified description about the authentication used by a proxy to log in as a specific database user.
         */
        description?: string;
        /**
         * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. One of `DISABLED`, `REQUIRED`.
         */
        iamAuth?: string;
        /**
         * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
         */
        secretArn?: string;
        /**
         * The name of the database user to which the proxy connects.
         */
        username?: string;
    }

    export interface ProxyDefaultTargetGroupConnectionPoolConfig {
        /**
         * The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
         */
        connectionBorrowTimeout?: number;
        /**
         * One or more SQL statements for the proxy to run when opening each new database connection. Typically used with `SET` statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single `SET` statement, such as `SET x=1, y=2`.
         */
        initQuery?: string;
        /**
         * The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the maxConnections setting for the RDS DB instance or Aurora DB cluster used by the target group.
         */
        maxConnectionsPercent?: number;
        /**
         * Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the maxConnections setting for the RDS DB instance or Aurora DB cluster used by the target group.
         */
        maxIdleConnectionsPercent?: number;
        /**
         * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Currently, the only allowed value is `EXCLUDE_VARIABLE_SETS`.
         */
        sessionPinningFilters?: string[];
    }

    export interface ReservedInstanceRecurringCharge {
        recurringChargeAmount: number;
        recurringChargeFrequency: string;
    }

}

export namespace redshift {
    export interface ClusterClusterNode {
        /**
         * Whether the node is a leader node or a compute node
         */
        nodeRole: string;
        /**
         * The private IP address of a node within a cluster
         */
        privateIpAddress: string;
        /**
         * The public IP address of a node within a cluster
         */
        publicIpAddress: string;
    }

    export interface ClusterLogging {
        /**
         * The name of an existing S3 bucket where the log files are to be stored. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions.
         * For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
         */
        bucketName: string;
        /**
         * Enables logging information such as queries and connection attempts, for the specified Amazon Redshift cluster.
         */
        enable: boolean;
        /**
         * The log destination type. An enum with possible values of `s3` and `cloudwatch`.
         */
        logDestinationType?: string;
        /**
         * The collection of exported log types. Log types include the connection log, user log and user activity log. Required when `logDestinationType` is `cloudwatch`. Valid log types are `connectionlog`, `userlog`, and `useractivitylog`.
         */
        logExports?: string[];
        /**
         * The prefix applied to the log file names.
         */
        s3KeyPrefix: string;
    }

    export interface ClusterSnapshotCopy {
        /**
         * The destination region that you want to copy snapshots to.
         */
        destinationRegion: string;
        /**
         * The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
         */
        grantName?: string;
        /**
         * The number of days to retain automated snapshots in the destination region after they are copied from the source region. Defaults to `7`.
         */
        retentionPeriod?: number;
    }

    export interface EndpointAccessVpcEndpoint {
        /**
         * One or more network interfaces of the endpoint. Also known as an interface endpoint. See details below.
         */
        networkInterfaces: outputs.redshift.EndpointAccessVpcEndpointNetworkInterface[];
        /**
         * The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.
         */
        vpcEndpointId: string;
        /**
         * The VPC identifier that the endpoint is associated.
         */
        vpcId: string;
    }

    export interface EndpointAccessVpcEndpointNetworkInterface {
        /**
         * The Availability Zone.
         */
        availabilityZone: string;
        /**
         * The network interface identifier.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The subnet identifier.
         */
        subnetId: string;
    }

    export interface GetClusterClusterNode {
        /**
         * Whether the node is a leader node or a compute node
         */
        nodeRole: string;
        /**
         * Private IP address of a node within a cluster
         */
        privateIpAddress: string;
        /**
         * Public IP address of a node within a cluster
         */
        publicIpAddress: string;
    }

    export interface ParameterGroupParameter {
        /**
         * The name of the Redshift parameter.
         */
        name: string;
        /**
         * The value of the Redshift parameter.
         */
        value: string;
    }

    export interface ScheduledActionTargetAction {
        /**
         * An action that runs a `PauseCluster` API operation. Documented below.
         */
        pauseCluster?: outputs.redshift.ScheduledActionTargetActionPauseCluster;
        /**
         * An action that runs a `ResizeCluster` API operation. Documented below.
         */
        resizeCluster?: outputs.redshift.ScheduledActionTargetActionResizeCluster;
        /**
         * An action that runs a `ResumeCluster` API operation. Documented below.
         */
        resumeCluster?: outputs.redshift.ScheduledActionTargetActionResumeCluster;
    }

    export interface ScheduledActionTargetActionPauseCluster {
        /**
         * The identifier of the cluster to be paused.
         */
        clusterIdentifier: string;
    }

    export interface ScheduledActionTargetActionResizeCluster {
        /**
         * A boolean value indicating whether the resize operation is using the classic resize process. Default: `false`.
         */
        classic?: boolean;
        /**
         * The unique identifier for the cluster to resize.
         */
        clusterIdentifier: string;
        /**
         * The new cluster type for the specified cluster.
         */
        clusterType?: string;
        /**
         * The new node type for the nodes you are adding.
         */
        nodeType?: string;
        /**
         * The new number of nodes for the cluster.
         */
        numberOfNodes?: number;
    }

    export interface ScheduledActionTargetActionResumeCluster {
        /**
         * The identifier of the cluster to be resumed.
         */
        clusterIdentifier: string;
    }

}

export namespace redshiftdata {
    export interface StatementParameter {
        name: string;
        value: string;
    }

}

export namespace redshiftserverless {
    export interface EndpointAccessVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.EndpointAccessVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }

    export interface EndpointAccessVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }

    export interface GetWorkgroupEndpoint {
        /**
         * The DNS address of the VPC endpoint.
         */
        address: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        port: number;
        /**
         * The VPC endpoint or the Redshift Serverless workgroup. See `VPC Endpoint` below.
         */
        vpcEndpoints: outputs.redshiftserverless.GetWorkgroupEndpointVpcEndpoint[];
    }

    export interface GetWorkgroupEndpointVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.GetWorkgroupEndpointVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }

    export interface GetWorkgroupEndpointVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }

    export interface WorkgroupConfigParameter {
        /**
         * The key of the parameter. The options are `autoMv`, `datestyle`, `enableCaseSensitiveIdentifier`, `enableUserActivityLogging`, `queryGroup`, `searchPath` and [query monitoring metrics](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless) that let you define performance boundaries: `maxQueryCpuTime`, `maxQueryBlocksRead`, `maxScanRowCount`, `maxQueryExecutionTime`, `maxQueryQueueTime`, `maxQueryCpuUsagePercent`, `maxQueryTempBlocksToDisk`, `maxJoinRowCount` and `maxNestedLoopJoinRowCount`.
         */
        parameterKey: string;
        /**
         * The value of the parameter to set.
         */
        parameterValue: string;
    }

    export interface WorkgroupEndpoint {
        /**
         * The DNS address of the VPC endpoint.
         */
        address: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        port: number;
        /**
         * The VPC endpoint or the Redshift Serverless workgroup. See `VPC Endpoint` below.
         */
        vpcEndpoints: outputs.redshiftserverless.WorkgroupEndpointVpcEndpoint[];
    }

    export interface WorkgroupEndpointVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.WorkgroupEndpointVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }

    export interface WorkgroupEndpointVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }

}

export namespace resourceexplorer {
    export interface IndexTimeouts {
        create?: string;
        delete?: string;
        update?: string;
    }

    export interface ViewFilters {
        /**
         * The string that contains the search keywords, prefixes, and operators to control the results that can be returned by a search operation. For more details, see [Search query syntax](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html).
         */
        filterString: string;
    }

    export interface ViewIncludedProperty {
        /**
         * The name of the property that is included in this view. Valid values: `tags`.
         */
        name: string;
    }

}

export namespace resourcegroups {
    export interface GroupConfiguration {
        /**
         * A collection of parameters for this group configuration item. See below for details.
         */
        parameters?: outputs.resourcegroups.GroupConfigurationParameter[];
        /**
         * Specifies the type of group configuration item.
         */
        type: string;
    }

    export interface GroupConfigurationParameter {
        /**
         * The name of the group configuration parameter.
         */
        name: string;
        /**
         * The value or values to be used for the specified parameter.
         */
        values: string[];
    }

    export interface GroupResourceQuery {
        /**
         * The resource query as a JSON string.
         */
        query: string;
        /**
         * The type of the resource query. Defaults to `TAG_FILTERS_1_0`.
         */
        type?: string;
    }

}

export namespace resourcegroupstaggingapi {
    export interface GetResourcesResourceTagMappingList {
        /**
         * List of objects with information that shows whether a resource is compliant with the effective tag policy, including details on any noncompliant tag keys.
         */
        complianceDetails: outputs.resourcegroupstaggingapi.GetResourcesResourceTagMappingListComplianceDetail[];
        /**
         * ARN of the resource.
         */
        resourceArn: string;
        /**
         * Map of tags assigned to the resource.
         */
        tags: {[key: string]: string};
    }

    export interface GetResourcesResourceTagMappingListComplianceDetail {
        /**
         * Whether the resource is compliant.
         * * `keysWithNoncompliantValues ` - Set of tag keys with non-compliant tag values.
         * * `nonCompliantKeys ` - Set of non-compliant tag keys.
         */
        complianceStatus: boolean;
        keysWithNoncompliantValues: string[];
        nonCompliantKeys: string[];
    }

    export interface GetResourcesTagFilter {
        /**
         * One part of a key-value pair that makes up a tag.
         */
        key: string;
        /**
         * Optional part of a key-value pair that make up a tag.
         */
        values?: string[];
    }

}

export namespace rolesanywhere {
    export interface TrustAnchorSource {
        /**
         * The data denoting the source of trust, documented below
         */
        sourceData: outputs.rolesanywhere.TrustAnchorSourceSourceData;
        /**
         * The type of the source of trust. Must be either `AWS_ACM_PCA` or `CERTIFICATE_BUNDLE`.
         */
        sourceType: string;
    }

    export interface TrustAnchorSourceSourceData {
        /**
         * The ARN of an ACM Private Certificate Authority.
         */
        acmPcaArn?: string;
        x509CertificateData?: string;
    }

}

export namespace route53 {
    export interface GetQueryLogConfigFilter {
        /**
         * The name of the query logging configuration.
         */
        name: string;
        values: string[];
    }

    export interface GetResolverEndpointFilter {
        name: string;
        values: string[];
    }

    export interface GetResolverFirewallRulesFirewallRule {
        /**
         * The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list.
         */
        action: string;
        /**
         * The DNS record's type.
         */
        blockOverrideDnsType: string;
        /**
         * The custom DNS record to send back in response to the query.
         */
        blockOverrideDomain: string;
        /**
         * The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record.
         */
        blockOverrideTtl: number;
        /**
         * The way that you want DNS Firewall to block the request.
         */
        blockResponse: string;
        /**
         * The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
         */
        creationTime: string;
        /**
         * A unique string defined by you to identify the request.
         */
        creatorRequestId: string;
        /**
         * The ID of the domain list that's used in the rule.
         */
        firewallDomainListId: string;
        /**
         * The unique identifier of the firewall rule group that you want to retrieve the rules for.
         */
        firewallRuleGroupId: string;
        /**
         * The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
         */
        modificationTime: string;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The setting that determines the processing order of the rules in a rule group.
         */
        priority: number;
    }

    export interface GetTrafficPolicyDocumentEndpoint {
        /**
         * ID of an endpoint you want to assign.
         */
        id: string;
        /**
         * To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
         */
        region?: string;
        /**
         * Type of the endpoint. Valid values are `value` , `cloudfront` , `elastic-load-balancer`, `s3-website`
         */
        type?: string;
        /**
         * Value of the `type`.
         */
        value?: string;
    }

    export interface GetTrafficPolicyDocumentRule {
        /**
         * Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
         */
        geoProximityLocations?: outputs.route53.GetTrafficPolicyDocumentRuleGeoProximityLocation[];
        /**
         * ID of a rule you want to assign.
         */
        id: string;
        /**
         * Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
         */
        items?: outputs.route53.GetTrafficPolicyDocumentRuleItem[];
        /**
         * Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
         */
        locations?: outputs.route53.GetTrafficPolicyDocumentRuleLocation[];
        /**
         * Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
         */
        primary?: outputs.route53.GetTrafficPolicyDocumentRulePrimary;
        /**
         * To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
         */
        regions?: outputs.route53.GetTrafficPolicyDocumentRuleRegion[];
        /**
         * Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
         */
        secondary?: outputs.route53.GetTrafficPolicyDocumentRuleSecondary;
        /**
         * Type of the rule.
         */
        type?: string;
    }

    export interface GetTrafficPolicyDocumentRuleGeoProximityLocation {
        /**
         * Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
         */
        bias?: string;
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
         */
        latitude?: string;
        /**
         * Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
         */
        longitude?: string;
        /**
         * If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
         */
        region?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }

    export interface GetTrafficPolicyDocumentRuleItem {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
    }

    export interface GetTrafficPolicyDocumentRuleLocation {
        /**
         * Value of a continent.
         */
        continent?: string;
        /**
         * Value of a country.
         */
        country?: string;
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Indicates whether this set of values represents the default location.
         */
        isDefault?: boolean;
        /**
         * References to a rule.
         */
        ruleReference?: string;
        /**
         * Value of a subdivision.
         */
        subdivision?: string;
    }

    export interface GetTrafficPolicyDocumentRulePrimary {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }

    export interface GetTrafficPolicyDocumentRuleRegion {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Region code for the AWS Region that you created the resource in.
         */
        region?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }

    export interface GetTrafficPolicyDocumentRuleSecondary {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }

    export interface RecordAlias {
        /**
         * Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
         */
        evaluateTargetHealth: boolean;
        /**
         * DNS domain name for a CloudFront distribution, S3 bucket, ELB, or another resource record set in this hosted zone.
         */
        name: string;
        /**
         * Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
         */
        zoneId: string;
    }

    export interface RecordCidrRoutingPolicy {
        /**
         * The CIDR collection ID. See the `aws.route53.CidrCollection` resource for more details.
         */
        collectionId: string;
        /**
         * The CIDR collection location name. See the `aws.route53.CidrLocation` resource for more details. A `locationName` with an asterisk `"*"` can be used to create a default CIDR record. `collectionId` is still required for default record.
         */
        locationName: string;
    }

    export interface RecordFailoverRoutingPolicy {
        /**
         * `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
         */
        type: string;
    }

    export interface RecordGeolocationRoutingPolicy {
        /**
         * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
         */
        continent?: string;
        /**
         * A two-character country code or `*` to indicate a default resource record set.
         */
        country?: string;
        /**
         * A subdivision code for a country.
         */
        subdivision?: string;
    }

    export interface RecordLatencyRoutingPolicy {
        /**
         * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
         */
        region: string;
    }

    export interface RecordWeightedRoutingPolicy {
        /**
         * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
         */
        weight: number;
    }

    export interface ResolverEndpointIpAddress {
        /**
         * The IP address in the subnet that you want to use for DNS queries.
         */
        ip: string;
        ipId: string;
        /**
         * The ID of the subnet that contains the IP address.
         */
        subnetId: string;
    }

    export interface ResolverRuleTargetIp {
        /**
         * One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.
         */
        ip: string;
        /**
         * The port at `ip` that you want to forward DNS queries to. Default value is `53`
         */
        port?: number;
    }

    export interface ZoneVpc {
        /**
         * ID of the VPC to associate.
         */
        vpcId: string;
        /**
         * Region of the VPC to associate. Defaults to AWS provider region.
         */
        vpcRegion: string;
    }

}

export namespace route53domains {
    export interface RegisteredDomainAdminContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {[key: string]: string};
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }

    export interface RegisteredDomainNameServer {
        /**
         * Glue IP addresses of a name server. The list can contain only one IPv4 and one IPv6 address.
         */
        glueIps?: string[];
        /**
         * The fully qualified host name of the name server.
         */
        name: string;
    }

    export interface RegisteredDomainRegistrantContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {[key: string]: string};
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }

    export interface RegisteredDomainTechContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {[key: string]: string};
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }

}

export namespace route53recoverycontrol {
    export interface ClusterClusterEndpoint {
        /**
         * Cluster endpoint.
         */
        endpoint: string;
        /**
         * Region of the endpoint.
         */
        region: string;
    }

    export interface SafetyRuleRuleConfig {
        /**
         * Logical negation of the rule.
         */
        inverted: boolean;
        /**
         * Number of controls that must be set when you specify an `ATLEAST` type rule.
         */
        threshold: number;
        /**
         * Rule type. Valid values are `ATLEAST`, `AND`, and `OR`.
         */
        type: string;
    }

}

export namespace route53recoveryreadiness {
    export interface ResourceSetResource {
        componentId: string;
        /**
         * Component for DNS/Routing Control Readiness Checks.
         */
        dnsTargetResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResource;
        /**
         * Recovery group ARN or cell ARN that contains this resource set.
         */
        readinessScopes?: string[];
        /**
         * ARN of the resource.
         */
        resourceArn?: string;
    }

    export interface ResourceSetResourceDnsTargetResource {
        /**
         * DNS Name that acts as the ingress point to a portion of application.
         */
        domainName: string;
        /**
         * Hosted Zone ARN that contains the DNS record with the provided name of target resource.
         */
        hostedZoneArn?: string;
        /**
         * Route53 record set id to uniquely identify a record given a `domainName` and a `recordType`.
         */
        recordSetId?: string;
        /**
         * Type of DNS Record of target resource.
         */
        recordType?: string;
        /**
         * Target resource the R53 record specified with the above params points to.
         */
        targetResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResource;
    }

    export interface ResourceSetResourceDnsTargetResourceTargetResource {
        /**
         * NLB resource a DNS Target Resource points to. Required if `r53Resource` is not set.
         */
        nlbResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResourceNlbResource;
        /**
         * Route53 resource a DNS Target Resource record points to.
         */
        r53Resource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResourceR53Resource;
    }

    export interface ResourceSetResourceDnsTargetResourceTargetResourceNlbResource {
        /**
         * NLB resource ARN.
         */
        arn?: string;
    }

    export interface ResourceSetResourceDnsTargetResourceTargetResourceR53Resource {
        /**
         * DNS Name that acts as the ingress point to a portion of application.
         */
        domainName?: string;
        /**
         * Route53 record set id to uniquely identify a record given a `domainName` and a `recordType`.
         */
        recordSetId?: string;
    }

}

export namespace rum {
    export interface AppMonitorAppMonitorConfiguration {
        /**
         * If you set this to `true`, RUM web client sets two cookies, a session cookie  and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
         */
        allowCookies?: boolean;
        /**
         * If you set this to `true`, RUM enables X-Ray tracing for the user sessions  that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests.
         */
        enableXray?: boolean;
        /**
         * A list of URLs in your website or application to exclude from RUM data collection.
         */
        excludedPages?: string[];
        /**
         * A list of pages in the CloudWatch RUM console that are to be displayed with a "favorite" icon.
         */
        favoritePages?: string[];
        /**
         * The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
         */
        guestRoleArn?: string;
        /**
         * The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
         */
        identityPoolId?: string;
        /**
         * If this app monitor is to collect data from only certain pages in your application, this structure lists those pages.
         */
        includedPages?: string[];
        /**
         * Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. Default value is `0.1`.
         */
        sessionSampleRate?: number;
        /**
         * An array that lists the types of telemetry data that this app monitor is to collect. Valid values are `errors`, `performance`, and `http`.
         */
        telemetries?: string[];
    }

    export interface AppMonitorCustomEvents {
        /**
         * Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be `DISABLED`. Valid values are `DISABLED` and `ENABLED`.
         */
        status?: string;
    }

}

export namespace s3 {
    export interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing policies or ACLs. When set to `true` causes the following behavior:
         * * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         * * PUT Object calls fail if the request includes a public ACL.
         * * PUT Bucket calls fail if the request includes a public ACL.
         */
        blockPublicAcls?: boolean;
        /**
         * Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing bucket policies. When set to `true` causes Amazon S3 to:
         * * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         */
        blockPublicPolicy?: boolean;
        /**
         * Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to `true` causes Amazon S3 to:
         * * Ignore all public ACLs on buckets in this account and any objects that they contain.
         */
        ignorePublicAcls?: boolean;
        /**
         * Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to `true`:
         * * Only the bucket owner and AWS Services can access buckets with public policies.
         */
        restrictPublicBuckets?: boolean;
    }

    export interface AccessPointVpcConfiguration {
        /**
         * This access point will only allow connections from the specified VPC ID.
         */
        vpcId: string;
    }

    export interface AnalyticsConfigurationFilter {
        /**
         * Object prefix for filtering.
         */
        prefix?: string;
        /**
         * Set of object tags for filtering.
         */
        tags?: {[key: string]: string};
    }

    export interface AnalyticsConfigurationStorageClassAnalysis {
        /**
         * Data export configuration (documented below).
         */
        dataExport: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExport;
    }

    export interface AnalyticsConfigurationStorageClassAnalysisDataExport {
        /**
         * Specifies the destination for the exported analytics data (documented below).
         */
        destination: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExportDestination;
        /**
         * Schema version of exported analytics data. Allowed values: `V_1`. Default value: `V_1`.
         */
        outputSchemaVersion?: string;
    }

    export interface AnalyticsConfigurationStorageClassAnalysisDataExportDestination {
        /**
         * Analytics data export currently only supports an S3 bucket destination (documented below).
         *
         * The `s3BucketDestination` configuration supports the following:
         */
        s3BucketDestination: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestination;
    }

    export interface AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestination {
        /**
         * Account ID that owns the destination bucket.
         */
        bucketAccountId?: string;
        /**
         * ARN of the destination bucket.
         */
        bucketArn: string;
        /**
         * Output format of exported analytics data. Allowed values: `CSV`. Default value: `CSV`.
         */
        format?: string;
        /**
         * Object prefix for filtering.
         */
        prefix?: string;
    }

    export interface BucketAclV2AccessControlPolicy {
        /**
         * Set of `grant` configuration blocks. See below.
         */
        grants?: outputs.s3.BucketAclV2AccessControlPolicyGrant[];
        /**
         * Configuration block of the bucket owner's display name and ID. See below.
         */
        owner: outputs.s3.BucketAclV2AccessControlPolicyOwner;
    }

    export interface BucketAclV2AccessControlPolicyGrant {
        /**
         * Configuration block for the person being granted permissions. See below.
         */
        grantee?: outputs.s3.BucketAclV2AccessControlPolicyGrantGrantee;
        /**
         * Logging permissions assigned to the grantee for the bucket.
         */
        permission: string;
    }

    export interface BucketAclV2AccessControlPolicyGrantGrantee {
        /**
         * Display name of the owner.
         */
        displayName: string;
        /**
         * Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
         */
        emailAddress?: string;
        /**
         * Canonical user ID of the grantee.
         */
        id?: string;
        /**
         * Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
         */
        type: string;
        /**
         * URI of the grantee group.
         */
        uri?: string;
    }

    export interface BucketAclV2AccessControlPolicyOwner {
        /**
         * Display name of the owner.
         */
        displayName: string;
        /**
         * ID of the owner.
         */
        id: string;
    }

    export interface BucketCorsConfigurationV2CorsRule {
        /**
         * Set of Headers that are specified in the `Access-Control-Request-Headers` header.
         */
        allowedHeaders?: string[];
        /**
         * Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
         */
        allowedMethods: string[];
        /**
         * Set of origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
         */
        exposeHeaders?: string[];
        /**
         * Unique identifier for the rule. The value cannot be longer than 255 characters.
         */
        id?: string;
        /**
         * Time in seconds that your browser is to cache the preflight response for the specified resource.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders?: string[];
        /**
         * Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketGrant {
        /**
         * Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
         */
        type: string;
        /**
         * Uri address to grant for. Used only when `type` is `Group`.
         */
        uri?: string;
    }

    export interface BucketIntelligentTieringConfigurationFilter {
        /**
         * Object key name prefix that identifies the subset of objects to which the configuration applies.
         */
        prefix?: string;
        /**
         * All of these tags must exist in the object's tag set in order for the configuration to apply.
         */
        tags?: {[key: string]: string};
    }

    export interface BucketIntelligentTieringConfigurationTiering {
        /**
         * S3 Intelligent-Tiering access tier. Valid values: `ARCHIVE_ACCESS`, `DEEP_ARCHIVE_ACCESS`.
         */
        accessTier: string;
        /**
         * Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
         */
        days: number;
    }

    export interface BucketLifecycleConfigurationV2Rule {
        /**
         * Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
         */
        abortIncompleteMultipartUpload?: outputs.s3.BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUpload;
        /**
         * Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
         */
        expiration?: outputs.s3.BucketLifecycleConfigurationV2RuleExpiration;
        /**
         * Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the `rule` will default to using `prefix`.
         */
        filter?: outputs.s3.BucketLifecycleConfigurationV2RuleFilter;
        /**
         * Unique identifier for the rule. The value cannot be longer than 255 characters.
         */
        id: string;
        /**
         * Configuration block that specifies when noncurrent object versions expire. See below.
         */
        noncurrentVersionExpiration?: outputs.s3.BucketLifecycleConfigurationV2RuleNoncurrentVersionExpiration;
        /**
         * Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketLifecycleConfigurationV2RuleNoncurrentVersionTransition[];
        /**
         * **DEPRECATED** Use `filter` instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if `filter` is not specified.
         *
         * @deprecated Use filter instead
         */
        prefix?: string;
        /**
         * Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
         */
        status: string;
        /**
         * Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
         */
        transitions?: outputs.s3.BucketLifecycleConfigurationV2RuleTransition[];
    }

    export interface BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUpload {
        /**
         * Number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation?: number;
    }

    export interface BucketLifecycleConfigurationV2RuleExpiration {
        /**
         * Date the object is to be moved or deleted. Should be in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        date?: string;
        /**
         * Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
         */
        days?: number;
        /**
         * Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
         */
        expiredObjectDeleteMarker: boolean;
    }

    export interface BucketLifecycleConfigurationV2RuleFilter {
        /**
         * Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
         */
        and?: outputs.s3.BucketLifecycleConfigurationV2RuleFilterAnd;
        /**
         * Minimum object size (in bytes) to which the rule applies.
         */
        objectSizeGreaterThan?: string;
        /**
         * Maximum object size (in bytes) to which the rule applies.
         */
        objectSizeLessThan?: string;
        /**
         * Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
         */
        prefix?: string;
        /**
         * Configuration block for specifying a tag key and value. See below.
         */
        tag?: outputs.s3.BucketLifecycleConfigurationV2RuleFilterTag;
    }

    export interface BucketLifecycleConfigurationV2RuleFilterAnd {
        /**
         * Minimum object size to which the rule applies. Value must be at least `0` if specified.
         */
        objectSizeGreaterThan?: number;
        /**
         * Maximum object size to which the rule applies. Value must be at least `1` if specified.
         */
        objectSizeLessThan?: number;
        /**
         * Prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
         */
        tags?: {[key: string]: string};
    }

    export interface BucketLifecycleConfigurationV2RuleFilterTag {
        /**
         * Name of the object key.
         */
        key: string;
        /**
         * Value of the tag.
         */
        value: string;
    }

    export interface BucketLifecycleConfigurationV2RuleNoncurrentVersionExpiration {
        /**
         * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
         */
        newerNoncurrentVersions?: string;
        /**
         * Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
         */
        noncurrentDays?: number;
    }

    export interface BucketLifecycleConfigurationV2RuleNoncurrentVersionTransition {
        /**
         * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
         */
        newerNoncurrentVersions?: string;
        /**
         * Number of days an object is noncurrent before Amazon S3 can perform the associated action.
         */
        noncurrentDays?: number;
        /**
         * Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
         */
        storageClass: string;
    }

    export interface BucketLifecycleConfigurationV2RuleTransition {
        /**
         * Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) and set to midnight UTC e.g. `2023-01-13T00:00:00Z`.
         */
        date?: string;
        /**
         * Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storageClass`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
         */
        days?: number;
        /**
         * Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
         */
        abortIncompleteMultipartUploadDays?: number;
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expiration?: outputs.s3.BucketLifecycleRuleExpiration;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire (documented below).
         */
        noncurrentVersionExpiration?: outputs.s3.BucketLifecycleRuleNoncurrentVersionExpiration;
        /**
         * Specifies when noncurrent object versions transitions (documented below).
         *
         * At least one of `abortIncompleteMultipartUploadDays`, `expiration`, `transition`, `noncurrentVersionExpiration`, `noncurrentVersionTransition` must be specified.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies object tags key and value.
         */
        tags?: {[key: string]: string};
        /**
         * Specifies a period in the object's transitions (documented below).
         */
        transitions?: outputs.s3.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions expire.
         */
        days?: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }

    export interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketLoggingV2TargetGrant {
        /**
         * Configuration block for the person being granted permissions. See below.
         */
        grantee: outputs.s3.BucketLoggingV2TargetGrantGrantee;
        /**
         * Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
         */
        permission: string;
    }

    export interface BucketLoggingV2TargetGrantGrantee {
        displayName: string;
        /**
         * Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
         */
        emailAddress?: string;
        /**
         * Canonical user ID of the grantee.
         */
        id?: string;
        /**
         * Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
         */
        type: string;
        /**
         * URI of the grantee group.
         */
        uri?: string;
    }

    export interface BucketMetricFilter {
        /**
         * Object prefix for filtering (singular).
         */
        prefix?: string;
        /**
         * Object tags for filtering (up to 10).
         */
        tags?: {[key: string]: string};
    }

    export interface BucketNotificationLambdaFunction {
        /**
         * [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * Lambda function ARN.
         */
        lambdaFunctionArn?: string;
    }

    export interface BucketNotificationQueue {
        /**
         * Specifies [event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * SQS queue ARN.
         */
        queueArn: string;
    }

    export interface BucketNotificationTopic {
        /**
         * [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * SNS topic ARN.
         */
        topicArn: string;
    }

    export interface BucketObjectLockConfiguration {
        /**
         * Indicates whether this bucket has an Object Lock configuration enabled. Valid value is `Enabled`.
         */
        objectLockEnabled: string;
        /**
         * The Object Lock rule in place for this bucket.
         */
        rule?: outputs.s3.BucketObjectLockConfigurationRule;
    }

    export interface BucketObjectLockConfigurationRule {
        /**
         * The default retention period that you want to apply to new objects placed in this bucket.
         */
        defaultRetention: outputs.s3.BucketObjectLockConfigurationRuleDefaultRetention;
    }

    export interface BucketObjectLockConfigurationRuleDefaultRetention {
        /**
         * The number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * The default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
         */
        mode: string;
        /**
         * The number of years that you want to specify for the default retention period.
         *
         * Either `days` or `years` must be specified, but not both.
         *
         * > **NOTE on `objectLockConfiguration`:** You can only enable S3 Object Lock for new buckets. If you need to turn on S3 Object Lock for an existing bucket, please contact AWS Support.
         * When you create a bucket with S3 Object Lock enabled, Amazon S3 automatically enables versioning for the bucket.
         * Once you create a bucket with S3 Object Lock enabled, you can't disable Object Lock or suspend versioning for the bucket.
         */
        years?: number;
    }

    export interface BucketObjectLockConfigurationV2Rule {
        /**
         * Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
         */
        defaultRetention: outputs.s3.BucketObjectLockConfigurationV2RuleDefaultRetention;
    }

    export interface BucketObjectLockConfigurationV2RuleDefaultRetention {
        /**
         * Number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
         */
        mode?: string;
        /**
         * Number of years that you want to specify for the default retention period.
         */
        years?: number;
    }

    export interface BucketOwnershipControlsRule {
        /**
         * Object ownership. Valid values: `BucketOwnerPreferred`, `ObjectWriter` or `BucketOwnerEnforced`
         */
        objectOwnership: string;
    }

    export interface BucketReplicationConfigRule {
        /**
         * Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when `filter` is used)documented below.
         */
        deleteMarkerReplication?: outputs.s3.BucketReplicationConfigRuleDeleteMarkerReplication;
        /**
         * Specifies the destination for the rule. See below.
         */
        destination: outputs.s3.BucketReplicationConfigRuleDestination;
        /**
         * Replicate existing objects in the source bucket according to the rule configurations. See below.
         */
        existingObjectReplication?: outputs.s3.BucketReplicationConfigRuleExistingObjectReplication;
        /**
         * Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the `rule` will default to using `prefix`.
         */
        filter?: outputs.s3.BucketReplicationConfigRuleFilter;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string (`""`) if `filter` is not specified.
         *
         * @deprecated Use filter instead
         */
        prefix?: string;
        /**
         * Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria. See below.
         */
        sourceSelectionCriteria?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteria;
        /**
         * Status of the rule. Either `"Enabled"` or `"Disabled"`. The rule is ignored if status is not "Enabled".
         */
        status: string;
    }

    export interface BucketReplicationConfigRuleDeleteMarkerReplication {
        /**
         * Whether delete markers should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }

    export interface BucketReplicationConfigRuleDestination {
        /**
         * Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with `account` owner override configuration.
         */
        accessControlTranslation?: outputs.s3.BucketReplicationConfigRuleDestinationAccessControlTranslation;
        /**
         * Account ID to specify the replica ownership. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        account?: string;
        /**
         * ARN of the bucket where you want Amazon S3 to store the results.
         */
        bucket: string;
        /**
         * Configuration block that provides information about encryption. See below. If `sourceSelectionCriteria` is specified, you must specify this element.
         */
        encryptionConfiguration?: outputs.s3.BucketReplicationConfigRuleDestinationEncryptionConfiguration;
        /**
         * Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
         */
        metrics?: outputs.s3.BucketReplicationConfigRuleDestinationMetrics;
        /**
         * Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with `metrics`.
         */
        replicationTime?: outputs.s3.BucketReplicationConfigRuleDestinationReplicationTime;
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }

    export interface BucketReplicationConfigRuleDestinationAccessControlTranslation {
        /**
         * Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference. Valid values: `Destination`.
         */
        owner: string;
    }

    export interface BucketReplicationConfigRuleDestinationEncryptionConfiguration {
        /**
         * ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
         */
        replicaKmsKeyId: string;
    }

    export interface BucketReplicationConfigRuleDestinationMetrics {
        /**
         * Configuration block that specifies the time threshold for emitting the `s3:Replication:OperationMissedThreshold` event. See below.
         */
        eventThreshold?: outputs.s3.BucketReplicationConfigRuleDestinationMetricsEventThreshold;
        /**
         * Status of the Destination Metrics. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }

    export interface BucketReplicationConfigRuleDestinationMetricsEventThreshold {
        /**
         * Time in minutes. Valid values: `15`.
         */
        minutes: number;
    }

    export interface BucketReplicationConfigRuleDestinationReplicationTime {
        /**
         * Status of the Replication Time Control. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
        /**
         * Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
         */
        time: outputs.s3.BucketReplicationConfigRuleDestinationReplicationTimeTime;
    }

    export interface BucketReplicationConfigRuleDestinationReplicationTimeTime {
        /**
         * Time in minutes. Valid values: `15`.
         */
        minutes: number;
    }

    export interface BucketReplicationConfigRuleExistingObjectReplication {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }

    export interface BucketReplicationConfigRuleFilter {
        /**
         * Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
         */
        and?: outputs.s3.BucketReplicationConfigRuleFilterAnd;
        /**
         * Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Configuration block for specifying a tag key and value. See below.
         */
        tag?: outputs.s3.BucketReplicationConfigRuleFilterTag;
    }

    export interface BucketReplicationConfigRuleFilterAnd {
        /**
         * Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {[key: string]: string};
    }

    export interface BucketReplicationConfigRuleFilterTag {
        /**
         * Name of the object key.
         */
        key: string;
        /**
         * Value of the tag.
         */
        value: string;
    }

    export interface BucketReplicationConfigRuleSourceSelectionCriteria {
        /**
         * Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when `filter` is specified), you can specify this element and set the status to `Enabled` to replicate modifications on replicas.
         */
        replicaModifications?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModifications;
        /**
         * Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, `replicaKmsKeyId` in `destination` `encryptionConfiguration` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjects;
    }

    export interface BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModifications {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }

    export interface BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjects {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }

    export interface BucketReplicationConfiguration {
        /**
         * The ARN of the IAM role for Amazon S3 to assume when replicating the objects.
         */
        role: string;
        /**
         * Specifies the rules managing the replication (documented below).
         */
        rules: outputs.s3.BucketReplicationConfigurationRule[];
    }

    export interface BucketReplicationConfigurationRule {
        /**
         * Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
         */
        deleteMarkerReplicationStatus?: string;
        /**
         * Specifies the destination for the rule (documented below).
         */
        destination: outputs.s3.BucketReplicationConfigurationRuleDestination;
        /**
         * Filter that identifies subset of objects to which the replication rule applies (documented below).
         */
        filter?: outputs.s3.BucketReplicationConfigurationRuleFilter;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id?: string;
        /**
         * Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * The priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria (documented below).
         */
        sourceSelectionCriteria?: outputs.s3.BucketReplicationConfigurationRuleSourceSelectionCriteria;
        /**
         * The status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
         *
         * > **NOTE:** Replication to multiple destination buckets requires that `priority` is specified in the `rules` object. If the corresponding rule requires no filter, an empty configuration block `filter {}` must be specified.
         */
        status: string;
    }

    export interface BucketReplicationConfigurationRuleDestination {
        /**
         * Specifies the overrides to use for object owners on replication. Must be used in conjunction with `accountId` owner override configuration.
         */
        accessControlTranslation?: outputs.s3.BucketReplicationConfigurationRuleDestinationAccessControlTranslation;
        /**
         * The Account ID to use for overriding the object owner on replication. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        accountId?: string;
        /**
         * The ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
         */
        bucket: string;
        /**
         * Enables replication metrics (required for S3 RTC) (documented below).
         */
        metrics?: outputs.s3.BucketReplicationConfigurationRuleDestinationMetrics;
        /**
         * Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
         * `sseKmsEncryptedObjects` source selection criteria.
         */
        replicaKmsKeyId?: string;
        /**
         * Enables S3 Replication Time Control (S3 RTC) (documented below).
         */
        replicationTime?: outputs.s3.BucketReplicationConfigurationRuleDestinationReplicationTime;
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }

    export interface BucketReplicationConfigurationRuleDestinationAccessControlTranslation {
        /**
         * The override value for the owner on replicated objects. Currently only `Destination` is supported.
         */
        owner: string;
    }

    export interface BucketReplicationConfigurationRuleDestinationMetrics {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * The status of replication metrics. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }

    export interface BucketReplicationConfigurationRuleDestinationReplicationTime {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * The status of RTC. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }

    export interface BucketReplicationConfigurationRuleFilter {
        /**
         * Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * A map of tags that identifies subset of objects to which the rule applies.
         * The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {[key: string]: string};
    }

    export interface BucketReplicationConfigurationRuleSourceSelectionCriteria {
        /**
         * Match SSE-KMS encrypted objects (documented below). If specified, `replicaKmsKeyId`
         * in `destination` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjects;
    }

    export interface BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjects {
        /**
         * Boolean which indicates if this criteria is enabled.
         */
        enabled: boolean;
    }

    export interface BucketServerSideEncryptionConfiguration {
        /**
         * A single object for server-side encryption by default configuration. (documented below)
         */
        rule: outputs.s3.BucketServerSideEncryptionConfigurationRule;
    }

    export interface BucketServerSideEncryptionConfigurationRule {
        /**
         * A single object for setting server-side encryption by default. (documented below)
         */
        applyServerSideEncryptionByDefault: outputs.s3.BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }

    export interface BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
        /**
         * The AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * The server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
         */
        sseAlgorithm: string;
    }

    export interface BucketServerSideEncryptionConfigurationV2Rule {
        /**
         * Single object for setting server-side encryption by default. See below.
         */
        applyServerSideEncryptionByDefault?: outputs.s3.BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefault;
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }

    export interface BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefault {
        /**
         * AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
         */
        sseAlgorithm: string;
    }

    export interface BucketV2CorsRule {
        /**
         * List of headers allowed.
         */
        allowedHeaders?: string[];
        /**
         * One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * One or more origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketV2Grant {
        /**
         * Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
         */
        type: string;
        /**
         * Uri address to grant for. Used only when `type` is `Group`.
         */
        uri?: string;
    }

    export interface BucketV2LifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
         */
        abortIncompleteMultipartUploadDays?: number;
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire. See Expiration below for details.
         */
        expirations?: outputs.s3.BucketV2LifecycleRuleExpiration[];
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
         */
        noncurrentVersionExpirations?: outputs.s3.BucketV2LifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketV2LifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies object tags key and value.
         */
        tags?: {[key: string]: string};
        /**
         * Specifies a period in the object's transitions. See Transition below for details.
         */
        transitions?: outputs.s3.BucketV2LifecycleRuleTransition[];
    }

    export interface BucketV2LifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketV2LifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions expire.
         */
        days?: number;
    }

    export interface BucketV2LifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }

    export interface BucketV2LifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }

    export interface BucketV2Logging {
        /**
         * Name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketV2ObjectLockConfiguration {
        /**
         * Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
         *
         * @deprecated Use the top-level parameter object_lock_enabled instead
         */
        objectLockEnabled?: string;
        /**
         * Object Lock rule in place for this bucket (documented below).
         *
         * @deprecated Use the aws_s3_bucket_object_lock_configuration resource instead
         */
        rules?: outputs.s3.BucketV2ObjectLockConfigurationRule[];
    }

    export interface BucketV2ObjectLockConfigurationRule {
        /**
         * Default retention period that you want to apply to new objects placed in this bucket (documented below).
         */
        defaultRetentions: outputs.s3.BucketV2ObjectLockConfigurationRuleDefaultRetention[];
    }

    export interface BucketV2ObjectLockConfigurationRuleDefaultRetention {
        /**
         * Number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * Default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
         */
        mode: string;
        /**
         * Number of years that you want to specify for the default retention period.
         */
        years?: number;
    }

    export interface BucketV2ReplicationConfiguration {
        /**
         * ARN of the IAM role for Amazon S3 to assume when replicating the objects.
         */
        role: string;
        /**
         * Specifies the rules managing the replication (documented below).
         */
        rules: outputs.s3.BucketV2ReplicationConfigurationRule[];
    }

    export interface BucketV2ReplicationConfigurationRule {
        /**
         * Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
         */
        deleteMarkerReplicationStatus?: string;
        /**
         * Specifies the destination for the rule (documented below).
         */
        destinations: outputs.s3.BucketV2ReplicationConfigurationRuleDestination[];
        /**
         * Filter that identifies subset of objects to which the replication rule applies (documented below).
         */
        filters?: outputs.s3.BucketV2ReplicationConfigurationRuleFilter[];
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id?: string;
        /**
         * Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria (documented below).
         */
        sourceSelectionCriterias?: outputs.s3.BucketV2ReplicationConfigurationRuleSourceSelectionCriteria[];
        /**
         * Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
         */
        status: string;
    }

    export interface BucketV2ReplicationConfigurationRuleDestination {
        /**
         * Specifies the overrides to use for object owners on replication. Must be used in conjunction with `accountId` owner override configuration.
         */
        accessControlTranslations?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslation[];
        /**
         * Account ID to use for overriding the object owner on replication. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        accountId?: string;
        /**
         * ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
         */
        bucket: string;
        /**
         * Enables replication metrics (required for S3 RTC) (documented below).
         */
        metrics?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationMetric[];
        /**
         * Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
         * `sseKmsEncryptedObjects` source selection criteria.
         */
        replicaKmsKeyId?: string;
        /**
         * Enables S3 Replication Time Control (S3 RTC) (documented below).
         */
        replicationTimes?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationReplicationTime[];
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }

    export interface BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslation {
        owner: string;
    }

    export interface BucketV2ReplicationConfigurationRuleDestinationMetric {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * Status of replication metrics. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }

    export interface BucketV2ReplicationConfigurationRuleDestinationReplicationTime {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * Status of RTC. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }

    export interface BucketV2ReplicationConfigurationRuleFilter {
        /**
         * Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * A map of tags that identifies subset of objects to which the rule applies.
         * The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {[key: string]: string};
    }

    export interface BucketV2ReplicationConfigurationRuleSourceSelectionCriteria {
        /**
         * Match SSE-KMS encrypted objects (documented below). If specified, `replicaKmsKeyId`
         * in `destination` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObject[];
    }

    export interface BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObject {
        /**
         * Boolean which indicates if this criteria is enabled.
         */
        enabled: boolean;
    }

    export interface BucketV2ServerSideEncryptionConfiguration {
        /**
         * Single object for server-side encryption by default configuration. (documented below)
         */
        rules: outputs.s3.BucketV2ServerSideEncryptionConfigurationRule[];
    }

    export interface BucketV2ServerSideEncryptionConfigurationRule {
        /**
         * Single object for setting server-side encryption by default. (documented below)
         */
        applyServerSideEncryptionByDefaults: outputs.s3.BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault[];
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }

    export interface BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
        /**
         * AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
         */
        sseAlgorithm: string;
    }

    export interface BucketV2Versioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
         */
        enabled?: boolean;
        /**
         * Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
         */
        mfaDelete?: boolean;
    }

    export interface BucketV2Website {
        /**
         * Absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument?: string;
        /**
         * Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
         * describing redirect behavior and when redirects are applied.
         */
        routingRules?: string;
    }

    export interface BucketVersioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
         */
        enabled?: boolean;
        /**
         * Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
         */
        mfaDelete?: boolean;
    }

    export interface BucketVersioningV2VersioningConfiguration {
        /**
         * Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
         */
        mfaDelete: string;
        /**
         * Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
         */
        status: string;
    }

    export interface BucketWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument?: string;
        /**
         * A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * A json array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
         * describing redirect behavior and when redirects are applied.
         *
         * The `CORS` object supports the following:
         */
        routingRules?: string;
    }

    export interface BucketWebsiteConfigurationV2ErrorDocument {
        /**
         * Object key name to use when a 4XX class error occurs.
         */
        key: string;
    }

    export interface BucketWebsiteConfigurationV2IndexDocument {
        /**
         * Suffix that is appended to a request that is for a directory on the website endpoint.
         * For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
         * The suffix must not be empty and must not include a slash character.
         */
        suffix: string;
    }

    export interface BucketWebsiteConfigurationV2RedirectAllRequestsTo {
        /**
         * Name of the host where requests are redirected.
         */
        hostName: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
         */
        protocol?: string;
    }

    export interface BucketWebsiteConfigurationV2RoutingRule {
        /**
         * Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
         */
        condition?: outputs.s3.BucketWebsiteConfigurationV2RoutingRuleCondition;
        /**
         * Configuration block for redirect information. See below.
         */
        redirect: outputs.s3.BucketWebsiteConfigurationV2RoutingRuleRedirect;
    }

    export interface BucketWebsiteConfigurationV2RoutingRuleCondition {
        /**
         * HTTP error code when the redirect is applied. If specified with `keyPrefixEquals`, then both must be true for the redirect to be applied.
         */
        httpErrorCodeReturnedEquals?: string;
        /**
         * Object key name prefix when the redirect is applied. If specified with `httpErrorCodeReturnedEquals`, then both must be true for the redirect to be applied.
         */
        keyPrefixEquals?: string;
    }

    export interface BucketWebsiteConfigurationV2RoutingRuleRedirect {
        /**
         * Host name to use in the redirect request.
         */
        hostName?: string;
        /**
         * HTTP redirect code to use on the response.
         */
        httpRedirectCode?: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
         */
        protocol?: string;
        /**
         * Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `keyPrefixEquals` set to `docs/` and in the `redirect` set `replaceKeyPrefixWith` to `/documents`.
         */
        replaceKeyPrefixWith?: string;
        /**
         * Specific object key to use in the redirect request. For example, redirect request to `error.html`.
         */
        replaceKeyWith?: string;
    }

    export interface InventoryDestination {
        /**
         * S3 bucket configuration where inventory results are published (documented below).
         */
        bucket: outputs.s3.InventoryDestinationBucket;
    }

    export interface InventoryDestinationBucket {
        /**
         * ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
         */
        accountId?: string;
        /**
         * Amazon S3 bucket ARN of the destination.
         */
        bucketArn: string;
        /**
         * Contains the type of server-side encryption to use to encrypt the inventory (documented below).
         */
        encryption?: outputs.s3.InventoryDestinationBucketEncryption;
        /**
         * Specifies the output format of the inventory results. Can be `CSV`, [`ORC`](https://orc.apache.org/) or [`Parquet`](https://parquet.apache.org/).
         */
        format: string;
        /**
         * Prefix that is prepended to all inventory results.
         */
        prefix?: string;
    }

    export interface InventoryDestinationBucketEncryption {
        /**
         * Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
         */
        sseKms?: outputs.s3.InventoryDestinationBucketEncryptionSseKms;
        /**
         * Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
         */
        sseS3?: outputs.s3.InventoryDestinationBucketEncryptionSseS3;
    }

    export interface InventoryDestinationBucketEncryptionSseKms {
        /**
         * ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
         */
        keyId: string;
    }

    export interface InventoryDestinationBucketEncryptionSseS3 {
    }

    export interface InventoryFilter {
        /**
         * Prefix that an object must have to be included in the inventory results.
         */
        prefix?: string;
    }

    export interface InventorySchedule {
        /**
         * Specifies how frequently inventory results are produced. Valid values: `Daily`, `Weekly`.
         */
        frequency: string;
    }

    export interface ObjectCopyGrant {
        /**
         * Email address of the grantee. Used only when `type` is `AmazonCustomerByEmail`.
         */
        email?: string;
        /**
         * Canonical user ID of the grantee. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to grant to grantee. Valid values are `READ`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee. Valid values are `CanonicalUser`, `Group`, and `AmazonCustomerByEmail`.
         *
         * This configuration block has the following optional arguments (one of the three is required):
         */
        type: string;
        /**
         * URI of the grantee group. Used only when `type` is `Group`.
         */
        uri?: string;
    }

}

export namespace s3control {
    export interface BucketLifecycleConfigurationRule {
        /**
         * Configuration block containing settings for abort incomplete multipart upload.
         */
        abortIncompleteMultipartUpload?: outputs.s3control.BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload;
        /**
         * Configuration block containing settings for expiration of objects.
         */
        expiration?: outputs.s3control.BucketLifecycleConfigurationRuleExpiration;
        /**
         * Configuration block containing settings for filtering.
         */
        filter?: outputs.s3control.BucketLifecycleConfigurationRuleFilter;
        /**
         * Unique identifier for the rule.
         */
        id: string;
        /**
         * Status of the rule. Valid values: `Enabled` and `Disabled`. Defaults to `Enabled`.
         */
        status?: string;
    }

    export interface BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload {
        /**
         * Number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation: number;
    }

    export interface BucketLifecycleConfigurationRuleExpiration {
        /**
         * Date the object is to be deleted. Should be in `YYYY-MM-DD` date format, e.g., `2020-09-30`.
         */
        date?: string;
        /**
         * Number of days before the object is to be deleted.
         */
        days?: number;
        /**
         * Enable to remove a delete marker with no noncurrent versions. Cannot be specified with `date` or `days`.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleConfigurationRuleFilter {
        /**
         * Object prefix for rule filtering.
         */
        prefix?: string;
        /**
         * Key-value map of object tags for rule filtering.
         */
        tags?: {[key: string]: string};
    }

    export interface GetMultiRegionAccessPointPublicAccessBlock {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs). When set to `true` causes the following behavior:
         * * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         * * PUT Object calls fail if the request includes a public ACL.
         * * PUT Bucket calls fail if the request includes a public ACL.
         */
        blockPublicAcls: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. When set to `true` causes Amazon S3 to:
         * * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         */
        blockPublicPolicy: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. When set to `true` causes Amazon S3 to:
         * * Ignore all public ACLs on buckets in this account and any objects that they contain.
         */
        ignorePublicAcls: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. When set to `true`:
         * * Only the bucket owner and AWS Services can access buckets with public policies.
         */
        restrictPublicBuckets: boolean;
    }

    export interface GetMultiRegionAccessPointRegion {
        /**
         * The name of the bucket.
         */
        bucket: string;
        /**
         * The name of the region.
         */
        region: string;
    }

    export interface MultiRegionAccessPointDetails {
        name: string;
        publicAccessBlock?: outputs.s3control.MultiRegionAccessPointDetailsPublicAccessBlock;
        regions: outputs.s3control.MultiRegionAccessPointDetailsRegion[];
    }

    export interface MultiRegionAccessPointDetailsPublicAccessBlock {
        blockPublicAcls?: boolean;
        blockPublicPolicy?: boolean;
        ignorePublicAcls?: boolean;
        restrictPublicBuckets?: boolean;
    }

    export interface MultiRegionAccessPointDetailsRegion {
        bucket: string;
    }

    export interface MultiRegionAccessPointPolicyDetails {
        /**
         * The name of the Multi-Region Access Point.
         */
        name: string;
        /**
         * A valid JSON document that specifies the policy that you want to associate with this Multi-Region Access Point. Once applied, the policy can be edited, but not deleted. For more information, see the documentation on [Multi-Region Access Point Permissions](https://docs.aws.amazon.com/AmazonS3/latest/userguide/MultiRegionAccessPointPermissions.html).
         *
         * > **NOTE:** When you update the `policy`, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
         */
        policy: string;
    }

    export interface ObjectLambdaAccessPointConfiguration {
        /**
         * Allowed features. Valid values: `GetObject-Range`, `GetObject-PartNumber`.
         */
        allowedFeatures?: string[];
        /**
         * Whether or not the CloudWatch metrics configuration is enabled.
         */
        cloudWatchMetricsEnabled?: boolean;
        /**
         * Standard access point associated with the Object Lambda Access Point.
         */
        supportingAccessPoint: string;
        /**
         * List of transformation configurations for the Object Lambda Access Point. See Transformation Configuration below for more details.
         */
        transformationConfigurations: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfiguration[];
    }

    export interface ObjectLambdaAccessPointConfigurationTransformationConfiguration {
        /**
         * The actions of an Object Lambda Access Point configuration. Valid values: `GetObject`.
         */
        actions: string[];
        /**
         * The content transformation of an Object Lambda Access Point configuration. See Content Transformation below for more details.
         */
        contentTransformation: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformation;
    }

    export interface ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformation {
        /**
         * Configuration for an AWS Lambda function. See AWS Lambda below for more details.
         */
        awsLambda: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformationAwsLambda;
    }

    export interface ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformationAwsLambda {
        /**
         * The Amazon Resource Name (ARN) of the AWS Lambda function.
         */
        functionArn: string;
        /**
         * Additional JSON that provides supplemental data to the Lambda function used to transform objects.
         */
        functionPayload?: string;
    }

    export interface StorageLensConfigurationStorageLensConfiguration {
        /**
         * The account-level configurations of the S3 Storage Lens configuration. See Account Level below for more details.
         */
        accountLevel: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevel;
        /**
         * The Amazon Web Services organization for the S3 Storage Lens configuration. See AWS Org below for more details.
         */
        awsOrg?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAwsOrg;
        /**
         * Properties of S3 Storage Lens metrics export including the destination, schema and format. See Data Export below for more details.
         */
        dataExport?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExport;
        /**
         * Whether the S3 Storage Lens configuration is enabled.
         */
        enabled: boolean;
        /**
         * What is excluded in this configuration. Conflicts with `include`. See Exclude below for more details.
         */
        exclude?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationExclude;
        /**
         * What is included in this configuration. Conflicts with `exclude`. See Include below for more details.
         */
        include?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationInclude;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevel {
        /**
         * S3 Storage Lens activity metrics. See Activity Metrics below for more details.
         */
        activityMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelActivityMetrics;
        /**
         * Advanced cost-optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics below for more details.
         */
        advancedCostOptimizationMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics;
        /**
         * Advanced data-protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics below for more details.
         */
        advancedDataProtectionMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics;
        /**
         * S3 Storage Lens bucket-level configuration. See Bucket Level below for more details.
         */
        bucketLevel: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevel;
        /**
         * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics below for more details.
         */
        detailedStatusCodeMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelActivityMetrics {
        /**
         * Whether the activity metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics {
        /**
         * Whether advanced cost-optimization metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics {
        /**
         * Whether advanced data-protection metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevel {
        /**
         * S3 Storage Lens activity metrics. See Activity Metrics above for more details.
         */
        activityMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelActivityMetrics;
        /**
         * Advanced cost-optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics above for more details.
         */
        advancedCostOptimizationMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics;
        /**
         * Advanced data-protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics above for more details.
         */
        advancedDataProtectionMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics;
        /**
         * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics above for more details.
         */
        detailedStatusCodeMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics;
        /**
         * Prefix-level metrics for S3 Storage Lens. See Prefix Level below for more details.
         */
        prefixLevel?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevel;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelActivityMetrics {
        /**
         * Whether the activity metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics {
        /**
         * Whether advanced cost-optimization metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics {
        /**
         * Whether advanced data-protection metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics {
        /**
         * Whether detailed status code metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevel {
        /**
         * Prefix-level storage metrics for S3 Storage Lens. See Prefix Level Storage Metrics below for more details.
         */
        storageMetrics: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics {
        /**
         * Whether prefix-level storage metrics are enabled.
         */
        enabled?: boolean;
        /**
         * Selection criteria. See Selection Criteria below for more details.
         */
        selectionCriteria?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria {
        /**
         * The delimiter of the selection criteria being used.
         */
        delimiter?: string;
        /**
         * The max depth of the selection criteria.
         */
        maxDepth?: number;
        /**
         * The minimum number of storage bytes percentage whose metrics will be selected.
         */
        minStorageBytesPercentage?: number;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics {
        /**
         * Whether detailed status code metrics are enabled.
         */
        enabled?: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationAwsOrg {
        /**
         * The Amazon Resource Name (ARN) of the Amazon Web Services organization.
         */
        arn: string;
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExport {
        /**
         * Amazon CloudWatch publishing for S3 Storage Lens metrics. See Cloud Watch Metrics below for more details.
         */
        cloudWatchMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportCloudWatchMetrics;
        /**
         * The bucket where the S3 Storage Lens metrics export will be located. See S3 Bucket Destination below for more details.
         */
        s3BucketDestination?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestination;
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExportCloudWatchMetrics {
        /**
         * Whether CloudWatch publishing for S3 Storage Lens metrics is enabled.
         */
        enabled: boolean;
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestination {
        /**
         * The AWS account ID for the S3 Storage Lens configuration. Defaults to automatically determined account ID of the AWS provider.
         */
        accountId: string;
        /**
         * The Amazon Resource Name (ARN) of the Amazon Web Services organization.
         */
        arn: string;
        /**
         * Encryption of the metrics exports in this bucket. See Encryption below for more details.
         */
        encryption?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryption;
        /**
         * The export format. Valid values: `CSV`, `Parquet`.
         */
        format: string;
        /**
         * The schema version of the export file. Valid values: `V_1`.
         */
        outputSchemaVersion: string;
        /**
         * The prefix of the destination bucket where the metrics export will be delivered.
         */
        prefix?: string;
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryption {
        /**
         * SSE-KMS encryption. See SSE KMS below for more details.
         */
        sseKms?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms;
        /**
         * SSE-S3 encryption. An empty configuration block `{}` should be used.
         */
        sseS3s?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseS3[];
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms {
        /**
         * KMS key ARN.
         */
        keyId: string;
    }

    export interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseS3 {
    }

    export interface StorageLensConfigurationStorageLensConfigurationExclude {
        /**
         * List of S3 bucket ARNs.
         */
        buckets?: string[];
        /**
         * List of AWS Regions.
         */
        regions?: string[];
    }

    export interface StorageLensConfigurationStorageLensConfigurationInclude {
        /**
         * List of S3 bucket ARNs.
         */
        buckets?: string[];
        /**
         * List of AWS Regions.
         */
        regions?: string[];
    }

}

export namespace s3outposts {
    export interface EndpointNetworkInterface {
        /**
         * Identifier of the Elastic Network Interface (ENI).
         */
        networkInterfaceId: string;
    }

}

export namespace sagemaker {
    export interface AppImageConfigKernelGatewayImageConfig {
        /**
         * The URL where the Git repository is located. See File System Config details below.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigKernelGatewayImageConfigFileSystemConfig;
        /**
         * The default branch for the Git repository. See Kernel Spec details below.
         */
        kernelSpec: outputs.sagemaker.AppImageConfigKernelGatewayImageConfigKernelSpec;
    }

    export interface AppImageConfigKernelGatewayImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to `100`. Valid values are `0` and `100`.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to `1000`. Valid values are `0` and `1000`.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to `/home/sagemaker-user`.
         *
         * > **Note:** When specifying `defaultGid` and `defaultUid`, Valid value pairs are [`0`, `0`] and [`100`, `1000`].
         */
        mountPath?: string;
    }

    export interface AppImageConfigKernelGatewayImageConfigKernelSpec {
        /**
         * The display name of the kernel.
         */
        displayName?: string;
        /**
         * The name of the kernel.
         */
        name: string;
    }

    export interface AppResourceSpec {
        /**
         * The instance type that the image version runs on. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface CodeRepositoryGitConfig {
        /**
         * The default branch for the Git repository.
         */
        branch?: string;
        /**
         * The URL where the Git repository is located.
         */
        repositoryUrl: string;
        /**
         * The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format: `{"username": UserName, "password": Password}`
         */
        secretArn?: string;
    }

    export interface DataQualityJobDefinitionDataQualityAppSpecification {
        /**
         * Sets the environment variables in the container that the monitoring job runs. A list of key value pairs.
         */
        environment?: {[key: string]: string};
        /**
         * The container image that the data quality monitoring job runs.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.
         */
        recordPreprocessorSourceUri?: string;
    }

    export interface DataQualityJobDefinitionDataQualityBaselineConfig {
        /**
         * The constraints resource for a monitoring job. Fields are documented below.
         */
        constraintsResource?: outputs.sagemaker.DataQualityJobDefinitionDataQualityBaselineConfigConstraintsResource;
        /**
         * The statistics resource for a monitoring job. Fields are documented below.
         */
        statisticsResource?: outputs.sagemaker.DataQualityJobDefinitionDataQualityBaselineConfigStatisticsResource;
    }

    export interface DataQualityJobDefinitionDataQualityBaselineConfigConstraintsResource {
        /**
         * The Amazon S3 URI for the constraints resource.
         */
        s3Uri?: string;
    }

    export interface DataQualityJobDefinitionDataQualityBaselineConfigStatisticsResource {
        /**
         * The Amazon S3 URI for the statistics resource.
         */
        s3Uri?: string;
    }

    export interface DataQualityJobDefinitionDataQualityJobInput {
        /**
         * Input object for the batch transform job. Fields are documented below.
         */
        batchTransformInput?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInput;
        /**
         * Input object for the endpoint. Fields are documented below.
         */
        endpointInput?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputEndpointInput;
    }

    export interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInput {
        /**
         * The Amazon S3 location being used to capture the data.
         */
        dataCapturedDestinationS3Uri: string;
        /**
         * The dataset format for your batch transform job. Fields are documented below.
         */
        datasetFormat: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormat;
        /**
         * Path to the filesystem where the batch transform data is available to the container. Defaults to `/opt/ml/processing/input`.
         */
        localPath?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to `FullyReplicated`. Valid values are `FullyReplicated` or `ShardedByS3Key`
         */
        s3DataDistributionType: string;
        /**
         * Whether the `Pipe` or `File` is used as the input mode for transferring data for the monitoring job. `Pipe` mode is recommended for large datasets. `File` mode is useful for small files that fit in memory. Defaults to `File`.  Valid values are `Pipe` or `File`
         */
        s3InputMode: string;
    }

    export interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormat {
        /**
         * The CSV dataset used in the monitoring job. Fields are documented below.
         */
        csv?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatCsv;
        /**
         * The JSON dataset used in the monitoring job. Fields are documented below.
         */
        json?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatJson;
    }

    export interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatCsv {
        /**
         * Indicates if the CSV data has a header.
         */
        header?: boolean;
    }

    export interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatJson {
        /**
         * Indicates if the file should be read as a json object per line.
         */
        line?: boolean;
    }

    export interface DataQualityJobDefinitionDataQualityJobInputEndpointInput {
        /**
         * An endpoint in customer's account which has `dataCaptureConfig` enabled.
         */
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container. Defaults to `/opt/ml/processing/input`.
         */
        localPath?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to `FullyReplicated`. Valid values are `FullyReplicated` or `ShardedByS3Key`
         */
        s3DataDistributionType: string;
        /**
         * Whether the `Pipe` or `File` is used as the input mode for transferring data for the monitoring job. `Pipe` mode is recommended for large datasets. `File` mode is useful for small files that fit in memory. Defaults to `File`.  Valid values are `Pipe` or `File`
         */
        s3InputMode: string;
    }

    export interface DataQualityJobDefinitionDataQualityJobOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded. Fields are documented below.
         */
        monitoringOutputs: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputs;
    }

    export interface DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputs {
        /**
         * The Amazon S3 storage location where the results of a monitoring job are saved. Fields are documented below.
         */
        s3Output: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputsS3Output;
    }

    export interface DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputsS3Output {
        /**
         * Path to the filesystem where the batch transform data is available to the container. Defaults to `/opt/ml/processing/input`.
         */
        localPath?: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes. Valid values are `Continuous` or `EndOfJob`
         */
        s3UploadMode: string;
        /**
         * The Amazon S3 URI for the constraints resource.
         */
        s3Uri: string;
    }

    export interface DataQualityJobDefinitionJobResources {
        /**
         * The configuration for the cluster resources used to run the processing job. Fields are documented below.
         */
        clusterConfig: outputs.sagemaker.DataQualityJobDefinitionJobResourcesClusterConfig;
    }

    export interface DataQualityJobDefinitionJobResourcesClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: number;
    }

    export interface DataQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between the instances used for the monitoring jobs. Choose `true` to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.
         */
        enableNetworkIsolation?: boolean;
        /**
         * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. Fields are documented below.
         */
        vpcConfig?: outputs.sagemaker.DataQualityJobDefinitionNetworkConfigVpcConfig;
    }

    export interface DataQualityJobDefinitionNetworkConfigVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the `subnets` field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect your training job or model.
         */
        subnets: string[];
    }

    export interface DataQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    export interface DeviceDevice {
        /**
         * A description for the device.
         */
        description?: string;
        /**
         * The name of the device.
         */
        deviceName: string;
        /**
         * Amazon Web Services Internet of Things (IoT) object name.
         */
        iotThingName?: string;
    }

    export interface DeviceFleetOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
         */
        kmsKeyId?: string;
        /**
         * The Amazon Simple Storage (S3) bucker URI.
         */
        s3OutputLocation: string;
    }

    export interface DomainDefaultSpaceSettings {
        /**
         * The execution role for the space.
         */
        executionRole: string;
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the space uses for communication.
         */
        securityGroups?: string[];
    }

    export interface DomainDefaultSpaceSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface DomainDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }

    export interface DomainDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDefaultSpaceSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface DomainDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface DomainDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDefaultUserSettings {
        /**
         * The Canvas app settings. See Canvas App Settings below.
         */
        canvasAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettings;
        /**
         * The execution role ARN for the user.
         */
        executionRole: string;
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettings;
        /**
         * The RSession app settings. See RSession App Settings below.
         */
        rSessionAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettings;
        /**
         * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudioServerProAppSettings below.
         */
        rStudioServerProAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsRStudioServerProAppSettings;
        /**
         * A list of security group IDs that will be attached to the user.
         */
        securityGroups?: string[];
        /**
         * The sharing settings. See Sharing Settings below.
         */
        sharingSettings?: outputs.sagemaker.DomainDefaultUserSettingsSharingSettings;
        /**
         * The TensorBoard app settings. See TensorBoard App Settings below.
         */
        tensorBoardAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsTensorBoardAppSettings;
    }

    export interface DomainDefaultUserSettingsCanvasAppSettings {
        /**
         * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
         */
        modelRegisterSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsModelRegisterSettings;
        /**
         * Time series forecast settings for the Canvas app. See Time Series Forecasting Settings below.
         */
        timeSeriesForecastingSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings;
    }

    export interface DomainDefaultUserSettingsCanvasAppSettingsModelRegisterSettings {
        /**
         * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
         */
        crossAccountModelRegisterRoleArn?: string;
        /**
         * Describes whether the integration to the model registry is enabled or disabled in the Canvas application.. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }

    export interface DomainDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
        /**
         * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the [AmazonSageMakerCanvasForecastAccess](https://docs.aws.amazon.com/sagemaker/latest/dg/security-iam-awsmanpol-canvas.html#security-iam-awsmanpol-AmazonSageMakerCanvasForecastAccess) policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
         */
        amazonForecastRoleArn?: string;
        /**
         * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }

    export interface DomainDefaultUserSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface DomainDefaultUserSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }

    export interface DomainDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDefaultUserSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface DomainDefaultUserSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface DomainDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDefaultUserSettingsRSessionAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec;
    }

    export interface DomainDefaultUserSettingsRSessionAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface DomainDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDefaultUserSettingsRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app. Valid values are `ENABLED` and `DISABLED`.
         */
        accessStatus?: string;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to `R_STUDIO_USER`. The `R_STUDIO_ADMIN` value allows the user access to the RStudio Administrative Dashboard. Valid values are `R_STUDIO_USER` and `R_STUDIO_ADMIN`.
         */
        userGroup?: string;
    }

    export interface DomainDefaultUserSettingsSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is `Disabled`. Valid values are `Allowed` and `Disabled`.
         */
        notebookOutputOption?: string;
        /**
         * When `notebookOutputOption` is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When `notebookOutputOption` is Allowed, the Amazon S3 bucket used to save the notebook cell output.
         */
        s3OutputPath?: string;
    }

    export interface DomainDefaultUserSettingsTensorBoardAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec;
    }

    export interface DomainDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainDomainSettings {
        /**
         * The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key [AWS Docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html). Valid values are `USER_PROFILE_NAME` and `DISABLED`.
         */
        executionRoleIdentityConfig?: string;
        /**
         * A collection of settings that configure the RStudioServerPro Domain-level app. see RStudioServerProDomainSettings below.
         */
        rStudioServerProDomainSettings?: outputs.sagemaker.DomainDomainSettingsRStudioServerProDomainSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
         */
        securityGroupIds?: string[];
    }

    export interface DomainDomainSettingsRStudioServerProDomainSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec;
        /**
         * The ARN of the execution role for the RStudioServerPro Domain-level app.
         */
        domainExecutionRoleArn: string;
        /**
         * A URL pointing to an RStudio Connect server.
         */
        rStudioConnectUrl?: string;
        /**
         * A URL pointing to an RStudio Package Manager server.
         */
        rStudioPackageManagerUrl?: string;
    }

    export interface DomainDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface DomainRetentionPolicy {
        /**
         * The retention policy for data stored on an Amazon Elastic File System (EFS) volume. Valid values are `Retain` or `Delete`.  Default value is `Retain`.
         */
        homeEfsFileSystem?: string;
    }

    export interface EndpointConfigurationAsyncInferenceConfig {
        /**
         * Configures the behavior of the client used by Amazon SageMaker to interact with the model container during asynchronous inference.
         */
        clientConfig?: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigClientConfig;
        /**
         * Specifies the configuration for asynchronous inference invocation outputs.
         */
        outputConfig: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigOutputConfig;
    }

    export interface EndpointConfigurationAsyncInferenceConfigClientConfig {
        /**
         * The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, Amazon SageMaker will choose an optimal value for you.
         */
        maxConcurrentInvocationsPerInstance?: number;
    }

    export interface EndpointConfigurationAsyncInferenceConfigOutputConfig {
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the asynchronous inference output in Amazon S3.
         */
        kmsKeyId?: string;
        /**
         * Specifies the configuration for notifications of inference results for asynchronous inference.
         */
        notificationConfig?: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigOutputConfigNotificationConfig;
        /**
         * The Amazon S3 location to upload failure inference responses to.
         */
        s3FailurePath?: string;
        /**
         * The Amazon S3 location to upload inference responses to.
         */
        s3OutputPath: string;
    }

    export interface EndpointConfigurationAsyncInferenceConfigOutputConfigNotificationConfig {
        /**
         * Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.
         */
        errorTopic?: string;
        /**
         * The Amazon SNS topics where you want the inference response to be included. Valid values are `SUCCESS_NOTIFICATION_TOPIC` and `ERROR_NOTIFICATION_TOPIC`.
         */
        includeInferenceResponseIns?: string[];
        /**
         * Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.
         */
        successTopic?: string;
    }

    export interface EndpointConfigurationDataCaptureConfig {
        /**
         * The content type headers to capture. Fields are documented below.
         */
        captureContentTypeHeader?: outputs.sagemaker.EndpointConfigurationDataCaptureConfigCaptureContentTypeHeader;
        /**
         * Specifies what data to capture. Fields are documented below.
         */
        captureOptions: outputs.sagemaker.EndpointConfigurationDataCaptureConfigCaptureOption[];
        /**
         * The URL for S3 location where the captured data is stored.
         */
        destinationS3Uri: string;
        /**
         * Flag to enable data capture. Defaults to `false`.
         */
        enableCapture?: boolean;
        /**
         * Portion of data to capture. Should be between 0 and 100.
         */
        initialSamplingPercentage: number;
        /**
         * Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt the captured data on Amazon S3.
         */
        kmsKeyId?: string;
    }

    export interface EndpointConfigurationDataCaptureConfigCaptureContentTypeHeader {
        /**
         * The CSV content type headers to capture.
         */
        csvContentTypes?: string[];
        /**
         * The JSON content type headers to capture.
         */
        jsonContentTypes?: string[];
    }

    export interface EndpointConfigurationDataCaptureConfigCaptureOption {
        /**
         * Specifies the data to be captured. Should be one of `Input` or `Output`.
         */
        captureMode: string;
    }

    export interface EndpointConfigurationProductionVariant {
        /**
         * The size of the Elastic Inference (EI) instance to use for the production variant.
         */
        acceleratorType?: string;
        /**
         * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests). Valid values between `60` and `3600`.
         */
        containerStartupHealthCheckTimeoutInSeconds?: number;
        /**
         * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
         */
        coreDumpConfig?: outputs.sagemaker.EndpointConfigurationProductionVariantCoreDumpConfig;
        /**
         * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
         */
        enableSsmAccess?: boolean;
        /**
         * Initial number of instances used for auto-scaling.
         */
        initialInstanceCount?: number;
        /**
         * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to `1.0`.
         */
        initialVariantWeight?: number;
        /**
         * The type of instance to start.
         */
        instanceType?: string;
        /**
         * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between `60` and `3600`.
         */
        modelDataDownloadTimeoutInSeconds?: number;
        /**
         * The name of the model to use.
         */
        modelName: string;
        /**
         * Specifies configuration for how an endpoint performs asynchronous inference.
         */
        serverlessConfig?: outputs.sagemaker.EndpointConfigurationProductionVariantServerlessConfig;
        /**
         * The name of the variant. If omitted, this provider will assign a random, unique name.
         */
        variantName: string;
        /**
         * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between `1` and `512`.
         */
        volumeSizeInGb: number;
    }

    export interface EndpointConfigurationProductionVariantCoreDumpConfig {
        /**
         * The Amazon S3 bucket to send the core dump to.
         */
        destinationS3Uri: string;
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
    }

    export interface EndpointConfigurationProductionVariantServerlessConfig {
        /**
         * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between `1` and `200`.
         */
        maxConcurrency: number;
        /**
         * The memory size of your serverless endpoint. Valid values are in 1 GB increments: `1024` MB, `2048` MB, `3072` MB, `4096` MB, `5120` MB, or `6144` MB.
         */
        memorySizeInMb: number;
        /**
         * The amount of provisioned concurrency to allocate for the serverless endpoint. Should be less than or equal to `maxConcurrency`. Valid values are between `1` and `200`.
         */
        provisionedConcurrency?: number;
    }

    export interface EndpointConfigurationShadowProductionVariant {
        /**
         * The size of the Elastic Inference (EI) instance to use for the production variant.
         */
        acceleratorType?: string;
        /**
         * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests). Valid values between `60` and `3600`.
         */
        containerStartupHealthCheckTimeoutInSeconds?: number;
        /**
         * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
         */
        coreDumpConfig?: outputs.sagemaker.EndpointConfigurationShadowProductionVariantCoreDumpConfig;
        /**
         * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
         */
        enableSsmAccess?: boolean;
        /**
         * Initial number of instances used for auto-scaling.
         */
        initialInstanceCount?: number;
        /**
         * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to `1.0`.
         */
        initialVariantWeight?: number;
        /**
         * The type of instance to start.
         */
        instanceType?: string;
        /**
         * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between `60` and `3600`.
         */
        modelDataDownloadTimeoutInSeconds?: number;
        /**
         * The name of the model to use.
         */
        modelName: string;
        /**
         * Specifies configuration for how an endpoint performs asynchronous inference.
         */
        serverlessConfig?: outputs.sagemaker.EndpointConfigurationShadowProductionVariantServerlessConfig;
        /**
         * The name of the variant. If omitted, this provider will assign a random, unique name.
         */
        variantName: string;
        /**
         * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between `1` and `512`.
         */
        volumeSizeInGb?: number;
    }

    export interface EndpointConfigurationShadowProductionVariantCoreDumpConfig {
        /**
         * The Amazon S3 bucket to send the core dump to.
         */
        destinationS3Uri: string;
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId: string;
    }

    export interface EndpointConfigurationShadowProductionVariantServerlessConfig {
        /**
         * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between `1` and `200`.
         */
        maxConcurrency: number;
        /**
         * The memory size of your serverless endpoint. Valid values are in 1 GB increments: `1024` MB, `2048` MB, `3072` MB, `4096` MB, `5120` MB, or `6144` MB.
         */
        memorySizeInMb: number;
        /**
         * The amount of provisioned concurrency to allocate for the serverless endpoint. Should be less than or equal to `maxConcurrency`. Valid values are between `1` and `200`.
         */
        provisionedConcurrency?: number;
    }

    export interface EndpointDeploymentConfig {
        /**
         * Automatic rollback configuration for handling endpoint deployment failures and recovery. See Auto Rollback Configuration.
         */
        autoRollbackConfiguration?: outputs.sagemaker.EndpointDeploymentConfigAutoRollbackConfiguration;
        /**
         * Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. See Blue Green Update Config.
         */
        blueGreenUpdatePolicy: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicy;
    }

    export interface EndpointDeploymentConfigAutoRollbackConfiguration {
        /**
         * List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment. See Alarms.
         */
        alarms?: outputs.sagemaker.EndpointDeploymentConfigAutoRollbackConfigurationAlarm[];
    }

    export interface EndpointDeploymentConfigAutoRollbackConfigurationAlarm {
        /**
         * The name of a CloudWatch alarm in your account.
         */
        alarmName: string;
    }

    export interface EndpointDeploymentConfigBlueGreenUpdatePolicy {
        /**
         * Maximum execution timeout for the deployment. Note that the timeout value should be larger than the total waiting time specified in `terminationWaitInSeconds` and `waitIntervalInSeconds`. Valid values are between `600` and `14400`.
         */
        maximumExecutionTimeoutInSeconds?: number;
        /**
         * Additional waiting time in seconds after the completion of an endpoint deployment before terminating the old endpoint fleet. Default is `0`. Valid values are between `0` and `3600`.
         */
        terminationWaitInSeconds?: number;
        /**
         * Defines the traffic routing strategy to shift traffic from the old fleet to the new fleet during an endpoint deployment. See Traffic Routing Configuration.
         */
        trafficRoutingConfiguration: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfiguration;
    }

    export interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfiguration {
        /**
         * Batch size for the first step to turn on traffic on the new endpoint fleet. Value must be less than or equal to 50% of the variant's total instance count. See Canary Size.
         */
        canarySize?: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationCanarySize;
        /**
         * Batch size for each step to turn on traffic on the new endpoint fleet. Value must be 10-50% of the variant's total instance count. See Linear Step Size.
         */
        linearStepSize?: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationLinearStepSize;
        /**
         * Traffic routing strategy type. Valid values are: `ALL_AT_ONCE`, `CANARY`, and `LINEAR`.
         */
        type: string;
        /**
         * The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet. Valid values are between `0` and `3600`.
         */
        waitIntervalInSeconds: number;
    }

    export interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationCanarySize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }

    export interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationLinearStepSize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }

    export interface FeatureGroupFeatureDefinition {
        /**
         * The name of a feature. `featureName` cannot be any of the following: `isDeleted`, `writeTime`, `apiInvocationTime`.
         */
        featureName?: string;
        /**
         * The value type of a feature. Valid values are `Integral`, `Fractional`, or `String`.
         */
        featureType?: string;
    }

    export interface FeatureGroupOfflineStoreConfig {
        /**
         * The meta data of the Glue table that is autogenerated when an OfflineStore is created. See Data Catalog Config Below.
         */
        dataCatalogConfig: outputs.sagemaker.FeatureGroupOfflineStoreConfigDataCatalogConfig;
        /**
         * Set to `true` to turn Online Store On.
         */
        disableGlueTableCreation?: boolean;
        /**
         * The Amazon Simple Storage (Amazon S3) location of OfflineStore. See S3 Storage Config Below.
         */
        s3StorageConfig: outputs.sagemaker.FeatureGroupOfflineStoreConfigS3StorageConfig;
        /**
         * Format for the offline store table. Supported formats are `Glue` (Default) and Apache `Iceberg` (https://iceberg.apache.org/).
         */
        tableFormat?: string;
    }

    export interface FeatureGroupOfflineStoreConfigDataCatalogConfig {
        /**
         * The name of the Glue table catalog.
         */
        catalog: string;
        /**
         * The name of the Glue table database.
         */
        database: string;
        /**
         * The name of the Glue table.
         */
        tableName: string;
    }

    export interface FeatureGroupOfflineStoreConfigS3StorageConfig {
        /**
         * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
         */
        kmsKeyId?: string;
        /**
         * The S3 URI, or location in Amazon S3, of OfflineStore.
         */
        s3Uri: string;
    }

    export interface FeatureGroupOnlineStoreConfig {
        /**
         * Set to `true` to disable the automatic creation of an AWS Glue table when configuring an OfflineStore.
         */
        enableOnlineStore?: boolean;
        /**
         * Security config for at-rest encryption of your OnlineStore. See Security Config Below.
         */
        securityConfig?: outputs.sagemaker.FeatureGroupOnlineStoreConfigSecurityConfig;
    }

    export interface FeatureGroupOnlineStoreConfigSecurityConfig {
        /**
         * The ID of the AWS Key Management Service (AWS KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
    }

    export interface FlowDefinitionHumanLoopActivationConfig {
        /**
         * defines under what conditions SageMaker creates a human loop. See Human Loop Activation Conditions Config details below.
         */
        humanLoopActivationConditionsConfig?: outputs.sagemaker.FlowDefinitionHumanLoopActivationConfigHumanLoopActivationConditionsConfig;
    }

    export interface FlowDefinitionHumanLoopActivationConfigHumanLoopActivationConditionsConfig {
        /**
         * A JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. For more information about how to structure the JSON, see [JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI](https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html).
         */
        humanLoopActivationConditions: string;
    }

    export interface FlowDefinitionHumanLoopConfig {
        /**
         * The Amazon Resource Name (ARN) of the human task user interface.
         */
        humanTaskUiArn: string;
        /**
         * Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. See Public Workforce Task Price details below.
         */
        publicWorkforceTaskPrice?: outputs.sagemaker.FlowDefinitionHumanLoopConfigPublicWorkforceTaskPrice;
        /**
         * The length of time that a task remains available for review by human workers. Valid value range between `1` and `864000`.
         */
        taskAvailabilityLifetimeInSeconds?: number;
        /**
         * The number of distinct workers who will perform the same task on each object. Valid value range between `1` and `3`.
         */
        taskCount: number;
        /**
         * A description for the human worker task.
         */
        taskDescription: string;
        /**
         * An array of keywords used to describe the task so that workers can discover the task.
         */
        taskKeywords?: string[];
        /**
         * The amount of time that a worker has to complete a task. The default value is `3600` seconds.
         */
        taskTimeLimitInSeconds?: number;
        /**
         * A title for the human worker task.
         */
        taskTitle: string;
        /**
         * The Amazon Resource Name (ARN) of the human task user interface. Amazon Resource Name (ARN) of a team of workers. For Public workforces see [AWS Docs](https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management-public.html).
         */
        workteamArn: string;
    }

    export interface FlowDefinitionHumanLoopConfigPublicWorkforceTaskPrice {
        /**
         * Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars. See Amount In Usd details below.
         */
        amountInUsd?: outputs.sagemaker.FlowDefinitionHumanLoopConfigPublicWorkforceTaskPriceAmountInUsd;
    }

    export interface FlowDefinitionHumanLoopConfigPublicWorkforceTaskPriceAmountInUsd {
        /**
         * The fractional portion, in cents, of the amount. Valid value range between `0` and `99`.
         */
        cents?: number;
        /**
         * The whole number of dollars in the amount. Valid value range between `0` and `2`.
         */
        dollars?: number;
        /**
         * Fractions of a cent, in tenths. Valid value range between `0` and `9`.
         */
        tenthFractionsOfACent?: number;
    }

    export interface FlowDefinitionHumanLoopRequestSource {
        /**
         * Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. Valid values are: `AWS/Rekognition/DetectModerationLabels/Image/V3` and `AWS/Textract/AnalyzeDocument/Forms/V1`.
         */
        awsManagedHumanLoopRequestSource: string;
    }

    export interface FlowDefinitionOutputConfig {
        /**
         * The Amazon Key Management Service (KMS) key ARN for server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * The Amazon S3 path where the object containing human output will be made available.
         */
        s3OutputPath: string;
    }

    export interface HumanTaskUIUiTemplate {
        /**
         * The content of the Liquid template for the worker user interface.
         */
        content?: string;
        /**
         * The SHA-256 digest of the contents of the template.
         */
        contentSha256: string;
        /**
         * The URL for the user interface template.
         */
        url: string;
    }

    export interface ModelContainer {
        /**
         * The DNS host name for the container.
         */
        containerHostname?: string;
        /**
         * Environment variables for the Docker container.
         * A list of key value pairs.
         */
        environment?: {[key: string]: string};
        /**
         * The registry path where the inference code image is stored in Amazon ECR.
         */
        image?: string;
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see [Using a Private Docker Registry for Real-Time Inference Containers](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html). see Image Config.
         */
        imageConfig?: outputs.sagemaker.ModelContainerImageConfig;
        /**
         * The container hosts value `SingleModel/MultiModel`. The default value is `SingleModel`.
         */
        mode?: string;
        /**
         * The URL for the S3 location where model artifacts are stored.
         */
        modelDataUrl?: string;
        /**
         * The Amazon Resource Name (ARN) of the model package to use to create the model.
         */
        modelPackageName?: string;
    }

    export interface ModelContainerImageConfig {
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: `Platform` and `Vpc`.
         */
        repositoryAccessMode: string;
        /**
         * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
         */
        repositoryAuthConfig?: outputs.sagemaker.ModelContainerImageConfigRepositoryAuthConfig;
    }

    export interface ModelContainerImageConfigRepositoryAuthConfig {
        /**
         * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see [Create a Lambda function with the console](https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html) in the _AWS Lambda Developer Guide_.
         */
        repositoryCredentialsProviderArn: string;
    }

    export interface ModelInferenceExecutionConfig {
        /**
         * The container hosts value `SingleModel/MultiModel`. The default value is `SingleModel`.
         */
        mode: string;
    }

    export interface ModelPrimaryContainer {
        /**
         * The DNS host name for the container.
         */
        containerHostname?: string;
        /**
         * Environment variables for the Docker container.
         * A list of key value pairs.
         */
        environment?: {[key: string]: string};
        /**
         * The registry path where the inference code image is stored in Amazon ECR.
         */
        image?: string;
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see [Using a Private Docker Registry for Real-Time Inference Containers](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html). see Image Config.
         */
        imageConfig?: outputs.sagemaker.ModelPrimaryContainerImageConfig;
        /**
         * The container hosts value `SingleModel/MultiModel`. The default value is `SingleModel`.
         */
        mode?: string;
        /**
         * The URL for the S3 location where model artifacts are stored.
         */
        modelDataUrl?: string;
        /**
         * The Amazon Resource Name (ARN) of the model package to use to create the model.
         */
        modelPackageName?: string;
    }

    export interface ModelPrimaryContainerImageConfig {
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: `Platform` and `Vpc`.
         */
        repositoryAccessMode: string;
        /**
         * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
         */
        repositoryAuthConfig?: outputs.sagemaker.ModelPrimaryContainerImageConfigRepositoryAuthConfig;
    }

    export interface ModelPrimaryContainerImageConfigRepositoryAuthConfig {
        /**
         * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see [Create a Lambda function with the console](https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html) in the _AWS Lambda Developer Guide_.
         */
        repositoryCredentialsProviderArn: string;
    }

    export interface ModelVpcConfig {
        securityGroupIds: string[];
        subnets: string[];
    }

    export interface MonitoringScheduleMonitoringScheduleConfig {
        /**
         * The name of the monitoring job definition to schedule.
         */
        monitoringJobDefinitionName: string;
        /**
         * The type of the monitoring job definition to schedule. Valid values are `DataQuality`, `ModelQuality`, `ModelBias` or `ModelExplainability`
         */
        monitoringType: string;
        /**
         * Configures the monitoring schedule. Fields are documented below.
         */
        scheduleConfig: outputs.sagemaker.MonitoringScheduleMonitoringScheduleConfigScheduleConfig;
    }

    export interface MonitoringScheduleMonitoringScheduleConfigScheduleConfig {
        /**
         * A cron expression that describes details about the monitoring schedule. For example, and hourly schedule would be `cron(0 * ? * * *)`.
         */
        scheduleExpression: string;
    }

    export interface NotebookInstanceInstanceMetadataServiceConfiguration {
        /**
         * Indicates the minimum IMDS version that the notebook instance supports. When passed "1" is passed. This means that both IMDSv1 and IMDSv2 are supported. Valid values are `1` and `2`.
         */
        minimumInstanceMetadataServiceVersion: string;
    }

    export interface ProjectServiceCatalogProvisioningDetails {
        /**
         * The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
         */
        pathId?: string;
        /**
         * The ID of the product to provision.
         */
        productId: string;
        /**
         * The ID of the provisioning artifact.
         */
        provisioningArtifactId: string;
        /**
         * A list of key value pairs that you specify when you provision a product. See Provisioning Parameter below.
         */
        provisioningParameters?: outputs.sagemaker.ProjectServiceCatalogProvisioningDetailsProvisioningParameter[];
    }

    export interface ProjectServiceCatalogProvisioningDetailsProvisioningParameter {
        /**
         * The key that identifies a provisioning parameter.
         */
        key: string;
        /**
         * The value of the provisioning parameter.
         */
        value?: string;
    }

    export interface SpaceSpaceSettings {
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettings;
    }

    export interface SpaceSpaceSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface SpaceSpaceSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }

    export interface SpaceSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface SpaceSpaceSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface SpaceSpaceSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface SpaceSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface UserProfileUserSettings {
        /**
         * The Canvas app settings. See Canvas App Settings below.
         */
        canvasAppSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettings;
        /**
         * The execution role ARN for the user.
         */
        executionRole: string;
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettings;
        /**
         * The RSession app settings. See RSession App Settings below.
         */
        rSessionAppSettings?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettings;
        /**
         * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudio Server Pro App Settings below.
         */
        rStudioServerProAppSettings?: outputs.sagemaker.UserProfileUserSettingsRStudioServerProAppSettings;
        /**
         * The security groups.
         */
        securityGroups?: string[];
        /**
         * The sharing settings. See Sharing Settings below.
         */
        sharingSettings?: outputs.sagemaker.UserProfileUserSettingsSharingSettings;
        /**
         * The TensorBoard app settings. See TensorBoard App Settings below.
         */
        tensorBoardAppSettings?: outputs.sagemaker.UserProfileUserSettingsTensorBoardAppSettings;
    }

    export interface UserProfileUserSettingsCanvasAppSettings {
        /**
         * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
         */
        modelRegisterSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsModelRegisterSettings;
        /**
         * Time series forecast settings for the Canvas app. see Time Series Forecasting Settings below.
         */
        timeSeriesForecastingSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings;
    }

    export interface UserProfileUserSettingsCanvasAppSettingsModelRegisterSettings {
        /**
         * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
         */
        crossAccountModelRegisterRoleArn?: string;
        /**
         * Describes whether the integration to the model registry is enabled or disabled in the Canvas application.. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }

    export interface UserProfileUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
        /**
         * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the [AmazonSageMakerCanvasForecastAccess](https://docs.aws.amazon.com/sagemaker/latest/dg/security-iam-awsmanpol-canvas.html#security-iam-awsmanpol-AmazonSageMakerCanvasForecastAccess) policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
         */
        amazonForecastRoleArn?: string;
        /**
         * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }

    export interface UserProfileUserSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface UserProfileUserSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }

    export interface UserProfileUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface UserProfileUserSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }

    export interface UserProfileUserSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface UserProfileUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface UserProfileUserSettingsRSessionAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettingsDefaultResourceSpec;
    }

    export interface UserProfileUserSettingsRSessionAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }

    export interface UserProfileUserSettingsRSessionAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface UserProfileUserSettingsRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app. Valid values are `ENABLED` and `DISABLED`.
         */
        accessStatus?: string;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to `R_STUDIO_USER`. The `R_STUDIO_ADMIN` value allows the user access to the RStudio Administrative Dashboard. Valid values are `R_STUDIO_USER` and `R_STUDIO_ADMIN`.
         */
        userGroup?: string;
    }

    export interface UserProfileUserSettingsSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is `Disabled`. Valid values are `Allowed` and `Disabled`.
         */
        notebookOutputOption?: string;
        /**
         * When `notebookOutputOption` is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When `notebookOutputOption` is Allowed, the Amazon S3 bucket used to save the notebook cell output.
         */
        s3OutputPath?: string;
    }

    export interface UserProfileUserSettingsTensorBoardAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.UserProfileUserSettingsTensorBoardAppSettingsDefaultResourceSpec;
    }

    export interface UserProfileUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }

    export interface WorkforceCognitoConfig {
        /**
         * The client ID for your Amazon Cognito user pool.
         */
        clientId: string;
        /**
         * ID for your Amazon Cognito user pool.
         */
        userPool: string;
    }

    export interface WorkforceOidcConfig {
        /**
         * The OIDC IdP authorization endpoint used to configure your private workforce.
         */
        authorizationEndpoint: string;
        /**
         * The OIDC IdP client ID used to configure your private workforce.
         */
        clientId: string;
        /**
         * The OIDC IdP client secret used to configure your private workforce.
         */
        clientSecret: string;
        /**
         * The OIDC IdP issuer used to configure your private workforce.
         */
        issuer: string;
        /**
         * The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
         */
        jwksUri: string;
        /**
         * The OIDC IdP logout endpoint used to configure your private workforce.
         */
        logoutEndpoint: string;
        /**
         * The OIDC IdP token endpoint used to configure your private workforce.
         */
        tokenEndpoint: string;
        /**
         * The OIDC IdP user information endpoint used to configure your private workforce.
         */
        userInfoEndpoint: string;
    }

    export interface WorkforceSourceIpConfig {
        /**
         * A list of up to 10 CIDR values.
         */
        cidrs: string[];
    }

    export interface WorkforceWorkforceVpcConfig {
        /**
         * The VPC security group IDs. The security groups must be for the same VPC as specified in the subnet.
         */
        securityGroupIds?: string[];
        /**
         * The ID of the subnets in the VPC that you want to connect.
         */
        subnets?: string[];
        vpcEndpointId: string;
        /**
         * The ID of the VPC that the workforce uses for communication.
         */
        vpcId?: string;
    }

    export interface WorkteamMemberDefinition {
        /**
         * The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
         */
        cognitoMemberDefinition?: outputs.sagemaker.WorkteamMemberDefinitionCognitoMemberDefinition;
        /**
         * A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
         */
        oidcMemberDefinition?: outputs.sagemaker.WorkteamMemberDefinitionOidcMemberDefinition;
    }

    export interface WorkteamMemberDefinitionCognitoMemberDefinition {
        /**
         * An identifier for an application client. You must create the app client ID using Amazon Cognito.
         */
        clientId: string;
        /**
         * An identifier for a user group.
         */
        userGroup: string;
        /**
         * An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
         */
        userPool: string;
    }

    export interface WorkteamMemberDefinitionOidcMemberDefinition {
        /**
         * A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
         */
        groups: string[];
    }

    export interface WorkteamNotificationConfiguration {
        /**
         * The ARN for the SNS topic to which notifications should be published.
         */
        notificationTopicArn?: string;
    }

}

export namespace scheduler {
    export interface ScheduleFlexibleTimeWindow {
        /**
         * Maximum time window during which a schedule can be invoked. Ranges from `1` to `1440` minutes.
         */
        maximumWindowInMinutes?: number;
        /**
         * Determines whether the schedule is invoked within a flexible time window. One of: `OFF`, `FLEXIBLE`.
         */
        mode: string;
    }

    export interface ScheduleTarget {
        /**
         * ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a [Service ARN specific to the target service](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html#supported-universal-targets).
         */
        arn: string;
        /**
         * Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
         */
        deadLetterConfig?: outputs.scheduler.ScheduleTargetDeadLetterConfig;
        /**
         * Templated target type for the Amazon ECS [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation. Detailed below.
         */
        ecsParameters?: outputs.scheduler.ScheduleTargetEcsParameters;
        /**
         * Templated target type for the EventBridge [`PutEvents`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation. Detailed below.
         */
        eventbridgeParameters?: outputs.scheduler.ScheduleTargetEventbridgeParameters;
        /**
         * Text, or well-formed JSON, passed to the target. Read more in [Universal target](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html).
         */
        input?: string;
        /**
         * Templated target type for the Amazon Kinesis [`PutRecord`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation. Detailed below.
         */
        kinesisParameters?: outputs.scheduler.ScheduleTargetKinesisParameters;
        /**
         * Information about the retry policy settings. Detailed below.
         */
        retryPolicy?: outputs.scheduler.ScheduleTargetRetryPolicy;
        /**
         * ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in [Set up the execution role](https://docs.aws.amazon.com/scheduler/latest/UserGuide/setting-up.html#setting-up-execution-role).
         *
         * The following arguments are optional:
         */
        roleArn: string;
        /**
         * Templated target type for the Amazon SageMaker [`StartPipelineExecution`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation. Detailed below.
         */
        sagemakerPipelineParameters?: outputs.scheduler.ScheduleTargetSagemakerPipelineParameters;
        /**
         * The templated target type for the Amazon SQS [`SendMessage`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Detailed below.
         */
        sqsParameters?: outputs.scheduler.ScheduleTargetSqsParameters;
    }

    export interface ScheduleTargetDeadLetterConfig {
        /**
         * ARN of the SQS queue specified as the destination for the dead-letter queue.
         */
        arn: string;
    }

    export interface ScheduleTargetEcsParameters {
        /**
         * Up to `6` capacity provider strategies to use for the task. Detailed below.
         */
        capacityProviderStrategies?: outputs.scheduler.ScheduleTargetEcsParametersCapacityProviderStrategy[];
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon ECS Developer Guide.
         */
        enableEcsManagedTags?: boolean;
        /**
         * Specifies whether to enable the execute command functionality for the containers in this task.
         */
        enableExecuteCommand?: boolean;
        /**
         * Specifies an ECS task group for the task. At most 255 characters.
         */
        group?: string;
        /**
         * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: `EC2`, `FARGATE`, `EXTERNAL`.
         */
        launchType?: string;
        /**
         * Configures the networking associated with the task. Detailed below.
         */
        networkConfiguration?: outputs.scheduler.ScheduleTargetEcsParametersNetworkConfiguration;
        /**
         * A set of up to 10 placement constraints to use for the task. Detailed below.
         */
        placementConstraints?: outputs.scheduler.ScheduleTargetEcsParametersPlacementConstraint[];
        /**
         * A set of up to 5 placement strategies. Detailed below.
         */
        placementStrategies?: outputs.scheduler.ScheduleTargetEcsParametersPlacementStrategy[];
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`.
         */
        platformVersion?: string;
        /**
         * Specifies whether to propagate the tags from the task definition to the task. One of: `TASK_DEFINITION`.
         */
        propagateTags?: string;
        /**
         * Reference ID to use for the task.
         */
        referenceId?: string;
        /**
         * The metadata that you apply to the task. Each tag consists of a key and an optional value. For more information, see [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the Amazon ECS API Reference.
         */
        tags?: {[key: string]: string};
        /**
         * The number of tasks to create. Ranges from `1` (default) to `10`.
         */
        taskCount?: number;
        /**
         * ARN of the task definition to use.
         *
         * The following arguments are optional:
         */
        taskDefinitionArn: string;
    }

    export interface ScheduleTargetEcsParametersCapacityProviderStrategy {
        /**
         * How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from `0` (default) to `100000`.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from `0` to `1000`.
         */
        weight?: number;
    }

    export interface ScheduleTargetEcsParametersNetworkConfiguration {
        /**
         * Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where `true` maps to `ENABLED` and `false` to `DISABLED`. You can specify `true` only when the `launchType` is set to `FARGATE`.
         */
        assignPublicIp?: boolean;
        /**
         * Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
         */
        securityGroups?: string[];
        /**
         * Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
         */
        subnets: string[];
    }

    export interface ScheduleTargetEcsParametersPlacementConstraint {
        /**
         * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is `distinctInstance`. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the Amazon ECS Developer Guide.
         */
        expression?: string;
        /**
         * The type of constraint. One of: `distinctInstance`, `memberOf`.
         */
        type: string;
    }

    export interface ScheduleTargetEcsParametersPlacementStrategy {
        /**
         * The field to apply the placement strategy against.
         */
        field?: string;
        /**
         * The type of placement strategy. One of: `random`, `spread`, `binpack`.
         */
        type: string;
    }

    export interface ScheduleTargetEventbridgeParameters {
        /**
         * Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
         */
        detailType: string;
        /**
         * Source of the event.
         */
        source: string;
    }

    export interface ScheduleTargetKinesisParameters {
        /**
         * Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
         */
        partitionKey: string;
    }

    export interface ScheduleTargetRetryPolicy {
        /**
         * Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from `60` to `86400` (default).
         */
        maximumEventAgeInSeconds?: number;
        /**
         * Maximum number of retry attempts to make before the request fails. Ranges from `0` to `185` (default).
         */
        maximumRetryAttempts?: number;
    }

    export interface ScheduleTargetSagemakerPipelineParameters {
        /**
         * Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
         */
        pipelineParameters?: outputs.scheduler.ScheduleTargetSagemakerPipelineParametersPipelineParameter[];
    }

    export interface ScheduleTargetSagemakerPipelineParametersPipelineParameter {
        /**
         * Name of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        name: string;
        /**
         * Value of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        value: string;
    }

    export interface ScheduleTargetSqsParameters {
        /**
         * FIFO message group ID to use as the target.
         */
        messageGroupId?: string;
    }

}

export namespace secretsmanager {
    export interface GetSecretRotationRotationRule {
        automaticallyAfterDays: number;
        duration: string;
        scheduleExpression: string;
    }

    export interface GetSecretsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Secrets Manager ListSecrets API Reference](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_ListSecrets.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface SecretReplica {
        /**
         * ARN, Key ID, or Alias of the AWS KMS key within the region secret is replicated to. If one is not specified, then Secrets Manager defaults to using the AWS account's default KMS key (`aws/secretsmanager`) in the region or creates one for use if non-existent.
         */
        kmsKeyId: string;
        /**
         * Date that you last accessed the secret in the Region.
         */
        lastAccessedDate: string;
        /**
         * Region for replicating the secret.
         */
        region: string;
        /**
         * Status can be `InProgress`, `Failed`, or `InSync`.
         */
        status: string;
        /**
         * Message such as `Replication succeeded` or `Secret with this name already exists in this region`.
         */
        statusMessage: string;
    }

    export interface SecretRotationRotationRules {
        /**
         * Specifies the number of days between automatic scheduled rotations of the secret. Either `automaticallyAfterDays` or `scheduleExpression` must be specified.
         */
        automaticallyAfterDays?: number;
        /**
         * The length of the rotation window in hours. For example, `3h` for a three hour window.
         */
        duration?: string;
        /**
         * A `cron()` or `rate()` expression that defines the schedule for rotating your secret. Either `automaticallyAfterDays` or `scheduleExpression` must be specified.
         */
        scheduleExpression?: string;
    }

}

export namespace securityhub {
    export interface InsightFilters {
        /**
         * AWS account ID that a finding is generated in. See String_Filter below for more details.
         */
        awsAccountIds?: outputs.securityhub.InsightFiltersAwsAccountId[];
        /**
         * The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details.
         */
        companyNames?: outputs.securityhub.InsightFiltersCompanyName[];
        /**
         * Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details.
         */
        complianceStatuses?: outputs.securityhub.InsightFiltersComplianceStatus[];
        /**
         * A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
         */
        confidences?: outputs.securityhub.InsightFiltersConfidence[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details.
         */
        createdAts?: outputs.securityhub.InsightFiltersCreatedAt[];
        /**
         * The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
         */
        criticalities?: outputs.securityhub.InsightFiltersCriticality[];
        /**
         * A finding's description. See String Filter below for more details.
         */
        descriptions?: outputs.securityhub.InsightFiltersDescription[];
        /**
         * The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
         */
        findingProviderFieldsConfidences?: outputs.securityhub.InsightFiltersFindingProviderFieldsConfidence[];
        /**
         * The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
         */
        findingProviderFieldsCriticalities?: outputs.securityhub.InsightFiltersFindingProviderFieldsCriticality[];
        /**
         * The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details.
         */
        findingProviderFieldsRelatedFindingsIds?: outputs.securityhub.InsightFiltersFindingProviderFieldsRelatedFindingsId[];
        /**
         * The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details.
         */
        findingProviderFieldsRelatedFindingsProductArns?: outputs.securityhub.InsightFiltersFindingProviderFieldsRelatedFindingsProductArn[];
        /**
         * The finding provider value for the severity label. See String Filter below for more details.
         */
        findingProviderFieldsSeverityLabels?: outputs.securityhub.InsightFiltersFindingProviderFieldsSeverityLabel[];
        /**
         * The finding provider's original value for the severity. See String Filter below for more details.
         */
        findingProviderFieldsSeverityOriginals?: outputs.securityhub.InsightFiltersFindingProviderFieldsSeverityOriginal[];
        /**
         * One or more finding types that the finding provider assigned to the finding. Uses the format of `namespace/category/classifier` that classify a finding. Valid namespace values include: `Software and Configuration Checks`, `TTPs`, `Effects`, `Unusual Behaviors`, and `Sensitive Data Identifications`. See String Filter below for more details.
         */
        findingProviderFieldsTypes?: outputs.securityhub.InsightFiltersFindingProviderFieldsType[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details.
         */
        firstObservedAts?: outputs.securityhub.InsightFiltersFirstObservedAt[];
        /**
         * The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details.
         */
        generatorIds?: outputs.securityhub.InsightFiltersGeneratorId[];
        /**
         * The security findings provider-specific identifier for a finding. See String Filter below for more details.
         */
        ids?: outputs.securityhub.InsightFiltersId[];
        /**
         * A keyword for a finding. See Keyword Filter below for more details.
         */
        keywords?: outputs.securityhub.InsightFiltersKeyword[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details.
         */
        lastObservedAts?: outputs.securityhub.InsightFiltersLastObservedAt[];
        /**
         * The name of the malware that was observed. See String Filter below for more details.
         */
        malwareNames?: outputs.securityhub.InsightFiltersMalwareName[];
        /**
         * The filesystem path of the malware that was observed. See String Filter below for more details.
         */
        malwarePaths?: outputs.securityhub.InsightFiltersMalwarePath[];
        /**
         * The state of the malware that was observed. See String Filter below for more details.
         */
        malwareStates?: outputs.securityhub.InsightFiltersMalwareState[];
        /**
         * The type of the malware that was observed. See String Filter below for more details.
         */
        malwareTypes?: outputs.securityhub.InsightFiltersMalwareType[];
        /**
         * The destination domain of network-related information about a finding. See String Filter below for more details.
         */
        networkDestinationDomains?: outputs.securityhub.InsightFiltersNetworkDestinationDomain[];
        /**
         * The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkDestinationIpv4s?: outputs.securityhub.InsightFiltersNetworkDestinationIpv4[];
        /**
         * The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkDestinationIpv6s?: outputs.securityhub.InsightFiltersNetworkDestinationIpv6[];
        /**
         * The destination port of network-related information about a finding. See Number Filter below for more details.
         */
        networkDestinationPorts?: outputs.securityhub.InsightFiltersNetworkDestinationPort[];
        /**
         * Indicates the direction of network traffic associated with a finding. See String Filter below for more details.
         */
        networkDirections?: outputs.securityhub.InsightFiltersNetworkDirection[];
        /**
         * The protocol of network-related information about a finding. See String Filter below for more details.
         */
        networkProtocols?: outputs.securityhub.InsightFiltersNetworkProtocol[];
        /**
         * The source domain of network-related information about a finding. See String Filter below for more details.
         */
        networkSourceDomains?: outputs.securityhub.InsightFiltersNetworkSourceDomain[];
        /**
         * The source IPv4 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkSourceIpv4s?: outputs.securityhub.InsightFiltersNetworkSourceIpv4[];
        /**
         * The source IPv6 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkSourceIpv6s?: outputs.securityhub.InsightFiltersNetworkSourceIpv6[];
        /**
         * The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details.
         */
        networkSourceMacs?: outputs.securityhub.InsightFiltersNetworkSourceMac[];
        /**
         * The source port of network-related information about a finding. See Number Filter below for more details.
         */
        networkSourcePorts?: outputs.securityhub.InsightFiltersNetworkSourcePort[];
        /**
         * The text of a note. See String Filter below for more details.
         */
        noteTexts?: outputs.securityhub.InsightFiltersNoteText[];
        /**
         * The timestamp of when the note was updated. See Date Filter below for more details.
         */
        noteUpdatedAts?: outputs.securityhub.InsightFiltersNoteUpdatedAt[];
        /**
         * The principal that created a note. See String Filter below for more details.
         */
        noteUpdatedBies?: outputs.securityhub.InsightFiltersNoteUpdatedBy[];
        /**
         * The date/time that the process was launched. See Date Filter below for more details.
         */
        processLaunchedAts?: outputs.securityhub.InsightFiltersProcessLaunchedAt[];
        /**
         * The name of the process. See String Filter below for more details.
         */
        processNames?: outputs.securityhub.InsightFiltersProcessName[];
        /**
         * The parent process ID. See Number Filter below for more details.
         */
        processParentPids?: outputs.securityhub.InsightFiltersProcessParentPid[];
        /**
         * The path to the process executable. See String Filter below for more details.
         */
        processPaths?: outputs.securityhub.InsightFiltersProcessPath[];
        /**
         * The process ID. See Number Filter below for more details.
         */
        processPids?: outputs.securityhub.InsightFiltersProcessPid[];
        /**
         * The date/time that the process was terminated. See Date Filter below for more details.
         */
        processTerminatedAts?: outputs.securityhub.InsightFiltersProcessTerminatedAt[];
        /**
         * The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.
         */
        productArns?: outputs.securityhub.InsightFiltersProductArn[];
        /**
         * A data type where security-findings providers can include additional solution-specific details that aren't part of the defined `AwsSecurityFinding` format. See Map Filter below for more details.
         */
        productFields?: outputs.securityhub.InsightFiltersProductField[];
        /**
         * The name of the solution (product) that generates findings. See String Filter below for more details.
         */
        productNames?: outputs.securityhub.InsightFiltersProductName[];
        /**
         * The recommendation of what to do about the issue described in a finding. See String Filter below for more details.
         */
        recommendationTexts?: outputs.securityhub.InsightFiltersRecommendationText[];
        /**
         * The updated record state for the finding. See String Filter below for more details.
         */
        recordStates?: outputs.securityhub.InsightFiltersRecordState[];
        /**
         * The solution-generated identifier for a related finding. See String Filter below for more details.
         */
        relatedFindingsIds?: outputs.securityhub.InsightFiltersRelatedFindingsId[];
        /**
         * The ARN of the solution that generated a related finding. See String Filter below for more details.
         */
        relatedFindingsProductArns?: outputs.securityhub.InsightFiltersRelatedFindingsProductArn[];
        /**
         * The IAM profile ARN of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceIamInstanceProfileArns?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIamInstanceProfileArn[];
        /**
         * The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceImageIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceImageId[];
        /**
         * The IPv4 addresses associated with the instance. See Ip Filter below for more details.
         */
        resourceAwsEc2InstanceIpv4Addresses?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIpv4Address[];
        /**
         * The IPv6 addresses associated with the instance. See Ip Filter below for more details.
         */
        resourceAwsEc2InstanceIpv6Addresses?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIpv6Address[];
        /**
         * The key name associated with the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceKeyNames?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceKeyName[];
        /**
         * The date and time the instance was launched. See Date Filter below for more details.
         */
        resourceAwsEc2InstanceLaunchedAts?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceLaunchedAt[];
        /**
         * The identifier of the subnet that the instance was launched in. See String Filter below for more details.
         */
        resourceAwsEc2InstanceSubnetIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceSubnetId[];
        /**
         * The instance type of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceTypes?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceType[];
        /**
         * The identifier of the VPC that the instance was launched in. See String Filter below for more details.
         */
        resourceAwsEc2InstanceVpcIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceVpcId[];
        /**
         * The creation date/time of the IAM access key related to a finding. See Date Filter below for more details.
         */
        resourceAwsIamAccessKeyCreatedAts?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyCreatedAt[];
        /**
         * The status of the IAM access key related to a finding. See String Filter below for more details.
         */
        resourceAwsIamAccessKeyStatuses?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyStatus[];
        /**
         * The user associated with the IAM access key related to a finding. See String Filter below for more details.
         */
        resourceAwsIamAccessKeyUserNames?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyUserName[];
        /**
         * The canonical user ID of the owner of the S3 bucket. See String Filter below for more details.
         */
        resourceAwsS3BucketOwnerIds?: outputs.securityhub.InsightFiltersResourceAwsS3BucketOwnerId[];
        /**
         * The display name of the owner of the S3 bucket. See String Filter below for more details.
         */
        resourceAwsS3BucketOwnerNames?: outputs.securityhub.InsightFiltersResourceAwsS3BucketOwnerName[];
        /**
         * The identifier of the image related to a finding. See String Filter below for more details.
         */
        resourceContainerImageIds?: outputs.securityhub.InsightFiltersResourceContainerImageId[];
        /**
         * The name of the image related to a finding. See String Filter below for more details.
         */
        resourceContainerImageNames?: outputs.securityhub.InsightFiltersResourceContainerImageName[];
        /**
         * The date/time that the container was started. See Date Filter below for more details.
         */
        resourceContainerLaunchedAts?: outputs.securityhub.InsightFiltersResourceContainerLaunchedAt[];
        /**
         * The name of the container related to a finding. See String Filter below for more details.
         */
        resourceContainerNames?: outputs.securityhub.InsightFiltersResourceContainerName[];
        /**
         * The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.
         */
        resourceDetailsOthers?: outputs.securityhub.InsightFiltersResourceDetailsOther[];
        /**
         * The canonical identifier for the given resource type. See String Filter below for more details.
         */
        resourceIds?: outputs.securityhub.InsightFiltersResourceId[];
        /**
         * The canonical AWS partition name that the Region is assigned to. See String Filter below for more details.
         */
        resourcePartitions?: outputs.securityhub.InsightFiltersResourcePartition[];
        /**
         * The canonical AWS external Region name where this resource is located. See String Filter below for more details.
         */
        resourceRegions?: outputs.securityhub.InsightFiltersResourceRegion[];
        /**
         * A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details.
         */
        resourceTags?: outputs.securityhub.InsightFiltersResourceTag[];
        /**
         * Specifies the type of the resource that details are provided for. See String Filter below for more details.
         */
        resourceTypes?: outputs.securityhub.InsightFiltersResourceType[];
        /**
         * The label of a finding's severity. See String Filter below for more details.
         */
        severityLabels?: outputs.securityhub.InsightFiltersSeverityLabel[];
        /**
         * A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.
         */
        sourceUrls?: outputs.securityhub.InsightFiltersSourceUrl[];
        /**
         * The category of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorCategories?: outputs.securityhub.InsightFiltersThreatIntelIndicatorCategory[];
        /**
         * The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details.
         */
        threatIntelIndicatorLastObservedAts?: outputs.securityhub.InsightFiltersThreatIntelIndicatorLastObservedAt[];
        /**
         * The URL for more details from the source of the threat intelligence. See String Filter below for more details.
         */
        threatIntelIndicatorSourceUrls?: outputs.securityhub.InsightFiltersThreatIntelIndicatorSourceUrl[];
        /**
         * The source of the threat intelligence. See String Filter below for more details.
         */
        threatIntelIndicatorSources?: outputs.securityhub.InsightFiltersThreatIntelIndicatorSource[];
        /**
         * The type of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorTypes?: outputs.securityhub.InsightFiltersThreatIntelIndicatorType[];
        /**
         * The value of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorValues?: outputs.securityhub.InsightFiltersThreatIntelIndicatorValue[];
        /**
         * A finding's title. See String Filter below for more details.
         */
        titles?: outputs.securityhub.InsightFiltersTitle[];
        /**
         * A finding type in the format of `namespace/category/classifier` that classifies a finding. See String Filter below for more details.
         */
        types?: outputs.securityhub.InsightFiltersType[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details.
         */
        updatedAts?: outputs.securityhub.InsightFiltersUpdatedAt[];
        /**
         * A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details.
         */
        userDefinedValues?: outputs.securityhub.InsightFiltersUserDefinedValue[];
        /**
         * The veracity of a finding. See String Filter below for more details.
         */
        verificationStates?: outputs.securityhub.InsightFiltersVerificationState[];
        /**
         * The status of the investigation into a finding. See Workflow Status Filter below for more details.
         */
        workflowStatuses?: outputs.securityhub.InsightFiltersWorkflowStatus[];
    }

    export interface InsightFiltersAwsAccountId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersCompanyName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersComplianceStatus {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersConfidence {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersCreatedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersCreatedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersCreatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersCriticality {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersDescription {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFindingProviderFieldsConfidence {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersFindingProviderFieldsCriticality {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersFindingProviderFieldsRelatedFindingsId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFindingProviderFieldsRelatedFindingsProductArn {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFindingProviderFieldsSeverityLabel {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFindingProviderFieldsSeverityOriginal {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFindingProviderFieldsType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersFirstObservedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersFirstObservedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersFirstObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersGeneratorId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersKeyword {
        /**
         * A value for the keyword.
         */
        value: string;
    }

    export interface InsightFiltersLastObservedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersLastObservedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersLastObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersMalwareName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersMalwarePath {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersMalwareState {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersMalwareType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkDestinationDomain {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkDestinationIpv4 {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersNetworkDestinationIpv6 {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersNetworkDestinationPort {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersNetworkDirection {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkProtocol {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkSourceDomain {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkSourceIpv4 {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersNetworkSourceIpv6 {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersNetworkSourceMac {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNetworkSourcePort {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersNoteText {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersNoteUpdatedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersNoteUpdatedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersNoteUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersNoteUpdatedBy {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersProcessLaunchedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersProcessLaunchedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersProcessLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersProcessName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersProcessParentPid {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersProcessPath {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersProcessPid {
        /**
         * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
         */
        eq?: string;
        /**
         * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        gte?: string;
        /**
         * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
         */
        lte?: string;
    }

    export interface InsightFiltersProcessTerminatedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersProcessTerminatedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersProcessTerminatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersProductArn {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersProductField {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * The key of the map filter. For example, for `ResourceTags`, `Key` identifies the name of the tag. For `UserDefinedFields`, `Key` is the name of the field.
         */
        key: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersProductName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersRecommendationText {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersRecordState {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersRelatedFindingsId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersRelatedFindingsProductArn {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceIamInstanceProfileArn {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceImageId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceIpv4Address {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceIpv6Address {
        /**
         * A finding's CIDR value.
         */
        cidr: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceKeyName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceLaunchedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceLaunchedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersResourceAwsEc2InstanceSubnetId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsEc2InstanceVpcId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsIamAccessKeyCreatedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyCreatedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersResourceAwsIamAccessKeyCreatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersResourceAwsIamAccessKeyStatus {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsIamAccessKeyUserName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsS3BucketOwnerId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceAwsS3BucketOwnerName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceContainerImageId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceContainerImageName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceContainerLaunchedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersResourceContainerLaunchedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersResourceContainerLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersResourceContainerName {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceDetailsOther {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * The key of the map filter. For example, for `ResourceTags`, `Key` identifies the name of the tag. For `UserDefinedFields`, `Key` is the name of the field.
         */
        key: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceId {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourcePartition {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceRegion {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceTag {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * The key of the map filter. For example, for `ResourceTags`, `Key` identifies the name of the tag. For `UserDefinedFields`, `Key` is the name of the field.
         */
        key: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersResourceType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersSeverityLabel {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersSourceUrl {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersThreatIntelIndicatorCategory {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersThreatIntelIndicatorLastObservedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersThreatIntelIndicatorLastObservedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersThreatIntelIndicatorLastObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersThreatIntelIndicatorSource {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersThreatIntelIndicatorSourceUrl {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersThreatIntelIndicatorType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersThreatIntelIndicatorValue {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersTitle {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersType {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersUpdatedAt {
        /**
         * A configuration block of the date range for the date filter. See dateRange below for more details.
         */
        dateRange?: outputs.securityhub.InsightFiltersUpdatedAtDateRange;
        /**
         * An end date for the date filter. Required with `start` if `dateRange` is not specified.
         */
        end?: string;
        /**
         * A start date for the date filter. Required with `end` if `dateRange` is not specified.
         */
        start?: string;
    }

    export interface InsightFiltersUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }

    export interface InsightFiltersUserDefinedValue {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * The key of the map filter. For example, for `ResourceTags`, `Key` identifies the name of the tag. For `UserDefinedFields`, `Key` is the name of the field.
         */
        key: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersVerificationState {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

    export interface InsightFiltersWorkflowStatus {
        /**
         * The condition to apply to a string value when querying for findings. Valid values include: `EQUALS` and `NOT_EQUALS`.
         */
        comparison: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: string;
    }

}

export namespace servicecatalog {
    export interface GetLaunchPathsSummary {
        /**
         * Block for constraints on the portfolio-product relationship. See details below.
         */
        constraintSummaries: outputs.servicecatalog.GetLaunchPathsSummaryConstraintSummary[];
        /**
         * Name of the portfolio to which the path was assigned.
         */
        name: string;
        /**
         * Identifier of the product path.
         */
        pathId: string;
        /**
         * Tags associated with this product path.
         */
        tags: {[key: string]: string};
    }

    export interface GetLaunchPathsSummaryConstraintSummary {
        /**
         * Description of the constraint.
         */
        description: string;
        /**
         * Type of constraint. Valid values are `LAUNCH`, `NOTIFICATION`, `STACKSET`, and `TEMPLATE`.
         */
        type: string;
    }

    export interface GetPortfolioConstraintsDetail {
        /**
         * Identifier of the constraint.
         */
        constraintId: string;
        /**
         * Description of the constraint.
         */
        description: string;
        owner: string;
        /**
         * Portfolio identifier.
         *
         * The following arguments are optional:
         */
        portfolioId: string;
        /**
         * Product identifier.
         */
        productId: string;
        /**
         * Type of constraint. Valid values are `LAUNCH`, `NOTIFICATION`, `STACKSET`, and `TEMPLATE`.
         */
        type: string;
    }

    export interface GetProvisioningArtifactsProvisioningArtifactDetail {
        /**
         * Indicates whether the product version is active.
         */
        active: boolean;
        /**
         * The UTC time stamp of the creation time.
         */
        createdTime: string;
        /**
         * The description of the provisioning artifact.
         */
        description: string;
        /**
         * Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
         */
        guidance: string;
        /**
         * The identifier of the provisioning artifact.
         */
        id: string;
        /**
         * The name of the provisioning artifact.
         */
        name: string;
        /**
         * The type of provisioning artifact.
         */
        type: string;
    }

    export interface ProductProvisioningArtifactParameters {
        /**
         * Description of the provisioning artifact (i.e., version), including how it differs from the previous provisioning artifact.
         */
        description?: string;
        /**
         * Whether AWS Service Catalog stops validating the specified provisioning artifact template even if it is invalid.
         */
        disableTemplateValidation?: boolean;
        /**
         * Name of the provisioning artifact (for example, `v1`, `v2beta`). No spaces are allowed.
         */
        name?: string;
        /**
         * Template source as the physical ID of the resource that contains the template. Currently only supports CloudFormation stack ARN. Specify the physical ID as `arn:[partition]:cloudformation:[region]:[account ID]:stack/[stack name]/[resource ID]`.
         */
        templatePhysicalId?: string;
        /**
         * Template source as URL of the CloudFormation template in Amazon S3.
         */
        templateUrl?: string;
        /**
         * Type of provisioning artifact. See [AWS Docs](https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ProvisioningArtifactProperties.html) for valid list of values.
         */
        type?: string;
    }

    export interface ProvisionedProductOutput {
        /**
         * The description of the output.
         */
        description: string;
        /**
         * Parameter key.
         */
        key: string;
        /**
         * Parameter value.
         */
        value: string;
    }

    export interface ProvisionedProductProvisioningParameter {
        /**
         * Parameter key.
         */
        key: string;
        /**
         * Whether to ignore `value` and keep the previous parameter value. Ignored when initially provisioning a product.
         */
        usePreviousValue?: boolean;
        /**
         * Parameter value.
         */
        value?: string;
    }

    export interface ProvisionedProductStackSetProvisioningPreferences {
        /**
         * One or more AWS accounts that will have access to the provisioned product. The AWS accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the `awsServicecatalogProvisioningParameters` data source. If no values are specified, the default value is all accounts from the STACKSET constraint.
         */
        accounts?: string[];
        /**
         * Number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. You must specify either `failureToleranceCount` or `failureTolerancePercentage`, but not both. The default value is 0 if no value is specified.
         */
        failureToleranceCount?: number;
        /**
         * Percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. You must specify either `failureToleranceCount` or `failureTolerancePercentage`, but not both.
         */
        failureTolerancePercentage?: number;
        /**
         * Maximum number of accounts in which to perform this operation at one time. This is dependent on the value of `failureToleranceCount`. `maxConcurrencyCount` is at most one more than the `failureToleranceCount`. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. You must specify either `maxConcurrencyCount` or `maxConcurrencyPercentage`, but not both.
         */
        maxConcurrencyCount?: number;
        /**
         * Maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. You must specify either `maxConcurrencyCount` or `maxConcurrencyPercentage`, but not both.
         */
        maxConcurrencyPercentage?: number;
        /**
         * One or more AWS Regions where the provisioned product will be available. The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the `awsServicecatalogProvisioningParameters` data source. If no values are specified, the default value is all regions from the STACKSET constraint.
         */
        regions?: string[];
    }

    export interface ServiceActionDefinition {
        /**
         * ARN of the role that performs the self-service actions on your behalf. For example, `arn:aws:iam::12345678910:role/ActionRole`. To reuse the provisioned product launch role, set to `LAUNCH_ROLE`.
         */
        assumeRole?: string;
        /**
         * Name of the SSM document. For example, `AWS-RestartEC2Instance`. If you are using a shared SSM document, you must provide the ARN instead of the name.
         */
        name: string;
        /**
         * List of parameters in JSON format. For example: `[{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}]` or `[{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}]`.
         */
        parameters?: string;
        /**
         * Service action definition type. Valid value is `SSM_AUTOMATION`. Default is `SSM_AUTOMATION`.
         */
        type?: string;
        /**
         * SSM document version. For example, `1`.
         */
        version: string;
    }

}

export namespace servicediscovery {
    export interface GetServiceDnsConfig {
        /**
         * An array that contains one DnsRecord object for each resource record set.
         */
        dnsRecords: outputs.servicediscovery.GetServiceDnsConfigDnsRecord[];
        /**
         * ID of the namespace that the service belongs to.
         */
        namespaceId: string;
        /**
         * Routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
         */
        routingPolicy: string;
    }

    export interface GetServiceDnsConfigDnsRecord {
        /**
         * Amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
         */
        ttl: number;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type: string;
    }

    export interface GetServiceHealthCheckConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold: number;
        /**
         * Path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
         */
        resourcePath: string;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type: string;
    }

    export interface GetServiceHealthCheckCustomConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold: number;
    }

    export interface ServiceDnsConfig {
        /**
         * An array that contains one DnsRecord object for each resource record set.
         */
        dnsRecords: outputs.servicediscovery.ServiceDnsConfigDnsRecord[];
        /**
         * The ID of the namespace to use for DNS configuration.
         */
        namespaceId: string;
        /**
         * The routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
         */
        routingPolicy?: string;
    }

    export interface ServiceDnsConfigDnsRecord {
        /**
         * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
         */
        ttl: number;
        /**
         * The type of the resource, which indicates the value that Amazon Route 53 returns in response to DNS queries. Valid Values: A, AAAA, SRV, CNAME
         */
        type: string;
    }

    export interface ServiceHealthCheckConfig {
        /**
         * The number of consecutive health checks. Maximum value of 10.
         */
        failureThreshold?: number;
        /**
         * The path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
         */
        resourcePath?: string;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type?: string;
    }

    export interface ServiceHealthCheckCustomConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold?: number;
    }

}

export namespace servicequotas {
    export interface GetServiceQuotaUsageMetric {
        /**
         * The metric dimensions.
         */
        metricDimensions: outputs.servicequotas.GetServiceQuotaUsageMetricMetricDimension[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        metricNamespace: string;
        /**
         * The metric statistic that AWS recommend you use when determining quota usage.
         */
        metricStatisticRecommendation: string;
    }

    export interface GetServiceQuotaUsageMetricMetricDimension {
        class: string;
        resource: string;
        service: string;
        type: string;
    }

    export interface ServiceQuotaUsageMetric {
        /**
         * The metric dimensions.
         */
        metricDimensions: outputs.servicequotas.ServiceQuotaUsageMetricMetricDimension[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        metricNamespace: string;
        /**
         * The metric statistic that AWS recommend you use when determining quota usage.
         */
        metricStatisticRecommendation: string;
    }

    export interface ServiceQuotaUsageMetricMetricDimension {
        class: string;
        resource: string;
        service: string;
        type: string;
    }

}

export namespace ses {
    export interface ConfigurationSetDeliveryOptions {
        /**
         * Whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is `Require`, messages are only delivered if a TLS connection can be established. If the value is `Optional`, messages can be delivered in plain text if a TLS connection can't be established. Valid values: `Require` or `Optional`. Defaults to `Optional`.
         */
        tlsPolicy?: string;
    }

    export interface ConfigurationSetTrackingOptions {
        /**
         * Custom subdomain that is used to redirect email recipients to the Amazon SES event tracking domain.
         */
        customRedirectDomain?: string;
    }

    export interface EventDestinationCloudwatchDestination {
        /**
         * The default value for the event
         */
        defaultValue: string;
        /**
         * The name for the dimension
         */
        dimensionName: string;
        /**
         * The source for the value. May be any of `"messageTag"`, `"emailHeader"` or `"linkTag"`.
         */
        valueSource: string;
    }

    export interface EventDestinationKinesisDestination {
        /**
         * The ARN of the role that has permissions to access the Kinesis Stream
         */
        roleArn: string;
        /**
         * The ARN of the Kinesis Stream
         */
        streamArn: string;
    }

    export interface EventDestinationSnsDestination {
        /**
         * The ARN of the SNS topic
         */
        topicArn: string;
    }

    export interface ReceiptRuleAddHeaderAction {
        /**
         * The name of the header to add
         */
        headerName: string;
        /**
         * The value of the header to add
         */
        headerValue: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
    }

    export interface ReceiptRuleBounceAction {
        /**
         * The message to send
         */
        message: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The email address of the sender
         */
        sender: string;
        /**
         * The RFC 5321 SMTP reply code
         */
        smtpReplyCode: string;
        /**
         * The RFC 3463 SMTP enhanced status code
         */
        statusCode?: string;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }

    export interface ReceiptRuleLambdaAction {
        /**
         * The ARN of the Lambda function to invoke
         */
        functionArn: string;
        /**
         * `Event` or `RequestResponse`
         */
        invocationType?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }

    export interface ReceiptRuleS3Action {
        /**
         * The name of the S3 bucket
         */
        bucketName: string;
        /**
         * The ARN of the KMS key
         */
        kmsKeyArn?: string;
        /**
         * The key prefix of the S3 bucket
         */
        objectKeyPrefix?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }

    export interface ReceiptRuleSnsAction {
        /**
         * The encoding to use for the email within the Amazon SNS notification. Default value is `UTF-8`.
         */
        encoding?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn: string;
    }

    export interface ReceiptRuleStopAction {
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The scope to apply. The only acceptable value is `RuleSet`.
         */
        scope: string;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }

    export interface ReceiptRuleWorkmailAction {
        /**
         * The ARN of the WorkMail organization
         */
        organizationArn: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }

}

export namespace sesv2 {
    export interface ConfigurationSetDeliveryOptions {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName?: string;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). Valid values: `REQUIRE`, `OPTIONAL`.
         */
        tlsPolicy?: string;
    }

    export interface ConfigurationSetEventDestinationEventDestination {
        /**
         * An object that defines an Amazon CloudWatch destination for email events. See cloudWatchDestination below
         */
        cloudWatchDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationCloudWatchDestination;
        /**
         * When the event destination is enabled, the specified event types are sent to the destinations. Default: `false`.
         */
        enabled?: boolean;
        /**
         * An object that defines an Amazon Kinesis Data Firehose destination for email events. See kinesisFirehoseDestination below.
         */
        kinesisFirehoseDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination;
        /**
         * An array that specifies which events the Amazon SES API v2 should send to the destinations. Valid values: `SEND`, `REJECT`, `BOUNCE`, `COMPLAINT`, `DELIVERY`, `OPEN`, `CLICK`, `RENDERING_FAILURE`, `DELIVERY_DELAY`, `SUBSCRIPTION`.
         *
         * The following arguments are optional:
         */
        matchingEventTypes: string[];
        /**
         * An object that defines an Amazon Pinpoint project destination for email events. See pinpointDestination below.
         */
        pinpointDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationPinpointDestination;
        /**
         * An object that defines an Amazon SNS destination for email events. See snsDestination below.
         */
        snsDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationSnsDestination;
    }

    export interface ConfigurationSetEventDestinationEventDestinationCloudWatchDestination {
        /**
         * An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch. See dimensionConfiguration below.
         */
        dimensionConfigurations: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration[];
    }

    export interface ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration {
        /**
         * The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email.
         * ( `dimensionName` - (Required) The name of an Amazon CloudWatch dimension associated with an email sending metric.
         */
        defaultDimensionValue: string;
        dimensionName: string;
        /**
         * The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. Valid values: `MESSAGE_TAG`, `EMAIL_HEADER`, `LINK_TAG`.
         */
        dimensionValueSource: string;
    }

    export interface ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination {
        /**
         * The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email events to.
         */
        deliveryStreamArn: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email events to the Amazon Kinesis Data Firehose stream.
         */
        iamRoleArn: string;
    }

    export interface ConfigurationSetEventDestinationEventDestinationPinpointDestination {
        applicationArn: string;
    }

    export interface ConfigurationSetEventDestinationEventDestinationSnsDestination {
        /**
         * The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to.
         */
        topicArn: string;
    }

    export interface ConfigurationSetReputationOptions {
        /**
         * The date and time (in Unix time) when the reputation metrics were last given a fresh start. When your account is given a fresh start, your reputation metrics are calculated starting from the date of the fresh start.
         */
        lastFreshStart: string;
        /**
         * If `true`, tracking of reputation metrics is enabled for the configuration set. If `false`, tracking of reputation metrics is disabled for the configuration set.
         */
        reputationMetricsEnabled: boolean;
    }

    export interface ConfigurationSetSendingOptions {
        /**
         * If `true`, email sending is enabled for the configuration set. If `false`, email sending is disabled for the configuration set.
         */
        sendingEnabled: boolean;
    }

    export interface ConfigurationSetSuppressionOptions {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account. Valid values: `BOUNCE`, `COMPLAINT`.
         */
        suppressedReasons?: string[];
    }

    export interface ConfigurationSetTrackingOptions {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain: string;
    }

    export interface ConfigurationSetVdmOptions {
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Dashboard.
         */
        dashboardOptions?: outputs.sesv2.ConfigurationSetVdmOptionsDashboardOptions;
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Guardian.
         */
        guardianOptions?: outputs.sesv2.ConfigurationSetVdmOptionsGuardianOptions;
    }

    export interface ConfigurationSetVdmOptionsDashboardOptions {
        /**
         * Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
         */
        engagementMetrics?: string;
    }

    export interface ConfigurationSetVdmOptionsGuardianOptions {
        /**
         * Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
         */
        optimizedSharedDelivery?: string;
    }

    export interface ContactListTopic {
        /**
         * The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
         */
        defaultSubscriptionStatus: string;
        /**
         * A description of what the topic is about, which the contact will see.
         */
        description?: string;
        /**
         * The name of the topic the contact will see.
         */
        displayName: string;
        /**
         * The name of the topic.
         *
         * The following arguments are optional:
         */
        topicName: string;
    }

    export interface EmailIdentityDkimSigningAttributes {
        /**
         * [Easy DKIM] The key length of the DKIM key pair in use.
         */
        currentSigningKeyLength: string;
        /**
         * [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
         *
         * > **NOTE:** You have to delete the first and last lines ('-----BEGIN PRIVATE KEY-----' and '-----END PRIVATE KEY-----', respectively) of the generated private key. Additionally, you have to remove the line breaks in the generated private key. The resulting value is a string of characters with no spaces or line breaks.
         */
        domainSigningPrivateKey?: string;
        /**
         * [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
         */
        domainSigningSelector?: string;
        /**
         * [Easy DKIM] The last time a key pair was generated for this identity.
         */
        lastKeyGenerationTimestamp: string;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day. Valid values: `RSA_1024_BIT`, `RSA_2048_BIT`.
         */
        nextSigningKeyLength: string;
        /**
         * A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
         */
        signingAttributesOrigin: string;
        /**
         * Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
         */
        status: string;
        /**
         * If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
         */
        tokens: string[];
    }

    export interface GetConfigurationSetDeliveryOption {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName: string;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS).
         */
        tlsPolicy: string;
    }

    export interface GetConfigurationSetReputationOption {
        /**
         * The date and time (in Unix time) when the reputation metrics were last given a fresh start.
         */
        lastFreshStart: string;
        /**
         * Specifies whether tracking of reputation metrics is enabled.
         */
        reputationMetricsEnabled: boolean;
    }

    export interface GetConfigurationSetSendingOption {
        /**
         * Specifies whether email sending is enabled.
         */
        sendingEnabled: boolean;
    }

    export interface GetConfigurationSetSuppressionOption {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
         */
        suppressedReasons: string[];
    }

    export interface GetConfigurationSetTrackingOption {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain: string;
    }

    export interface GetConfigurationSetVdmOption {
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Dashboard.
         */
        dashboardOptions: outputs.sesv2.GetConfigurationSetVdmOptionDashboardOption[];
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Guardian.
         */
        guardianOptions: outputs.sesv2.GetConfigurationSetVdmOptionGuardianOption[];
    }

    export interface GetConfigurationSetVdmOptionDashboardOption {
        /**
         * Specifies the status of your VDM engagement metrics collection.
         */
        engagementMetrics: string;
    }

    export interface GetConfigurationSetVdmOptionGuardianOption {
        /**
         * Specifies the status of your VDM optimized shared delivery.
         */
        optimizedSharedDelivery: string;
    }

    export interface GetDedicatedIpPoolDedicatedIp {
        /**
         * IPv4 address.
         */
        ip: string;
        /**
         * Indicates how complete the dedicated IP warm-up process is. When this value equals `1`, the address has completed the warm-up process and is ready for use.
         */
        warmupPercentage: number;
        /**
         * The warm-up status of a dedicated IP address. Valid values: `IN_PROGRESS`, `DONE`.
         */
        warmupStatus: string;
    }

    export interface GetEmailIdentityDkimSigningAttribute {
        /**
         * [Easy DKIM] The key length of the DKIM key pair in use.
         */
        currentSigningKeyLength: string;
        domainSigningPrivateKey: string;
        domainSigningSelector: string;
        /**
         * [Easy DKIM] The last time a key pair was generated for this identity.
         */
        lastKeyGenerationTimestamp: string;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
         */
        nextSigningKeyLength: string;
        /**
         * A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
         */
        signingAttributesOrigin: string;
        /**
         * Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
         */
        status: string;
        /**
         * If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
         */
        tokens: string[];
    }

}

export namespace sfn {
    export interface AliasRoutingConfiguration {
        /**
         * A version of the state machine.
         */
        stateMachineVersionArn: string;
        /**
         * Percentage of traffic routed to the state machine version.
         *
         * The following arguments are optional:
         */
        weight: number;
    }

    export interface GetAliasRoutingConfiguration {
        stateMachineVersionArn: string;
        weight: number;
    }

    export interface StateMachineLoggingConfiguration {
        /**
         * Determines whether execution data is included in your log. When set to `false`, data is excluded.
         */
        includeExecutionData?: boolean;
        /**
         * Defines which category of execution history events are logged. Valid values: `ALL`, `ERROR`, `FATAL`, `OFF`
         */
        level?: string;
        /**
         * Amazon Resource Name (ARN) of a CloudWatch log group. Make sure the State Machine has the correct IAM policies for logging. The ARN must end with `:*`
         */
        logDestination?: string;
    }

    export interface StateMachineTracingConfiguration {
        /**
         * When set to `true`, AWS X-Ray tracing is enabled. Make sure the State Machine has the correct IAM policies for logging. See the [AWS Step Functions Developer Guide](https://docs.aws.amazon.com/step-functions/latest/dg/xray-iam.html) for details.
         */
        enabled?: boolean;
    }

}

export namespace signer {
    export interface GetSigningJobRevocationRecord {
        reason: string;
        revokedAt: string;
        revokedBy: string;
    }

    export interface GetSigningJobSignedObject {
        s3s: outputs.signer.GetSigningJobSignedObjectS3[];
    }

    export interface GetSigningJobSignedObjectS3 {
        bucket: string;
        key: string;
    }

    export interface GetSigningJobSource {
        s3s: outputs.signer.GetSigningJobSourceS3[];
    }

    export interface GetSigningJobSourceS3 {
        bucket: string;
        key: string;
        version: string;
    }

    export interface GetSigningProfileRevocationRecord {
        revocationEffectiveFrom: string;
        revokedAt: string;
        revokedBy: string;
    }

    export interface GetSigningProfileSignatureValidityPeriod {
        type: string;
        value: number;
    }

    export interface SigningJobDestination {
        /**
         * A configuration block describing the S3 Destination object: See S3 Destination below for details.
         */
        s3: outputs.signer.SigningJobDestinationS3;
    }

    export interface SigningJobDestinationS3 {
        /**
         * Name of the S3 bucket.
         */
        bucket: string;
        /**
         * An Amazon S3 object key prefix that you can use to limit signed objects keys to begin with the specified prefix.
         */
        prefix?: string;
    }

    export interface SigningJobRevocationRecord {
        reason: string;
        revokedAt: string;
        revokedBy: string;
    }

    export interface SigningJobSignedObject {
        /**
         * A configuration block describing the S3 Source object: See S3 Source below for details.
         */
        s3s: outputs.signer.SigningJobSignedObjectS3[];
    }

    export interface SigningJobSignedObjectS3 {
        /**
         * Name of the S3 bucket.
         */
        bucket: string;
        /**
         * Key name of the object that contains your unsigned code.
         */
        key: string;
    }

    export interface SigningJobSource {
        /**
         * A configuration block describing the S3 Source object: See S3 Source below for details.
         */
        s3: outputs.signer.SigningJobSourceS3;
    }

    export interface SigningJobSourceS3 {
        /**
         * Name of the S3 bucket.
         */
        bucket: string;
        /**
         * Key name of the object that contains your unsigned code.
         */
        key: string;
        /**
         * Version of your source image in your version enabled S3 bucket.
         */
        version: string;
    }

    export interface SigningProfileRevocationRecord {
        revocationEffectiveFrom: string;
        revokedAt: string;
        revokedBy: string;
    }

    export interface SigningProfileSignatureValidityPeriod {
        type: string;
        value: number;
    }

}

export namespace ssm {
    export interface AssociationOutputLocation {
        /**
         * The S3 bucket name.
         */
        s3BucketName: string;
        /**
         * The S3 bucket prefix. Results stored in the root if not configured.
         */
        s3KeyPrefix?: string;
        /**
         * The S3 bucket region.
         *
         * Targets specify what instance IDs or tags to apply the document to and has these keys:
         */
        s3Region?: string;
    }

    export interface AssociationTarget {
        /**
         * Either `InstanceIds` or `tag:Tag Name` to specify an EC2 tag.
         */
        key: string;
        /**
         * A list of instance IDs or tag values. AWS currently limits this list size to one value.
         */
        values: string[];
    }

    export interface DocumentAttachmentsSource {
        /**
         * The key describing the location of an attachment to a document. Valid key types include: `SourceUrl` and `S3FileUrl`
         */
        key: string;
        /**
         * The name of the document attachment file
         */
        name?: string;
        /**
         * The value describing the location of an attachment to a document
         */
        values: string[];
    }

    export interface DocumentParameter {
        defaultValue: string;
        /**
         * The description of the document.
         */
        description: string;
        /**
         * The name of the document.
         */
        name: string;
        type: string;
    }

    export interface GetInstancesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [SSM InstanceInformationStringFilter API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_InstanceInformationStringFilter.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetMaintenanceWindowsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [SSM DescribeMaintenanceWindows API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribeMaintenanceWindows.html#API_DescribeMaintenanceWindows_RequestSyntax).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetPatchBaselineApprovalRule {
        /**
         * The number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline.
         */
        approveAfterDays: number;
        /**
         * The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approveAfterDays`
         */
        approveUntilDate: string;
        /**
         * The compliance level for patches approved by this rule.
         */
        complianceLevel: string;
        /**
         * Boolean enabling the application of non-security updates.
         */
        enableNonSecurity: boolean;
        /**
         * The patch filter group that defines the criteria for the rule.
         */
        patchFilters: outputs.ssm.GetPatchBaselineApprovalRulePatchFilter[];
    }

    export interface GetPatchBaselineApprovalRulePatchFilter {
        /**
         * The key for the filter.
         */
        key: string;
        /**
         * The value for the filter.
         */
        values: string[];
    }

    export interface GetPatchBaselineGlobalFilter {
        /**
         * The key for the filter.
         */
        key: string;
        /**
         * The value for the filter.
         */
        values: string[];
    }

    export interface GetPatchBaselineSource {
        /**
         * The value of the yum repo configuration.
         */
        configuration: string;
        /**
         * The name specified to identify the patch source.
         */
        name: string;
        /**
         * The specific operating system versions a patch repository applies to.
         */
        products: string[];
    }

    export interface MaintenanceWindowTargetTarget {
        key: string;
        values: string[];
    }

    export interface MaintenanceWindowTaskTarget {
        key: string;
        /**
         * The array of strings.
         */
        values: string[];
    }

    export interface MaintenanceWindowTaskTaskInvocationParameters {
        /**
         * The parameters for an AUTOMATION task type. Documented below.
         */
        automationParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersAutomationParameters;
        /**
         * The parameters for a LAMBDA task type. Documented below.
         */
        lambdaParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersLambdaParameters;
        /**
         * The parameters for a RUN_COMMAND task type. Documented below.
         */
        runCommandParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParameters;
        /**
         * The parameters for a STEP_FUNCTIONS task type. Documented below.
         */
        stepFunctionsParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParameters;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersAutomationParameters {
        /**
         * The version of an Automation document to use during task execution.
         */
        documentVersion?: string;
        /**
         * The parameters for the RUN_COMMAND task execution. Documented below.
         */
        parameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameter[];
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The array of strings.
         */
        values: string[];
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersLambdaParameters {
        /**
         * Pass client-specific information to the Lambda function that you are invoking.
         */
        clientContext?: string;
        /**
         * JSON to provide to your Lambda function as input.
         */
        payload?: string;
        /**
         * Specify a Lambda function version or alias name.
         */
        qualifier?: string;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParameters {
        /**
         * Configuration options for sending command output to CloudWatch Logs. Documented below.
         */
        cloudwatchConfig?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfig;
        /**
         * Information about the command(s) to execute.
         */
        comment?: string;
        /**
         * The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
         */
        documentHash?: string;
        /**
         * SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: `Sha256` and `Sha1`
         */
        documentHashType?: string;
        /**
         * The version of an Automation document to use during task execution.
         */
        documentVersion?: string;
        /**
         * Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
         */
        notificationConfig?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfig;
        /**
         * The name of the Amazon S3 bucket.
         */
        outputS3Bucket?: string;
        /**
         * The Amazon S3 bucket subfolder.
         */
        outputS3KeyPrefix?: string;
        /**
         * The parameters for the RUN_COMMAND task execution. Documented below.
         */
        parameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameter[];
        /**
         * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
         */
        serviceRoleArn?: string;
        /**
         * If this time is reached and the command has not already started executing, it doesn't run.
         */
        timeoutSeconds?: number;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfig {
        /**
         * The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
         */
        cloudwatchLogGroupName: string;
        /**
         * Enables Systems Manager to send command output to CloudWatch Logs.
         */
        cloudwatchOutputEnabled?: boolean;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfig {
        /**
         * An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
         */
        notificationArn?: string;
        /**
         * The different events for which you can receive notifications. Valid values: `All`, `InProgress`, `Success`, `TimedOut`, `Cancelled`, and `Failed`
         */
        notificationEvents?: string[];
        /**
         * When specified with `Command`, receive notification when the status of a command changes. When specified with `Invocation`, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: `Command` and `Invocation`
         */
        notificationType?: string;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The array of strings.
         */
        values: string[];
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParameters {
        /**
         * The inputs for the STEP_FUNCTION task.
         */
        input?: string;
        /**
         * The name of the STEP_FUNCTION task.
         */
        name?: string;
    }

    export interface PatchBaselineApprovalRule {
        /**
         * The number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline.
         * Valid Range: 0 to 100.
         * Conflicts with `approveUntilDate`.
         */
        approveAfterDays?: number;
        /**
         * The cutoff date for auto approval of released patches.
         * Any patches released on or before this date are installed automatically.
         * Date is formatted as `YYYY-MM-DD`.
         * Conflicts with `approveAfterDays`
         */
        approveUntilDate?: string;
        /**
         * The compliance level for patches approved by this rule.
         * Valid values are `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `INFORMATIONAL`, and `UNSPECIFIED`.
         * The default value is `UNSPECIFIED`.
         */
        complianceLevel?: string;
        /**
         * Boolean enabling the application of non-security updates.
         * The default value is `false`.
         * Valid for Linux instances only.
         */
        enableNonSecurity?: boolean;
        /**
         * The patch filter group that defines the criteria for the rule.
         * Up to 5 patch filters can be specified per approval rule using Key/Value pairs.
         * Valid combinations of these Keys and the `operatingSystem` value can be found in the [SSM DescribePatchProperties API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchProperties.html).
         * Valid Values are exact values for the patch property given as the key, or a wildcard `*`, which matches all values.
         */
        patchFilters: outputs.ssm.PatchBaselineApprovalRulePatchFilter[];
    }

    export interface PatchBaselineApprovalRulePatchFilter {
        key: string;
        values: string[];
    }

    export interface PatchBaselineGlobalFilter {
        key: string;
        values: string[];
    }

    export interface PatchBaselineSource {
        /**
         * The value of the yum repo configuration.
         * For information about other options available for your yum repository configuration, see the [`dnf.conf` documentation](https://man7.org/linux/man-pages/man5/dnf.conf.5.html)
         */
        configuration: string;
        /**
         * The name specified to identify the patch source.
         */
        name: string;
        /**
         * The specific operating system versions a patch repository applies to, such as `"Ubuntu16.04"`, `"AmazonLinux2016.09"`, `"RedhatEnterpriseLinux7.2"` or `"Suse12.7"`.
         * For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html).
         */
        products: string[];
    }

    export interface ResourceDataSyncS3Destination {
        /**
         * Name of S3 bucket where the aggregated data is stored.
         */
        bucketName: string;
        /**
         * ARN of an encryption key for a destination in Amazon S3.
         */
        kmsKeyArn?: string;
        /**
         * Prefix for the bucket.
         */
        prefix?: string;
        /**
         * Region with the bucket targeted by the Resource Data Sync.
         */
        region: string;
        /**
         * A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
         */
        syncFormat?: string;
    }

}

export namespace ssmcontacts {
    export interface ContactChannelDeliveryAddress {
        /**
         * Details to engage this contact channel. The expected format depends on the contact channel type and is described in the [`ContactChannelAddress` section of the SSM Contacts API Reference](https://docs.aws.amazon.com/incident-manager/latest/APIReference/API_SSMContacts_ContactChannelAddress.html).
         */
        simpleAddress: string;
    }

    export interface GetContactChannelDeliveryAddress {
        simpleAddress: string;
    }

    export interface GetPlanStage {
        durationInMinutes: number;
        targets: outputs.ssmcontacts.GetPlanStageTarget[];
    }

    export interface GetPlanStageTarget {
        channelTargetInfos: outputs.ssmcontacts.GetPlanStageTargetChannelTargetInfo[];
        contactTargetInfos: outputs.ssmcontacts.GetPlanStageTargetContactTargetInfo[];
    }

    export interface GetPlanStageTargetChannelTargetInfo {
        contactChannelId: string;
        retryIntervalInMinutes: number;
    }

    export interface GetPlanStageTargetContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact or escalation plan.
         */
        contactId: string;
        isEssential: boolean;
    }

    export interface PlanStage {
        durationInMinutes: number;
        targets?: outputs.ssmcontacts.PlanStageTarget[];
    }

    export interface PlanStageTarget {
        channelTargetInfo?: outputs.ssmcontacts.PlanStageTargetChannelTargetInfo;
        contactTargetInfo?: outputs.ssmcontacts.PlanStageTargetContactTargetInfo;
    }

    export interface PlanStageTargetChannelTargetInfo {
        contactChannelId: string;
        retryIntervalInMinutes?: number;
    }

    export interface PlanStageTargetContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact or escalation plan.
         */
        contactId?: string;
        isEssential: boolean;
    }

}

export namespace ssmincidents {
    export interface GetReplicationSetRegion {
        /**
         * The ARN of the AWS Key Management Service (AWS KMS) encryption key.
         */
        kmsKeyArn: string;
        /**
         * The name of the Region.
         */
        name: string;
        /**
         * The current status of the Region.
         * * Valid Values: `ACTIVE` | `CREATING` | `UPDATING` | `DELETING` | `FAILED`
         */
        status: string;
        /**
         * More information about the status of a Region.
         */
        statusMessage: string;
    }

    export interface GetResponsePlanAction {
        /**
         * The Systems Manager automation document to start as the runbook at the beginning of the incident. The following values are supported:
         */
        ssmAutomations: outputs.ssmincidents.GetResponsePlanActionSsmAutomation[];
    }

    export interface GetResponsePlanActionSsmAutomation {
        /**
         * The automation document's name.
         */
        documentName: string;
        /**
         * The version of the automation document to use at runtime.
         */
        documentVersion: string;
        /**
         * The key-value pair used to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
         */
        dynamicParameters: {[key: string]: string};
        /**
         * The key-value pair parameters used when the automation document runs. The following values are supported:
         */
        parameters: outputs.ssmincidents.GetResponsePlanActionSsmAutomationParameter[];
        /**
         * The Amazon Resource Name (ARN) of the role that the automation document assumes when it runs commands.
         */
        roleArn: string;
        /**
         * The account that runs the automation document. This can be in either the management account or an application account.
         */
        targetAccount: string;
    }

    export interface GetResponsePlanActionSsmAutomationParameter {
        /**
         * The name of the PagerDuty configuration.
         */
        name: string;
        /**
         * The values for the associated parameter name.
         */
        values: string[];
    }

    export interface GetResponsePlanIncidentTemplate {
        /**
         * A string used to stop Incident Manager from creating multiple incident records for the same incident.
         */
        dedupeString: string;
        /**
         * The impact value of a generated incident. The following values are supported:
         */
        impact: number;
        /**
         * The tags assigned to an incident template. When an incident starts, Incident Manager assigns the tags specified in the template to the incident.
         */
        incidentTags: {[key: string]: string};
        /**
         * The Amazon Simple Notification Service (Amazon SNS) targets that this incident notifies when it is updated. The `notificationTarget` configuration block supports the following argument:
         */
        notificationTargets: outputs.ssmincidents.GetResponsePlanIncidentTemplateNotificationTarget[];
        /**
         * The summary of an incident.
         */
        summary: string;
        /**
         * The title of a generated incident.
         */
        title: string;
    }

    export interface GetResponsePlanIncidentTemplateNotificationTarget {
        /**
         * The ARN of the Amazon SNS topic.
         */
        snsTopicArn: string;
    }

    export interface GetResponsePlanIntegration {
        /**
         * Details about the PagerDuty configuration for a response plan. The following values are supported:
         */
        pagerduties: outputs.ssmincidents.GetResponsePlanIntegrationPagerduty[];
    }

    export interface GetResponsePlanIntegrationPagerduty {
        /**
         * The name of the PagerDuty configuration.
         */
        name: string;
        /**
         * The ID of the AWS Secrets Manager secret that stores your PagerDuty key &mdash; either a General Access REST API Key or User Token REST API Key &mdash; and other user credentials.
         */
        secretId: string;
        /**
         * The ID of the PagerDuty service that the response plan associates with an incident when it launches.
         */
        serviceId: string;
    }

    export interface ReplicationSetRegion {
        /**
         * The Amazon Resource name (ARN) of the customer managed key. If omitted, AWS manages the AWS KMS keys for you, using an AWS owned key, as indicated by a default value of `DefaultKey`.
         *
         * The following arguments are optional:
         */
        kmsKeyArn?: string;
        /**
         * The name of the Region, such as `ap-southeast-2`.
         */
        name: string;
        /**
         * The current status of the Region.
         * * Valid Values: `ACTIVE` | `CREATING` | `UPDATING` | `DELETING` | `FAILED`
         */
        status: string;
        /**
         * More information about the status of a Region.
         */
        statusMessage: string;
    }

    export interface ResponsePlanAction {
        /**
         * The Systems Manager automation document to start as the runbook at the beginning of the incident. The following values are supported:
         */
        ssmAutomations?: outputs.ssmincidents.ResponsePlanActionSsmAutomation[];
    }

    export interface ResponsePlanActionSsmAutomation {
        /**
         * The automation document's name.
         */
        documentName: string;
        /**
         * The version of the automation document to use at runtime.
         */
        documentVersion?: string;
        /**
         * The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
         */
        dynamicParameters?: {[key: string]: string};
        /**
         * The key-value pair parameters to use when the automation document runs. The following values are supported:
         */
        parameters?: outputs.ssmincidents.ResponsePlanActionSsmAutomationParameter[];
        /**
         * The Amazon Resource Name (ARN) of the role that the automation document assumes when it runs commands.
         */
        roleArn: string;
        /**
         * The account that the automation document runs in. This can be in either the management account or an application account.
         */
        targetAccount?: string;
    }

    export interface ResponsePlanActionSsmAutomationParameter {
        /**
         * The name of the response plan.
         */
        name: string;
        /**
         * The values for the associated parameter name.
         */
        values: string[];
    }

    export interface ResponsePlanIncidentTemplate {
        /**
         * A string used to stop Incident Manager from creating multiple incident records for the same incident.
         */
        dedupeString?: string;
        /**
         * The impact value of a generated incident. The following values are supported:
         */
        impact: number;
        /**
         * The tags assigned to an incident template. When an incident starts, Incident Manager assigns the tags specified in the template to the incident.
         */
        incidentTags?: {[key: string]: string};
        /**
         * The Amazon Simple Notification Service (Amazon SNS) targets that this incident notifies when it is updated. The `notificationTarget` configuration block supports the following argument:
         */
        notificationTargets?: outputs.ssmincidents.ResponsePlanIncidentTemplateNotificationTarget[];
        /**
         * The summary of an incident.
         */
        summary?: string;
        /**
         * The title of a generated incident.
         */
        title: string;
    }

    export interface ResponsePlanIncidentTemplateNotificationTarget {
        /**
         * The ARN of the Amazon SNS topic.
         *
         * The following arguments are optional:
         */
        snsTopicArn: string;
    }

    export interface ResponsePlanIntegration {
        /**
         * Details about the PagerDuty configuration for a response plan. The following values are supported:
         */
        pagerduties?: outputs.ssmincidents.ResponsePlanIntegrationPagerduty[];
    }

    export interface ResponsePlanIntegrationPagerduty {
        /**
         * The name of the response plan.
         */
        name: string;
        /**
         * The ID of the AWS Secrets Manager secret that stores your PagerDuty key &mdash; either a General Access REST API Key or User Token REST API Key &mdash; and other user credentials.
         *
         * For more information about the constraints for each field, see [CreateResponsePlan](https://docs.aws.amazon.com/incident-manager/latest/APIReference/API_CreateResponsePlan.html) in the *AWS Systems Manager Incident Manager API Reference*.
         */
        secretId: string;
        /**
         * The ID of the PagerDuty service that the response plan associated with the incident at launch.
         */
        serviceId: string;
    }

}

export namespace ssoadmin {
    export interface CustomerManagedPolicyAttachmentCustomerManagedPolicyReference {
        /**
         * Name of the customer managed IAM Policy to be attached.
         */
        name: string;
        /**
         * The path to the IAM policy to be attached. The default is `/`. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) for more information.
         */
        path?: string;
    }

    export interface InstanceAccessControlAttributesAttribute {
        /**
         * The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in AWS SSO.
         */
        key: string;
        /**
         * The value used for mapping a specified attribute to an identity source. See AccessControlAttributeValue
         */
        values: outputs.ssoadmin.InstanceAccessControlAttributesAttributeValue[];
    }

    export interface InstanceAccessControlAttributesAttributeValue {
        /**
         * The identity source to use when mapping a specified attribute to AWS SSO.
         */
        sources: string[];
    }

    export interface PermissionsBoundaryAttachmentPermissionsBoundary {
        /**
         * Specifies the name and path of a customer managed policy. See below.
         */
        customerManagedPolicyReference?: outputs.ssoadmin.PermissionsBoundaryAttachmentPermissionsBoundaryCustomerManagedPolicyReference;
        /**
         * AWS-managed IAM policy ARN to use as the permissions boundary.
         */
        managedPolicyArn?: string;
    }

    export interface PermissionsBoundaryAttachmentPermissionsBoundaryCustomerManagedPolicyReference {
        /**
         * Name of the customer managed IAM Policy to be attached.
         */
        name: string;
        /**
         * The path to the IAM policy to be attached. The default is `/`. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) for more information.
         */
        path?: string;
    }

}

export namespace storagegateway {
    export interface FileSystemAssociationCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: `0` or `300` to `2592000` seconds (5 minutes to 30 days). Defaults to `0`
         */
        cacheStaleTimeoutInSeconds?: number;
    }

    export interface GatewayGatewayNetworkInterface {
        /**
         * The Internet Protocol version 4 (IPv4) address of the interface.
         */
        ipv4Address: string;
    }

    export interface GatewayMaintenanceStartTime {
        /**
         * The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
         */
        dayOfMonth?: string;
        /**
         * The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
         */
        dayOfWeek?: string;
        /**
         * The hour component of the maintenance start time represented as _hh_, where _hh_ is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
         */
        hourOfDay: number;
        /**
         * The minute component of the maintenance start time represented as _mm_, where _mm_ is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
         */
        minuteOfHour?: number;
    }

    export interface GatewaySmbActiveDirectorySettings {
        activeDirectoryStatus: string;
        /**
         * List of IPv4 addresses, NetBIOS names, or host names of your domain server.
         * If you need to specify the port number include it after the colon (“:”). For example, `mydc.mydomain.com:389`.
         */
        domainControllers?: string[];
        /**
         * The name of the domain that you want the gateway to join.
         */
        domainName: string;
        /**
         * The organizational unit (OU) is a container in an Active Directory that can hold users, groups,
         * computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
         */
        organizationalUnit?: string;
        /**
         * The password of the user who has permission to add the gateway to the Active Directory domain.
         */
        password: string;
        /**
         * Specifies the time in seconds, in which the JoinDomain operation must complete. The default is `20` seconds.
         */
        timeoutInSeconds?: number;
        /**
         * The user name of user who has permission to add the gateway to the Active Directory domain.
         */
        username: string;
    }

    export interface NfsFileShareCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
         */
        cacheStaleTimeoutInSeconds?: number;
    }

    export interface NfsFileShareNfsFileShareDefaults {
        /**
         * The Unix directory mode in the string form "nnnn". Defaults to `"0777"`.
         */
        directoryMode?: string;
        /**
         * The Unix file mode in the string form "nnnn". Defaults to `"0666"`.
         */
        fileMode?: string;
        /**
         * The default group ID for the file share (unless the files have another group ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
         */
        groupId?: string;
        /**
         * The default owner ID for the file share (unless the files have another owner ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
         */
        ownerId?: string;
    }

    export interface SmbFileShareCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
         */
        cacheStaleTimeoutInSeconds?: number;
    }

}

export namespace synthetics {
    export interface CanaryArtifactConfig {
        /**
         * Configuration of the encryption-at-rest settings for artifacts that the canary uploads to Amazon S3. See S3 Encryption.
         */
        s3Encryption?: outputs.synthetics.CanaryArtifactConfigS3Encryption;
    }

    export interface CanaryArtifactConfigS3Encryption {
        /**
         * The encryption method to use for artifacts created by this canary. Valid values are: `SSE_S3` and `SSE_KMS`.
         */
        encryptionMode?: string;
        /**
         * The ARN of the customer-managed KMS key to use, if you specify `SSE_KMS` for `encryptionMode`.
         */
        kmsKeyArn?: string;
    }

    export interface CanaryRunConfig {
        /**
         * Whether this canary is to use active AWS X-Ray tracing when it runs. You can enable active tracing only for canaries that use version syn-nodejs-2.0 or later for their canary runtime.
         */
        activeTracing?: boolean;
        /**
         * Map of environment variables that are accessible from the canary during execution. Please see [AWS Docs](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime) for variables reserved for Lambda.
         */
        environmentVariables?: {[key: string]: string};
        /**
         * Maximum amount of memory available to the canary while it is running, in MB. The value you specify must be a multiple of 64.
         */
        memoryInMb: number;
        /**
         * Number of seconds the canary is allowed to run before it must stop. If you omit this field, the frequency of the canary is used, up to a maximum of 840 (14 minutes).
         */
        timeoutInSeconds?: number;
    }

    export interface CanarySchedule {
        /**
         * Duration in seconds, for the canary to continue making regular runs according to the schedule in the Expression value.
         */
        durationInSeconds?: number;
        /**
         * Rate expression or cron expression that defines how often the canary is to run. For rate expression, the syntax is `rate(number unit)`. _unit_ can be `minute`, `minutes`, or `hour`. For cron expression, the syntax is `cron(expression)`. For more information about the syntax for cron expressions, see [Scheduling canary runs using cron](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html).
         */
        expression: string;
    }

    export interface CanaryTimeline {
        /**
         * Date and time the canary was created.
         */
        created: string;
        /**
         * Date and time the canary was most recently modified.
         */
        lastModified: string;
        /**
         * Date and time that the canary's most recent run started.
         */
        lastStarted: string;
        /**
         * Date and time that the canary's most recent run ended.
         */
        lastStopped: string;
    }

    export interface CanaryVpcConfig {
        /**
         * IDs of the security groups for this canary.
         */
        securityGroupIds?: string[];
        /**
         * IDs of the subnets where this canary is to run.
         */
        subnetIds?: string[];
        /**
         * ID of the VPC where this canary is to run.
         */
        vpcId: string;
    }

}

export namespace timestreamwrite {
    export interface TableMagneticStoreWriteProperties {
        /**
         * A flag to enable magnetic store writes.
         */
        enableMagneticStoreWrites?: boolean;
        /**
         * The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
         */
        magneticStoreRejectedDataLocation?: outputs.timestreamwrite.TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation;
    }

    export interface TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation {
        /**
         * Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
         */
        s3Configuration?: outputs.timestreamwrite.TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration;
    }

    export interface TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration {
        /**
         * Bucket name of the customer S3 bucket.
         */
        bucketName?: string;
        /**
         * Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
         */
        encryptionOption?: string;
        /**
         * KMS key arn for the customer s3 location when encrypting with a KMS managed key.
         */
        kmsKeyId?: string;
        /**
         * Object key prefix for the customer S3 location.
         */
        objectKeyPrefix?: string;
    }

    export interface TableRetentionProperties {
        /**
         * The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
         */
        magneticStoreRetentionPeriodInDays: number;
        /**
         * The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
         */
        memoryStoreRetentionPeriodInHours: number;
    }

    export interface TableSchema {
        /**
         * A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed. See Composite Partition Key below for more details.
         */
        compositePartitionKey: outputs.timestreamwrite.TableSchemaCompositePartitionKey;
    }

    export interface TableSchemaCompositePartitionKey {
        /**
         * The level of enforcement for the specification of a dimension key in ingested records. Valid values: `REQUIRED`, `OPTIONAL`.
         */
        enforcementInRecord?: string;
        /**
         * The name of the attribute used for a dimension key.
         */
        name?: string;
        /**
         * The type of the partition key. Valid values: `DIMENSION`, `MEASURE`.
         */
        type: string;
    }

}

export namespace transcribe {
    export interface LanguageModelInputDataConfig {
        /**
         * IAM role with access to S3 bucket.
         */
        dataAccessRoleArn: string;
        /**
         * S3 URI where training data is located.
         */
        s3Uri: string;
        /**
         * S3 URI where tuning data is located.
         *
         * The following arguments are optional:
         */
        tuningDataS3Uri: string;
    }

}

export namespace transfer {
    export interface AccessHomeDirectoryMapping {
        /**
         * Represents an entry and a target.
         */
        entry: string;
        /**
         * Represents the map target.
         */
        target: string;
    }

    export interface AccessPosixProfile {
        /**
         * The POSIX group ID used for all EFS operations by this user.
         */
        gid: number;
        /**
         * The secondary POSIX group IDs used for all EFS operations by this user.
         */
        secondaryGids?: number[];
        /**
         * The POSIX user ID used for all EFS operations by this user.
         */
        uid: number;
    }

    export interface ConnectorAs2Config {
        /**
         * Specifies weather AS2 file is compressed. The valud values are ZLIB and  DISABLED.
         */
        compression: string;
        /**
         * The algorithm that is used to encrypt the file. The valid values are AES128_CBC | AES192_CBC | AES256_CBC | NONE.
         */
        encryptionAlgorithm: string;
        /**
         * The unique identifier for the AS2 local profile.
         */
        localProfileId: string;
        /**
         * Used for outbound requests to determine if a partner response for transfers is synchronous or asynchronous. The valid values are SYNC and NONE.
         */
        mdnResponse: string;
        /**
         * The signing algorithm for the Mdn response. The valid values are SHA256 | SHA384 | SHA512 | SHA1 | NONE | DEFAULT.
         */
        mdnSigningAlgorithm?: string;
        /**
         * Used as the subject HTTP header attribute in AS2 messages that are being sent with the connector.
         */
        messageSubject?: string;
        /**
         * The unique identifier for the AS2 partner profile.
         */
        partnerProfileId: string;
        /**
         * The algorithm that is used to sign AS2 messages sent with the connector. The valid values are SHA256 | SHA384 | SHA512 | SHA1 | NONE .
         */
        signingAlgorithm: string;
    }

    export interface ServerEndpointDetails {
        /**
         * A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when `endpointType` is set to `VPC`.
         */
        addressAllocationIds?: string[];
        /**
         * A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when `endpointType` is set to `VPC`.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when `endpointType` is set to `VPC`.
         */
        subnetIds?: string[];
        /**
         * The ID of the VPC endpoint. This property can only be used when `endpointType` is set to `VPC_ENDPOINT`
         */
        vpcEndpointId: string;
        /**
         * The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when `endpointType` is set to `VPC`.
         */
        vpcId?: string;
    }

    export interface ServerProtocolDetails {
        /**
         * Indicates the transport method for the AS2 messages. Currently, only `HTTP` is supported.
         */
        as2Transports: string[];
        /**
         * Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
         */
        passiveIp: string;
        /**
         * Use to ignore the error that is generated when the client attempts to use `SETSTAT` on a file you are uploading to an S3 bucket. Valid values: `DEFAULT`, `ENABLE_NO_OP`.
         */
        setStatOption: string;
        /**
         * A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: `DISABLED`, `ENABLED`, `ENFORCED`.
         */
        tlsSessionResumptionMode: string;
    }

    export interface ServerWorkflowDetails {
        /**
         * A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below.
         */
        onPartialUpload?: outputs.transfer.ServerWorkflowDetailsOnPartialUpload;
        /**
         * A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See Workflow Detail below.
         */
        onUpload?: outputs.transfer.ServerWorkflowDetailsOnUpload;
    }

    export interface ServerWorkflowDetailsOnPartialUpload {
        /**
         * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
         */
        executionRole: string;
        /**
         * A unique identifier for the workflow.
         */
        workflowId: string;
    }

    export interface ServerWorkflowDetailsOnUpload {
        /**
         * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
         */
        executionRole: string;
        /**
         * A unique identifier for the workflow.
         */
        workflowId: string;
    }

    export interface UserHomeDirectoryMapping {
        /**
         * Represents an entry and a target.
         */
        entry: string;
        /**
         * Represents the map target.
         *
         * The `Restricted` option is achieved using the following mapping:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        target: string;
    }

    export interface UserPosixProfile {
        /**
         * The POSIX group ID used for all EFS operations by this user.
         */
        gid: number;
        /**
         * The secondary POSIX group IDs used for all EFS operations by this user.
         */
        secondaryGids?: number[];
        /**
         * The POSIX user ID used for all EFS operations by this user.
         */
        uid: number;
    }

    export interface WorkflowOnExceptionStep {
        /**
         * Details for a step that performs a file copy. See Copy Step Details below.
         */
        copyStepDetails?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetails;
        /**
         * Details for a step that invokes a lambda function.
         */
        customStepDetails?: outputs.transfer.WorkflowOnExceptionStepCustomStepDetails;
        /**
         * Details for a step that decrypts the file.
         */
        decryptStepDetails?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetails;
        /**
         * Details for a step that deletes the file.
         */
        deleteStepDetails?: outputs.transfer.WorkflowOnExceptionStepDeleteStepDetails;
        /**
         * Details for a step that creates one or more tags.
         */
        tagStepDetails?: outputs.transfer.WorkflowOnExceptionStepTagStepDetails;
        /**
         * One of the following step types are supported. `COPY`, `CUSTOM`, `DECRYPT`, `DELETE`, and `TAG`.
         */
        type: string;
    }

    export interface WorkflowOnExceptionStepCopyStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }

    export interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationS3FileLocation;
    }

    export interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }

    export interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }

    export interface WorkflowOnExceptionStepCustomStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: string;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: number;
    }

    export interface WorkflowOnExceptionStepDecryptStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The type of encryption used. Currently, this value must be `"PGP"`.
         */
        type: string;
    }

    export interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationS3FileLocation;
    }

    export interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }

    export interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }

    export interface WorkflowOnExceptionStepDeleteStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }

    export interface WorkflowOnExceptionStepTagStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * Array that contains from 1 to 10 key/value pairs. See S3 Tags below.
         */
        tags?: outputs.transfer.WorkflowOnExceptionStepTagStepDetailsTag[];
    }

    export interface WorkflowOnExceptionStepTagStepDetailsTag {
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key: string;
        /**
         * The value that corresponds to the key.
         */
        value: string;
    }

    export interface WorkflowStep {
        /**
         * Details for a step that performs a file copy. See Copy Step Details below.
         */
        copyStepDetails?: outputs.transfer.WorkflowStepCopyStepDetails;
        /**
         * Details for a step that invokes a lambda function.
         */
        customStepDetails?: outputs.transfer.WorkflowStepCustomStepDetails;
        /**
         * Details for a step that decrypts the file.
         */
        decryptStepDetails?: outputs.transfer.WorkflowStepDecryptStepDetails;
        /**
         * Details for a step that deletes the file.
         */
        deleteStepDetails?: outputs.transfer.WorkflowStepDeleteStepDetails;
        /**
         * Details for a step that creates one or more tags.
         */
        tagStepDetails?: outputs.transfer.WorkflowStepTagStepDetails;
        /**
         * One of the following step types are supported. `COPY`, `CUSTOM`, `DECRYPT`, `DELETE`, and `TAG`.
         */
        type: string;
    }

    export interface WorkflowStepCopyStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }

    export interface WorkflowStepCopyStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocationS3FileLocation;
    }

    export interface WorkflowStepCopyStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }

    export interface WorkflowStepCopyStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }

    export interface WorkflowStepCustomStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: string;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: number;
    }

    export interface WorkflowStepDecryptStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The type of encryption used. Currently, this value must be `"PGP"`.
         */
        type: string;
    }

    export interface WorkflowStepDecryptStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocationS3FileLocation;
    }

    export interface WorkflowStepDecryptStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }

    export interface WorkflowStepDecryptStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }

    export interface WorkflowStepDeleteStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }

    export interface WorkflowStepTagStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * Array that contains from 1 to 10 key/value pairs. See S3 Tags below.
         */
        tags?: outputs.transfer.WorkflowStepTagStepDetailsTag[];
    }

    export interface WorkflowStepTagStepDetailsTag {
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key: string;
        /**
         * The value that corresponds to the key.
         */
        value: string;
    }

}

export namespace vpc {
    export interface GetSecurityGroupRuleFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeSecurityGroupRules`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroupRules.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }

    export interface GetSecurityGroupRulesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroupRules.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * Security group rule IDs will be selected if any one of the given values match.
         */
        values: string[];
    }

}

export namespace vpclattice {
    export interface GetListenerDefaultAction {
        fixedResponses: outputs.vpclattice.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.vpclattice.GetListenerDefaultActionForward[];
    }

    export interface GetListenerDefaultActionFixedResponse {
        statusCode: number;
    }

    export interface GetListenerDefaultActionForward {
        targetGroups: outputs.vpclattice.GetListenerDefaultActionForwardTargetGroup[];
    }

    export interface GetListenerDefaultActionForwardTargetGroup {
        targetGroupIdentifier: string;
        weight: number;
    }

    export interface GetServiceDnsEntry {
        domainName: string;
        hostedZoneId: string;
    }

    export interface ListenerDefaultAction {
        fixedResponse?: outputs.vpclattice.ListenerDefaultActionFixedResponse;
        /**
         * Route requests to one or more target groups. See Forward blocks below.
         *
         * > **NOTE:** You must specify exactly one of the following argument blocks: `fixedResponse` or `forward`.
         */
        forwards?: outputs.vpclattice.ListenerDefaultActionForward[];
    }

    export interface ListenerDefaultActionFixedResponse {
        /**
         * Custom HTTP status code to return, e.g. a 404 response code. See [Listeners](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html) in the AWS documentation for a list of supported codes.
         */
        statusCode: number;
    }

    export interface ListenerDefaultActionForward {
        /**
         * One or more target group blocks.
         */
        targetGroups?: outputs.vpclattice.ListenerDefaultActionForwardTargetGroup[];
    }

    export interface ListenerDefaultActionForwardTargetGroup {
        /**
         * ID or Amazon Resource Name (ARN) of the target group.
         */
        targetGroupIdentifier?: string;
        /**
         * Determines how requests are distributed to the target group. Only required if you specify multiple target groups for a forward action. For example, if you specify two target groups, one with a
         * weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. See [Listener rules](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html#listener-rules) in the AWS documentation for additional examples. Default: `100`.
         */
        weight?: number;
    }

    export interface ListenerRuleAction {
        /**
         * Describes the rule action that returns a custom HTTP response.
         */
        fixedResponse?: outputs.vpclattice.ListenerRuleActionFixedResponse;
        /**
         * The forward action. Traffic that matches the rule is forwarded to the specified target groups.
         */
        forward?: outputs.vpclattice.ListenerRuleActionForward;
    }

    export interface ListenerRuleActionFixedResponse {
        /**
         * The HTTP response code.
         */
        statusCode: number;
    }

    export interface ListenerRuleActionForward {
        /**
         * The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
         *
         * The default value is 1 with maximum number of 2. If only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
         */
        targetGroups: outputs.vpclattice.ListenerRuleActionForwardTargetGroup[];
    }

    export interface ListenerRuleActionForwardTargetGroup {
        targetGroupIdentifier: string;
        weight?: number;
    }

    export interface ListenerRuleMatch {
        /**
         * The HTTP criteria that a rule must match.
         */
        httpMatch?: outputs.vpclattice.ListenerRuleMatchHttpMatch;
    }

    export interface ListenerRuleMatchHttpMatch {
        /**
         * The header matches. Matches incoming requests with rule based on request header value before applying rule action.
         */
        headerMatches?: outputs.vpclattice.ListenerRuleMatchHttpMatchHeaderMatch[];
        /**
         * The HTTP method type.
         */
        method?: string;
        /**
         * The path match.
         */
        pathMatch?: outputs.vpclattice.ListenerRuleMatchHttpMatchPathMatch;
    }

    export interface ListenerRuleMatchHttpMatchHeaderMatch {
        /**
         * Indicates whether the match is case sensitive. Defaults to false.
         */
        caseSensitive?: boolean;
        /**
         * The header match type.
         */
        match: outputs.vpclattice.ListenerRuleMatchHttpMatchHeaderMatchMatch;
        /**
         * The name of the header.
         */
        name: string;
    }

    export interface ListenerRuleMatchHttpMatchHeaderMatchMatch {
        /**
         * Specifies a contains type match.
         */
        contains?: string;
        /**
         * Specifies an exact type match.
         */
        exact?: string;
        /**
         * Specifies a prefix type match. Matches the value with the prefix.
         */
        prefix?: string;
    }

    export interface ListenerRuleMatchHttpMatchPathMatch {
        /**
         * Indicates whether the match is case sensitive. Defaults to false.
         */
        caseSensitive?: boolean;
        /**
         * The header match type.
         */
        match: outputs.vpclattice.ListenerRuleMatchHttpMatchPathMatchMatch;
    }

    export interface ListenerRuleMatchHttpMatchPathMatchMatch {
        /**
         * Specifies an exact type match.
         */
        exact?: string;
        /**
         * Specifies a prefix type match. Matches the value with the prefix.
         */
        prefix?: string;
    }

    export interface ServiceDnsEntry {
        domainName: string;
        hostedZoneId: string;
    }

    export interface ServiceNetworkServiceAssociationDnsEntry {
        /**
         * The domain name of the service.
         */
        domainName: string;
        /**
         * The ID of the hosted zone.
         */
        hostedZoneId: string;
    }

    export interface TargetGroupAttachmentTarget {
        /**
         * The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
         */
        id: string;
        /**
         * The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
         */
        port: number;
    }

    export interface TargetGroupConfig {
        /**
         * The health check configuration.
         */
        healthCheck?: outputs.vpclattice.TargetGroupConfigHealthCheck;
        /**
         * The type of IP address used for the target group. Valid values: `IPV4` | `IPV6`
         */
        ipAddressType: string;
        /**
         * The port on which the targets are listening.
         */
        port: number;
        /**
         * The protocol to use for routing traffic to the targets. Valid Values are `HTTP` | `HTTPS`
         */
        protocol: string;
        /**
         * The protocol version. Valid Values are `HTTP1` | `HTTP2` | `GRPC`. Default value is `HTTP1`.
         */
        protocolVersion?: string;
        /**
         * The ID of the VPC.
         */
        vpcIdentifier: string;
    }

    export interface TargetGroupConfigHealthCheck {
        /**
         * Indicates whether health checking is enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
         */
        healthCheckIntervalSeconds?: number;
        /**
         * The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
         * * `healthyThresholdCount ` - (Optional) The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
         */
        healthCheckTimeoutSeconds?: number;
        healthyThresholdCount?: number;
        /**
         * The codes to use when checking for a successful response from a target. These are called _Success codes_ in the console.
         */
        matcher?: outputs.vpclattice.TargetGroupConfigHealthCheckMatcher;
        /**
         * The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is `/`. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
         */
        path?: string;
        /**
         * The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
         */
        port: number;
        /**
         * The protocol used when performing health checks on targets. The possible protocols are `HTTP` and `HTTPS`.
         */
        protocol: string;
        /**
         * The protocol version used when performing health checks on targets. The possible protocol versions are `HTTP1` and `HTTP2`. The default is `HTTP1`.
         */
        protocolVersion?: string;
        /**
         * The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
         */
        unhealthyThresholdCount?: number;
    }

    export interface TargetGroupConfigHealthCheckMatcher {
        /**
         * The HTTP codes to use when checking for a successful response from a target.
         */
        value?: string;
    }

}

export namespace waf {
    export interface ByteMatchSetByteMatchTuple {
        /**
         * The part of a web request that you want to search, such as a specified header or a query string.
         */
        fieldToMatch: outputs.waf.ByteMatchSetByteMatchTupleFieldToMatch;
        /**
         * Within the portion of a web request that you want to search
         * (for example, in the query string, if any), specify where you want to search.
         * e.g., `CONTAINS`, `CONTAINS_WORD` or `EXACTLY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-PositionalConstraint)
         * for all supported values.
         */
        positionalConstraint: string;
        /**
         * The value that you want to search for within the field specified by `fieldToMatch`, e.g., `badrefer1`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_waf_ByteMatchTuple.html)
         * for all supported values.
         */
        targetString?: string;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `targetString` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface ByteMatchSetByteMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface GeoMatchSetGeoMatchConstraint {
        /**
         * The type of geographical area you want AWS WAF to search for. Currently Country is the only valid value.
         */
        type: string;
        /**
         * The country that you want AWS WAF to search for.
         * This is the two-letter country code, e.g., `US`, `CA`, `RU`, `CN`, etc.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchConstraint.html) for all supported values.
         */
        value: string;
    }

    export interface IpSetIpSetDescriptor {
        /**
         * Type of the IP address - `IPV4` or `IPV6`.
         */
        type: string;
        /**
         * An IPv4 or IPv6 address specified via CIDR notationE.g., `192.0.2.44/32` or `1111:0000:0000:0000:0000:0000:0000:0000/64`
         */
        value: string;
    }

    export interface RateBasedRulePredicate {
        /**
         * A unique identifier for a predicate in the rule, such as Byte Match Set ID or IPSet ID.
         */
        dataId: string;
        /**
         * Set this to `false` if you want to allow, block, or count requests
         * based on the settings in the specified `ByteMatchSet`, `IPSet`, `SqlInjectionMatchSet`, `XssMatchSet`, or `SizeConstraintSet`.
         * For example, if an IPSet includes the IP address `192.0.2.44`, AWS WAF will allow or block requests based on that IP address.
         * If set to `true`, AWS WAF will allow, block, or count requests based on all IP addresses _except_ `192.0.2.44`.
         */
        negated: boolean;
        /**
         * The type of predicate in a rule. Valid values: `ByteMatch`, `GeoMatch`, `IPMatch`, `RegexMatch`, `SizeConstraint`, `SqlInjectionMatch`, or `XssMatch`.
         */
        type: string;
    }

    export interface RegexMatchSetRegexMatchTuple {
        /**
         * The part of a web request that you want to search, such as a specified header or a query string.
         */
        fieldToMatch: outputs.waf.RegexMatchSetRegexMatchTupleFieldToMatch;
        /**
         * The ID of a Regex Pattern Set.
         */
        regexPatternSetId: string;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface RegexMatchSetRegexMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface RuleGroupActivatedRule {
        /**
         * Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule.
         */
        action: outputs.waf.RuleGroupActivatedRuleAction;
        /**
         * Specifies the order in which the rules are evaluated. Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * The ID of a rule
         */
        ruleId: string;
        /**
         * e.g., `BLOCK`, `ALLOW`, or `COUNT`
         */
        type?: string;
    }

    export interface RuleGroupActivatedRuleAction {
        /**
         * e.g., `BLOCK`, `ALLOW`, or `COUNT`
         */
        type: string;
    }

    export interface RulePredicate {
        /**
         * A unique identifier for a predicate in the rule, such as Byte Match Set ID or IPSet ID.
         */
        dataId: string;
        /**
         * Set this to `false` if you want to allow, block, or count requests
         * based on the settings in the specified waf_byte_match_set, waf_ipset, aws_waf_size_constraint_set, aws.waf.SqlInjectionMatchSet or aws_waf_xss_match_set.
         * For example, if an IPSet includes the IP address `192.0.2.44`, AWS WAF will allow or block requests based on that IP address.
         * If set to `true`, AWS WAF will allow, block, or count requests based on all IP addresses except `192.0.2.44`.
         */
        negated: boolean;
        /**
         * The type of predicate in a rule. Valid values: `ByteMatch`, `GeoMatch`, `IPMatch`, `RegexMatch`, `SizeConstraint`, `SqlInjectionMatch`, or `XssMatch`.
         */
        type: string;
    }

    export interface SizeConstraintSetSizeConstraint {
        /**
         * The type of comparison you want to perform.
         * e.g., `EQ`, `NE`, `LT`, `GT`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_wafRegional_SizeConstraint.html) for all supported values.
         */
        comparisonOperator: string;
        /**
         * Specifies where in a web request to look for the size constraint.
         */
        fieldToMatch: outputs.waf.SizeConstraintSetSizeConstraintFieldToMatch;
        /**
         * The size in bytes that you want to compare against the size of the specified `fieldToMatch`.
         * Valid values are between 0 - 21474836480 bytes (0 - 20 GB).
         */
        size: number;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_SizeConstraint.html#WAF-Type-SizeConstraint-TextTransformation)
         * for all supported values.
         * **Note:** if you choose `BODY` as `type`, you must choose `NONE` because CloudFront forwards only the first 8192 bytes for inspection.
         */
        textTransformation: string;
    }

    export interface SizeConstraintSetSizeConstraintFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        /**
         * Specifies where in a web request to look for snippets of malicious SQL code.
         */
        fieldToMatch: outputs.waf.SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_SqlInjectionMatchTuple.html#WAF-Type-SqlInjectionMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface WebAclDefaultAction {
        /**
         * Specifies how you want AWS WAF to respond to requests that don't match the criteria in any of the `rules`.
         * e.g., `ALLOW` or `BLOCK`
         */
        type: string;
    }

    export interface WebAclLoggingConfiguration {
        /**
         * Amazon Resource Name (ARN) of Kinesis Firehose Delivery Stream
         */
        logDestination: string;
        /**
         * Configuration block containing parts of the request that you want redacted from the logs. Detailed below.
         */
        redactedFields?: outputs.waf.WebAclLoggingConfigurationRedactedFields;
    }

    export interface WebAclLoggingConfigurationRedactedFields {
        /**
         * Set of configuration blocks for fields to redact. Detailed below.
         */
        fieldToMatches: outputs.waf.WebAclLoggingConfigurationRedactedFieldsFieldToMatch[];
    }

    export interface WebAclLoggingConfigurationRedactedFieldsFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }

    export interface WebAclRule {
        /**
         * The action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule. Not used if `type` is `GROUP`.
         */
        action?: outputs.waf.WebAclRuleAction;
        /**
         * Override the action that a group requests CloudFront or AWS WAF takes when a web request matches the conditions in the rule. Only used if `type` is `GROUP`.
         */
        overrideAction?: outputs.waf.WebAclRuleOverrideAction;
        /**
         * Specifies the order in which the rules in a WebACL are evaluated.
         * Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * ID of the associated WAF (Global) rule (e.g., `aws.waf.Rule`). WAF (Regional) rules cannot be used.
         */
        ruleId: string;
        /**
         * The rule type, either `REGULAR`, as defined by [Rule](http://docs.aws.amazon.com/waf/latest/APIReference/API_Rule.html), `RATE_BASED`, as defined by [RateBasedRule](http://docs.aws.amazon.com/waf/latest/APIReference/API_RateBasedRule.html), or `GROUP`, as defined by [RuleGroup](https://docs.aws.amazon.com/waf/latest/APIReference/API_RuleGroup.html). The default is REGULAR. If you add a RATE_BASED rule, you need to set `type` as `RATE_BASED`. If you add a GROUP rule, you need to set `type` as `GROUP`.
         */
        type?: string;
    }

    export interface WebAclRuleAction {
        /**
         * Specifies how you want AWS WAF to respond to requests that don't match the criteria in any of the `rules`.
         * e.g., `ALLOW` or `BLOCK`
         */
        type: string;
    }

    export interface WebAclRuleOverrideAction {
        /**
         * Specifies how you want AWS WAF to respond to requests that don't match the criteria in any of the `rules`.
         * e.g., `ALLOW` or `BLOCK`
         */
        type: string;
    }

    export interface XssMatchSetXssMatchTuple {
        /**
         * Specifies where in a web request to look for cross-site scripting attacks.
         */
        fieldToMatch: outputs.waf.XssMatchSetXssMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `targetString` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_XssMatchTuple.html#WAF-Type-XssMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface XssMatchSetXssMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

}

export namespace wafregional {
    export interface ByteMatchSetByteMatchTuple {
        /**
         * Settings for the ByteMatchTuple. FieldToMatch documented below.
         */
        fieldToMatch: outputs.wafregional.ByteMatchSetByteMatchTupleFieldToMatch;
        /**
         * Within the portion of a web request that you want to search.
         */
        positionalConstraint: string;
        /**
         * The value that you want AWS WAF to search for. The maximum length of the value is 50 bytes.
         */
        targetString?: string;
        /**
         * The formatting way for web request.
         *
         * FieldToMatch(field_to_match) support following:
         */
        textTransformation: string;
    }

    export interface ByteMatchSetByteMatchTupleFieldToMatch {
        /**
         * When the value of Type is HEADER, enter the name of the header that you want AWS WAF to search, for example, User-Agent or Referer. If the value of Type is any other value, omit Data.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         */
        type: string;
    }

    export interface GeoMatchSetGeoMatchConstraint {
        /**
         * The type of geographical area you want AWS WAF to search for. Currently Country is the only valid value.
         */
        type: string;
        /**
         * The country that you want AWS WAF to search for.
         * This is the two-letter country code, e.g., `US`, `CA`, `RU`, `CN`, etc.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchConstraint.html) for all supported values.
         */
        value: string;
    }

    export interface IpSetIpSetDescriptor {
        /**
         * The string like IPV4 or IPV6.
         */
        type: string;
        /**
         * The CIDR notation.
         */
        value: string;
    }

    export interface RateBasedRulePredicate {
        /**
         * A unique identifier for a predicate in the rule, such as Byte Match Set ID or IPSet ID.
         */
        dataId: string;
        /**
         * Set this to `false` if you want to allow, block, or count requests
         * based on the settings in the specified `ByteMatchSet`, `IPSet`, `SqlInjectionMatchSet`, `XssMatchSet`, or `SizeConstraintSet`.
         * For example, if an IPSet includes the IP address `192.0.2.44`, AWS WAF will allow or block requests based on that IP address.
         * If set to `true`, AWS WAF will allow, block, or count requests based on all IP addresses _except_ `192.0.2.44`.
         */
        negated: boolean;
        /**
         * The type of predicate in a rule. Valid values: `ByteMatch`, `GeoMatch`, `IPMatch`, `RegexMatch`, `SizeConstraint`, `SqlInjectionMatch`, or `XssMatch`.
         */
        type: string;
    }

    export interface RegexMatchSetRegexMatchTuple {
        /**
         * The part of a web request that you want to search, such as a specified header or a query string.
         */
        fieldToMatch: outputs.wafregional.RegexMatchSetRegexMatchTupleFieldToMatch;
        /**
         * The ID of a Regex Pattern Set.
         */
        regexPatternSetId: string;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface RegexMatchSetRegexMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface RuleGroupActivatedRule {
        /**
         * Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule.
         */
        action: outputs.wafregional.RuleGroupActivatedRuleAction;
        /**
         * Specifies the order in which the rules are evaluated. Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * The ID of a rule
         */
        ruleId: string;
        /**
         * e.g., `BLOCK`, `ALLOW`, or `COUNT`
         */
        type?: string;
    }

    export interface RuleGroupActivatedRuleAction {
        /**
         * e.g., `BLOCK`, `ALLOW`, or `COUNT`
         */
        type: string;
    }

    export interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }

    export interface SizeConstraintSetSizeConstraint {
        /**
         * The type of comparison you want to perform.
         * e.g., `EQ`, `NE`, `LT`, `GT`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_wafRegional_SizeConstraint.html) for all supported values.
         */
        comparisonOperator: string;
        /**
         * Specifies where in a web request to look for the size constraint.
         */
        fieldToMatch: outputs.wafregional.SizeConstraintSetSizeConstraintFieldToMatch;
        /**
         * The size in bytes that you want to compare against the size of the specified `fieldToMatch`.
         * Valid values are between 0 - 21474836480 bytes (0 - 20 GB).
         */
        size: number;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_SizeConstraint.html#WAF-Type-SizeConstraint-TextTransformation)
         * for all supported values.
         * **Note:** if you choose `BODY` as `type`, you must choose `NONE` because CloudFront forwards only the first 8192 bytes for inspection.
         */
        textTransformation: string;
    }

    export interface SizeConstraintSetSizeConstraintFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        /**
         * Specifies where in a web request to look for snippets of malicious SQL code.
         */
        fieldToMatch: outputs.wafregional.SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_regional_SqlInjectionMatchTuple.html#WAF-Type-regional_SqlInjectionMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_regional_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }

    export interface WebAclDefaultAction {
        /**
         * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a ruleE.g., `ALLOW`, `BLOCK` or `COUNT`
         */
        type: string;
    }

    export interface WebAclLoggingConfiguration {
        /**
         * Amazon Resource Name (ARN) of Kinesis Firehose Delivery Stream
         */
        logDestination: string;
        /**
         * Configuration block containing parts of the request that you want redacted from the logs. Detailed below.
         */
        redactedFields?: outputs.wafregional.WebAclLoggingConfigurationRedactedFields;
    }

    export interface WebAclLoggingConfigurationRedactedFields {
        /**
         * Set of configuration blocks for fields to redact. Detailed below.
         */
        fieldToMatches: outputs.wafregional.WebAclLoggingConfigurationRedactedFieldsFieldToMatch[];
    }

    export interface WebAclLoggingConfigurationRedactedFieldsFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }

    export interface WebAclRule {
        /**
         * Configuration block of the action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Not used if `type` is `GROUP`. Detailed below.
         */
        action?: outputs.wafregional.WebAclRuleAction;
        /**
         * Configuration block of the override the action that a group requests CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Only used if `type` is `GROUP`. Detailed below.
         */
        overrideAction?: outputs.wafregional.WebAclRuleOverrideAction;
        /**
         * Specifies the order in which the rules in a WebACL are evaluated.
         * Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * ID of the associated WAF (Regional) rule (e.g., `aws.wafregional.Rule`). WAF (Global) rules cannot be used.
         */
        ruleId: string;
        /**
         * The rule type, either `REGULAR`, as defined by [Rule](http://docs.aws.amazon.com/waf/latest/APIReference/API_Rule.html), `RATE_BASED`, as defined by [RateBasedRule](http://docs.aws.amazon.com/waf/latest/APIReference/API_RateBasedRule.html), or `GROUP`, as defined by [RuleGroup](https://docs.aws.amazon.com/waf/latest/APIReference/API_RuleGroup.html). The default is REGULAR. If you add a RATE_BASED rule, you need to set `type` as `RATE_BASED`. If you add a GROUP rule, you need to set `type` as `GROUP`.
         */
        type?: string;
    }

    export interface WebAclRuleAction {
        /**
         * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a rule. Valid values for `action` are `ALLOW`, `BLOCK` or `COUNT`. Valid values for `overrideAction` are `COUNT` and `NONE`.
         */
        type: string;
    }

    export interface WebAclRuleOverrideAction {
        /**
         * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a ruleE.g., `ALLOW`, `BLOCK` or `COUNT`
         */
        type: string;
    }

    export interface XssMatchSetXssMatchTuple {
        /**
         * Specifies where in a web request to look for cross-site scripting attacks.
         */
        fieldToMatch: outputs.wafregional.XssMatchSetXssMatchTupleFieldToMatch;
        /**
         * Which text transformation, if any, to perform on the web request before inspecting the request for cross-site scripting attacks.
         */
        textTransformation: string;
    }

    export interface XssMatchSetXssMatchTupleFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }

}

export namespace wafv2 {
    export interface GetRegexPatternSetRegularExpression {
        /**
         * (Required) String representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
         */
        regexString: string;
    }

    export interface RegexPatternSetRegularExpression {
        /**
         * The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
         */
        regexString: string;
    }

    export interface RuleGroupCustomResponseBody {
        /**
         * The payload of the custom response.
         */
        content: string;
        /**
         * The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
         */
        contentType: string;
        /**
         * A unique key identifying the custom response body. This is referenced by the `customResponseBodyKey` argument in the Custom Response block.
         */
        key: string;
    }

    export interface RuleGroupRule {
        /**
         * The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `aws.wafv2.WebAcl` level can override the rule action setting. See Action below for details.
         */
        action: outputs.wafv2.RuleGroupRuleAction;
        /**
         * Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
         */
        captchaConfig?: outputs.wafv2.RuleGroupRuleCaptchaConfig;
        /**
         * A friendly name of the rule.
         */
        name: string;
        /**
         * If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
         */
        priority: number;
        /**
         * Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
         */
        ruleLabels?: outputs.wafv2.RuleGroupRuleRuleLabel[];
        /**
         * The AWS WAF processing statement for the rule, for example `byteMatchStatement` or `geoMatchStatement`. See Statement below for details.
         */
        statement: outputs.wafv2.RuleGroupRuleStatement;
        /**
         * Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
         */
        visibilityConfig: outputs.wafv2.RuleGroupRuleVisibilityConfig;
    }

    export interface RuleGroupRuleAction {
        /**
         * Instructs AWS WAF to allow the web request. See Allow below for details.
         */
        allow?: outputs.wafv2.RuleGroupRuleActionAllow;
        /**
         * Instructs AWS WAF to block the web request. See Block below for details.
         */
        block?: outputs.wafv2.RuleGroupRuleActionBlock;
        /**
         * Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
         */
        captcha?: outputs.wafv2.RuleGroupRuleActionCaptcha;
        /**
         * Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
         */
        challenge?: outputs.wafv2.RuleGroupRuleActionChallenge;
        /**
         * Instructs AWS WAF to count the web request and allow it. See Count below for details.
         */
        count?: outputs.wafv2.RuleGroupRuleActionCount;
    }

    export interface RuleGroupRuleActionAllow {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionAllowCustomRequestHandling;
    }

    export interface RuleGroupRuleActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader[];
    }

    export interface RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * The value of the custom header.
         */
        value: string;
    }

    export interface RuleGroupRuleActionBlock {
        /**
         * Defines a custom response for the web request. See Custom Response below for details.
         */
        customResponse?: outputs.wafv2.RuleGroupRuleActionBlockCustomResponse;
    }

    export interface RuleGroupRuleActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
         */
        responseHeaders?: outputs.wafv2.RuleGroupRuleActionBlockCustomResponseResponseHeader[];
    }

    export interface RuleGroupRuleActionBlockCustomResponseResponseHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * The value of the custom header.
         */
        value: string;
    }

    export interface RuleGroupRuleActionCaptcha {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionCaptchaCustomRequestHandling;
    }

    export interface RuleGroupRuleActionCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader[];
    }

    export interface RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * The value of the custom header.
         */
        value: string;
    }

    export interface RuleGroupRuleActionChallenge {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionChallengeCustomRequestHandling;
    }

    export interface RuleGroupRuleActionChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader[];
    }

    export interface RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * The value of the custom header.
         */
        value: string;
    }

    export interface RuleGroupRuleActionCount {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionCountCustomRequestHandling;
    }

    export interface RuleGroupRuleActionCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader[];
    }

    export interface RuleGroupRuleActionCountCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * The value of the custom header.
         */
        value: string;
    }

    export interface RuleGroupRuleCaptchaConfig {
        /**
         * Defines custom immunity time. See Immunity Time Property below for details.
         */
        immunityTimeProperty?: outputs.wafv2.RuleGroupRuleCaptchaConfigImmunityTimeProperty;
    }

    export interface RuleGroupRuleCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }

    export interface RuleGroupRuleRuleLabel {
        /**
         * The label string.
         */
        name: string;
    }

    export interface RuleGroupRuleStatement {
        /**
         * A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
         */
        andStatement?: outputs.wafv2.RuleGroupRuleStatementAndStatement;
        /**
         * A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
         */
        byteMatchStatement?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatement;
        /**
         * A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
         */
        geoMatchStatement?: outputs.wafv2.RuleGroupRuleStatementGeoMatchStatement;
        /**
         * A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementIpSetReferenceStatement;
        /**
         * A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
         */
        labelMatchStatement?: outputs.wafv2.RuleGroupRuleStatementLabelMatchStatement;
        /**
         * A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
         */
        notStatement?: outputs.wafv2.RuleGroupRuleStatementNotStatement;
        /**
         * A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
         */
        orStatement?: outputs.wafv2.RuleGroupRuleStatementOrStatement;
        /**
         * A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
         */
        rateBasedStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatement;
        /**
         * A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
         */
        regexMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatement;
        /**
         * A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatement;
        /**
         * A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
         */
        sqliMatchStatement?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatement;
        /**
         * A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
         */
        xssMatchStatement?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatement;
    }

    export interface RuleGroupRuleStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementByteMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatch;
        /**
         * The area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementByteMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementGeoMatchStatement {
        /**
         * An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig;
    }

    export interface RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface RuleGroupRuleStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }

    export interface RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }

    export interface RuleGroupRuleStatementLabelMatchStatement {
        /**
         * The string to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }

    export interface RuleGroupRuleStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementRateBasedStatement {
        /**
         * Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `FORWARDED_IP` or `IP`. Default: `IP`.
         */
        aggregateKeyType?: string;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregateKeyType` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig;
        /**
         * The limit on requests per 5-minute period for a single originating IP address.
         */
        limit: number;
        /**
         * An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregateKeyType` is set to `CONSTANT`, this block is required.
         */
        scopeDownStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatement;
    }

    export interface RuleGroupRuleStatementRateBasedStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatement {
        /**
         * A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
         */
        andStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement;
        /**
         * A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
         */
        byteMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement;
        /**
         * A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
         */
        geoMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement;
        /**
         * A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement;
        /**
         * A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
         */
        labelMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement;
        /**
         * A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
         */
        notStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement;
        /**
         * A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
         */
        orStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement;
        /**
         * A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
         */
        regexMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement;
        /**
         * A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement;
        /**
         * A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
         */
        sqliMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement;
        /**
         * A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
         */
        xssMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * The area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement {
        /**
         * An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement {
        /**
         * The string to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement {
        /**
         * The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatch;
        /**
         * The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRegexMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatement {
        /**
         * The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch;
        /**
         * The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementSizeConstraintStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementSqliMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementTextTransformation[];
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchBody {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString {
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath {
    }

    export interface RuleGroupRuleStatementXssMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface RuleGroupRuleVisibilityConfig {
        /**
         * A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }

    export interface RuleGroupVisibilityConfig {
        /**
         * A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }

    export interface WebAclCaptchaConfig {
        /**
         * Defines custom immunity time. See `immunityTimeProperty` below for details.
         */
        immunityTimeProperty?: outputs.wafv2.WebAclCaptchaConfigImmunityTimeProperty;
    }

    export interface WebAclCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }

    export interface WebAclCustomResponseBody {
        /**
         * Payload of the custom response.
         */
        content: string;
        /**
         * Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
         */
        contentType: string;
        /**
         * Unique key identifying the custom response body. This is referenced by the `customResponseBodyKey` argument in the `customResponse` block.
         */
        key: string;
    }

    export interface WebAclDefaultAction {
        /**
         * Specifies that AWS WAF should allow requests by default. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclDefaultActionAllow;
        /**
         * Specifies that AWS WAF should block requests by default. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclDefaultActionBlock;
    }

    export interface WebAclDefaultActionAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclDefaultActionAllowCustomRequestHandling;
    }

    export interface WebAclDefaultActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclDefaultActionAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclDefaultActionBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclDefaultActionBlockCustomResponse;
    }

    export interface WebAclDefaultActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclDefaultActionBlockCustomResponseResponseHeader[];
    }

    export interface WebAclDefaultActionBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclLoggingConfigurationLoggingFilter {
        /**
         * Default handling for logs that don't match any of the specified filtering conditions. Valid values for `defaultBehavior` are `KEEP` or `DROP`.
         */
        defaultBehavior: string;
        /**
         * Filter(s) that you want to apply to the logs. See Filter below for more details.
         */
        filters: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilter[];
    }

    export interface WebAclLoggingConfigurationLoggingFilterFilter {
        /**
         * Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
         */
        behavior: string;
        /**
         * Match condition(s) for the filter. See Condition below for more details.
         */
        conditions: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterCondition[];
        /**
         * Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
         */
        requirement: string;
    }

    export interface WebAclLoggingConfigurationLoggingFilterFilterCondition {
        /**
         * Configuration for a single action condition. See Action Condition below for more details.
         */
        actionCondition?: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition;
        /**
         * Condition for a single label name. See Label Name Condition below for more details.
         */
        labelNameCondition?: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition;
    }

    export interface WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition {
        /**
         * Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
         */
        action: string;
    }

    export interface WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition {
        /**
         * Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
         */
        labelName: string;
    }

    export interface WebAclLoggingConfigurationRedactedField {
        /**
         * HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldMethod;
        /**
         * Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldQueryString;
        /**
         * "singleHeader" refers to the redaction of a single header. For more information, please see the details below under Single Header.
         */
        singleHeader?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldSingleHeader;
        /**
         * Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldUriPath;
    }

    export interface WebAclLoggingConfigurationRedactedFieldMethod {
    }

    export interface WebAclLoggingConfigurationRedactedFieldQueryString {
    }

    export interface WebAclLoggingConfigurationRedactedFieldSingleHeader {
        /**
         * Name of the query header to redact. This setting must be provided in lowercase characters.
         */
        name: string;
    }

    export interface WebAclLoggingConfigurationRedactedFieldUriPath {
    }

    export interface WebAclRule {
        /**
         * Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
         */
        action?: outputs.wafv2.WebAclRuleAction;
        /**
         * Specifies how AWS WAF should handle CAPTCHA evaluations. See `captchaConfig` below for details.
         */
        captchaConfig?: outputs.wafv2.WebAclRuleCaptchaConfig;
        /**
         * Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
         */
        name: string;
        /**
         * Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `ruleGroupReferenceStatement` and `managedRuleGroupStatement`. See `overrideAction` below for details.
         */
        overrideAction?: outputs.wafv2.WebAclRuleOverrideAction;
        /**
         * If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
         */
        priority: number;
        /**
         * Labels to apply to web requests that match the rule match statement. See `ruleLabel` below for details.
         */
        ruleLabels?: outputs.wafv2.WebAclRuleRuleLabel[];
        /**
         * The AWS WAF processing statement for the rule, for example `byteMatchStatement` or `geoMatchStatement`. See `statement` below for details.
         */
        statement: outputs.wafv2.WebAclRuleStatement;
        /**
         * Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibilityConfig` below for details.
         */
        visibilityConfig: outputs.wafv2.WebAclRuleVisibilityConfig;
    }

    export interface WebAclRuleAction {
        /**
         * Instructs AWS WAF to allow the web request. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclRuleActionAllow;
        /**
         * Instructs AWS WAF to block the web request. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclRuleActionBlock;
        /**
         * Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
         */
        captcha?: outputs.wafv2.WebAclRuleActionCaptcha;
        /**
         * Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
         */
        challenge?: outputs.wafv2.WebAclRuleActionChallenge;
        /**
         * Instructs AWS WAF to count the web request and allow it. See `count` below for details.
         */
        count?: outputs.wafv2.WebAclRuleActionCount;
    }

    export interface WebAclRuleActionAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionAllowCustomRequestHandling;
    }

    export interface WebAclRuleActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionAllowCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleActionAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleActionBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleActionBlockCustomResponse;
    }

    export interface WebAclRuleActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleActionBlockCustomResponseResponseHeader[];
    }

    export interface WebAclRuleActionBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleActionCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionCaptchaCustomRequestHandling;
    }

    export interface WebAclRuleActionCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleActionChallenge {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionChallengeCustomRequestHandling;
    }

    export interface WebAclRuleActionChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleActionChallengeCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleActionCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionCountCustomRequestHandling;
    }

    export interface WebAclRuleActionCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionCountCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleActionCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleCaptchaConfig {
        /**
         * Defines custom immunity time. See `immunityTimeProperty` below for details.
         */
        immunityTimeProperty?: outputs.wafv2.WebAclRuleCaptchaConfigImmunityTimeProperty;
    }

    export interface WebAclRuleCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }

    export interface WebAclRuleOverrideAction {
        /**
         * Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
         */
        count?: outputs.wafv2.WebAclRuleOverrideActionCount;
        /**
         * Don't override the rule action setting. Configured as an empty block `{}`.
         */
        none?: outputs.wafv2.WebAclRuleOverrideActionNone;
    }

    export interface WebAclRuleOverrideActionCount {
    }

    export interface WebAclRuleOverrideActionNone {
    }

    export interface WebAclRuleRuleLabel {
        /**
         * Label string.
         */
        name: string;
    }

    export interface WebAclRuleStatement {
        /**
         * Logical rule statement used to combine other rule statements with AND logic. See `andStatement` below for details.
         */
        andStatement?: outputs.wafv2.WebAclRuleStatementAndStatement;
        /**
         * Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byteMatchStatement` below for details.
         */
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementByteMatchStatement;
        /**
         * Rule statement used to identify web requests based on country of origin. See `geoMatchStatement` below for details.
         */
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementGeoMatchStatement;
        /**
         * Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ipSetReferenceStatement` below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementIpSetReferenceStatement;
        /**
         * Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `labelMatchStatement` below for details.
         */
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementLabelMatchStatement;
        /**
         * Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managedRuleGroupStatement` below for details.
         */
        managedRuleGroupStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatement;
        /**
         * Logical rule statement used to negate the results of another rule statement. See `notStatement` below for details.
         */
        notStatement?: outputs.wafv2.WebAclRuleStatementNotStatement;
        /**
         * Logical rule statement used to combine other rule statements with OR logic. See `orStatement` below for details.
         */
        orStatement?: outputs.wafv2.WebAclRuleStatementOrStatement;
        /**
         * Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rateBasedStatement` below for details.
         */
        rateBasedStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatement;
        /**
         * Rule statement used to search web request components for a match against a single regular expression. See `regexMatchStatement` below for details.
         */
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementRegexMatchStatement;
        /**
         * Rule statement used to search web request components for matches with regular expressions. See `regexPatternSetReferenceStatement` below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatement;
        /**
         * Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `ruleGroupReferenceStatement` below for details.
         */
        ruleGroupReferenceStatement?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatement;
        /**
         * Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `sizeConstraintStatement` below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqliMatchStatement` below for details.
         */
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementSqliMatchStatement;
        /**
         * Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xssMatchStatement` below for details.
         */
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementXssMatchStatement;
    }

    export interface WebAclRuleStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementByteMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementByteMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementGeoMatchStatementForwardedIpConfig;
    }

    export interface WebAclRuleStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface WebAclRuleStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }

    export interface WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }

    export interface WebAclRuleStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatement {
        /**
         * Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managedRuleGroupConfigs` for more details
         */
        managedRuleGroupConfigs?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig[];
        /**
         * Name of the managed rule group.
         */
        name: string;
        /**
         * Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `ruleActionOverride` below for details.
         */
        ruleActionOverrides?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride[];
        /**
         * Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
         */
        scopeDownStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement;
        /**
         * Name of the managed rule group vendor.
         */
        vendorName: string;
        /**
         * Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
         */
        version?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig {
        /**
         * Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
         */
        awsManagedRulesAtpRuleSet?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet;
        /**
         * Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `awsManagedRulesBotControlRuleSet` for more details
         */
        awsManagedRulesBotControlRuleSet?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet;
        /**
         * The path of the login endpoint for your application.
         */
        loginPath?: string;
        /**
         * Details about your login page password field. See `passwordField` for more details.
         */
        passwordField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField;
        /**
         * The payload type for your login endpoint, either JSON or form encoded.
         */
        payloadType?: string;
        /**
         * Details about your login page username field. See `usernameField` for more details.
         */
        usernameField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet {
        /**
         * The path of the login endpoint for your application.
         */
        loginPath: string;
        /**
         * The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `requestInspection` for more details.
         */
        requestInspection?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection;
        /**
         * The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `responseInspection` for more details.
         */
        responseInspection?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection {
        /**
         * Details about your login page password field. See `passwordField` for more details.
         */
        passwordField: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField;
        /**
         * The payload type for your login endpoint, either JSON or form encoded.
         */
        payloadType: string;
        /**
         * Details about your login page username field. See `usernameField` for more details.
         */
        usernameField: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField {
        /**
         * The name of the password field.
         */
        identifier: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField {
        /**
         * The name of the username field.
         */
        identifier: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection {
        /**
         * Configures inspection of the response body. See `bodyContains` for more details.
         */
        bodyContains?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains;
        /**
         * Configures inspection of the response header.See `header` for more details.
         */
        header?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader;
        /**
         * Configures inspection of the response JSON. See `json` for more details.
         */
        json?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson;
        /**
         * Configures inspection of the response status code.See `statusCode` for more details.
         */
        statusCode?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains {
        /**
         * Strings in the body of the response that indicate a failed login attempt.
         */
        failureStrings: string[];
        /**
         * Strings in the body of the response that indicate a successful login attempt.
         */
        successStrings: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader {
        /**
         * Values in the response header with the specified name that indicate a failed login attempt.
         */
        failureValues: string[];
        /**
         * The name of the header to match against. The name must be an exact match, including case.
         */
        name: string;
        /**
         * Values in the response header with the specified name that indicate a successful login attempt.
         */
        successValues: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson {
        /**
         * Values in the response header with the specified name that indicate a failed login attempt.
         */
        failureValues: string[];
        /**
         * The identifier for the value to match against in the JSON.
         */
        identifier: string;
        /**
         * Values in the response header with the specified name that indicate a successful login attempt.
         */
        successValues: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode {
        /**
         * Status codes in the response that indicate a failed login attempt.
         */
        failureCodes: number[];
        /**
         * Status codes in the response that indicate a successful login attempt.
         */
        successCodes: number[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet {
        /**
         * The inspection level to use for the Bot Control rule group.
         */
        inspectionLevel: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField {
        /**
         * The name of the password field.
         */
        identifier: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField {
        /**
         * The name of the username field.
         */
        identifier: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride {
        /**
         * Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
         */
        actionToUse: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse;
        /**
         * Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse {
        /**
         * Specifies that AWS WAF should allow requests by default. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow;
        /**
         * Specifies that AWS WAF should block requests by default. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock;
        /**
         * Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
         */
        captcha?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha;
        /**
         * Instructs AWS WAF to count the web request and allow it. See `count` below for details.
         */
        count?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement {
        /**
         * Logical rule statement used to combine other rule statements with AND logic. See `andStatement` below for details.
         */
        andStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement;
        /**
         * Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byteMatchStatement` below for details.
         */
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement;
        /**
         * Rule statement used to identify web requests based on country of origin. See `geoMatchStatement` below for details.
         */
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement;
        /**
         * Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ipSetReferenceStatement` below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement;
        /**
         * Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `labelMatchStatement` below for details.
         */
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement;
        /**
         * Logical rule statement used to negate the results of another rule statement. See `notStatement` below for details.
         */
        notStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement;
        /**
         * Logical rule statement used to combine other rule statements with OR logic. See `orStatement` below for details.
         */
        orStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement;
        /**
         * Rule statement used to search web request components for a match against a single regular expression. See `regexMatchStatement` below for details.
         */
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement;
        /**
         * Rule statement used to search web request components for matches with regular expressions. See `regexPatternSetReferenceStatement` below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement;
        /**
         * Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `sizeConstraintStatement` below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqliMatchStatement` below for details.
         */
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement;
        /**
         * Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xssMatchStatement` below for details.
         */
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementRateBasedStatement {
        /**
         * Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `FORWARDED_IP` or `IP`. Default: `IP`.
         */
        aggregateKeyType?: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregateKeyType` is set to `FORWARDED_IP`, this block is required. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementForwardedIpConfig;
        /**
         * Limit on requests per 5-minute period for a single originating IP address.
         */
        limit: number;
        /**
         * Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregateKeyType` is set to `CONSTANT`, this block is required.
         */
        scopeDownStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatement;
    }

    export interface WebAclRuleStatementRateBasedStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatement {
        /**
         * Logical rule statement used to combine other rule statements with AND logic. See `andStatement` below for details.
         */
        andStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement;
        /**
         * Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byteMatchStatement` below for details.
         */
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement;
        /**
         * Rule statement used to identify web requests based on country of origin. See `geoMatchStatement` below for details.
         */
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement;
        /**
         * Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ipSetReferenceStatement` below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement;
        /**
         * Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `labelMatchStatement` below for details.
         */
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement;
        /**
         * Logical rule statement used to negate the results of another rule statement. See `notStatement` below for details.
         */
        notStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement;
        /**
         * Logical rule statement used to combine other rule statements with OR logic. See `orStatement` below for details.
         */
        orStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement;
        /**
         * Rule statement used to search web request components for a match against a single regular expression. See `regexMatchStatement` below for details.
         */
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement;
        /**
         * Rule statement used to search web request components for matches with regular expressions. See `regexPatternSetReferenceStatement` below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement;
        /**
         * Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `sizeConstraintStatement` below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqliMatchStatement` below for details.
         */
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement;
        /**
         * Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xssMatchStatement` below for details.
         */
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRegexMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation[];
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the `aws.wafv2.RuleGroup` resource.
         */
        arn: string;
        /**
         * Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `ruleActionOverride` below for details.
         */
        ruleActionOverrides?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride[];
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride {
        /**
         * Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
         */
        actionToUse: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse;
        /**
         * Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
         */
        name: string;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse {
        /**
         * Specifies that AWS WAF should allow requests by default. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow;
        /**
         * Specifies that AWS WAF should block requests by default. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock;
        /**
         * Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
         */
        captcha?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha;
        /**
         * Instructs AWS WAF to count the web request and allow it. See `count` below for details.
         */
        count?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader[];
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling;
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader[];
    }

    export interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementTextTransformation[];
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementSqliMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementXssMatchStatementTextTransformation[];
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchMethod {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchQueryString {
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }

    export interface WebAclRuleStatementXssMatchStatementFieldToMatchUriPath {
    }

    export interface WebAclRuleStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }

    export interface WebAclRuleVisibilityConfig {
        /**
         * Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }

    export interface WebAclVisibilityConfig {
        /**
         * Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }

}

export namespace worklink {
    export interface FleetIdentityProvider {
        /**
         * The SAML metadata document provided by the customer’s identity provider.
         */
        samlMetadata: string;
        /**
         * The type of identity provider.
         */
        type: string;
    }

    export interface FleetNetwork {
        /**
         * A list of security group IDs associated with access to the provided subnets.
         *
         * **identity_provider** requires the following:
         *
         * > **NOTE:** `identityProvider` cannot be removed without force recreating.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs used for X-ENI connections from Amazon WorkLink rendering containers.
         */
        subnetIds: string[];
        /**
         * The VPC ID with connectivity to associated websites.
         */
        vpcId: string;
    }

}

export namespace workspaces {
    export interface DirectorySelfServicePermissions {
        /**
         * Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default `false`.
         */
        changeComputeType?: boolean;
        /**
         * Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default `false`.
         */
        increaseVolumeSize?: boolean;
        /**
         * Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default `false`.
         */
        rebuildWorkspace?: boolean;
        /**
         * Whether WorkSpaces directory users can restart their workspace. Default `true`.
         */
        restartWorkspace?: boolean;
        /**
         * Whether WorkSpaces directory users can switch the running mode of their workspace. Default `false`.
         */
        switchRunningMode?: boolean;
    }

    export interface DirectoryWorkspaceAccessProperties {
        /**
         * Indicates whether users can use Android devices to access their WorkSpaces.
         */
        deviceTypeAndroid?: string;
        /**
         * Indicates whether users can use Chromebooks to access their WorkSpaces.
         */
        deviceTypeChromeos?: string;
        /**
         * Indicates whether users can use iOS devices to access their WorkSpaces.
         */
        deviceTypeIos?: string;
        /**
         * Indicates whether users can use Linux clients to access their WorkSpaces.
         */
        deviceTypeLinux?: string;
        /**
         * Indicates whether users can use macOS clients to access their WorkSpaces.
         */
        deviceTypeOsx?: string;
        /**
         * Indicates whether users can access their WorkSpaces through a web browser.
         */
        deviceTypeWeb?: string;
        /**
         * Indicates whether users can use Windows clients to access their WorkSpaces.
         */
        deviceTypeWindows?: string;
        /**
         * Indicates whether users can use zero client devices to access their WorkSpaces.
         */
        deviceTypeZeroclient?: string;
    }

    export interface DirectoryWorkspaceCreationProperties {
        /**
         * The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
         */
        customSecurityGroupId?: string;
        /**
         * The default organizational unit (OU) for your WorkSpace directories. Should conform `"OU=<value>,DC=<value>,...,DC=<value>"` pattern.
         */
        defaultOu?: string;
        /**
         * Indicates whether internet access is enabled for your WorkSpaces.
         */
        enableInternetAccess?: boolean;
        /**
         * Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html)..
         */
        enableMaintenanceMode?: boolean;
        /**
         * Indicates whether users are local administrators of their WorkSpaces.
         */
        userEnabledAsLocalAdministrator?: boolean;
    }

    export interface GetBundleComputeType {
        /**
         * Name of the bundle. You cannot combine this parameter with `bundleId`.
         */
        name: string;
    }

    export interface GetBundleRootStorage {
        /**
         * Size of the user storage.
         */
        capacity: string;
    }

    export interface GetBundleUserStorage {
        /**
         * Size of the user storage.
         */
        capacity: string;
    }

    export interface GetDirectorySelfServicePermission {
        /**
         * Whether WorkSpaces directory users can change the compute type (bundle) for their workspace.
         */
        changeComputeType: boolean;
        /**
         * Whether WorkSpaces directory users can increase the volume size of the drives on their workspace.
         */
        increaseVolumeSize: boolean;
        /**
         * Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state.
         */
        rebuildWorkspace: boolean;
        /**
         * Whether WorkSpaces directory users can restart their workspace.
         */
        restartWorkspace: boolean;
        /**
         * Whether WorkSpaces directory users can switch the running mode of their workspace.
         */
        switchRunningMode: boolean;
    }

    export interface GetDirectoryWorkspaceAccessProperty {
        /**
         * (Optional) Indicates whether users can use Android devices to access their WorkSpaces.
         */
        deviceTypeAndroid: string;
        /**
         * (Optional) Indicates whether users can use Chromebooks to access their WorkSpaces.
         */
        deviceTypeChromeos: string;
        /**
         * (Optional) Indicates whether users can use iOS devices to access their WorkSpaces.
         */
        deviceTypeIos: string;
        /**
         * (Optional) Indicates whether users can use Linux clients to access their WorkSpaces.
         */
        deviceTypeLinux: string;
        /**
         * (Optional) Indicates whether users can use macOS clients to access their WorkSpaces.
         */
        deviceTypeOsx: string;
        /**
         * (Optional) Indicates whether users can access their WorkSpaces through a web browser.
         */
        deviceTypeWeb: string;
        /**
         * (Optional) Indicates whether users can use Windows clients to access their WorkSpaces.
         */
        deviceTypeWindows: string;
        /**
         * (Optional) Indicates whether users can use zero client devices to access their WorkSpaces.
         */
        deviceTypeZeroclient: string;
    }

    export interface GetDirectoryWorkspaceCreationProperty {
        /**
         * The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
         */
        customSecurityGroupId: string;
        /**
         * The default organizational unit (OU) for your WorkSpace directories.
         */
        defaultOu: string;
        /**
         * Indicates whether internet access is enabled for your WorkSpaces.
         */
        enableInternetAccess: boolean;
        /**
         * Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
         */
        enableMaintenanceMode: boolean;
        /**
         * Indicates whether users are local administrators of their WorkSpaces.
         */
        userEnabledAsLocalAdministrator: boolean;
    }

    export interface GetWorkspaceWorkspaceProperty {
        /**
         * Compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO` and `GRAPHICSPRO`.
         */
        computeTypeName: string;
        /**
         * Size of the root volume.
         */
        rootVolumeSizeGib: number;
        /**
         * Running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
         */
        runningMode: string;
        /**
         * Time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
         */
        runningModeAutoStopTimeoutInMinutes: number;
        /**
         * Size of the user storage.
         */
        userVolumeSizeGib: number;
    }

    export interface IpGroupRule {
        /**
         * The description of the IP group.
         */
        description?: string;
        /**
         * The IP address range, in CIDR notation, e.g., `10.0.0.0/16`
         */
        source: string;
    }

    export interface WorkspaceWorkspaceProperties {
        /**
         * The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO`, `GRAPHICSPRO`, `GRAPHICS_G4DN`, and `GRAPHICSPRO_G4DN`.
         */
        computeTypeName?: string;
        /**
         * The size of the root volume.
         */
        rootVolumeSizeGib?: number;
        /**
         * The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
         */
        runningMode?: string;
        /**
         * The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
         */
        runningModeAutoStopTimeoutInMinutes: number;
        /**
         * The size of the user storage.
         */
        userVolumeSizeGib?: number;
    }

}

export namespace xray {
    export interface GroupInsightsConfiguration {
        /**
         * Specifies whether insights are enabled.
         */
        insightsEnabled: boolean;
        /**
         * Specifies whether insight notifications are enabled.
         */
        notificationsEnabled: boolean;
    }

}
