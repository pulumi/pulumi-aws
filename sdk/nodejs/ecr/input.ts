// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";

export interface RegistryScanningConfigurationRule {
    /**
     * One or more repository filter blocks, containing a `filter` (required string filtering repositories, see pattern regex [here](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_ScanningRepositoryFilter.html)) and a `filterType` (required string, currently only `WILDCARD` is supported).
     */
    repositoryFilters: pulumi.Input<pulumi.Input<inputs.RegistryScanningConfigurationRuleRepositoryFilter>[]>;
    /**
     * The frequency that scans are performed at for a private registry. Can be `SCAN_ON_PUSH`, `CONTINUOUS_SCAN`, or `MANUAL`.
     */
    scanFrequency: pulumi.Input<string>;
}
export interface RegistryScanningConfigurationRuleRepositoryFilter {
    filter: pulumi.Input<string>;
    filterType: pulumi.Input<string>;
}
export interface ReplicationConfigurationReplicationConfiguration {
    /**
     * The replication rules for a replication configuration. A maximum of 10 are allowed per `replicationConfiguration`. See Rule
     */
    rules: pulumi.Input<pulumi.Input<inputs.ReplicationConfigurationReplicationConfigurationRule>[]>;
}
export interface ReplicationConfigurationReplicationConfigurationRule {
    /**
     * the details of a replication destination. A maximum of 25 are allowed per `rule`. See Destination.
     */
    destinations: pulumi.Input<pulumi.Input<inputs.ReplicationConfigurationReplicationConfigurationRuleDestination>[]>;
    /**
     * filters for a replication rule. See Repository Filter.
     */
    repositoryFilters?: pulumi.Input<pulumi.Input<inputs.ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter>[]>;
}
export interface ReplicationConfigurationReplicationConfigurationRuleDestination {
    /**
     * A Region to replicate to.
     */
    region: pulumi.Input<string>;
    /**
     * The account ID of the destination registry to replicate to.
     */
    registryId: pulumi.Input<string>;
}
export interface ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter {
    /**
     * The repository filter details.
     */
    filter: pulumi.Input<string>;
    /**
     * The repository filter type. The only supported value is `PREFIX_MATCH`, which is a repository name prefix specified with the filter parameter.
     */
    filterType: pulumi.Input<string>;
}
export interface RepositoryEncryptionConfiguration {
    /**
     * The encryption type to use for the repository. Valid values are `AES256` or `KMS`. Defaults to `AES256`.
     */
    encryptionType?: pulumi.Input<string>;
    /**
     * The ARN of the KMS key to use when `encryptionType` is `KMS`. If not specified, uses the default AWS managed key for ECR.
     */
    kmsKey?: pulumi.Input<string>;
}
export interface RepositoryImageScanningConfiguration {
    /**
     * Indicates whether images are scanned after being pushed to the repository (true) or not scanned (false).
     */
    scanOnPush: pulumi.Input<boolean>;
}
export interface GetLifecyclePolicyDocumentRule {
    /**
     * Specifies the action type.
     */
    action?: inputs.GetLifecyclePolicyDocumentRuleAction;
    /**
     * Describes the purpose of a rule within a lifecycle policy.
     */
    description?: string;
    /**
     * Sets the order in which rules are evaluated, lowest to highest. When you add rules to a lifecycle policy, you must give them each a unique value for `priority`. Values do not need to be sequential across rules in a policy. A rule with a `tagStatus` value of any must have the highest value for `priority` and be evaluated last.
     */
    priority: number;
    /**
     * Collects parameters describing the selection criteria for the ECR lifecycle policy:
     */
    selection?: inputs.GetLifecyclePolicyDocumentRuleSelection;
}
export interface GetLifecyclePolicyDocumentRuleArgs {
    /**
     * Specifies the action type.
     */
    action?: pulumi.Input<inputs.GetLifecyclePolicyDocumentRuleActionArgs>;
    /**
     * Describes the purpose of a rule within a lifecycle policy.
     */
    description?: pulumi.Input<string>;
    /**
     * Sets the order in which rules are evaluated, lowest to highest. When you add rules to a lifecycle policy, you must give them each a unique value for `priority`. Values do not need to be sequential across rules in a policy. A rule with a `tagStatus` value of any must have the highest value for `priority` and be evaluated last.
     */
    priority: pulumi.Input<number>;
    /**
     * Collects parameters describing the selection criteria for the ECR lifecycle policy:
     */
    selection?: pulumi.Input<inputs.GetLifecyclePolicyDocumentRuleSelectionArgs>;
}
export interface GetLifecyclePolicyDocumentRuleAction {
    /**
     * The supported value is `expire`.
     */
    type: string;
}
export interface GetLifecyclePolicyDocumentRuleActionArgs {
    /**
     * The supported value is `expire`.
     */
    type: pulumi.Input<string>;
}
export interface GetLifecyclePolicyDocumentRuleSelection {
    /**
     * Specify a count number. If the `countType` used is imageCountMoreThan, then the value is the maximum number of images that you want to retain in your repository. If the `countType` used is sinceImagePushed, then the value is the maximum age limit for your images.
     */
    countNumber: number;
    /**
     * Specify a count type to apply to the images. If `countType` is set to imageCountMoreThan, you also specify `countNumber` to create a rule that sets a limit on the number of images that exist in your repository. If `countType` is set to sinceImagePushed, you also specify `countUnit` and `countNumber` to specify a time limit on the images that exist in your repository.
     */
    countType: string;
    /**
     * Specify a count unit of days to indicate that as the unit of time, in addition to `countNumber`, which is the number of days.
     */
    countUnit?: string;
    /**
     * You must specify a comma-separated list of image tag patterns that may contain wildcards (*) on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag pattern list prod* to specify all of them. If you specify multiple tags, only the images with all specified tags are selected. There is a maximum limit of four wildcards (*) per string. For example, ["*test*1*2*3", "test*1*2*3*"] is valid but ["test*1*2*3*4*5*6"] is invalid.
     */
    tagPatternLists?: string[];
    /**
     * You must specify a comma-separated list of image tag prefixes on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag prefix prod to specify all of them. If you specify multiple tags, only images with all specified tags are selected.
     */
    tagPrefixLists?: string[];
    /**
     * Determines whether the lifecycle policy rule that you are adding specifies a tag for an image. Acceptable options are tagged, untagged, or any. If you specify any, then all images have the rule applied to them. If you specify tagged, then you must also specify a `tagPrefixList` value. If you specify untagged, then you must omit `tagPrefixList`.
     */
    tagStatus: string;
}
export interface GetLifecyclePolicyDocumentRuleSelectionArgs {
    /**
     * Specify a count number. If the `countType` used is imageCountMoreThan, then the value is the maximum number of images that you want to retain in your repository. If the `countType` used is sinceImagePushed, then the value is the maximum age limit for your images.
     */
    countNumber: pulumi.Input<number>;
    /**
     * Specify a count type to apply to the images. If `countType` is set to imageCountMoreThan, you also specify `countNumber` to create a rule that sets a limit on the number of images that exist in your repository. If `countType` is set to sinceImagePushed, you also specify `countUnit` and `countNumber` to specify a time limit on the images that exist in your repository.
     */
    countType: pulumi.Input<string>;
    /**
     * Specify a count unit of days to indicate that as the unit of time, in addition to `countNumber`, which is the number of days.
     */
    countUnit?: pulumi.Input<string>;
    /**
     * You must specify a comma-separated list of image tag patterns that may contain wildcards (*) on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag pattern list prod* to specify all of them. If you specify multiple tags, only the images with all specified tags are selected. There is a maximum limit of four wildcards (*) per string. For example, ["*test*1*2*3", "test*1*2*3*"] is valid but ["test*1*2*3*4*5*6"] is invalid.
     */
    tagPatternLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * You must specify a comma-separated list of image tag prefixes on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag prefix prod to specify all of them. If you specify multiple tags, only images with all specified tags are selected.
     */
    tagPrefixLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether the lifecycle policy rule that you are adding specifies a tag for an image. Acceptable options are tagged, untagged, or any. If you specify any, then all images have the rule applied to them. If you specify tagged, then you must also specify a `tagPrefixList` value. If you specify untagged, then you must omit `tagPrefixList`.
     */
    tagStatus: pulumi.Input<string>;
}
