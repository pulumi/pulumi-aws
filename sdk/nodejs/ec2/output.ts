// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./input";
import * as outputs from "./output";
import * as enums from "./enums";

export interface AmiCopyEbsBlockDevice {
    /**
     * Boolean controlling whether the EBS volumes created to
     * support each created instance will be deleted once that instance is terminated.
     */
    deleteOnTermination: boolean;
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
     */
    encrypted: boolean;
    /**
     * Number of I/O operations per second the
     * created volumes will support.
     */
    iops: number;
    /**
     * ARN of the Outpost on which the snapshot is stored.
     *
     * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
     */
    outpostArn: string;
    /**
     * ID of an EBS snapshot that will be used to initialize the created
     * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
     * snapshot.
     */
    snapshotId: string;
    /**
     * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    /**
     * Size of created volumes in GiB.
     * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
     * as the selected snapshot.
     */
    volumeSize: number;
    /**
     * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
     */
    volumeType: string;
}
export interface AmiCopyEphemeralBlockDevice {
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Name for the ephemeral device, of the form "ephemeralN" where
     * *N* is a volume number starting from zero.
     */
    virtualName: string;
}
export interface AmiEbsBlockDevice {
    /**
     * Boolean controlling whether the EBS volumes created to
     * support each created instance will be deleted once that instance is terminated.
     */
    deleteOnTermination?: boolean;
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
     */
    encrypted?: boolean;
    /**
     * Number of I/O operations per second the
     * created volumes will support.
     */
    iops?: number;
    /**
     * ARN of the Outpost on which the snapshot is stored.
     *
     * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
     */
    outpostArn?: string;
    /**
     * ID of an EBS snapshot that will be used to initialize the created
     * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
     * snapshot.
     */
    snapshotId?: string;
    /**
     * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    /**
     * Size of created volumes in GiB.
     * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
     * as the selected snapshot.
     */
    volumeSize: number;
    /**
     * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
     */
    volumeType?: string;
}
export interface AmiEphemeralBlockDevice {
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Name for the ephemeral device, of the form "ephemeralN" where
     * *N* is a volume number starting from zero.
     */
    virtualName: string;
}
export interface AmiFromInstanceEbsBlockDevice {
    /**
     * Boolean controlling whether the EBS volumes created to
     * support each created instance will be deleted once that instance is terminated.
     */
    deleteOnTermination: boolean;
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
     */
    encrypted: boolean;
    /**
     * Number of I/O operations per second the
     * created volumes will support.
     */
    iops: number;
    /**
     * ARN of the Outpost on which the snapshot is stored.
     *
     * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
     */
    outpostArn: string;
    /**
     * ID of an EBS snapshot that will be used to initialize the created
     * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
     * snapshot.
     */
    snapshotId: string;
    /**
     * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    /**
     * Size of created volumes in GiB.
     * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
     * as the selected snapshot.
     */
    volumeSize: number;
    /**
     * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
     */
    volumeType: string;
}
export interface AmiFromInstanceEphemeralBlockDevice {
    /**
     * Path at which the device is exposed to created instances.
     */
    deviceName: string;
    /**
     * Name for the ephemeral device, of the form "ephemeralN" where
     * *N* is a volume number starting from zero.
     */
    virtualName: string;
}
export interface DefaultNetworkAclEgress {
    /**
     * The action to take.
     */
    action: string;
    /**
     * The CIDR block to match. This must be a valid network mask.
     */
    cidrBlock?: string;
    /**
     * The from port to match.
     */
    fromPort: number;
    /**
     * The ICMP type code to be used. Default 0.
     */
    icmpCode?: number;
    /**
     * The ICMP type to be used. Default 0.
     */
    icmpType?: number;
    /**
     * The IPv6 CIDR block.
     *
     * > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
     */
    ipv6CidrBlock?: string;
    /**
     * The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
     */
    protocol: string;
    /**
     * The rule number. Used for ordering.
     */
    ruleNo: number;
    /**
     * The to port to match.
     *
     * The following arguments are optional:
     */
    toPort: number;
}
export interface DefaultNetworkAclIngress {
    action: string;
    cidrBlock?: string;
    fromPort: number;
    icmpCode?: number;
    icmpType?: number;
    ipv6CidrBlock?: string;
    protocol: string;
    ruleNo: number;
    toPort: number;
}
export interface DefaultRouteTableRoute {
    /**
     * The CIDR block of the route.
     */
    cidrBlock?: string;
    /**
     * The Amazon Resource Name (ARN) of a core network.
     */
    coreNetworkArn?: string;
    /**
     * The ID of a managed prefix list destination of the route.
     *
     * One of the following target arguments must be supplied:
     */
    destinationPrefixListId?: string;
    /**
     * Identifier of a VPC Egress Only Internet Gateway.
     */
    egressOnlyGatewayId?: string;
    /**
     * Identifier of a VPC internet gateway or a virtual private gateway.
     */
    gatewayId?: string;
    /**
     * Identifier of an EC2 instance.
     */
    instanceId?: string;
    /**
     * The Ipv6 CIDR block of the route
     */
    ipv6CidrBlock?: string;
    /**
     * Identifier of a VPC NAT gateway.
     */
    natGatewayId?: string;
    /**
     * Identifier of an EC2 network interface.
     */
    networkInterfaceId?: string;
    /**
     * Identifier of an EC2 Transit Gateway.
     */
    transitGatewayId?: string;
    /**
     * Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
     */
    vpcEndpointId?: string;
    /**
     * Identifier of a VPC peering connection.
     *
     * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
     */
    vpcPeeringConnectionId?: string;
}
export interface DefaultSecurityGroupEgress {
    /**
     * List of CIDR blocks.
     */
    cidrBlocks?: string[];
    /**
     * Description of this rule.
     */
    description?: string;
    /**
     * Start port (or ICMP type number if protocol is `icmp`)
     */
    fromPort: number;
    /**
     * List of IPv6 CIDR blocks.
     */
    ipv6CidrBlocks?: string[];
    /**
     * List of prefix list IDs (for allowing access to VPC endpoints)
     */
    prefixListIds?: string[];
    /**
     * Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    protocol: string;
    /**
     * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
     */
    securityGroups?: string[];
    /**
     * Whether the security group itself will be added as a source to this egress rule.
     */
    self?: boolean;
    /**
     * End range port (or ICMP code if protocol is `icmp`).
     */
    toPort: number;
}
export interface DefaultSecurityGroupIngress {
    cidrBlocks?: string[];
    /**
     * Description of the security group.
     */
    description?: string;
    fromPort: number;
    ipv6CidrBlocks?: string[];
    prefixListIds?: string[];
    protocol: string;
    securityGroups?: string[];
    self?: boolean;
    toPort: number;
}
export interface EipDomainNameTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}
export interface FleetFleetInstanceSet {
    /**
     * The IDs of the instances.
     */
    instanceIds: string[];
    /**
     * The instance type.
     */
    instanceType: string;
    /**
     * Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
     */
    lifecycle: string;
    /**
     * The value is `Windows` for Windows instances. Otherwise, the value is blank.
     */
    platform: string;
}
export interface FleetLaunchTemplateConfig {
    /**
     * Nested argument containing EC2 Launch Template to use. Defined below.
     */
    launchTemplateSpecification?: outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification;
    /**
     * Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
     */
    overrides?: outputs.FleetLaunchTemplateConfigOverride[];
}
export interface FleetLaunchTemplateConfigLaunchTemplateSpecification {
    /**
     * The ID of the launch template.
     */
    launchTemplateId?: string;
    /**
     * The name of the launch template.
     */
    launchTemplateName?: string;
    /**
     * The launch template version number, `$Latest`, or `$Default.`
     */
    version: string;
}
export interface FleetLaunchTemplateConfigOverride {
    /**
     * Availability Zone in which to launch the instances.
     */
    availabilityZone?: string;
    /**
     * Override the instance type in the Launch Template with instance types that satisfy the requirements.
     */
    instanceRequirements?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements;
    /**
     * Instance type.
     */
    instanceType?: string;
    /**
     * Maximum price per unit hour that you are willing to pay for a Spot Instance.
     */
    maxPrice?: string;
    /**
     * Priority for the launch template override. If `onDemandOptions` `allocationStrategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
     */
    priority?: number;
    /**
     * ID of the subnet in which to launch the instances.
     */
    subnetId?: string;
    /**
     * Number of units provided by the specified instance type.
     */
    weightedCapacity?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirements {
    /**
     * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
     */
    acceleratorCount?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
    /**
     * List of accelerator manufacturer names. Default is any manufacturer.
     */
    acceleratorManufacturers?: string[];
    /**
     * List of accelerator names. Default is any acclerator.
     */
    acceleratorNames?: string[];
    /**
     * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
     */
    acceleratorTotalMemoryMib?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
    /**
     * The accelerator types that must be on the instance type. Default is any accelerator type.
     */
    acceleratorTypes?: string[];
    /**
     * The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.
     *
     * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
     */
    allowedInstanceTypes?: string[];
    /**
     * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
     */
    bareMetal?: string;
    /**
     * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
     */
    baselineEbsBandwidthMbps?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
    /**
     * Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
     */
    burstablePerformance?: string;
    /**
     * The CPU manufacturers to include. Default is any manufacturer.
     * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     */
    cpuManufacturers?: string[];
    /**
     * The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
     *
     * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
     */
    excludedInstanceTypes?: string[];
    /**
     * Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
     */
    instanceGenerations?: string[];
    /**
     * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
     */
    localStorage?: string;
    /**
     * List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
     */
    localStorageTypes?: string[];
    /**
     * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
     */
    memoryGibPerVcpu?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
    /**
     * The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
     */
    memoryMib: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
     */
    networkBandwidthGbps?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
    /**
     * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
     */
    networkInterfaceCount?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
    /**
     * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
     *
     * If you set `targetCapacityUnitType` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     */
    onDemandMaxPricePercentageOverLowestPrice?: number;
    /**
     * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
     */
    requireHibernateSupport?: boolean;
    /**
     * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
     *
     * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
     */
    spotMaxPricePercentageOverLowestPrice?: number;
    /**
     * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
     */
    totalLocalStorageGb?: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
    /**
     * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
     */
    vcpuCount: outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
    /**
     * Maximum. Set to `0` to exclude instance types with accelerators.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
    /**
     * The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
    /**
     * The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter..
     */
    max?: number;
    /**
     * The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter..
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
    /**
     * The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
    /**
     * The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum amount of memory, in MiB. To specify no minimum limit, specify `0`.
     */
    min: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
    /**
     * The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
    /**
     * The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
    /**
     * The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
     */
    min?: number;
}
export interface FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
    /**
     * The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
     */
    max?: number;
    /**
     * The minimum number of vCPUs. To specify no minimum limit, specify `0`.
     */
    min: number;
}
export interface FleetOnDemandOptions {
    /**
     * The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
     */
    allocationStrategy?: string;
    /**
     * The maximum amount per hour for On-Demand Instances that you're willing to pay.
     */
    maxTotalPrice?: string;
    /**
     * The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
     * If you specify `minTargetCapacity`, at least one of the following must be specified: `singleAvailabilityZone` or `singleInstanceType`.
     */
    minTargetCapacity?: number;
    /**
     * Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
     */
    singleAvailabilityZone?: boolean;
    /**
     * Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
     */
    singleInstanceType?: boolean;
}
export interface FleetSpotOptions {
    /**
     * How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
     */
    allocationStrategy?: string;
    /**
     * Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
     */
    instanceInterruptionBehavior?: string;
    /**
     * Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocationStrategy` is set to `lowestPrice`. Default: `1`.
     */
    instancePoolsToUseCount?: number;
    /**
     * Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
     */
    maintenanceStrategies?: outputs.FleetSpotOptionsMaintenanceStrategies;
}
export interface FleetSpotOptionsMaintenanceStrategies {
    /**
     * Nested argument containing the capacity rebalance for your fleet request. Defined below.
     */
    capacityRebalance?: outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance;
}
export interface FleetSpotOptionsMaintenanceStrategiesCapacityRebalance {
    /**
     * The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
     */
    replacementStrategy?: string;
    terminationDelay?: number;
}
export interface FleetTargetCapacitySpecification {
    /**
     * Default target capacity type. Valid values: `on-demand`, `spot`.
     */
    defaultTargetCapacityType: string;
    /**
     * The number of On-Demand units to request.
     */
    onDemandTargetCapacity?: number;
    /**
     * The number of Spot units to request.
     */
    spotTargetCapacity?: number;
    /**
     * The unit for the target capacity.
     * If you specify `targetCapacityUnitType`, `instanceRequirements` must be specified.
     */
    targetCapacityUnitType?: string;
    /**
     * The number of units to request, filled using `defaultTargetCapacityType`.
     */
    totalTargetCapacity: number;
}
export interface FlowLogDestinationOptions {
    /**
     * The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
     */
    fileFormat?: string;
    /**
     * Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
     */
    hiveCompatiblePartitions?: boolean;
    /**
     * Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
     */
    perHourPartition?: boolean;
}
export interface InstanceCapacityReservationSpecification {
    /**
     * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
     */
    capacityReservationPreference?: string;
    /**
     * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
     *
     * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
     */
    capacityReservationTarget?: outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget;
}
export interface InstanceCapacityReservationSpecificationCapacityReservationTarget {
    /**
     * ID of the Capacity Reservation in which to run the instance.
     */
    capacityReservationId?: string;
    /**
     * ARN of the Capacity Reservation resource group in which to run the instance.
     */
    capacityReservationResourceGroupArn?: string;
}
export interface InstanceCpuOptions {
    /**
     * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
     */
    amdSevSnp: string;
    /**
     * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
     */
    coreCount: number;
    /**
     * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
     *
     * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
     */
    threadsPerCore: number;
}
export interface InstanceCreditSpecification {
    /**
     * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
     */
    cpuCredits?: string;
}
export interface InstanceEbsBlockDevice {
    /**
     * Whether the volume should be destroyed on instance termination. Defaults to `true`.
     */
    deleteOnTermination?: boolean;
    /**
     * Name of the device to mount.
     */
    deviceName: string;
    /**
     * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
     */
    encrypted: boolean;
    /**
     * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
     */
    iops: number;
    /**
     * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
     */
    kmsKeyId: string;
    /**
     * Snapshot ID to mount.
     */
    snapshotId: string;
    /**
     * Map of tags to assign to the device.
     */
    tags?: {[key: string]: string};
    /**
     * Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     */
    tagsAll: {[key: string]: string};
    /**
     * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    /**
     * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
     */
    volumeId: string;
    /**
     * Size of the volume in gibibytes (GiB).
     */
    volumeSize: number;
    /**
     * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
     *
     * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
     */
    volumeType: string;
}
export interface InstanceEnclaveOptions {
    /**
     * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
     *
     * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
     */
    enabled: boolean;
}
export interface InstanceEphemeralBlockDevice {
    /**
     * Name of the block device to mount on the instance.
     */
    deviceName: string;
    /**
     * Suppresses the specified device included in the AMI's block device mapping.
     */
    noDevice?: boolean;
    /**
     * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
     *
     * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
     */
    virtualName?: string;
}
export interface InstanceInstanceMarketOptions {
    /**
     * Type of market for the instance. Valid value is `spot`. Defaults to `spot`. Required if `spotOptions` is specified.
     */
    marketType: string;
    /**
     * Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
     */
    spotOptions: outputs.InstanceInstanceMarketOptionsSpotOptions;
}
export interface InstanceInstanceMarketOptionsSpotOptions {
    /**
     * The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
     */
    instanceInterruptionBehavior: string;
    /**
     * The maximum hourly price that you're willing to pay for a Spot Instance.
     */
    maxPrice: string;
    /**
     * The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
     */
    spotInstanceType: string;
    /**
     * The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
     */
    validUntil: string;
}
export interface InstanceLaunchTemplate {
    /**
     * ID of the launch template. Conflicts with `name`.
     */
    id: string;
    /**
     * Name of the launch template. Conflicts with `id`.
     */
    name: string;
    /**
     * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
     */
    version?: string;
}
export interface InstanceMaintenanceOptions {
    /**
     * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
     */
    autoRecovery: string;
}
export interface InstanceMetadataOptions {
    /**
     * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
     */
    httpEndpoint?: string;
    /**
     * Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
     */
    httpProtocolIpv6?: string;
    /**
     * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
     */
    httpPutResponseHopLimit: number;
    /**
     * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
     */
    httpTokens: string;
    /**
     * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
     *
     * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
     */
    instanceMetadataTags: string;
}
export interface InstanceNetworkInterface {
    /**
     * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
     */
    deleteOnTermination?: boolean;
    /**
     * Integer index of the network interface attachment. Limited by instance type.
     */
    deviceIndex: number;
    /**
     * Integer index of the network card. Limited by instance type. The default index is `0`.
     */
    networkCardIndex?: number;
    /**
     * ID of the network interface to attach.
     */
    networkInterfaceId: string;
}
export interface InstancePrivateDnsNameOptions {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     */
    enableResourceNameDnsARecord: boolean;
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     */
    enableResourceNameDnsAaaaRecord: boolean;
    /**
     * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
     */
    hostnameType: string;
}
export interface InstanceRootBlockDevice {
    /**
     * Whether the volume should be destroyed on instance termination. Defaults to `true`.
     */
    deleteOnTermination?: boolean;
    /**
     * Device name, e.g., `/dev/sdh` or `xvdh`.
     */
    deviceName: string;
    /**
     * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
     */
    encrypted: boolean;
    /**
     * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
     */
    iops: number;
    /**
     * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
     */
    kmsKeyId: string;
    /**
     * Map of tags to assign to the device.
     */
    tags?: {[key: string]: string};
    /**
     * Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     */
    tagsAll: {[key: string]: string};
    /**
     * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    /**
     * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
     */
    volumeId: string;
    /**
     * Size of the volume in gibibytes (GiB).
     */
    volumeSize: number;
    /**
     * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
     *
     * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
     */
    volumeType: string;
}
export interface LaunchConfigurationEbsBlockDevice {
    deleteOnTermination?: boolean;
    deviceName: string;
    encrypted: boolean;
    iops: number;
    noDevice?: boolean;
    snapshotId: string;
    throughput: number;
    volumeSize: number;
    volumeType: string;
}
export interface LaunchConfigurationEphemeralBlockDevice {
    deviceName: string;
    noDevice?: boolean;
    virtualName?: string;
}
export interface LaunchConfigurationMetadataOptions {
    /**
     * The state of the metadata service: `enabled`, `disabled`.
     */
    httpEndpoint: string;
    /**
     * The desired HTTP PUT response hop limit for instance metadata requests.
     */
    httpPutResponseHopLimit: number;
    /**
     * If session tokens are required: `optional`, `required`.
     */
    httpTokens: string;
}
export interface LaunchConfigurationRootBlockDevice {
    deleteOnTermination?: boolean;
    encrypted: boolean;
    iops: number;
    throughput: number;
    volumeSize: number;
    volumeType: string;
}
export interface LaunchTemplateBlockDeviceMapping {
    /**
     * The name of the device to mount.
     */
    deviceName?: string;
    /**
     * Configure EBS volume properties.
     */
    ebs?: outputs.LaunchTemplateBlockDeviceMappingEbs;
    /**
     * Suppresses the specified device included in the AMI's block device mapping.
     */
    noDevice?: string;
    /**
     * The [Instance Store Device
     * Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
     * (e.g., `"ephemeral0"`).
     */
    virtualName?: string;
}
export interface LaunchTemplateBlockDeviceMappingEbs {
    /**
     * Whether the volume should be destroyed on instance termination.
     * See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/preserving-volumes-on-termination.html) for more information.
     */
    deleteOnTermination?: string;
    /**
     * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
     * Cannot be used with `snapshotId`.
     */
    encrypted?: string;
    /**
     * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
     * This must be set with a `volumeType` of `"io1/io2/gp3"`.
     */
    iops: number;
    /**
     * The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
     * `encrypted` must be set to `true` when this is set.
     */
    kmsKeyId?: string;
    /**
     * The Snapshot ID to mount.
     */
    snapshotId?: string;
    /**
     * The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
     */
    throughput: number;
    /**
     * The size of the volume in gigabytes.
     */
    volumeSize: number;
    /**
     * The volume type.
     * Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
     */
    volumeType: string;
}
export interface LaunchTemplateCapacityReservationSpecification {
    /**
     * Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
     */
    capacityReservationPreference?: string;
    /**
     * Used to target a specific Capacity Reservation:
     */
    capacityReservationTarget?: outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget;
}
export interface LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
    /**
     * The ID of the Capacity Reservation in which to run the instance.
     */
    capacityReservationId?: string;
    /**
     * The ARN of the Capacity Reservation resource group in which to run the instance.
     */
    capacityReservationResourceGroupArn?: string;
}
export interface LaunchTemplateCpuOptions {
    /**
     * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
     */
    amdSevSnp?: string;
    /**
     * The number of CPU cores for the instance.
     */
    coreCount?: number;
    /**
     * The number of threads per CPU core.
     * To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
     * Otherwise, specify the default value of 2.
     *
     * Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
     */
    threadsPerCore?: number;
}
export interface LaunchTemplateCreditSpecification {
    /**
     * The credit option for CPU usage.
     * Can be `standard` or `unlimited`.
     * T3 instances are launched as `unlimited` by default.
     * T2 instances are launched as `standard` by default.
     */
    cpuCredits?: string;
}
export interface LaunchTemplateElasticGpuSpecification {
    /**
     * The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
     */
    type: string;
}
export interface LaunchTemplateElasticInferenceAccelerator {
    /**
     * Accelerator type.
     */
    type: string;
}
export interface LaunchTemplateEnclaveOptions {
    /**
     * If set to `true`, Nitro Enclaves will be enabled on the instance.
     *
     * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
     */
    enabled?: boolean;
}
export interface LaunchTemplateHibernationOptions {
    /**
     * If set to `true`, the launched EC2 instance will hibernation enabled.
     */
    configured: boolean;
}
export interface LaunchTemplateIamInstanceProfile {
    /**
     * The Amazon Resource Name (ARN) of the instance profile. Conflicts with `name`.
     */
    arn?: string;
    /**
     * The name of the instance profile.
     */
    name?: string;
}
export interface LaunchTemplateInstanceMarketOptions {
    /**
     * The market type. Can be `spot`.
     */
    marketType?: string;
    /**
     * The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
     */
    spotOptions?: outputs.LaunchTemplateInstanceMarketOptionsSpotOptions;
}
export interface LaunchTemplateInstanceMarketOptionsSpotOptions {
    /**
     * The required duration in minutes. This value must be a multiple of 60.
     */
    blockDurationMinutes?: number;
    /**
     * The behavior when a Spot Instance is interrupted. Can be `hibernate`,
     * `stop`, or `terminate`. (Default: `terminate`).
     */
    instanceInterruptionBehavior?: string;
    /**
     * The maximum hourly price you're willing to pay for the Spot Instances.
     */
    maxPrice?: string;
    /**
     * The Spot Instance request type. Can be `one-time`, or `persistent`.
     */
    spotInstanceType?: string;
    /**
     * The end date of the request.
     */
    validUntil: string;
}
export interface LaunchTemplateInstanceRequirements {
    /**
     * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
     */
    acceleratorCount?: outputs.LaunchTemplateInstanceRequirementsAcceleratorCount;
    /**
     * List of accelerator manufacturer names. Default is any manufacturer.
     *
     * ```
     * Valid names:
     * * amazon-web-services
     * * amd
     * * nvidia
     * * xilinx
     * ```
     */
    acceleratorManufacturers?: string[];
    /**
     * List of accelerator names. Default is any acclerator.
     *
     * ```
     * Valid names:
     * * a100            - NVIDIA A100 GPUs
     * * v100            - NVIDIA V100 GPUs
     * * k80             - NVIDIA K80 GPUs
     * * t4              - NVIDIA T4 GPUs
     * * m60             - NVIDIA M60 GPUs
     * * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
     * * vu9p            - Xilinx VU9P FPGAs
     * ```
     */
    acceleratorNames?: string[];
    /**
     * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
     */
    acceleratorTotalMemoryMib?: outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib;
    /**
     * List of accelerator types. Default is any accelerator type.
     *
     * ```
     * Valid types:
     * * fpga
     * * gpu
     * * inference
     * ```
     */
    acceleratorTypes?: string[];
    /**
     * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
     *
     * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
     */
    allowedInstanceTypes?: string[];
    /**
     * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
     */
    bareMetal?: string;
    /**
     * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
     */
    baselineEbsBandwidthMbps?: outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps;
    /**
     * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
     */
    burstablePerformance?: string;
    /**
     * List of CPU manufacturer names. Default is any manufacturer.
     *
     * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * ```
     * Valid names:
     * * amazon-web-services
     * * amd
     * * intel
     * ```
     */
    cpuManufacturers?: string[];
    /**
     * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
     *
     * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
     */
    excludedInstanceTypes?: string[];
    /**
     * List of instance generation names. Default is any generation.
     *
     * ```
     * Valid names:
     * * current  - Recommended for best performance.
     * * previous - For existing applications optimized for older instance types.
     * ```
     */
    instanceGenerations?: string[];
    /**
     * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
     */
    localStorage?: string;
    /**
     * List of local storage type names. Default any storage type.
     *
     * ```
     * Value names:
     * * hdd - hard disk drive
     * * ssd - solid state drive
     * ```
     */
    localStorageTypes?: string[];
    /**
     * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
     */
    memoryGibPerVcpu?: outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu;
    /**
     * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
     */
    memoryMib: outputs.LaunchTemplateInstanceRequirementsMemoryMib;
    /**
     * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
     */
    networkBandwidthGbps?: outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps;
    /**
     * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
     */
    networkInterfaceCount?: outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount;
    /**
     * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
     *
     * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
     */
    onDemandMaxPricePercentageOverLowestPrice?: number;
    /**
     * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
     */
    requireHibernateSupport?: boolean;
    /**
     * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
     *
     * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
     */
    spotMaxPricePercentageOverLowestPrice?: number;
    /**
     * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
     */
    totalLocalStorageGb?: outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb;
    /**
     * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
     */
    vcpuCount: outputs.LaunchTemplateInstanceRequirementsVcpuCount;
}
export interface LaunchTemplateInstanceRequirementsAcceleratorCount {
    /**
     * Maximum. Set to `0` to exclude instance types with accelerators.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsMemoryGibPerVcpu {
    /**
     * Maximum. May be a decimal number, e.g. `0.5`.
     */
    max?: number;
    /**
     * Minimum. May be a decimal number, e.g. `0.5`.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsMemoryMib {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min: number;
}
export interface LaunchTemplateInstanceRequirementsNetworkBandwidthGbps {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsNetworkInterfaceCount {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsTotalLocalStorageGb {
    /**
     * Maximum. May be a decimal number, e.g. `0.5`.
     */
    max?: number;
    /**
     * Minimum. May be a decimal number, e.g. `0.5`.
     */
    min?: number;
}
export interface LaunchTemplateInstanceRequirementsVcpuCount {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min: number;
}
export interface LaunchTemplateLicenseSpecification {
    /**
     * ARN of the license configuration.
     */
    licenseConfigurationArn: string;
}
export interface LaunchTemplateMaintenanceOptions {
    /**
     * Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
     */
    autoRecovery?: string;
}
export interface LaunchTemplateMetadataOptions {
    /**
     * Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
     */
    httpEndpoint: string;
    /**
     * Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
     */
    httpProtocolIpv6: string;
    /**
     * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
     */
    httpPutResponseHopLimit: number;
    /**
     * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
     */
    httpTokens: string;
    /**
     * Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.
     *
     * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
     */
    instanceMetadataTags: string;
}
export interface LaunchTemplateMonitoring {
    /**
     * If `true`, the launched EC2 instance will have detailed monitoring enabled.
     */
    enabled?: boolean;
}
export interface LaunchTemplateNetworkInterface {
    /**
     * Associate a Carrier IP address with `eth0` for a new network interface.
     * Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface.
     * Boolean value, can be left unset.
     */
    associateCarrierIpAddress?: string;
    /**
     * Associate a public ip address with the network interface.
     * Boolean value, can be left unset.
     */
    associatePublicIpAddress?: string;
    /**
     * Whether the network interface should be destroyed on instance termination.
     */
    deleteOnTermination?: string;
    /**
     * Description of the network interface.
     */
    description?: string;
    /**
     * The integer index of the network interface attachment.
     */
    deviceIndex?: number;
    /**
     * The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
     */
    interfaceType?: string;
    /**
     * The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4Addresses`
     */
    ipv4AddressCount?: number;
    /**
     * One or more private IPv4 addresses to associate. Conflicts with `ipv4AddressCount`
     */
    ipv4Addresses?: string[];
    /**
     * The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4Prefixes`
     */
    ipv4PrefixCount?: number;
    /**
     * One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4PrefixCount`
     */
    ipv4Prefixes?: string[];
    /**
     * The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6Addresses`
     */
    ipv6AddressCount?: number;
    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6AddressCount`
     */
    ipv6Addresses?: string[];
    /**
     * The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6Prefixes`
     */
    ipv6PrefixCount?: number;
    /**
     * One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6PrefixCount`
     */
    ipv6Prefixes?: string[];
    /**
     * The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
     */
    networkCardIndex?: number;
    /**
     * The ID of the network interface to attach.
     */
    networkInterfaceId?: string;
    /**
     * The primary private IPv4 address.
     */
    privateIpAddress?: string;
    /**
     * A list of security group IDs to associate.
     */
    securityGroups?: string[];
    /**
     * The VPC Subnet ID to associate.
     */
    subnetId?: string;
}
export interface LaunchTemplatePlacement {
    /**
     * The affinity setting for an instance on a Dedicated Host.
     */
    affinity?: string;
    /**
     * The Availability Zone for the instance.
     */
    availabilityZone?: string;
    /**
     * The name of the placement group for the instance.
     */
    groupName?: string;
    /**
     * The ID of the Dedicated Host for the instance.
     */
    hostId?: string;
    /**
     * The ARN of the Host Resource Group in which to launch instances.
     */
    hostResourceGroupArn?: string;
    /**
     * The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
     */
    partitionNumber?: number;
    /**
     * Reserved for future use.
     */
    spreadDomain?: string;
    /**
     * The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
     */
    tenancy?: string;
}
export interface LaunchTemplatePrivateDnsNameOptions {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     */
    enableResourceNameDnsARecord?: boolean;
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     */
    enableResourceNameDnsAaaaRecord?: boolean;
    /**
     * The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
     */
    hostnameType?: string;
}
export interface LaunchTemplateTagSpecification {
    /**
     * The type of resource to tag.
     */
    resourceType?: string;
    /**
     * A map of tags to assign to the resource.
     */
    tags?: {[key: string]: string};
}
export interface ManagedPrefixListEntry {
    /**
     * CIDR block of this entry.
     */
    cidr: string;
    /**
     * Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
     */
    description?: string;
}
export interface NetworkAclEgress {
    /**
     * The action to take.
     */
    action: string;
    /**
     * The CIDR block to match. This must be a
     * valid network mask.
     */
    cidrBlock?: string;
    /**
     * The from port to match.
     */
    fromPort: number;
    /**
     * The ICMP type code to be used. Default 0.
     *
     * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
     */
    icmpCode?: number;
    /**
     * The ICMP type to be used. Default 0.
     */
    icmpType?: number;
    /**
     * The IPv6 CIDR block.
     */
    ipv6CidrBlock?: string;
    /**
     * The protocol to match. If using the -1 'all'
     * protocol, you must specify a from and to port of 0.
     */
    protocol: string;
    /**
     * The rule number. Used for ordering.
     */
    ruleNo: number;
    /**
     * The to port to match.
     */
    toPort: number;
}
export interface NetworkAclIngress {
    /**
     * The action to take.
     */
    action: string;
    /**
     * The CIDR block to match. This must be a
     * valid network mask.
     */
    cidrBlock?: string;
    /**
     * The from port to match.
     */
    fromPort: number;
    /**
     * The ICMP type code to be used. Default 0.
     *
     * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
     */
    icmpCode?: number;
    /**
     * The ICMP type to be used. Default 0.
     */
    icmpType?: number;
    /**
     * The IPv6 CIDR block.
     */
    ipv6CidrBlock?: string;
    /**
     * The protocol to match. If using the -1 'all'
     * protocol, you must specify a from and to port of 0.
     */
    protocol: string;
    /**
     * The rule number. Used for ordering.
     */
    ruleNo: number;
    /**
     * The to port to match.
     */
    toPort: number;
}
export interface NetworkInsightsAnalysisAlternatePathHint {
    /**
     * The Amazon Resource Name (ARN) of the component.
     */
    componentArn: string;
    /**
     * The ID of the component.
     */
    componentId: string;
}
export interface NetworkInsightsAnalysisExplanation {
    aclRules: outputs.NetworkInsightsAnalysisExplanationAclRule[];
    acls: outputs.NetworkInsightsAnalysisExplanationAcl[];
    address: string;
    addresses: string[];
    attachedTos: outputs.NetworkInsightsAnalysisExplanationAttachedTo[];
    availabilityZones: string[];
    cidrs: string[];
    classicLoadBalancerListeners: outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
    components: outputs.NetworkInsightsAnalysisExplanationComponent[];
    customerGateways: outputs.NetworkInsightsAnalysisExplanationCustomerGateway[];
    destinationVpcs: outputs.NetworkInsightsAnalysisExplanationDestinationVpc[];
    destinations: outputs.NetworkInsightsAnalysisExplanationDestination[];
    direction: string;
    elasticLoadBalancerListeners: outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
    explanationCode: string;
    ingressRouteTables: outputs.NetworkInsightsAnalysisExplanationIngressRouteTable[];
    internetGateways: outputs.NetworkInsightsAnalysisExplanationInternetGateway[];
    loadBalancerArn: string;
    loadBalancerListenerPort: number;
    loadBalancerTargetGroup: outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
    loadBalancerTargetGroups: outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
    loadBalancerTargetPort: number;
    missingComponent: string;
    natGateways: outputs.NetworkInsightsAnalysisExplanationNatGateway[];
    networkInterfaces: outputs.NetworkInsightsAnalysisExplanationNetworkInterface[];
    packetField: string;
    port: number;
    portRanges: outputs.NetworkInsightsAnalysisExplanationPortRange[];
    prefixLists: outputs.NetworkInsightsAnalysisExplanationPrefixList[];
    protocols: string[];
    routeTableRoutes: outputs.NetworkInsightsAnalysisExplanationRouteTableRoute[];
    routeTables: outputs.NetworkInsightsAnalysisExplanationRouteTable[];
    securityGroup: outputs.NetworkInsightsAnalysisExplanationSecurityGroup[];
    securityGroupRules: outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule[];
    securityGroups: outputs.NetworkInsightsAnalysisExplanationSecurityGroup[];
    sourceVpcs: outputs.NetworkInsightsAnalysisExplanationSourceVpc[];
    state: string;
    subnetRouteTables: outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable[];
    subnets: outputs.NetworkInsightsAnalysisExplanationSubnet[];
    transitGatewayAttachments: outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
    transitGatewayRouteTableRoutes: outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
    transitGatewayRouteTables: outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
    transitGateways: outputs.NetworkInsightsAnalysisExplanationTransitGateway[];
    vpcEndpoints: outputs.NetworkInsightsAnalysisExplanationVpcEndpoint[];
    vpcPeeringConnections: outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection[];
    vpcs: outputs.NetworkInsightsAnalysisExplanationVpc[];
    vpnConnections: outputs.NetworkInsightsAnalysisExplanationVpnConnection[];
    vpnGateways: outputs.NetworkInsightsAnalysisExplanationVpnGateway[];
}
export interface NetworkInsightsAnalysisExplanationAcl {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.NetworkInsightsAnalysisExplanationAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface NetworkInsightsAnalysisExplanationAclRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisExplanationAttachedTo {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
    instancePort: number;
    loadBalancerPort: number;
}
export interface NetworkInsightsAnalysisExplanationComponent {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationCustomerGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationDestination {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationDestinationVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationIngressRouteTable {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationInternetGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationNatGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationNetworkInterface {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationPortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisExplanationPrefixList {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationRouteTable {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface NetworkInsightsAnalysisExplanationSecurityGroup {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisExplanationSourceVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationSubnet {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationSubnetRouteTable {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationTransitGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationTransitGatewayAttachment {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface NetworkInsightsAnalysisExplanationVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationVpcEndpoint {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationVpcPeeringConnection {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationVpnConnection {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisExplanationVpnGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponent {
    aclRules: outputs.NetworkInsightsAnalysisForwardPathComponentAclRule[];
    additionalDetails: outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
    attachedTos: outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo[];
    components: outputs.NetworkInsightsAnalysisForwardPathComponentComponent[];
    destinationVpcs: outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
    inboundHeaders: outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader[];
    outboundHeaders: outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
    routeTableRoutes: outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
    securityGroupRules: outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
    sequenceNumber: number;
    sourceVpcs: outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc[];
    subnets: outputs.NetworkInsightsAnalysisForwardPathComponentSubnet[];
    transitGatewayRouteTableRoutes: outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
    transitGateways: outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway[];
    vpcs: outputs.NetworkInsightsAnalysisForwardPathComponentVpc[];
}
export interface NetworkInsightsAnalysisForwardPathComponentAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
    additionalDetailType: string;
    components: outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
}
export interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentAttachedTo {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentComponent {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentDestinationVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentInboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
}
export interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
}
export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisForwardPathComponentSourceVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentSubnet {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentTransitGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface NetworkInsightsAnalysisForwardPathComponentVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponent {
    aclRules: outputs.NetworkInsightsAnalysisReturnPathComponentAclRule[];
    additionalDetails: outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
    attachedTos: outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo[];
    components: outputs.NetworkInsightsAnalysisReturnPathComponentComponent[];
    destinationVpcs: outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
    inboundHeaders: outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader[];
    outboundHeaders: outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
    routeTableRoutes: outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
    securityGroupRules: outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
    sequenceNumber: number;
    sourceVpcs: outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc[];
    subnets: outputs.NetworkInsightsAnalysisReturnPathComponentSubnet[];
    transitGatewayRouteTableRoutes: outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
    transitGateways: outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway[];
    vpcs: outputs.NetworkInsightsAnalysisReturnPathComponentVpc[];
}
export interface NetworkInsightsAnalysisReturnPathComponentAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
    additionalDetailType: string;
    components: outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
}
export interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentAttachedTo {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentComponent {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentDestinationVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentInboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
}
export interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
}
export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface NetworkInsightsAnalysisReturnPathComponentSourceVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentSubnet {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentTransitGateway {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface NetworkInsightsAnalysisReturnPathComponentVpc {
    /**
     * ARN of the Network Insights Analysis.
     */
    arn: string;
    /**
     * ID of the Network Insights Analysis.
     */
    id: string;
    name: string;
}
export interface NetworkInterfaceAttachment {
    attachmentId: string;
    /**
     * Integer to define the devices index.
     */
    deviceIndex: number;
    /**
     * ID of the instance to attach to.
     */
    instance: string;
}
export interface PeeringConnectionOptionsAccepter {
    allowRemoteVpcDnsResolution?: boolean;
}
export interface PeeringConnectionOptionsRequester {
    allowRemoteVpcDnsResolution?: boolean;
}
export interface RouteTableRoute {
    /**
     * Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
     */
    carrierGatewayId?: string;
    /**
     * The CIDR block of the route.
     */
    cidrBlock?: string;
    /**
     * The Amazon Resource Name (ARN) of a core network.
     */
    coreNetworkArn?: string;
    /**
     * The ID of a managed prefix list destination of the route.
     *
     * One of the following target arguments must be supplied:
     */
    destinationPrefixListId?: string;
    /**
     * Identifier of a VPC Egress Only Internet Gateway.
     */
    egressOnlyGatewayId?: string;
    /**
     * Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
     */
    gatewayId?: string;
    /**
     * The Ipv6 CIDR block of the route.
     */
    ipv6CidrBlock?: string;
    /**
     * Identifier of a Outpost local gateway.
     */
    localGatewayId?: string;
    /**
     * Identifier of a VPC NAT gateway.
     */
    natGatewayId?: string;
    /**
     * Identifier of an EC2 network interface.
     */
    networkInterfaceId?: string;
    /**
     * Identifier of an EC2 Transit Gateway.
     */
    transitGatewayId?: string;
    /**
     * Identifier of a VPC Endpoint.
     */
    vpcEndpointId?: string;
    /**
     * Identifier of a VPC peering connection.
     *
     * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
     */
    vpcPeeringConnectionId?: string;
}
export interface SecurityGroupEgress {
    /**
     * List of CIDR blocks.
     */
    cidrBlocks?: string[];
    /**
     * Description of this egress rule.
     */
    description?: string;
    /**
     * Start port (or ICMP type number if protocol is `icmp`)
     */
    fromPort: number;
    /**
     * List of IPv6 CIDR blocks.
     */
    ipv6CidrBlocks?: string[];
    /**
     * List of Prefix List IDs.
     */
    prefixListIds?: string[];
    /**
     * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0. The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
     */
    protocol: string;
    /**
     * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
     */
    securityGroups?: string[];
    /**
     * Whether the security group itself will be added as a source to this egress rule.
     */
    self?: boolean;
    /**
     * End range port (or ICMP code if protocol is `icmp`).
     *
     * The following arguments are optional:
     *
     * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
     */
    toPort: number;
}
export interface SecurityGroupIngress {
    /**
     * List of CIDR blocks.
     */
    cidrBlocks?: string[];
    /**
     * Description of this ingress rule.
     */
    description?: string;
    /**
     * Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
     */
    fromPort: number;
    /**
     * List of IPv6 CIDR blocks.
     */
    ipv6CidrBlocks?: string[];
    /**
     * List of Prefix List IDs.
     */
    prefixListIds?: string[];
    /**
     * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0. The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
     *
     * The following arguments are optional:
     *
     * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
     */
    protocol: string;
    /**
     * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
     */
    securityGroups?: string[];
    /**
     * Whether the security group itself will be added as a source to this ingress rule.
     */
    self?: boolean;
    /**
     * End range port (or ICMP code if protocol is `icmp`).
     */
    toPort: number;
}
export interface SpotFleetRequestLaunchSpecification {
    ami: string;
    associatePublicIpAddress?: boolean;
    availabilityZone: string;
    ebsBlockDevices: outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice[];
    ebsOptimized?: boolean;
    ephemeralBlockDevices: outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice[];
    iamInstanceProfile?: string;
    iamInstanceProfileArn?: string;
    instanceType: string;
    keyName: string;
    monitoring?: boolean;
    placementGroup: string;
    placementTenancy?: string;
    rootBlockDevices: outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice[];
    /**
     * The maximum bid price per unit hour.
     */
    spotPrice?: string;
    subnetId: string;
    /**
     * A map of tags to assign to the resource. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     */
    tags?: {[key: string]: string};
    userData?: string;
    vpcSecurityGroupIds: string[];
    weightedCapacity?: string;
}
export interface SpotFleetRequestLaunchSpecificationEbsBlockDevice {
    deleteOnTermination?: boolean;
    deviceName: string;
    encrypted: boolean;
    iops: number;
    kmsKeyId: string;
    snapshotId: string;
    throughput: number;
    volumeSize: number;
    volumeType: string;
}
export interface SpotFleetRequestLaunchSpecificationEphemeralBlockDevice {
    deviceName: string;
    virtualName: string;
}
export interface SpotFleetRequestLaunchSpecificationRootBlockDevice {
    deleteOnTermination?: boolean;
    encrypted: boolean;
    iops: number;
    kmsKeyId: string;
    throughput: number;
    volumeSize: number;
    volumeType: string;
}
export interface SpotFleetRequestLaunchTemplateConfig {
    /**
     * Launch template specification. See Launch Template Specification below for more details.
     */
    launchTemplateSpecification: outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification;
    /**
     * One or more override configurations. See Overrides below for more details.
     */
    overrides?: outputs.SpotFleetRequestLaunchTemplateConfigOverride[];
}
export interface SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification {
    /**
     * The ID of the launch template. Conflicts with `name`.
     */
    id?: string;
    /**
     * The name of the launch template. Conflicts with `id`.
     */
    name?: string;
    /**
     * Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launchTemplate resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
     *
     * **Note:** The specified launch template can specify only a subset of the
     * inputs of `aws.ec2.LaunchTemplate`.  There are limitations on
     * what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instanceInitiatedShutdownBehavior` is confirmed unsupported.
     */
    version?: string;
}
export interface SpotFleetRequestLaunchTemplateConfigOverride {
    /**
     * The availability zone in which to place the request.
     */
    availabilityZone?: string;
    /**
     * The instance requirements. See below.
     */
    instanceRequirements?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements;
    /**
     * The type of instance to request.
     */
    instanceType?: string;
    /**
     * The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
     */
    priority: number;
    /**
     * The maximum spot bid for this override request.
     */
    spotPrice: string;
    /**
     * The subnet in which to launch the requested instance.
     */
    subnetId: string;
    /**
     * The capacity added to the fleet by a fulfilled request.
     */
    weightedCapacity: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements {
    /**
     * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
     */
    acceleratorCount?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
    /**
     * List of accelerator manufacturer names. Default is any manufacturer.
     *
     * ```
     * Valid names:
     * * amazon-web-services
     * * amd
     * * nvidia
     * * xilinx
     * ```
     */
    acceleratorManufacturers?: string[];
    /**
     * List of accelerator names. Default is any acclerator.
     *
     * ```
     * Valid names:
     * * a100            - NVIDIA A100 GPUs
     * * v100            - NVIDIA V100 GPUs
     * * k80             - NVIDIA K80 GPUs
     * * t4              - NVIDIA T4 GPUs
     * * m60             - NVIDIA M60 GPUs
     * * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
     * * vu9p            - Xilinx VU9P FPGAs
     * ```
     */
    acceleratorNames?: string[];
    /**
     * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
     */
    acceleratorTotalMemoryMib?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
    /**
     * List of accelerator types. Default is any accelerator type.
     *
     * ```
     * Valid types:
     * * fpga
     * * gpu
     * * inference
     * ```
     */
    acceleratorTypes?: string[];
    /**
     * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
     *
     * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
     */
    allowedInstanceTypes?: string[];
    /**
     * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
     */
    bareMetal?: string;
    /**
     * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
     */
    baselineEbsBandwidthMbps?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
    /**
     * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
     */
    burstablePerformance?: string;
    /**
     * List of CPU manufacturer names. Default is any manufacturer.
     *
     * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * ```
     * Valid names:
     * * amazon-web-services
     * * amd
     * * intel
     * ```
     */
    cpuManufacturers?: string[];
    /**
     * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
     *
     * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
     */
    excludedInstanceTypes?: string[];
    /**
     * List of instance generation names. Default is any generation.
     *
     * ```
     * Valid names:
     * * current  - Recommended for best performance.
     * * previous - For existing applications optimized for older instance types.
     * ```
     */
    instanceGenerations?: string[];
    /**
     * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
     */
    localStorage?: string;
    /**
     * List of local storage type names. Default any storage type.
     *
     * ```
     * Value names:
     * * hdd - hard disk drive
     * * ssd - solid state drive
     * ```
     */
    localStorageTypes?: string[];
    /**
     * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
     */
    memoryGibPerVcpu?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
    /**
     * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
     */
    memoryMib?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
    /**
     * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
     */
    networkBandwidthGbps?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
    /**
     * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
     */
    networkInterfaceCount?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
    /**
     * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
     *
     * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
     */
    onDemandMaxPricePercentageOverLowestPrice?: number;
    /**
     * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
     */
    requireHibernateSupport?: boolean;
    /**
     * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
     *
     * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
     */
    spotMaxPricePercentageOverLowestPrice?: number;
    /**
     * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
     */
    totalLocalStorageGb?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
    /**
     * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
     */
    vcpuCount?: outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
    /**
     * Maximum. Set to `0` to exclude instance types with accelerators.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
    /**
     * Maximum. May be a decimal number, e.g. `0.5`.
     */
    max?: number;
    /**
     * Minimum. May be a decimal number, e.g. `0.5`.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
    /**
     * Maximum. May be a decimal number, e.g. `0.5`.
     */
    max?: number;
    /**
     * Minimum. May be a decimal number, e.g. `0.5`.
     */
    min?: number;
}
export interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
    /**
     * Maximum.
     */
    max?: number;
    /**
     * Minimum.
     */
    min?: number;
}
export interface SpotFleetRequestSpotMaintenanceStrategies {
    /**
     * Nested argument containing the capacity rebalance for your fleet request. Defined below.
     */
    capacityRebalance?: outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance;
}
export interface SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance {
    /**
     * The replacement strategy to use. Only available for spot fleets with `fleetType` set to `maintain`. Valid values: `launch`.
     */
    replacementStrategy?: string;
}
export interface SpotInstanceRequestCapacityReservationSpecification {
    /**
     * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
     */
    capacityReservationPreference?: string;
    /**
     * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
     *
     * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
     */
    capacityReservationTarget?: outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget;
}
export interface SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget {
    /**
     * ID of the Capacity Reservation in which to run the instance.
     */
    capacityReservationId?: string;
    /**
     * ARN of the Capacity Reservation resource group in which to run the instance.
     */
    capacityReservationResourceGroupArn?: string;
}
export interface SpotInstanceRequestCpuOptions {
    /**
     * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
     */
    amdSevSnp: string;
    /**
     * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
     */
    coreCount: number;
    /**
     * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
     *
     * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
     */
    threadsPerCore: number;
}
export interface SpotInstanceRequestCreditSpecification {
    /**
     * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
     */
    cpuCredits?: string;
}
export interface SpotInstanceRequestEbsBlockDevice {
    /**
     * Whether the volume should be destroyed on instance termination. Defaults to `true`.
     */
    deleteOnTermination?: boolean;
    /**
     * Name of the device to mount.
     */
    deviceName: string;
    /**
     * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
     */
    encrypted: boolean;
    /**
     * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
     */
    iops: number;
    /**
     * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
     */
    kmsKeyId: string;
    /**
     * Snapshot ID to mount.
     */
    snapshotId: string;
    /**
     * Map of tags to assign to the device.
     */
    tags?: {[key: string]: string};
    /**
     * A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     */
    tagsAll: {[key: string]: string};
    /**
     * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    volumeId: string;
    /**
     * Size of the volume in gibibytes (GiB).
     */
    volumeSize: number;
    /**
     * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
     *
     * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
     */
    volumeType: string;
}
export interface SpotInstanceRequestEnclaveOptions {
    /**
     * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
     *
     * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
     */
    enabled: boolean;
}
export interface SpotInstanceRequestEphemeralBlockDevice {
    /**
     * Name of the block device to mount on the instance.
     */
    deviceName: string;
    /**
     * Suppresses the specified device included in the AMI's block device mapping.
     */
    noDevice?: boolean;
    /**
     * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
     *
     * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
     */
    virtualName?: string;
}
export interface SpotInstanceRequestLaunchTemplate {
    /**
     * ID of the launch template. Conflicts with `name`.
     */
    id: string;
    /**
     * Name of the launch template. Conflicts with `id`.
     */
    name: string;
    /**
     * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
     */
    version?: string;
}
export interface SpotInstanceRequestMaintenanceOptions {
    /**
     * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
     */
    autoRecovery: string;
}
export interface SpotInstanceRequestMetadataOptions {
    /**
     * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
     */
    httpEndpoint?: string;
    /**
     * Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
     */
    httpProtocolIpv6?: string;
    /**
     * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
     */
    httpPutResponseHopLimit: number;
    /**
     * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
     */
    httpTokens: string;
    /**
     * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
     *
     * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
     */
    instanceMetadataTags: string;
}
export interface SpotInstanceRequestNetworkInterface {
    /**
     * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
     */
    deleteOnTermination?: boolean;
    /**
     * Integer index of the network interface attachment. Limited by instance type.
     */
    deviceIndex: number;
    /**
     * Integer index of the network card. Limited by instance type. The default index is `0`.
     */
    networkCardIndex?: number;
    /**
     * ID of the network interface to attach.
     */
    networkInterfaceId: string;
}
export interface SpotInstanceRequestPrivateDnsNameOptions {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     */
    enableResourceNameDnsARecord: boolean;
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     */
    enableResourceNameDnsAaaaRecord: boolean;
    /**
     * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
     */
    hostnameType: string;
}
export interface SpotInstanceRequestRootBlockDevice {
    /**
     * Whether the volume should be destroyed on instance termination. Defaults to `true`.
     */
    deleteOnTermination?: boolean;
    deviceName: string;
    /**
     * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
     */
    encrypted: boolean;
    /**
     * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
     */
    iops: number;
    /**
     * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
     */
    kmsKeyId: string;
    /**
     * Map of tags to assign to the device.
     */
    tags?: {[key: string]: string};
    /**
     * A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     */
    tagsAll: {[key: string]: string};
    /**
     * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
     */
    throughput: number;
    volumeId: string;
    /**
     * Size of the volume in gibibytes (GiB).
     */
    volumeSize: number;
    /**
     * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
     *
     * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
     */
    volumeType: string;
}
export interface TrafficMirrorFilterRuleDestinationPortRange {
    /**
     * Starting port of the range
     */
    fromPort?: number;
    /**
     * Ending port of the range
     */
    toPort?: number;
}
export interface TrafficMirrorFilterRuleSourcePortRange {
    /**
     * Starting port of the range
     */
    fromPort?: number;
    /**
     * Ending port of the range
     */
    toPort?: number;
}
export interface VpcEndpointDnsEntry {
    /**
     * The DNS name.
     */
    dnsName: string;
    /**
     * The ID of the private hosted zone.
     */
    hostedZoneId: string;
}
export interface VpcEndpointDnsOptions {
    /**
     * The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
     */
    dnsRecordIpType: string;
    /**
     * Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if privateDnsEnabled is `true`.
     */
    privateDnsOnlyForInboundResolverEndpoint?: boolean;
}
export interface VpcEndpointServicePrivateDnsNameConfiguration {
    /**
     * Name of the record subdomain the service provider needs to create.
     */
    name: string;
    /**
     * Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
     */
    state: string;
    /**
     * Endpoint service verification type, for example `TXT`.
     */
    type: string;
    /**
     * Value the service provider adds to the private DNS name domain record before verification.
     */
    value: string;
}
export interface VpcIpamOperatingRegion {
    /**
     * The name of the Region you want to add to the IPAM.
     */
    regionName: string;
}
export interface VpcIpamPoolCidrCidrAuthorizationContext {
    /**
     * The plain-text authorization message for the prefix and account.
     */
    message?: string;
    /**
     * The signed authorization message for the prefix and account.
     */
    signature?: string;
}
export interface VpcIpamResourceDiscoveryOperatingRegion {
    /**
     * The name of the Region you want to add to the IPAM.
     */
    regionName: string;
}
export interface VpcPeeringConnectionAccepter {
    allowRemoteVpcDnsResolution?: boolean;
}
export interface VpcPeeringConnectionAccepterAccepter {
    /**
     * Indicates whether a local VPC can resolve public DNS hostnames to
     * private IP addresses when queried from instances in a peer VPC.
     */
    allowRemoteVpcDnsResolution?: boolean;
}
export interface VpcPeeringConnectionAccepterRequester {
    /**
     * Indicates whether a local VPC can resolve public DNS hostnames to
     * private IP addresses when queried from instances in a peer VPC.
     */
    allowRemoteVpcDnsResolution?: boolean;
}
export interface VpcPeeringConnectionRequester {
    allowRemoteVpcDnsResolution?: boolean;
}
export interface VpnConnectionRoute {
    /**
     * The CIDR block associated with the local subnet of the customer data center.
     */
    destinationCidrBlock: string;
    /**
     * Indicates how the routes were provided.
     */
    source: string;
    /**
     * The current state of the static route.
     */
    state: string;
}
export interface VpnConnectionTunnel1LogOptions {
    /**
     * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
     */
    cloudwatchLogOptions: outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions;
}
export interface VpnConnectionTunnel1LogOptionsCloudwatchLogOptions {
    /**
     * Enable or disable VPN tunnel logging feature. The default is `false`.
     */
    logEnabled?: boolean;
    /**
     * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
     */
    logGroupArn?: string;
    /**
     * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
     */
    logOutputFormat?: string;
}
export interface VpnConnectionTunnel2LogOptions {
    /**
     * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
     */
    cloudwatchLogOptions: outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions;
}
export interface VpnConnectionTunnel2LogOptionsCloudwatchLogOptions {
    /**
     * Enable or disable VPN tunnel logging feature. The default is `false`.
     */
    logEnabled?: boolean;
    /**
     * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
     */
    logGroupArn?: string;
    /**
     * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
     */
    logOutputFormat?: string;
}
export interface VpnConnectionVgwTelemetry {
    /**
     * The number of accepted routes.
     */
    acceptedRouteCount: number;
    /**
     * The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
     */
    certificateArn: string;
    /**
     * The date and time of the last change in status.
     */
    lastStatusChange: string;
    /**
     * The Internet-routable IP address of the virtual private gateway's outside interface.
     */
    outsideIpAddress: string;
    /**
     * The status of the VPN tunnel.
     */
    status: string;
    /**
     * If an error occurs, a description of the error.
     */
    statusMessage: string;
}
export interface GetAmiBlockDeviceMapping {
    /**
     * Physical name of the device.
     */
    deviceName: string;
    /**
     * Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volumeSize"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
     */
    ebs: {[key: string]: string};
    /**
     * Suppresses the specified device included in the block device mapping of the AMI.
     */
    noDevice: string;
    /**
     * Virtual device name (for instance stores).
     */
    virtualName: string;
}
export interface GetAmiProductCode {
    productCodeId: string;
    productCodeType: string;
}
export interface GetInstanceCreditSpecification {
    cpuCredits: string;
}
export interface GetInstanceEbsBlockDevice {
    /**
     * If the root block device will be deleted on termination.
     */
    deleteOnTermination: boolean;
    /**
     * Physical name of the device.
     */
    deviceName: string;
    /**
     * If the EBS volume is encrypted.
     */
    encrypted: boolean;
    /**
     * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
     */
    iops: number;
    kmsKeyId: string;
    /**
     * ID of the snapshot.
     */
    snapshotId: string;
    /**
     * Map of tags assigned to the Instance.
     */
    tags: {[key: string]: string};
    /**
     * Throughput of the volume, in MiB/s.
     */
    throughput: number;
    volumeId: string;
    /**
     * Size of the volume, in GiB.
     */
    volumeSize: number;
    /**
     * Type of the volume.
     */
    volumeType: string;
}
export interface GetInstanceEnclaveOption {
    /**
     * Whether Nitro Enclaves are enabled.
     */
    enabled: boolean;
}
export interface GetInstanceEphemeralBlockDevice {
    /**
     * Physical name of the device.
     */
    deviceName: string;
    /**
     * Whether the specified device included in the device mapping was suppressed or not (Boolean).
     */
    noDevice?: boolean;
    /**
     * Virtual device name.
     */
    virtualName?: string;
}
export interface GetInstanceMaintenanceOption {
    /**
     * Automatic recovery behavior of the instance.
     */
    autoRecovery: string;
}
export interface GetInstanceMetadataOption {
    /**
     * State of the metadata service: `enabled`, `disabled`.
     */
    httpEndpoint: string;
    /**
     * Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
     */
    httpProtocolIpv6: string;
    /**
     * Desired HTTP PUT response hop limit for instance metadata requests.
     */
    httpPutResponseHopLimit: number;
    /**
     * If session tokens are required: `optional`, `required`.
     */
    httpTokens: string;
    /**
     * If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
     */
    instanceMetadataTags: string;
}
export interface GetInstancePrivateDnsNameOption {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     */
    enableResourceNameDnsARecord: boolean;
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     */
    enableResourceNameDnsAaaaRecord: boolean;
    /**
     * Type of hostname for EC2 instances.
     */
    hostnameType: string;
}
export interface GetInstanceRootBlockDevice {
    /**
     * If the root block device will be deleted on termination.
     */
    deleteOnTermination: boolean;
    /**
     * Physical name of the device.
     */
    deviceName: string;
    /**
     * If the EBS volume is encrypted.
     */
    encrypted: boolean;
    /**
     * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
     */
    iops: number;
    kmsKeyId: string;
    /**
     * Map of tags assigned to the Instance.
     */
    tags: {[key: string]: string};
    /**
     * Throughput of the volume, in MiB/s.
     */
    throughput: number;
    volumeId: string;
    /**
     * Size of the volume, in GiB.
     */
    volumeSize: number;
    /**
     * Type of the volume.
     */
    volumeType: string;
}
export interface GetInstanceTypeFpga {
    count: number;
    manufacturer: string;
    /**
     * Size of the instance memory, in MiB.
     */
    memorySize: number;
    name: string;
}
export interface GetInstanceTypeGpus {
    count: number;
    manufacturer: string;
    /**
     * Size of the instance memory, in MiB.
     */
    memorySize: number;
    name: string;
}
export interface GetInstanceTypeInferenceAccelerator {
    count: number;
    manufacturer: string;
    name: string;
}
export interface GetInstanceTypeInstanceDisk {
    count: number;
    size: number;
    type: string;
}
export interface GetInternetGatewayAttachment {
    /**
     * Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
     */
    state: string;
    /**
     * ID of an attached VPC.
     */
    vpcId: string;
}
export interface GetLaunchConfigurationEbsBlockDevice {
    /**
     * Whether the EBS Volume will be deleted on instance termination.
     */
    deleteOnTermination: boolean;
    /**
     * Name of the device.
     */
    deviceName: string;
    /**
     * Whether the volume is Encrypted.
     */
    encrypted: boolean;
    /**
     * Provisioned IOPs of the volume.
     */
    iops: number;
    /**
     * Whether the device in the block device mapping of the AMI is suppressed.
     */
    noDevice: boolean;
    /**
     * Snapshot ID of the mount.
     */
    snapshotId: string;
    /**
     * Throughput of the volume.
     */
    throughput: number;
    /**
     * Size of the volume.
     */
    volumeSize: number;
    /**
     * Type of the volume.
     */
    volumeType: string;
}
export interface GetLaunchConfigurationEphemeralBlockDevice {
    /**
     * Name of the device.
     */
    deviceName: string;
    /**
     * Virtual Name of the device.
     */
    virtualName: string;
}
export interface GetLaunchConfigurationMetadataOption {
    /**
     * State of the metadata service: `enabled`, `disabled`.
     */
    httpEndpoint: string;
    /**
     * The desired HTTP PUT response hop limit for instance metadata requests.
     */
    httpPutResponseHopLimit: number;
    /**
     * If session tokens are required: `optional`, `required`.
     */
    httpTokens: string;
}
export interface GetLaunchConfigurationRootBlockDevice {
    /**
     * Whether the EBS Volume will be deleted on instance termination.
     */
    deleteOnTermination: boolean;
    /**
     * Whether the volume is Encrypted.
     */
    encrypted: boolean;
    /**
     * Provisioned IOPs of the volume.
     */
    iops: number;
    /**
     * Throughput of the volume.
     */
    throughput: number;
    /**
     * Size of the volume.
     */
    volumeSize: number;
    /**
     * Type of the volume.
     */
    volumeType: string;
}
export interface GetLaunchTemplateBlockDeviceMapping {
    deviceName: string;
    ebs: outputs.GetLaunchTemplateBlockDeviceMappingEb[];
    noDevice: string;
    virtualName: string;
}
export interface GetLaunchTemplateBlockDeviceMappingEb {
    deleteOnTermination: string;
    encrypted: string;
    iops: number;
    kmsKeyId: string;
    snapshotId: string;
    throughput: number;
    volumeSize: number;
    volumeType: string;
}
export interface GetLaunchTemplateCapacityReservationSpecification {
    capacityReservationPreference: string;
    capacityReservationTargets: outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget[];
}
export interface GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
    capacityReservationId: string;
    capacityReservationResourceGroupArn: string;
}
export interface GetLaunchTemplateCpuOption {
    amdSevSnp: string;
    coreCount: number;
    threadsPerCore: number;
}
export interface GetLaunchTemplateCreditSpecification {
    cpuCredits: string;
}
export interface GetLaunchTemplateElasticGpuSpecification {
    type: string;
}
export interface GetLaunchTemplateElasticInferenceAccelerator {
    type: string;
}
export interface GetLaunchTemplateEnclaveOption {
    enabled: boolean;
}
export interface GetLaunchTemplateHibernationOption {
    configured: boolean;
}
export interface GetLaunchTemplateIamInstanceProfile {
    arn: string;
    /**
     * Name of the launch template.
     */
    name: string;
}
export interface GetLaunchTemplateInstanceMarketOption {
    marketType: string;
    spotOptions: outputs.GetLaunchTemplateInstanceMarketOptionSpotOption[];
}
export interface GetLaunchTemplateInstanceMarketOptionSpotOption {
    blockDurationMinutes: number;
    instanceInterruptionBehavior: string;
    maxPrice: string;
    spotInstanceType: string;
    validUntil: string;
}
export interface GetLaunchTemplateInstanceRequirement {
    acceleratorCounts: outputs.GetLaunchTemplateInstanceRequirementAcceleratorCount[];
    acceleratorManufacturers: string[];
    acceleratorNames: string[];
    acceleratorTotalMemoryMibs: outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib[];
    acceleratorTypes: string[];
    allowedInstanceTypes: string[];
    bareMetal: string;
    baselineEbsBandwidthMbps: outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp[];
    burstablePerformance: string;
    cpuManufacturers: string[];
    excludedInstanceTypes: string[];
    instanceGenerations: string[];
    localStorage: string;
    localStorageTypes: string[];
    memoryGibPerVcpus: outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus[];
    memoryMibs: outputs.GetLaunchTemplateInstanceRequirementMemoryMib[];
    networkBandwidthGbps: outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp[];
    networkInterfaceCounts: outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCount[];
    onDemandMaxPricePercentageOverLowestPrice: number;
    requireHibernateSupport: boolean;
    spotMaxPricePercentageOverLowestPrice: number;
    totalLocalStorageGbs: outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGb[];
    vcpuCounts: outputs.GetLaunchTemplateInstanceRequirementVcpuCount[];
}
export interface GetLaunchTemplateInstanceRequirementAcceleratorCount {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementMemoryMib {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementNetworkInterfaceCount {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementTotalLocalStorageGb {
    max: number;
    min: number;
}
export interface GetLaunchTemplateInstanceRequirementVcpuCount {
    max: number;
    min: number;
}
export interface GetLaunchTemplateLicenseSpecification {
    licenseConfigurationArn: string;
}
export interface GetLaunchTemplateMaintenanceOption {
    autoRecovery: string;
}
export interface GetLaunchTemplateMetadataOption {
    httpEndpoint: string;
    httpProtocolIpv6: string;
    httpPutResponseHopLimit: number;
    httpTokens: string;
    instanceMetadataTags: string;
}
export interface GetLaunchTemplateMonitoring {
    enabled: boolean;
}
export interface GetLaunchTemplateNetworkInterface {
    associateCarrierIpAddress: string;
    associatePublicIpAddress?: boolean;
    deleteOnTermination?: boolean;
    description: string;
    deviceIndex: number;
    interfaceType: string;
    ipv4AddressCount: number;
    ipv4Addresses: string[];
    ipv4PrefixCount: number;
    ipv4Prefixes: string[];
    ipv6AddressCount: number;
    ipv6Addresses: string[];
    ipv6PrefixCount: number;
    ipv6Prefixes: string[];
    networkCardIndex: number;
    networkInterfaceId: string;
    privateIpAddress: string;
    securityGroups: string[];
    subnetId: string;
}
export interface GetLaunchTemplatePlacement {
    affinity: string;
    availabilityZone: string;
    groupName: string;
    hostId: string;
    hostResourceGroupArn: string;
    partitionNumber: number;
    spreadDomain: string;
    tenancy: string;
}
export interface GetLaunchTemplatePrivateDnsNameOption {
    enableResourceNameDnsARecord: boolean;
    enableResourceNameDnsAaaaRecord: boolean;
    hostnameType: string;
}
export interface GetLaunchTemplateTagSpecification {
    resourceType: string;
    /**
     * Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
     */
    tags: {[key: string]: string};
}
export interface GetManagedPrefixListEntry {
    cidr: string;
    description: string;
}
export interface GetNetworkInsightsAnalysisAlternatePathHint {
    componentArn: string;
    componentId: string;
}
export interface GetNetworkInsightsAnalysisExplanation {
    aclRules: outputs.GetNetworkInsightsAnalysisExplanationAclRule[];
    acls: outputs.GetNetworkInsightsAnalysisExplanationAcl[];
    address: string;
    addresses: string[];
    attachedTos: outputs.GetNetworkInsightsAnalysisExplanationAttachedTo[];
    availabilityZones: string[];
    cidrs: string[];
    classicLoadBalancerListeners: outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
    components: outputs.GetNetworkInsightsAnalysisExplanationComponent[];
    customerGateways: outputs.GetNetworkInsightsAnalysisExplanationCustomerGateway[];
    destinationVpcs: outputs.GetNetworkInsightsAnalysisExplanationDestinationVpc[];
    destinations: outputs.GetNetworkInsightsAnalysisExplanationDestination[];
    direction: string;
    elasticLoadBalancerListeners: outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
    explanationCode: string;
    ingressRouteTables: outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTable[];
    internetGateways: outputs.GetNetworkInsightsAnalysisExplanationInternetGateway[];
    loadBalancerArn: string;
    loadBalancerListenerPort: number;
    loadBalancerTargetGroup: outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
    loadBalancerTargetGroups: outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
    loadBalancerTargetPort: number;
    missingComponent: string;
    natGateways: outputs.GetNetworkInsightsAnalysisExplanationNatGateway[];
    networkInterfaces: outputs.GetNetworkInsightsAnalysisExplanationNetworkInterface[];
    packetField: string;
    port: number;
    portRanges: outputs.GetNetworkInsightsAnalysisExplanationPortRange[];
    prefixLists: outputs.GetNetworkInsightsAnalysisExplanationPrefixList[];
    protocols: string[];
    routeTableRoutes: outputs.GetNetworkInsightsAnalysisExplanationRouteTableRoute[];
    routeTables: outputs.GetNetworkInsightsAnalysisExplanationRouteTable[];
    securityGroup: outputs.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
    securityGroupRules: outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRule[];
    securityGroups: outputs.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
    sourceVpcs: outputs.GetNetworkInsightsAnalysisExplanationSourceVpc[];
    state: string;
    subnetRouteTables: outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTable[];
    subnets: outputs.GetNetworkInsightsAnalysisExplanationSubnet[];
    transitGatewayAttachments: outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
    transitGatewayRouteTableRoutes: outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
    transitGatewayRouteTables: outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
    transitGateways: outputs.GetNetworkInsightsAnalysisExplanationTransitGateway[];
    vpcEndpoints: outputs.GetNetworkInsightsAnalysisExplanationVpcEndpoint[];
    vpcPeeringConnections: outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnection[];
    vpcs: outputs.GetNetworkInsightsAnalysisExplanationVpc[];
    vpnConnections: outputs.GetNetworkInsightsAnalysisExplanationVpnConnection[];
    vpnGateways: outputs.GetNetworkInsightsAnalysisExplanationVpnGateway[];
}
export interface GetNetworkInsightsAnalysisExplanationAcl {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface GetNetworkInsightsAnalysisExplanationAclRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisExplanationAttachedTo {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
    instancePort: number;
    loadBalancerPort: number;
}
export interface GetNetworkInsightsAnalysisExplanationComponent {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationCustomerGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationDestination {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationDestinationVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationIngressRouteTable {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationInternetGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationNatGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationNetworkInterface {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationPortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisExplanationPrefixList {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationRouteTable {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface GetNetworkInsightsAnalysisExplanationSecurityGroup {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisExplanationSourceVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationSubnet {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationSubnetRouteTable {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationTransitGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface GetNetworkInsightsAnalysisExplanationVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationVpcEndpoint {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationVpcPeeringConnection {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationVpnConnection {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisExplanationVpnGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponent {
    aclRules: outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRule[];
    additionalDetails: outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
    attachedTos: outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedTo[];
    components: outputs.GetNetworkInsightsAnalysisForwardPathComponentComponent[];
    destinationVpcs: outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
    inboundHeaders: outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeader[];
    outboundHeaders: outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
    routeTableRoutes: outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
    securityGroupRules: outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
    sequenceNumber: number;
    sourceVpcs: outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpc[];
    subnets: outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnet[];
    transitGatewayRouteTableRoutes: outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
    transitGateways: outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGateway[];
    vpcs: outputs.GetNetworkInsightsAnalysisForwardPathComponentVpc[];
}
export interface GetNetworkInsightsAnalysisForwardPathComponentAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
    additionalDetailType: string;
    components: outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
}
export interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentAttachedTo {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentComponent {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
}
export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
}
export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentSourceVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentSubnet {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentTransitGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface GetNetworkInsightsAnalysisForwardPathComponentVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponent {
    aclRules: outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRule[];
    additionalDetails: outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
    attachedTos: outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedTo[];
    components: outputs.GetNetworkInsightsAnalysisReturnPathComponentComponent[];
    destinationVpcs: outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
    inboundHeaders: outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeader[];
    outboundHeaders: outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
    routeTableRoutes: outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
    securityGroupRules: outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
    sequenceNumber: number;
    sourceVpcs: outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpc[];
    subnets: outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnet[];
    transitGatewayRouteTableRoutes: outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
    transitGateways: outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGateway[];
    vpcs: outputs.GetNetworkInsightsAnalysisReturnPathComponentVpc[];
}
export interface GetNetworkInsightsAnalysisReturnPathComponentAclRule {
    cidr: string;
    egress: boolean;
    portRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
    protocol: string;
    ruleAction: string;
    ruleNumber: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
    additionalDetailType: string;
    components: outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
}
export interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentAttachedTo {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentComponent {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
}
export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader {
    destinationAddresses: string[];
    destinationPortRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
    protocol: string;
    sourceAddresses: string[];
    sourcePortRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
}
export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
    destinationCidr: string;
    destinationPrefixListId: string;
    egressOnlyInternetGatewayId: string;
    gatewayId: string;
    instanceId: string;
    natGatewayId: string;
    networkInterfaceId: string;
    origin: string;
    transitGatewayId: string;
    vpcPeeringConnectionId: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
    cidr: string;
    direction: string;
    portRanges: outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
    prefixListId: string;
    protocol: string;
    securityGroupId: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
    from: number;
    to: number;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentSourceVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentSubnet {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentTransitGateway {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
    attachmentId: string;
    destinationCidr: string;
    prefixListId: string;
    resourceId: string;
    resourceType: string;
    routeOrigin: string;
    state: string;
}
export interface GetNetworkInsightsAnalysisReturnPathComponentVpc {
    /**
     * ARN of the selected Network Insights Analysis.
     */
    arn: string;
    id: string;
    name: string;
}
export interface GetNetworkInterfaceAssociation {
    /**
     * Allocation ID.
     */
    allocationId: string;
    /**
     * Association ID.
     */
    associationId: string;
    /**
     * Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
     */
    carrierIp: string;
    /**
     * Customer-owned IP address.
     */
    customerOwnedIp: string;
    /**
     * ID of the Elastic IP address owner.
     */
    ipOwnerId: string;
    /**
     * Public DNS name.
     */
    publicDnsName: string;
    /**
     * Address of the Elastic IP address bound to the network interface.
     */
    publicIp: string;
}
export interface GetNetworkInterfaceAttachment {
    attachmentId: string;
    deviceIndex: number;
    instanceId: string;
    instanceOwnerId: string;
}
export interface GetPublicIpv4PoolPoolAddressRange {
    /**
     * Number of addresses in the range.
     */
    addressCount: number;
    /**
     * Number of available addresses in the range.
     */
    availableAddressCount: number;
    /**
     * First address in the range.
     */
    firstAddress: string;
    /**
     * Last address in the range.
     */
    lastAddress: string;
}
export interface GetRouteTableAssociation {
    /**
     * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
     */
    gatewayId: string;
    /**
     * Whether the association is due to the main route table.
     */
    main: boolean;
    /**
     * Association ID.
     */
    routeTableAssociationId: string;
    /**
     * ID of the specific Route Table to retrieve.
     */
    routeTableId: string;
    /**
     * ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
     */
    subnetId: string;
}
export interface GetRouteTableRoute {
    /**
     * ID of the Carrier Gateway.
     */
    carrierGatewayId: string;
    /**
     * CIDR block of the route.
     */
    cidrBlock: string;
    /**
     * ARN of the core network.
     */
    coreNetworkArn: string;
    /**
     * The ID of a managed prefix list destination of the route.
     */
    destinationPrefixListId: string;
    /**
     * ID of the Egress Only Internet Gateway.
     */
    egressOnlyGatewayId: string;
    /**
     * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
     */
    gatewayId: string;
    /**
     * EC2 instance ID.
     */
    instanceId: string;
    /**
     * IPv6 CIDR block of the route.
     */
    ipv6CidrBlock: string;
    /**
     * Local Gateway ID.
     */
    localGatewayId: string;
    /**
     * NAT Gateway ID.
     */
    natGatewayId: string;
    /**
     * ID of the elastic network interface (eni) to use.
     */
    networkInterfaceId: string;
    /**
     * EC2 Transit Gateway ID.
     */
    transitGatewayId: string;
    /**
     * VPC Endpoint ID.
     */
    vpcEndpointId: string;
    /**
     * VPC Peering ID.
     */
    vpcPeeringConnectionId: string;
}
export interface GetVpcCidrBlockAssociation {
    /**
     * Association ID for the IPv4 CIDR block.
     */
    associationId: string;
    /**
     * Cidr block of the desired VPC.
     */
    cidrBlock: string;
    /**
     * Current state of the desired VPC.
     * Can be either `"pending"` or `"available"`.
     */
    state: string;
}
export interface GetVpcEndpointDnsEntry {
    /**
     * DNS name.
     */
    dnsName: string;
    /**
     * ID of the private hosted zone.
     */
    hostedZoneId: string;
}
export interface GetVpcEndpointDnsOption {
    /**
     * The DNS records created for the endpoint.
     */
    dnsRecordIpType: string;
    /**
     * Indicates whether to enable private DNS only for inbound endpoints.
     */
    privateDnsOnlyForInboundResolverEndpoint: boolean;
}
export interface GetVpcIamPoolCidrsIpamPoolCidr {
    /**
     * A network CIDR.
     */
    cidr: string;
    /**
     * The provisioning state of that CIDR.
     */
    state: string;
}
export interface GetVpcIamPoolsIpamPool {
    /**
     * IP protocol assigned to this pool.
     */
    addressFamily: string;
    /**
     * A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
     */
    allocationDefaultNetmaskLength: number;
    /**
     * The maximum netmask length that will be required for CIDR allocations in this pool.
     */
    allocationMaxNetmaskLength: number;
    /**
     * The minimum netmask length that will be required for CIDR allocations in this pool.
     */
    allocationMinNetmaskLength: number;
    /**
     * Tags that are required to create resources in using this pool.
     */
    allocationResourceTags: {[key: string]: string};
    /**
     * ARN of the pool
     */
    arn: string;
    /**
     * If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
     */
    autoImport: boolean;
    /**
     * Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
     */
    awsService: string;
    /**
     * Description for the IPAM pool.
     */
    description: string;
    /**
     * ID of the IPAM pool.
     */
    id: string;
    /**
     * ID of the scope the pool belongs to.
     */
    ipamScopeId: string;
    ipamScopeType: string;
    /**
     * Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
     */
    locale: string;
    poolDepth: number;
    /**
     * Defines whether or not IPv6 pool space is publicly advertisable over the internet.
     */
    publiclyAdvertisable: boolean;
    /**
     * ID of the source IPAM pool.
     */
    sourceIpamPoolId: string;
    state: string;
    /**
     * Map of tags to assigned to the resource.
     */
    tags: {[key: string]: string};
}
export interface GetVpcIpamPoolCidrsIpamPoolCidr {
    /**
     * A network CIDR.
     */
    cidr: string;
    /**
     * The provisioning state of that CIDR.
     */
    state: string;
}
export interface GetVpcIpamPoolsIpamPool {
    /**
     * IP protocol assigned to this pool.
     */
    addressFamily: string;
    /**
     * A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
     */
    allocationDefaultNetmaskLength: number;
    /**
     * The maximum netmask length that will be required for CIDR allocations in this pool.
     */
    allocationMaxNetmaskLength: number;
    /**
     * The minimum netmask length that will be required for CIDR allocations in this pool.
     */
    allocationMinNetmaskLength: number;
    /**
     * Tags that are required to create resources in using this pool.
     */
    allocationResourceTags: {[key: string]: string};
    /**
     * ARN of the pool
     */
    arn: string;
    /**
     * If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
     */
    autoImport: boolean;
    /**
     * Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
     */
    awsService: string;
    /**
     * Description for the IPAM pool.
     */
    description: string;
    /**
     * ID of the IPAM pool.
     */
    id: string;
    /**
     * ID of the scope the pool belongs to.
     */
    ipamScopeId: string;
    ipamScopeType: string;
    /**
     * Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
     */
    locale: string;
    poolDepth: number;
    /**
     * Defines whether or not IPv6 pool space is publicly advertisable over the internet.
     */
    publiclyAdvertisable: boolean;
    /**
     * ID of the source IPAM pool.
     */
    sourceIpamPoolId: string;
    state: string;
    /**
     * Map of tags to assigned to the resource.
     */
    tags: {[key: string]: string};
}
export interface GetVpcPeeringConnectionCidrBlockSet {
    /**
     * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
     */
    cidrBlock: string;
}
export interface GetVpcPeeringConnectionIpv6CidrBlockSet {
    ipv6CidrBlock: string;
}
export interface GetVpcPeeringConnectionPeerCidrBlockSet {
    /**
     * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
     */
    cidrBlock: string;
}
export interface GetVpcPeeringConnectionPeerIpv6CidrBlockSet {
    ipv6CidrBlock: string;
}
