From cd21550f239724c15a3def9edcd5615e8657b6de Mon Sep 17 00:00:00 2001
From: Lee Briggs <jaxxstorm@users.noreply.github.com>
Date: Wed, 21 Dec 2022 12:23:59 -0800
Subject: [PATCH 18/29] add matchmaking configuration (#72)

* add matchmaking configuration
* add matchmaking rule set
* implement flex_match_mode
  * Also fixes error codes for read operations
* add resource docs
---
 internal/provider/provider.go                 |   4 +
 .../gamelift/matchmaking_configuration.go     | 386 ++++++++++++++++++
 .../matchmaking_configuration_test.go         | 267 ++++++++++++
 .../service/gamelift/matchmaking_rule_set.go  | 163 ++++++++
 .../gamelift/matchmaking_rule_set_test.go     | 138 +++++++
 ...ft_matchmaking_configuration.html.markdown | 106 +++++
 ...amelift_matchmaking_rule_set.html.markdown |  52 +++
 7 files changed, 1116 insertions(+)
 create mode 100644 internal/service/gamelift/matchmaking_configuration.go
 create mode 100644 internal/service/gamelift/matchmaking_configuration_test.go
 create mode 100644 internal/service/gamelift/matchmaking_rule_set.go
 create mode 100644 internal/service/gamelift/matchmaking_rule_set_test.go
 create mode 100644 website/docs/r/gamelift_matchmaking_configuration.html.markdown
 create mode 100644 website/docs/r/gamelift_matchmaking_rule_set.html.markdown

diff --git a/internal/provider/provider.go b/internal/provider/provider.go
index f3b7493b92..e7dd1d0f9b 100644
--- a/internal/provider/provider.go
+++ b/internal/provider/provider.go
@@ -9,6 +9,7 @@ import (
 	"time"
 
 	"github.com/hashicorp/terraform-provider-aws/internal/service/ecr"
+	"github.com/hashicorp/terraform-provider-aws/internal/service/gamelift"
 	"github.com/hashicorp/terraform-provider-aws/internal/service/globalaccelerator"
 	"github.com/hashicorp/terraform-provider-aws/internal/service/meta"
 	"github.com/hashicorp/terraform-provider-aws/internal/service/s3legacy"
@@ -253,6 +254,9 @@ func New(ctx context.Context) (*schema.Provider, error) {
 			"aws_globalaccelerator_accelerator":    globalaccelerator.ResourceAccelerator(),
 			"aws_globalaccelerator_endpoint_group": globalaccelerator.ResourceEndpointGroup(),
 			"aws_globalaccelerator_listener":       globalaccelerator.ResourceListener(),
+
+			"aws_gamelift_matchmaking_configuration": gamelift.ResourceMatchMakingConfiguration(),
+			"aws_gamelift_matchmaking_rule_set":      gamelift.ResourceMatchmakingRuleSet(),
 		},
 	}
 
diff --git a/internal/service/gamelift/matchmaking_configuration.go b/internal/service/gamelift/matchmaking_configuration.go
new file mode 100644
index 0000000000..0a7c8ea635
--- /dev/null
+++ b/internal/service/gamelift/matchmaking_configuration.go
@@ -0,0 +1,386 @@
+package gamelift
+
+import (
+	"context"
+	"fmt"
+	"log"
+	"regexp"
+
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/aws/aws-sdk-go/service/gamelift"
+	"github.com/hashicorp/aws-sdk-go-base/v2/awsv1shim/v2/tfawserr"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
+	"github.com/hashicorp/terraform-provider-aws/internal/conns"
+	"github.com/hashicorp/terraform-provider-aws/internal/flex"
+	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
+)
+
+func ResourceMatchMakingConfiguration() *schema.Resource {
+	return &schema.Resource{
+		Create: resourceMatchmakingConfigurationCreate,
+		Read:   resourceMatchmakingConfigurationRead,
+		Update: resourceMatchmakingConfigurationUpdate,
+		Delete: resourceMatchmakingConfigurationDelete,
+		Importer: &schema.ResourceImporter{
+			StateContext: schema.ImportStatePassthroughContext,
+		},
+
+		Schema: map[string]*schema.Schema{
+			"acceptance_required": {
+				Type:     schema.TypeBool,
+				Required: true,
+			},
+			"acceptance_timeout_seconds": {
+				Type:         schema.TypeInt,
+				Optional:     true,
+				ValidateFunc: validation.IntBetween(1, 600),
+			},
+			"additional_player_count": {
+				Type:         schema.TypeInt,
+				Optional:     true,
+				ValidateFunc: validation.IntAtLeast(0),
+			},
+			"arn": {
+				Type:     schema.TypeString,
+				Computed: true,
+			},
+			"backfill_mode": {
+				Type:         schema.TypeString,
+				Optional:     true,
+				ValidateFunc: validation.StringInSlice([]string{gamelift.BackfillModeAutomatic, gamelift.BackfillModeManual}, false),
+			},
+			"creation_time": {
+				Type:     schema.TypeString,
+				Computed: true,
+			},
+			"custom_event_data": {
+				Type:         schema.TypeString,
+				Optional:     true,
+				ValidateFunc: validation.StringLenBetween(0, 256),
+			},
+			"description": {
+				Type:         schema.TypeString,
+				Optional:     true,
+				ValidateFunc: validation.StringLenBetween(1, 1024),
+			},
+			"flex_match_mode": {
+				Type:         schema.TypeString,
+				Optional:     true,
+				Computed:     true,
+				ValidateFunc: validation.StringInSlice([]string{gamelift.FlexMatchModeStandalone, gamelift.FlexMatchModeWithQueue}, false),
+			},
+			"game_property": {
+				Type:     schema.TypeSet,
+				Optional: true,
+				MaxItems: 16,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"key": {
+							Type:         schema.TypeString,
+							Required:     true,
+							ValidateFunc: validation.StringLenBetween(0, 32),
+						},
+						"value": {
+							Type:         schema.TypeString,
+							Required:     true,
+							ValidateFunc: validation.StringLenBetween(0, 96),
+						},
+					},
+				},
+			},
+			"game_session_data": {
+				Type:         schema.TypeString,
+				Required:     true,
+				ValidateFunc: validation.StringLenBetween(0, 4096),
+			},
+			"game_session_queue_arns": {
+				Type:     schema.TypeSet,
+				Optional: true,
+				Elem: &schema.Schema{
+					Type: schema.TypeString,
+					ValidateFunc: validation.All(
+						validation.StringLenBetween(1, 256),
+						validation.StringMatch(regexp.MustCompile(`^[a-zA-Z0-9:/-]+$`), "must contain only alphanumeric characters, colon, slash and hyphens"),
+					),
+				},
+			},
+			"name": {
+				Type:     schema.TypeString,
+				Required: true,
+				ForceNew: true,
+				ValidateFunc: validation.All(
+					validation.StringLenBetween(0, 128),
+					validation.StringMatch(regexp.MustCompile(`^[a-zA-Z0-9-\.]*$`), "must contain only alphanumeric characters, hyphens and periods"),
+				),
+			},
+			"notification_target": {
+				Type:     schema.TypeString,
+				Optional: true,
+				ValidateFunc: validation.All(
+					validation.StringLenBetween(0, 300),
+					validation.StringMatch(regexp.MustCompile(`^[a-zA-Z0-9:_/-]*$`), "must contain only alphanumeric characters, colons, underscores, slashes and hyphens"),
+				),
+			},
+			"request_timeout_seconds": {
+				Type:         schema.TypeInt,
+				Required:     true,
+				ValidateFunc: validation.IntBetween(1, 43200),
+			},
+			"rule_set_arn": {
+				Type:     schema.TypeString,
+				Computed: true,
+			},
+			"rule_set_name": {
+				Type:     schema.TypeString,
+				Required: true,
+				ValidateFunc: validation.All(
+					validation.StringLenBetween(0, 128),
+					validation.StringMatch(regexp.MustCompile(`^[a-zA-Z0-9-\.]*$`), "must contain only alphanumeric characters, hyphens and periods"),
+				),
+			},
+			"tags":     tftags.TagsSchema(),
+			"tags_all": tftags.TagsSchemaTrulyComputed(),
+		},
+	}
+}
+
+func resourceMatchmakingConfigurationCreate(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
+	tags := defaultTagsConfig.MergeTags(tftags.New(context.Background(), d.Get("tags").(map[string]interface{})))
+
+	input := gamelift.CreateMatchmakingConfigurationInput{
+		AcceptanceRequired:    aws.Bool(d.Get("acceptance_required").(bool)),
+		Name:                  aws.String(d.Get("name").(string)),
+		RequestTimeoutSeconds: aws.Int64(int64(d.Get("request_timeout_seconds").(int))),
+		RuleSetName:           aws.String(d.Get("rule_set_name").(string)),
+		Tags:                  Tags(tags.IgnoreAWS()),
+	}
+
+	if v, ok := d.GetOk("acceptance_timeout_seconds"); ok {
+		input.AcceptanceTimeoutSeconds = aws.Int64(int64(v.(int)))
+	}
+	if v, ok := d.GetOk("additional_player_count"); ok {
+		input.AdditionalPlayerCount = aws.Int64(int64(v.(int)))
+	}
+	if v, ok := d.GetOk("backfill_mode"); ok {
+		input.BackfillMode = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("custom_event_data"); ok {
+		input.CustomEventData = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("description"); ok {
+		input.Description = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("flex_match_mode"); ok {
+		input.FlexMatchMode = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("game_property"); ok {
+		set := v.(*schema.Set)
+		input.GameProperties = expandGameliftGameProperties(set.List())
+	}
+	if v, ok := d.GetOk("game_session_data"); ok {
+		input.GameSessionData = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("game_session_queue_arns"); ok {
+		input.GameSessionQueueArns = flex.ExpandStringSet(v.(*schema.Set))
+	}
+	if v, ok := d.GetOk("notification_target"); ok {
+		input.NotificationTarget = aws.String(v.(string))
+	}
+
+	log.Printf("[INFO] Creating GameLift Matchmaking Configuration: %s", input)
+	out, err := conn.CreateMatchmakingConfiguration(&input)
+	if err != nil {
+		return fmt.Errorf("error creating GameLift Matchmaking Configuration: %s", err)
+	}
+
+	d.SetId(aws.StringValue(out.Configuration.ConfigurationArn))
+	return resourceMatchmakingConfigurationRead(d, meta)
+}
+
+func resourceMatchmakingConfigurationRead(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
+	ignoreTagsConfig := meta.(*conns.AWSClient).IgnoreTagsConfig
+
+	log.Printf("[INFO] Describing GameLift Matchmaking Configuration: %s", d.Id())
+	out, err := conn.DescribeMatchmakingConfigurations(&gamelift.DescribeMatchmakingConfigurationsInput{
+		Names: aws.StringSlice([]string{d.Id()}),
+	})
+	if err != nil {
+		if tfawserr.ErrStatusCodeEquals(err, 400) || tfawserr.ErrCodeEquals(err, gamelift.ErrCodeNotFoundException) {
+			log.Printf("[WARN] GameLift Matchmaking Configuration (%s) not found, removing from state", d.Id())
+			d.SetId("")
+			return nil
+		}
+		return fmt.Errorf("error reading GameLift Matchmaking Configuration (%s): %s", d.Id(), err)
+	}
+	configurations := out.Configurations
+
+	if len(configurations) < 1 {
+		log.Printf("[WARN] GameLift Matchmaking Configuration (%s) not found, removing from state", d.Id())
+		d.SetId("")
+		return nil
+	}
+	if len(configurations) != 1 {
+		return fmt.Errorf("expected exactly 1 GameLift Matchmaking Configuration, found %d under %q",
+			len(configurations), d.Id())
+	}
+	configuration := configurations[0]
+
+	arn := aws.StringValue(configuration.ConfigurationArn)
+	d.Set("acceptance_required", configuration.AcceptanceRequired)
+	d.Set("acceptance_timeout_seconds", configuration.AcceptanceTimeoutSeconds)
+	d.Set("additional_player_count", configuration.AdditionalPlayerCount)
+	d.Set("arn", arn)
+	d.Set("backfill_mode", configuration.BackfillMode)
+	d.Set("creation_time", configuration.CreationTime.Format("2006-01-02 15:04:05"))
+	d.Set("custom_event_data", configuration.CustomEventData)
+	d.Set("description", configuration.Description)
+	d.Set("flex_match_mode", configuration.FlexMatchMode)
+	d.Set("game_property", flattenGameliftGameProperties(configuration.GameProperties))
+	d.Set("game_session_data", configuration.GameSessionData)
+	d.Set("game_session_queue_arns", configuration.GameSessionQueueArns)
+	d.Set("name", configuration.Name)
+	d.Set("notification_target", configuration.NotificationTarget)
+	d.Set("request_timeout_seconds", configuration.RequestTimeoutSeconds)
+	d.Set("rule_set_arn", configuration.RuleSetArn)
+	d.Set("rule_set_name", configuration.RuleSetName)
+
+	tags, err := ListTags(context.Background(), conn, arn)
+
+	if err != nil {
+		return fmt.Errorf("error listing tags for GameLift Matchmaking Configuration (%s): %s", arn, err)
+	}
+
+	tags = tags.IgnoreAWS().IgnoreConfig(ignoreTagsConfig)
+
+	//lintignore:AWSR002
+	if err := d.Set("tags", tags.RemoveDefaultConfig(defaultTagsConfig).Map()); err != nil {
+		return fmt.Errorf("error setting tags: %w", err)
+	}
+
+	if err := d.Set("tags_all", tags.Map()); err != nil {
+		return fmt.Errorf("error setting tags_all: %w", err)
+	}
+
+	return nil
+}
+
+func resourceMatchmakingConfigurationUpdate(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+
+	log.Printf("[INFO] Updating GameLift Matchmaking Configuration: %s", d.Id())
+
+	input := gamelift.UpdateMatchmakingConfigurationInput{
+		Name:                  aws.String(d.Id()),
+		AcceptanceRequired:    aws.Bool(d.Get("acceptance_required").(bool)),
+		RequestTimeoutSeconds: aws.Int64(int64(d.Get("request_timeout_seconds").(int))),
+		RuleSetName:           aws.String(d.Get("rule_set_name").(string)),
+	}
+
+	if v, ok := d.GetOk("acceptance_timeout_seconds"); ok {
+		input.AcceptanceTimeoutSeconds = aws.Int64(int64(v.(int)))
+	}
+	if v, ok := d.GetOk("additional_player_count"); ok {
+		input.AdditionalPlayerCount = aws.Int64(int64(v.(int)))
+	}
+	if v, ok := d.GetOk("backfill_mode"); ok {
+		input.BackfillMode = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("custom_event_data"); ok {
+		input.CustomEventData = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("description"); ok {
+		input.Description = aws.String(v.(string))
+	}
+	if d.HasChange("flex_match_mode") {
+		if v, ok := d.GetOk("flex_match_mode"); ok {
+			input.FlexMatchMode = aws.String(v.(string))
+		}
+	}
+	if v, ok := d.GetOk("game_property"); ok {
+		set := v.(*schema.Set)
+		input.GameProperties = expandGameliftGameProperties(set.List())
+	}
+	if v, ok := d.GetOk("game_session_data"); ok {
+		input.GameSessionData = aws.String(v.(string))
+	}
+	if v, ok := d.GetOk("game_session_queue_arns"); ok {
+		input.GameSessionQueueArns = expandStringList(v.([]interface{}))
+	}
+	if v, ok := d.GetOk("notification_target"); ok {
+		input.NotificationTarget = aws.String(v.(string))
+	}
+
+	_, err := conn.UpdateMatchmakingConfiguration(&input)
+	if err != nil {
+		return fmt.Errorf("error updating Gamelift Matchmaking Configuration (%s): %s", d.Id(), err)
+	}
+
+	arn := d.Id()
+
+	if d.HasChange("tags_all") {
+		o, n := d.GetChange("tags_all")
+
+		if err := UpdateTags(context.Background(), conn, arn, o, n); err != nil {
+			return fmt.Errorf("error updating GameLift Matchmaking Configuration (%s) tags: %s", arn, err)
+		}
+	}
+
+	return resourceMatchmakingConfigurationRead(d, meta)
+}
+
+func resourceMatchmakingConfigurationDelete(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	log.Printf("[INFO] Deleting GameLift Matchmaking Configuration: %s", d.Id())
+	_, err := conn.DeleteMatchmakingConfiguration(&gamelift.DeleteMatchmakingConfigurationInput{
+		Name: aws.String(d.Id()),
+	})
+	if tfawserr.ErrStatusCodeEquals(err, 400) || tfawserr.ErrCodeEquals(err, gamelift.ErrCodeNotFoundException) {
+		return nil
+	}
+	if err != nil {
+		return fmt.Errorf("error deleting GameLift Matchmaking Configuration (%s): %s", d.Id(), err)
+	}
+
+	return nil
+}
+
+func expandGameliftGameProperties(cfg []interface{}) []*gamelift.GameProperty {
+	properties := make([]*gamelift.GameProperty, len(cfg))
+	for i, property := range cfg {
+		prop := property.(map[string]interface{})
+		properties[i] = &gamelift.GameProperty{
+			Key:   aws.String(prop["key"].(string)),
+			Value: aws.String(prop["value"].(string)),
+		}
+	}
+	return properties
+}
+
+func flattenGameliftGameProperties(awsProperties []*gamelift.GameProperty) []interface{} {
+	properties := []interface{}{}
+	for _, awsProperty := range awsProperties {
+		property := map[string]string{
+			"key":   *awsProperty.Key,
+			"value": *awsProperty.Value,
+		}
+		properties = append(properties, property)
+	}
+	return properties
+}
+
+func expandStringList(tfList []interface{}) []*string {
+	var result []*string
+
+	for _, rawVal := range tfList {
+		if v, ok := rawVal.(string); ok && v != "" {
+			result = append(result, &v)
+		}
+	}
+
+	return result
+}
diff --git a/internal/service/gamelift/matchmaking_configuration_test.go b/internal/service/gamelift/matchmaking_configuration_test.go
new file mode 100644
index 0000000000..7bd8451404
--- /dev/null
+++ b/internal/service/gamelift/matchmaking_configuration_test.go
@@ -0,0 +1,267 @@
+package gamelift_test
+
+import (
+	"fmt"
+	"regexp"
+	"testing"
+
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/aws/aws-sdk-go/service/gamelift"
+
+	sdkacctest "github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
+	"github.com/hashicorp/terraform-provider-aws/internal/acctest"
+	"github.com/hashicorp/terraform-provider-aws/internal/conns"
+	tfgamelift "github.com/hashicorp/terraform-provider-aws/internal/service/gamelift"
+)
+
+func TestAccMatchmakingConfiguration_basic(t *testing.T) {
+
+	var conf gamelift.MatchmakingConfiguration
+
+	rName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	resourceName := "aws_gamelift_matchmaking_configuration.test"
+	queueName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	ruleSetName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+
+	additionalParameters := ""
+
+	resource.ParallelTest(t, resource.TestCase{
+		PreCheck: func() {
+			acctest.PreCheck(t)
+			acctest.PreCheckPartitionHasService(gamelift.EndpointsID, t)
+			testAccPreCheck(t)
+		},
+		ErrorCheck:               acctest.ErrorCheck(t, gamelift.EndpointsID),
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories,
+		CheckDestroy:             testAccCheckGameServerGroupDestroy,
+		Steps: []resource.TestStep{
+			{
+				Config: testAccGameServerMatchmakingConfiguration_basic(rName, queueName, ruleSetName, additionalParameters, 10),
+				Check: resource.ComposeTestCheckFunc(
+					testAccCheckMatchmakingConfigurationExists(resourceName, &conf),
+					acctest.MatchResourceAttrRegionalARN(resourceName, "arn", "gamelift", regexp.MustCompile(`matchmakingconfiguration/.+`)),
+					resource.TestCheckResourceAttr(resourceName, "name", rName),
+					resource.TestCheckResourceAttr(resourceName, "tags.%", "0"),
+					resource.TestCheckResourceAttr(resourceName, "custom_event_data", "pvp"),
+					resource.TestCheckResourceAttr(resourceName, "game_session_data", "game_session_data"),
+					resource.TestCheckResourceAttr(resourceName, "acceptance_required", "false"),
+					resource.TestCheckResourceAttr(resourceName, "request_timeout_seconds", "10"),
+					resource.TestCheckResourceAttr(resourceName, "backfill_mode", gamelift.BackfillModeManual),
+				),
+			},
+			{
+				ResourceName:      resourceName,
+				ImportState:       true,
+				ImportStateVerify: true,
+			},
+		},
+	})
+}
+
+func TestAccMatchmakingConfiguration_tags(t *testing.T) {
+
+	var conf gamelift.MatchmakingConfiguration
+
+	rName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	resourceName := "aws_gamelift_matchmaking_configuration.test"
+	queueName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	ruleSetName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+
+	additionalParameters := ""
+
+	resource.ParallelTest(t, resource.TestCase{
+		PreCheck: func() {
+			acctest.PreCheck(t)
+			acctest.PreCheckPartitionHasService(gamelift.EndpointsID, t)
+			testAccPreCheck(t)
+		},
+		ErrorCheck:               acctest.ErrorCheck(t, gamelift.EndpointsID),
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories,
+		CheckDestroy:             testAccCheckGameServerGroupDestroy,
+		Steps: []resource.TestStep{
+			{
+				Config: testAccGameServerMatchmakingConfiguration_tags(rName, queueName, ruleSetName, additionalParameters, 10),
+				Check: resource.ComposeTestCheckFunc(
+					testAccCheckMatchmakingConfigurationExists(resourceName, &conf),
+					acctest.MatchResourceAttrRegionalARN(resourceName, "arn", "gamelift", regexp.MustCompile(`matchmakingconfiguration/.+`)),
+					resource.TestCheckResourceAttr(resourceName, "name", rName),
+					resource.TestCheckResourceAttr(resourceName, "tags.%", "1"),
+					resource.TestCheckResourceAttr(resourceName, "tags.key1", "value1"),
+					resource.TestCheckResourceAttr(resourceName, "custom_event_data", "pvp"),
+					resource.TestCheckResourceAttr(resourceName, "game_session_data", "game_session_data"),
+					resource.TestCheckResourceAttr(resourceName, "acceptance_required", "false"),
+					resource.TestCheckResourceAttr(resourceName, "request_timeout_seconds", "10"),
+					resource.TestCheckResourceAttr(resourceName, "backfill_mode", gamelift.BackfillModeManual),
+				),
+			},
+			{
+				ResourceName:      resourceName,
+				ImportState:       true,
+				ImportStateVerify: true,
+			},
+		},
+	})
+}
+
+func TestAccMatchmakingConfiguration_disappears(t *testing.T) {
+	var conf gamelift.MatchmakingConfiguration
+
+	rName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	resourceName := "aws_gamelift_matchmaking_configuration.test"
+	queueName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	ruleSetName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+
+	additionalParameters := ""
+
+	resource.ParallelTest(t, resource.TestCase{
+		PreCheck: func() {
+			acctest.PreCheck(t)
+			acctest.PreCheckPartitionHasService(gamelift.EndpointsID, t)
+			testAccPreCheck(t)
+		},
+		ErrorCheck:               acctest.ErrorCheck(t, gamelift.EndpointsID),
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories,
+		CheckDestroy:             testAccCheckGameServerGroupDestroy,
+		Steps: []resource.TestStep{
+			{
+				Config: testAccGameServerMatchmakingConfiguration_basic(rName, queueName, ruleSetName, additionalParameters, 10),
+				Check: resource.ComposeTestCheckFunc(
+					testAccCheckMatchmakingConfigurationExists(resourceName, &conf),
+					acctest.CheckResourceDisappears(acctest.Provider, tfgamelift.ResourceMatchMakingConfiguration(), resourceName),
+				),
+				ExpectNonEmptyPlan: true,
+			},
+		},
+	})
+}
+
+func testAccCheckMatchmakingConfigurationExists(n string, res *gamelift.MatchmakingConfiguration) resource.TestCheckFunc {
+	return func(s *terraform.State) error {
+
+		rs, ok := s.RootModule().Resources[n]
+		if !ok {
+			return fmt.Errorf("not found: %s", n)
+		}
+
+		if rs.Primary.ID == "" {
+			return fmt.Errorf("no Gamelift Matchmaking Configuration Name is set")
+		}
+
+		conn := acctest.Provider.Meta().(*conns.AWSClient).GameLiftConn
+
+		name := rs.Primary.Attributes["name"]
+		out, err := conn.DescribeMatchmakingConfigurations(&gamelift.DescribeMatchmakingConfigurationsInput{
+			Names: aws.StringSlice([]string{name}),
+		})
+
+		if err != nil {
+			return err
+		}
+		configurations := out.Configurations
+		if len(configurations) == 0 {
+			return fmt.Errorf("GameLift Matchmaking Configuration %q not found", name)
+		}
+		*res = *configurations[0]
+
+		return nil
+	}
+}
+
+func testAccAWSGameliftMatchMakingConfigurationRuleSetBody() string {
+	maxPlayers := int64(1)
+	return fmt.Sprintf(`{
+		"name": "test",
+		"ruleLanguageVersion": "1.0",
+		"teams": [{
+			"name": "alpha",
+			"minPlayers": 1,
+			"maxPlayers": %[1]d
+		}]
+	}`, maxPlayers)
+}
+
+func testAccGameServerMatchmakingConfiguration_basic(rName string, queueName string, ruleSetName string, additionalParameters string, requestTimeoutSeconds int) string {
+	backfillMode := gamelift.BackfillModeManual
+	return fmt.Sprintf(`
+resource "aws_gamelift_game_session_queue" "test" {
+	name         = %[2]q
+	destinations = []
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 3
+		policy_duration_seconds                        = 7
+	}
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 10
+	}
+	
+	timeout_in_seconds = 25
+}
+
+resource "aws_gamelift_matchmaking_rule_set" "test" {
+	name          = %[3]q
+	rule_set_body = <<RULE_SET_BODY
+	%[4]s
+	RULE_SET_BODY	
+}
+
+resource "aws_gamelift_matchmaking_configuration" "test" {
+	name          = %[1]q
+	acceptance_required = false
+	custom_event_data = "pvp"
+	game_session_data = "game_session_data"
+	backfill_mode = %[7]q
+	request_timeout_seconds = %[6]d
+	rule_set_name = aws_gamelift_matchmaking_rule_set.test.name
+	game_session_queue_arns = [aws_gamelift_game_session_queue.test.arn]
+	%[5]s
+}
+
+`, rName, queueName, ruleSetName, testAccAWSGameliftMatchMakingConfigurationRuleSetBody(), additionalParameters, requestTimeoutSeconds, backfillMode)
+}
+
+func testAccGameServerMatchmakingConfiguration_tags(rName string, queueName string, ruleSetName string, additionalParameters string, requestTimeoutSeconds int) string {
+	backfillMode := gamelift.BackfillModeManual
+	return fmt.Sprintf(`
+resource "aws_gamelift_game_session_queue" "test" {
+	name         = %[2]q
+	destinations = []
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 3
+		policy_duration_seconds                        = 7
+	}
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 10
+	}
+	
+	timeout_in_seconds = 25
+}
+
+resource "aws_gamelift_matchmaking_rule_set" "test" {
+	name          = %[3]q
+	rule_set_body = <<RULE_SET_BODY
+	%[4]s
+	RULE_SET_BODY	
+}
+
+resource "aws_gamelift_matchmaking_configuration" "test" {
+	name          = %[1]q
+	acceptance_required = false
+	custom_event_data = "pvp"
+	game_session_data = "game_session_data"
+	backfill_mode = %[7]q
+	request_timeout_seconds = %[6]d
+	rule_set_name = aws_gamelift_matchmaking_rule_set.test.name
+	game_session_queue_arns = [aws_gamelift_game_session_queue.test.arn]
+	tags = {
+		"key1" = "value1"
+	}
+	%[5]s
+}
+`, rName, queueName, ruleSetName, testAccAWSGameliftMatchMakingConfigurationRuleSetBody(), additionalParameters, requestTimeoutSeconds, backfillMode)
+}
diff --git a/internal/service/gamelift/matchmaking_rule_set.go b/internal/service/gamelift/matchmaking_rule_set.go
new file mode 100644
index 0000000000..28d15ecf5e
--- /dev/null
+++ b/internal/service/gamelift/matchmaking_rule_set.go
@@ -0,0 +1,163 @@
+package gamelift
+
+import (
+	"context"
+	"fmt"
+	"log"
+
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/aws/aws-sdk-go/service/gamelift"
+	"github.com/hashicorp/aws-sdk-go-base/v2/awsv1shim/v2/tfawserr"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
+	"github.com/hashicorp/terraform-provider-aws/internal/conns"
+	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
+	"github.com/hashicorp/terraform-provider-aws/internal/verify"
+)
+
+func ResourceMatchmakingRuleSet() *schema.Resource {
+	return &schema.Resource{
+		Create: resourceMatchmakingRuleSetCreate,
+		Read:   resourceMatchmakingRuleSetRead,
+		Update: resourceMatchmakingRuleSetUpdate,
+		Delete: resourceMatchmakingRuleSetDelete,
+		Importer: &schema.ResourceImporter{
+			StateContext: schema.ImportStatePassthroughContext,
+		},
+
+		Schema: map[string]*schema.Schema{
+			"name": {
+				Type:         schema.TypeString,
+				Required:     true,
+				ForceNew:     true,
+				ValidateFunc: validation.StringLenBetween(1, 128),
+			},
+			"rule_set_body": {
+				Type:     schema.TypeString,
+				Required: true,
+				ForceNew: true,
+				ValidateFunc: validation.All(
+					validation.StringLenBetween(1, 65535),
+					validation.StringIsJSON,
+				),
+				StateFunc: func(v interface{}) string {
+					json, _ := structure.NormalizeJsonString(v)
+					return json
+				},
+				DiffSuppressFunc: verify.SuppressEquivalentJSONDiffs,
+			},
+			"arn": {
+				Type:     schema.TypeString,
+				Computed: true,
+			},
+			"tags":     tftags.TagsSchema(),
+			"tags_all": tftags.TagsSchemaTrulyComputed(),
+		},
+	}
+}
+
+func resourceMatchmakingRuleSetCreate(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
+	tags := defaultTagsConfig.MergeTags(tftags.New(context.Background(), d.Get("tags").(map[string]interface{})))
+
+	input := gamelift.CreateMatchmakingRuleSetInput{
+		Name:        aws.String(d.Get("name").(string)),
+		RuleSetBody: aws.String(d.Get("rule_set_body").(string)),
+		Tags:        Tags(tags.IgnoreAWS()),
+	}
+	log.Printf("[INFO] Creating GameLift Matchmaking Rule Set: %s", input)
+	out, err := conn.CreateMatchmakingRuleSet(&input)
+	if err != nil {
+		return fmt.Errorf("error creating GameLift Matchmaking Rule Set: %s", err)
+	}
+
+	d.SetId(aws.StringValue(out.RuleSet.RuleSetName))
+
+	return resourceMatchmakingRuleSetRead(d, meta)
+}
+
+func resourceMatchmakingRuleSetRead(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
+
+	log.Printf("[INFO] Describing GameLift Matchmaking Rule Set: %s", d.Id())
+	out, err := conn.DescribeMatchmakingRuleSets(&gamelift.DescribeMatchmakingRuleSetsInput{
+		Names: aws.StringSlice([]string{d.Id()}),
+	})
+	if err != nil {
+		if tfawserr.ErrStatusCodeEquals(err, 400) || tfawserr.ErrCodeEquals(err, gamelift.ErrCodeNotFoundException) {
+			log.Printf("[WARN] GameLift Matchmaking Rule Set (%s) not found, removing from state", d.Id())
+			d.SetId("")
+			return nil
+		}
+		return fmt.Errorf("error reading GameLift Matchmaking Rule Set (%s): %s", d.Id(), err)
+	}
+	ruleSets := out.RuleSets
+
+	if len(ruleSets) < 1 {
+		log.Printf("[WARN] GameLift Matchmaking Rule Set (%s) not found, removing from state", d.Id())
+		d.SetId("")
+		return nil
+	}
+	if len(ruleSets) != 1 {
+		return fmt.Errorf("expected exactly 1 GameLift Matchmaking Rule Set, found %d under %q",
+			len(ruleSets), d.Id())
+	}
+	ruleSet := ruleSets[0]
+
+	arn := aws.StringValue(ruleSet.RuleSetArn)
+	d.Set("arn", arn)
+	d.Set("name", ruleSet.RuleSetName)
+	d.Set("rule_set_body", ruleSet.RuleSetBody)
+
+	tags, err := ListTags(context.Background(), conn, arn)
+
+	if err != nil {
+		return fmt.Errorf("error listing tags for GameLift Matchmaking Rule Set (%s): %s", arn, err)
+	}
+
+	if err := d.Set("tags", tags.RemoveDefaultConfig(defaultTagsConfig).Map()); err != nil {
+		return fmt.Errorf("error setting tags: %w", err)
+	}
+
+	if err := d.Set("tags_all", tags.Map()); err != nil {
+		return fmt.Errorf("error setting tags_all: %w", err)
+	}
+
+	return nil
+}
+
+func resourceMatchmakingRuleSetUpdate(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+
+	log.Printf("[INFO] Updating GameLift Matchmaking Rule Set: %s", d.Id())
+
+	arn := d.Id()
+	if d.HasChange("tags_all") {
+		o, n := d.GetChange("tags_all")
+
+		if err := UpdateTags(context.Background(), conn, arn, o, n); err != nil {
+			return fmt.Errorf("error updating GameLift Matchmaking Rule Set (%s) tags: %s", arn, err)
+		}
+	}
+
+	return resourceMatchmakingRuleSetRead(d, meta)
+}
+
+func resourceMatchmakingRuleSetDelete(d *schema.ResourceData, meta interface{}) error {
+	conn := meta.(*conns.AWSClient).GameLiftConn()
+	log.Printf("[INFO] Deleting GameLift Matchmaking Rule Set: %s", d.Id())
+	_, err := conn.DeleteMatchmakingRuleSet(&gamelift.DeleteMatchmakingRuleSetInput{
+		Name: aws.String(d.Id()),
+	})
+	if tfawserr.ErrCodeEquals(err, gamelift.ErrCodeNotFoundException) {
+		return nil
+	}
+	if err != nil {
+		return fmt.Errorf("error deleting GameLift Matchmaking Rule Set (%s): %s", d.Id(), err)
+	}
+
+	return nil
+}
diff --git a/internal/service/gamelift/matchmaking_rule_set_test.go b/internal/service/gamelift/matchmaking_rule_set_test.go
new file mode 100644
index 0000000000..8788ef5b45
--- /dev/null
+++ b/internal/service/gamelift/matchmaking_rule_set_test.go
@@ -0,0 +1,138 @@
+package gamelift_test
+
+import (
+	"fmt"
+	"regexp"
+	"testing"
+
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/aws/aws-sdk-go/service/gamelift"
+	sdkacctest "github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
+	"github.com/hashicorp/terraform-provider-aws/internal/acctest"
+	"github.com/hashicorp/terraform-provider-aws/internal/conns"
+	tfgamelift "github.com/hashicorp/terraform-provider-aws/internal/service/gamelift"
+)
+
+func TestAccMatchmakingRuleSet_basic(t *testing.T) {
+
+	var conf gamelift.MatchmakingRuleSet
+
+	ruleSetName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	resourceName := "aws_gamelift_matchmaking_rule_set.test"
+	maxPlayers := 5
+
+	resource.Test(t, resource.TestCase{
+		PreCheck: func() {
+			acctest.PreCheck(t)
+			acctest.PreCheckPartitionHasService(gamelift.EndpointsID, t)
+			testAccPreCheck(t)
+		},
+		ErrorCheck:               acctest.ErrorCheck(t, gamelift.EndpointsID),
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories,
+		CheckDestroy:             testAccCheckGameServerGroupDestroy,
+		Steps: []resource.TestStep{
+			{
+				Config: testAccMatchmakingRuleSetBasicConfig(ruleSetName, maxPlayers),
+				Check: resource.ComposeTestCheckFunc(
+					testAccCheckMatchmakingRuleSetExists(resourceName, &conf),
+					acctest.MatchResourceAttrRegionalARN(resourceName, "arn", "gamelift", regexp.MustCompile(`matchmakingruleset/.+`)),
+					resource.TestCheckResourceAttr(resourceName, "name", ruleSetName),
+					resource.TestCheckResourceAttr(resourceName, "rule_set_body", testAccMatchmakingRuleSetBody(maxPlayers)+"\n"),
+					resource.TestCheckResourceAttr(resourceName, "tags.%", "0"),
+				),
+			},
+			{
+				ResourceName:      resourceName,
+				ImportState:       true,
+				ImportStateVerify: true,
+			},
+		},
+	})
+}
+
+func TestAccMatchmakingRuleSet_disappears(t *testing.T) {
+
+	var conf gamelift.MatchmakingRuleSet
+
+	ruleSetName := sdkacctest.RandomWithPrefix(acctest.ResourcePrefix)
+	resourceName := "aws_gamelift_matchmaking_rule_set.test"
+	maxPlayers := 5
+
+	resource.ParallelTest(t, resource.TestCase{
+		PreCheck: func() {
+			acctest.PreCheck(t)
+			acctest.PreCheckPartitionHasService(gamelift.EndpointsID, t)
+			testAccPreCheck(t)
+		},
+		ErrorCheck:               acctest.ErrorCheck(t, gamelift.EndpointsID),
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories,
+		CheckDestroy:             testAccCheckGameServerGroupDestroy,
+		Steps: []resource.TestStep{
+			{
+				Config: testAccMatchmakingRuleSetBasicConfig(ruleSetName, maxPlayers),
+				Check: resource.ComposeTestCheckFunc(
+					testAccCheckMatchmakingRuleSetExists(resourceName, &conf),
+					acctest.CheckResourceDisappears(acctest.Provider, tfgamelift.ResourceMatchmakingRuleSet(), resourceName),
+				),
+				ExpectNonEmptyPlan: true,
+			},
+		},
+	})
+}
+
+func testAccCheckMatchmakingRuleSetExists(n string, res *gamelift.MatchmakingRuleSet) resource.TestCheckFunc {
+	return func(s *terraform.State) error {
+		rs, ok := s.RootModule().Resources[n]
+
+		if !ok {
+			return fmt.Errorf("not found: %s", n)
+		}
+
+		if rs.Primary.ID == "" {
+			return fmt.Errorf("no Gamelift Matchmaking Rule Set Name is set")
+		}
+
+		conn := acctest.Provider.Meta().(*conns.AWSClient).GameLiftConn
+
+		name := rs.Primary.Attributes["name"]
+		out, err := conn.DescribeMatchmakingRuleSets(&gamelift.DescribeMatchmakingRuleSetsInput{
+			Names: aws.StringSlice([]string{name}),
+		})
+		if err != nil {
+			return err
+		}
+		ruleSets := out.RuleSets
+		if len(ruleSets) == 0 {
+			return fmt.Errorf("GameLift Matchmaking Rule Set %q not found", name)
+		}
+
+		*res = *ruleSets[0]
+
+		return nil
+	}
+}
+
+func testAccMatchmakingRuleSetBody(maxPlayers int) string {
+	return fmt.Sprintf(`{
+	"name": "test",
+	"ruleLanguageVersion": "1.0",
+	"teams": [{
+		"name": "alpha",
+		"minPlayers": 1,
+		"maxPlayers": %[1]d
+	}]
+}`, maxPlayers)
+}
+
+func testAccMatchmakingRuleSetBasicConfig(rName string, maxPlayers int) string {
+	return fmt.Sprintf(`
+resource "aws_gamelift_matchmaking_rule_set" "test" {
+  name          = %[1]q
+  rule_set_body = <<RULE_SET_BODY
+%[2]s
+RULE_SET_BODY
+}
+`, rName, testAccMatchmakingRuleSetBody(maxPlayers))
+}
diff --git a/website/docs/r/gamelift_matchmaking_configuration.html.markdown b/website/docs/r/gamelift_matchmaking_configuration.html.markdown
new file mode 100644
index 0000000000..2d411ad301
--- /dev/null
+++ b/website/docs/r/gamelift_matchmaking_configuration.html.markdown
@@ -0,0 +1,106 @@
+---
+subcategory: "GameLift"
+layout: "aws"
+page_title: "AWS: aws_gamelift_matchmaking_configuration"
+description: |-
+  Provides a GameLift Matchmaking Configuration resource.
+---
+
+# Resource: aws_gamelift_matchmaking_configuration
+
+Provides a GameLift Alias resource.
+
+## Example Usage
+
+```terraform
+
+resource "aws_gamelift_game_session_queue" "example" {
+	name         = example
+	destinations = []
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 3
+		policy_duration_seconds                        = 7
+	}
+	
+	player_latency_policy {
+		maximum_individual_player_latency_milliseconds = 10
+	}
+	
+	timeout_in_seconds = 25
+}
+
+resource "aws_gamelift_matchmaking_rule_set" "example" {
+	name          = example
+	rule_set_body = jsonencode({
+		"name": "test",
+		"ruleLanguageVersion": "1.0",
+		"teams": [{
+			"name": "alpha",
+			"minPlayers": 1,
+			"maxPlayers": 5
+		}]
+	})
+}
+
+resource "aws_gamelift_matchmaking_configuration" "example" {
+	name          = example
+	acceptance_required = false
+	custom_event_data = "pvp"
+	game_session_data = "game_session_data"
+	backfill_mode = "MANUAL"
+	request_timeout_seconds = 30
+	rule_set_name = aws_gamelift_matchmaking_rule_set.test.name
+	game_session_queue_arns = [aws_gamelift_game_session_queue.test.arn]
+	tags = {
+		"key1" = "value1"
+	}
+}
+```
+
+## Argument Reference
+
+The following arguments are supported:
+
+* `name` - (Required) Name of the matchmaking configuration
+* `acceptance_required` - (Required) Specifies if the match that was created with this configuration must be accepted by matched players.
+* `additional_player_count` - (Required) The number of player slots in a match to keep open for future players.
+* `game_session_data` - (Required) A set of custom game session properties.
+* `rule_set_name` - (Required) A rule set names for the matchmaking rule set to use with this configuration.
+* `acceptance_timeout_seconds` - (Optional) The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
+* `backfill_mode` - (Optional) The method used to backfill game sessions that are created with this matchmaking configuration.
+* `custom_event_data` - (Optional) Information to be added to all events related to this matchmaking configuration.
+* `description` - (Optional) A human-readable description of the matchmaking configuration.
+* `flex_match_mode` - (Optional) Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
+* `game_property` - (Optional) One or more custom game properties. See below.
+* `game_session_queue_arns` - (Optional) The ARNs of the GameLift game session queue resources.
+* `notification_target` - (Optional) An SNS topic ARN that is set up to receive matchmaking notifications.
+* `request_timeout_seconds` - (Optional) The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
+* `tags` - (Optional) Key-value map of resource tags. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
+
+
+
+
+### Nested Fields
+
+#### `game_property`
+
+* `key` - (Optional) A game property key
+* `value` - (Optional) A game property value.
+
+## Attributes Reference
+
+In addition to all arguments above, the following attributes are exported:
+
+* `id` - Matchmaking Configuration ID.
+* `arn` - Matchmaking Configuration ARN.
+* `creation_time` - The time when the Matchmaking Configuration was created.
+* `tags_all` - A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
+
+## Import
+
+GameLift Matchmaking Configurations can be imported using the ID, e.g.,
+
+```
+$ terraform import aws_gamelift_matchmaking_configuration.example <matchmakingconfiguration-id>
+```
diff --git a/website/docs/r/gamelift_matchmaking_rule_set.html.markdown b/website/docs/r/gamelift_matchmaking_rule_set.html.markdown
new file mode 100644
index 0000000000..28013532bf
--- /dev/null
+++ b/website/docs/r/gamelift_matchmaking_rule_set.html.markdown
@@ -0,0 +1,52 @@
+---
+subcategory: "GameLift"
+layout: "aws"
+page_title: "AWS: aws_gamelift_matchmaking_rule_set"
+description: |-
+  Provides a GameLift Matchmaking Rule Set .
+---
+
+# Resource: aws_gamelift_matchmaking_rule_set
+
+Provides a GameLift Matchmaking Rule Set resources.
+
+## Example Usage
+
+```terraform
+resource "aws_gamelift_matchmaking_rule_set" "example" {
+  name          = %[1]q
+  rule_set_body = jsonencodes({
+	"name": "test",
+	"ruleLanguageVersion": "1.0",
+	"teams": [{
+		"name": "alpha",
+		"minPlayers": 1,
+		"maxPlayers": 5
+	}]
+})
+}
+```
+
+## Argument Reference
+
+The following arguments are supported:
+
+* `name` - (Required) Name of the matchmaking rule set.
+* `rule_set_body` - (Required) JSON encoded string containing rule set data.
+
+
+## Attributes Reference
+
+In addition to all arguments above, the following attributes are exported:
+
+* `id` - Rule Set ID.
+* `arn` - Rule Set ARN.
+* `tags_all` - A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
+
+## Import
+
+GameLift Matchmaking Rule Sets  can be imported using the ID, e.g.,
+
+```
+$ terraform import aws_gamelift_matchmaking_rule_set.example <ruleset-id>
+```
