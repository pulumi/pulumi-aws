// *** WARNING: this file was generated by the Pulumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "pulumi";

/**
 * Provides an AutoScaling Group resource.
 */
export class Group extends pulumi.Resource {
    /**
     * The ARN for this AutoScaling Group
     */
    public /*out*/ readonly arn: pulumi.Computed<string>;
    /**
     * A list of AZs to launch resources in.
     * Required only if you do not specify any `vpc_zone_identifier`
     */
    public readonly availabilityZones: pulumi.Computed<string[]>;
    /**
     * The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
     */
    public readonly defaultCooldown: pulumi.Computed<number>;
    /**
     * The number of Amazon EC2 instances that
     * should be running in the group. (See also [Waiting for
     * Capacity](#waiting-for-capacity) below.)
     */
    public readonly desiredCapacity: pulumi.Computed<number>;
    /**
     * A list of metrics to collect. The allowed values are `GroupMinSize`, `GroupMaxSize`, `GroupDesiredCapacity`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupTerminatingInstances`, `GroupTotalInstances`.
     * * `wait_for_capacity_timeout` (Default: "10m") A maximum
     * [duration](https://golang.org/pkg/time/#ParseDuration) that Terraform should
     * wait for ASG instances to be healthy before timing out.  (See also [Waiting
     * for Capacity](#waiting-for-capacity) below.) Setting this to "0" causes
     * Terraform to skip all Capacity Waiting behavior.
     */
    public readonly enabledMetrics?: pulumi.Computed<string[]>;
    /**
     * Allows deleting the autoscaling group without waiting
     * for all instances in the pool to terminate.  You can force an autoscaling group to delete
     * even if it's in the process of scaling a resource. Normally, Terraform
     * drains all the instances before deleting the group.  This bypasses that
     * behavior and potentially leaves resources dangling.
     */
    public readonly forceDelete?: pulumi.Computed<boolean>;
    /**
     * Time (in seconds) after instance comes into service before checking health.
     */
    public readonly healthCheckGracePeriod?: pulumi.Computed<number>;
    /**
     * "EC2" or "ELB". Controls how health checking is done.
     */
    public readonly healthCheckType: pulumi.Computed<string>;
    /**
     * One or more
     * [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
     * to attach to the autoscaling group **before** instances are launched. The
     * syntax is exactly the same as the separate
     * [`aws_autoscaling_lifecycle_hook`](/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
     * resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
     * a new autoscaling group. For all other use-cases, please use `aws_autoscaling_lifecycle_hook` resource.
     */
    public readonly initialLifecycleHook?: pulumi.Computed<{ defaultResult: string, heartbeatTimeout?: number, lifecycleTransition: string, name: string, notificationMetadata?: string, notificationTargetArn?: string, roleArn?: string }[]>;
    /**
     * The name of the launch configuration to use.
     */
    public readonly launchConfiguration: pulumi.Computed<string>;
    /**
     * A list of elastic load balancer names to add to the autoscaling
     * group names.
     */
    public readonly loadBalancers: pulumi.Computed<string[]>;
    /**
     * The maximum size of the auto scale group.
     */
    public readonly maxSize: pulumi.Computed<number>;
    /**
     * The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
     */
    public readonly metricsGranularity?: pulumi.Computed<string>;
    /**
     * Setting this causes Terraform to wait for
     * this number of instances to show up healthy in the ELB only on creation.
     * Updates will not wait on ELB instance number changes.
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    public readonly minElbCapacity?: pulumi.Computed<number>;
    /**
     * The minimum size of the auto scale group.
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    public readonly minSize: pulumi.Computed<number>;
    /**
     * The name of the auto scaling group. By default generated by Terraform.
     */
    public readonly name: pulumi.Computed<string>;
    /**
     * Creates a unique name beginning with the specified
     * prefix. Conflicts with `name`.
     */
    public readonly namePrefix?: pulumi.Computed<string>;
    /**
     * The name of the placement group into which you'll launch your instances, if any.
     */
    public readonly placementGroup?: pulumi.Computed<string>;
    /**
     * Allows setting instance protection. The
     * autoscaling group will not select instances with this setting for terminination
     * during scale in events.
     */
    public readonly protectFromScaleIn?: pulumi.Computed<boolean>;
    /**
     * A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
     * Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
     */
    public readonly suspendedProcesses?: pulumi.Computed<string[]>;
    /**
     * A list of tag blocks. Tags documented below.
     */
    public readonly tag?: pulumi.Computed<{ key: string, propagateAtLaunch: boolean, value: string }[]>;
    /**
     * A list of tag blocks (maps). Tags documented below.
     */
    public readonly tags?: pulumi.Computed<{[key: string]: any}[]>;
    /**
     * A list of `aws_alb_target_group` ARNs, for use with
     * Application Load Balancing
     */
    public readonly targetGroupArns: pulumi.Computed<string[]>;
    /**
     * A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `Default`.
     */
    public readonly terminationPolicies?: pulumi.Computed<string[]>;
    /**
     * A list of subnet IDs to launch resources in.
     */
    public readonly vpcZoneIdentifier: pulumi.Computed<string[]>;
    public readonly waitForCapacityTimeout?: pulumi.Computed<string>;
    /**
     * Setting this will cause Terraform to wait
     * for exactly this number of healthy instances in all attached load balancers
     * on both create and update operations. (Takes precedence over
     * `min_elb_capacity` behavior.)
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    public readonly waitForElbCapacity?: pulumi.Computed<number>;

    /**
     * Create a Group resource with the given unique name, arguments and optional additional
     * resource dependencies.
     *
     * @param urnName A _unique_ name for this Group instance
     * @param args A collection of arguments for creating this Group intance
     * @param dependsOn A optional array of additional resources this intance depends on
     */
    constructor(urnName: string, args: GroupArgs, dependsOn?: pulumi.Resource[]) {
        if (args.launchConfiguration === undefined) {
            throw new Error("Missing required property 'launchConfiguration'");
        }
        if (args.maxSize === undefined) {
            throw new Error("Missing required property 'maxSize'");
        }
        if (args.minSize === undefined) {
            throw new Error("Missing required property 'minSize'");
        }
        super("aws:autoscaling/group:Group", urnName, {
            "availabilityZones": args.availabilityZones,
            "defaultCooldown": args.defaultCooldown,
            "desiredCapacity": args.desiredCapacity,
            "enabledMetrics": args.enabledMetrics,
            "forceDelete": args.forceDelete,
            "healthCheckGracePeriod": args.healthCheckGracePeriod,
            "healthCheckType": args.healthCheckType,
            "initialLifecycleHook": args.initialLifecycleHook,
            "launchConfiguration": args.launchConfiguration,
            "loadBalancers": args.loadBalancers,
            "maxSize": args.maxSize,
            "metricsGranularity": args.metricsGranularity,
            "minElbCapacity": args.minElbCapacity,
            "minSize": args.minSize,
            "name": args.name,
            "namePrefix": args.namePrefix,
            "placementGroup": args.placementGroup,
            "protectFromScaleIn": args.protectFromScaleIn,
            "suspendedProcesses": args.suspendedProcesses,
            "tag": args.tag,
            "tags": args.tags,
            "targetGroupArns": args.targetGroupArns,
            "terminationPolicies": args.terminationPolicies,
            "vpcZoneIdentifier": args.vpcZoneIdentifier,
            "waitForCapacityTimeout": args.waitForCapacityTimeout,
            "waitForElbCapacity": args.waitForElbCapacity,
            "arn": undefined,
        }, dependsOn);
    }
}

/**
 * The set of arguments for constructing a Group resource.
 */
export interface GroupArgs {
    /**
     * A list of AZs to launch resources in.
     * Required only if you do not specify any `vpc_zone_identifier`
     */
    readonly availabilityZones?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
     */
    readonly defaultCooldown?: pulumi.ComputedValue<number>;
    /**
     * The number of Amazon EC2 instances that
     * should be running in the group. (See also [Waiting for
     * Capacity](#waiting-for-capacity) below.)
     */
    readonly desiredCapacity?: pulumi.ComputedValue<number>;
    /**
     * A list of metrics to collect. The allowed values are `GroupMinSize`, `GroupMaxSize`, `GroupDesiredCapacity`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupTerminatingInstances`, `GroupTotalInstances`.
     * * `wait_for_capacity_timeout` (Default: "10m") A maximum
     * [duration](https://golang.org/pkg/time/#ParseDuration) that Terraform should
     * wait for ASG instances to be healthy before timing out.  (See also [Waiting
     * for Capacity](#waiting-for-capacity) below.) Setting this to "0" causes
     * Terraform to skip all Capacity Waiting behavior.
     */
    readonly enabledMetrics?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * Allows deleting the autoscaling group without waiting
     * for all instances in the pool to terminate.  You can force an autoscaling group to delete
     * even if it's in the process of scaling a resource. Normally, Terraform
     * drains all the instances before deleting the group.  This bypasses that
     * behavior and potentially leaves resources dangling.
     */
    readonly forceDelete?: pulumi.ComputedValue<boolean>;
    /**
     * Time (in seconds) after instance comes into service before checking health.
     */
    readonly healthCheckGracePeriod?: pulumi.ComputedValue<number>;
    /**
     * "EC2" or "ELB". Controls how health checking is done.
     */
    readonly healthCheckType?: pulumi.ComputedValue<string>;
    /**
     * One or more
     * [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
     * to attach to the autoscaling group **before** instances are launched. The
     * syntax is exactly the same as the separate
     * [`aws_autoscaling_lifecycle_hook`](/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
     * resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
     * a new autoscaling group. For all other use-cases, please use `aws_autoscaling_lifecycle_hook` resource.
     */
    readonly initialLifecycleHook?: pulumi.ComputedValue<{ defaultResult?: pulumi.ComputedValue<string>, heartbeatTimeout?: pulumi.ComputedValue<number>, lifecycleTransition: pulumi.ComputedValue<string>, name: pulumi.ComputedValue<string>, notificationMetadata?: pulumi.ComputedValue<string>, notificationTargetArn?: pulumi.ComputedValue<string>, roleArn?: pulumi.ComputedValue<string> }>[];
    /**
     * The name of the launch configuration to use.
     */
    readonly launchConfiguration: pulumi.ComputedValue<string>;
    /**
     * A list of elastic load balancer names to add to the autoscaling
     * group names.
     */
    readonly loadBalancers?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * The maximum size of the auto scale group.
     */
    readonly maxSize: pulumi.ComputedValue<number>;
    /**
     * The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
     */
    readonly metricsGranularity?: pulumi.ComputedValue<string>;
    /**
     * Setting this causes Terraform to wait for
     * this number of instances to show up healthy in the ELB only on creation.
     * Updates will not wait on ELB instance number changes.
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    readonly minElbCapacity?: pulumi.ComputedValue<number>;
    /**
     * The minimum size of the auto scale group.
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    readonly minSize: pulumi.ComputedValue<number>;
    /**
     * The name of the auto scaling group. By default generated by Terraform.
     */
    readonly name?: pulumi.ComputedValue<string>;
    /**
     * Creates a unique name beginning with the specified
     * prefix. Conflicts with `name`.
     */
    readonly namePrefix?: pulumi.ComputedValue<string>;
    /**
     * The name of the placement group into which you'll launch your instances, if any.
     */
    readonly placementGroup?: pulumi.ComputedValue<string>;
    /**
     * Allows setting instance protection. The
     * autoscaling group will not select instances with this setting for terminination
     * during scale in events.
     */
    readonly protectFromScaleIn?: pulumi.ComputedValue<boolean>;
    /**
     * A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
     * Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
     */
    readonly suspendedProcesses?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * A list of tag blocks. Tags documented below.
     */
    readonly tag?: pulumi.ComputedValue<{ key: pulumi.ComputedValue<string>, propagateAtLaunch: pulumi.ComputedValue<boolean>, value: pulumi.ComputedValue<string> }>[];
    /**
     * A list of tag blocks (maps). Tags documented below.
     */
    readonly tags?: pulumi.ComputedValue<pulumi.ComputedValue<{[key: string]: any}>>[];
    /**
     * A list of `aws_alb_target_group` ARNs, for use with
     * Application Load Balancing
     */
    readonly targetGroupArns?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `Default`.
     */
    readonly terminationPolicies?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    /**
     * A list of subnet IDs to launch resources in.
     */
    readonly vpcZoneIdentifier?: pulumi.ComputedValue<pulumi.ComputedValue<string>>[];
    readonly waitForCapacityTimeout?: pulumi.ComputedValue<string>;
    /**
     * Setting this will cause Terraform to wait
     * for exactly this number of healthy instances in all attached load balancers
     * on both create and update operations. (Takes precedence over
     * `min_elb_capacity` behavior.)
     * (See also [Waiting for Capacity](#waiting-for-capacity) below.)
     */
    readonly waitForElbCapacity?: pulumi.ComputedValue<number>;
}

