// *** WARNING: this file was generated by the Pulumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as fabric from "@pulumi/pulumi-fabric";

export class Distribution extends fabric.Resource {
    public /*out*/ readonly activeTrustedSigners: fabric.Computed<{[key: string]: any}>;
    public readonly aliases?: fabric.Computed<string[]>;
    public /*out*/ readonly arn: fabric.Computed<string>;
    public readonly cacheBehavior?: fabric.Computed<{ allowedMethods: string[], cachedMethods: string[], compress?: boolean, defaultTtl: number, forwardedValues: { cookies: { forward: string, whitelistedNames?: string[] }[], headers?: string[], queryString: boolean, queryStringCacheKeys?: string[] }[], lambdaFunctionAssociation?: { eventType: string, lambdaArn: string }[], maxTtl: number, minTtl: number, pathPattern: string, smoothStreaming?: boolean, targetOriginId: string, trustedSigners?: string[], viewerProtocolPolicy: string }[]>;
    public /*out*/ readonly callerReference: fabric.Computed<string>;
    public readonly comment?: fabric.Computed<string>;
    public readonly customErrorResponse?: fabric.Computed<{ errorCachingMinTtl?: number, errorCode: number, responseCode?: number, responsePagePath?: string }[]>;
    public readonly defaultCacheBehavior: fabric.Computed<{ allowedMethods: string[], cachedMethods: string[], compress?: boolean, defaultTtl: number, forwardedValues: { cookies: { forward: string, whitelistedNames?: string[] }[], headers?: string[], queryString: boolean, queryStringCacheKeys?: string[] }[], lambdaFunctionAssociation?: { eventType: string, lambdaArn: string }[], maxTtl: number, minTtl: number, smoothStreaming?: boolean, targetOriginId: string, trustedSigners?: string[], viewerProtocolPolicy: string }[]>;
    public readonly defaultRootObject?: fabric.Computed<string>;
    public /*out*/ readonly domainName: fabric.Computed<string>;
    public readonly enabled: fabric.Computed<boolean>;
    public /*out*/ readonly etag: fabric.Computed<string>;
    public /*out*/ readonly hostedZoneId: fabric.Computed<string>;
    public readonly httpVersion?: fabric.Computed<string>;
    public /*out*/ readonly inProgressValidationBatches: fabric.Computed<number>;
    public readonly isIpv6Enabled?: fabric.Computed<boolean>;
    public /*out*/ readonly lastModifiedTime: fabric.Computed<string>;
    public readonly loggingConfig?: fabric.Computed<{ bucket: string, includeCookies?: boolean, prefix?: string }[]>;
    public readonly origin: fabric.Computed<{ customHeader?: { name: string, value: string }[], customOriginConfig?: { httpPort: number, httpsPort: number, originKeepaliveTimeout?: number, originProtocolPolicy: string, originReadTimeout?: number, originSslProtocols: string[] }[], domainName: string, originId: string, originPath?: string, s3OriginConfig?: { originAccessIdentity: string }[] }[]>;
    public readonly priceClass?: fabric.Computed<string>;
    public readonly restrictions: fabric.Computed<{ geoRestriction: { locations?: string[], restrictionType: string }[] }[]>;
    public readonly retainOnDelete?: fabric.Computed<boolean>;
    public /*out*/ readonly status: fabric.Computed<string>;
    public readonly tags?: fabric.Computed<{[key: string]: any}>;
    public readonly viewerCertificate: fabric.Computed<{ acmCertificateArn?: string, cloudfrontDefaultCertificate?: boolean, iamCertificateId?: string, minimumProtocolVersion?: string, sslSupportMethod?: string }[]>;
    public readonly webAclId?: fabric.Computed<string>;

    constructor(urnName: string, args: DistributionArgs, dependsOn?: fabric.Resource[]) {
        if (args.defaultCacheBehavior === undefined) {
            throw new Error("Missing required property 'defaultCacheBehavior'");
        }
        if (args.enabled === undefined) {
            throw new Error("Missing required property 'enabled'");
        }
        if (args.origin === undefined) {
            throw new Error("Missing required property 'origin'");
        }
        if (args.restrictions === undefined) {
            throw new Error("Missing required property 'restrictions'");
        }
        if (args.viewerCertificate === undefined) {
            throw new Error("Missing required property 'viewerCertificate'");
        }
        super("aws:cloudfront/distribution:Distribution", urnName, {
            "aliases": args.aliases,
            "cacheBehavior": args.cacheBehavior,
            "comment": args.comment,
            "customErrorResponse": args.customErrorResponse,
            "defaultCacheBehavior": args.defaultCacheBehavior,
            "defaultRootObject": args.defaultRootObject,
            "enabled": args.enabled,
            "httpVersion": args.httpVersion,
            "isIpv6Enabled": args.isIpv6Enabled,
            "loggingConfig": args.loggingConfig,
            "origin": args.origin,
            "priceClass": args.priceClass,
            "restrictions": args.restrictions,
            "retainOnDelete": args.retainOnDelete,
            "tags": args.tags,
            "viewerCertificate": args.viewerCertificate,
            "webAclId": args.webAclId,
            "activeTrustedSigners": undefined,
            "arn": undefined,
            "callerReference": undefined,
            "domainName": undefined,
            "etag": undefined,
            "hostedZoneId": undefined,
            "inProgressValidationBatches": undefined,
            "lastModifiedTime": undefined,
            "status": undefined,
        }, dependsOn);
    }
}

export interface DistributionArgs {
    readonly aliases?: fabric.ComputedValue<fabric.ComputedValue<string>>[];
    readonly cacheBehavior?: fabric.ComputedValue<{ allowedMethods: fabric.ComputedValue<fabric.ComputedValue<string>>[], cachedMethods: fabric.ComputedValue<fabric.ComputedValue<string>>[], compress?: fabric.ComputedValue<boolean>, defaultTtl: fabric.ComputedValue<number>, forwardedValues: fabric.ComputedValue<{ cookies: fabric.ComputedValue<{ forward: fabric.ComputedValue<string>, whitelistedNames?: fabric.ComputedValue<fabric.ComputedValue<string>>[] }>[], headers?: fabric.ComputedValue<fabric.ComputedValue<string>>[], queryString: fabric.ComputedValue<boolean>, queryStringCacheKeys?: fabric.ComputedValue<fabric.ComputedValue<string>>[] }>[], lambdaFunctionAssociation?: fabric.ComputedValue<{ eventType: fabric.ComputedValue<string>, lambdaArn: fabric.ComputedValue<string> }>[], maxTtl: fabric.ComputedValue<number>, minTtl: fabric.ComputedValue<number>, pathPattern: fabric.ComputedValue<string>, smoothStreaming?: fabric.ComputedValue<boolean>, targetOriginId: fabric.ComputedValue<string>, trustedSigners?: fabric.ComputedValue<fabric.ComputedValue<string>>[], viewerProtocolPolicy: fabric.ComputedValue<string> }>[];
    readonly comment?: fabric.ComputedValue<string>;
    readonly customErrorResponse?: fabric.ComputedValue<{ errorCachingMinTtl?: fabric.ComputedValue<number>, errorCode: fabric.ComputedValue<number>, responseCode?: fabric.ComputedValue<number>, responsePagePath?: fabric.ComputedValue<string> }>[];
    readonly defaultCacheBehavior: fabric.ComputedValue<{ allowedMethods: fabric.ComputedValue<fabric.ComputedValue<string>>[], cachedMethods: fabric.ComputedValue<fabric.ComputedValue<string>>[], compress?: fabric.ComputedValue<boolean>, defaultTtl: fabric.ComputedValue<number>, forwardedValues: fabric.ComputedValue<{ cookies: fabric.ComputedValue<{ forward: fabric.ComputedValue<string>, whitelistedNames?: fabric.ComputedValue<fabric.ComputedValue<string>>[] }>[], headers?: fabric.ComputedValue<fabric.ComputedValue<string>>[], queryString: fabric.ComputedValue<boolean>, queryStringCacheKeys?: fabric.ComputedValue<fabric.ComputedValue<string>>[] }>[], lambdaFunctionAssociation?: fabric.ComputedValue<{ eventType: fabric.ComputedValue<string>, lambdaArn: fabric.ComputedValue<string> }>[], maxTtl: fabric.ComputedValue<number>, minTtl: fabric.ComputedValue<number>, smoothStreaming?: fabric.ComputedValue<boolean>, targetOriginId: fabric.ComputedValue<string>, trustedSigners?: fabric.ComputedValue<fabric.ComputedValue<string>>[], viewerProtocolPolicy: fabric.ComputedValue<string> }>[];
    readonly defaultRootObject?: fabric.ComputedValue<string>;
    readonly enabled: fabric.ComputedValue<boolean>;
    readonly httpVersion?: fabric.ComputedValue<string>;
    readonly isIpv6Enabled?: fabric.ComputedValue<boolean>;
    readonly loggingConfig?: fabric.ComputedValue<{ bucket: fabric.ComputedValue<string>, includeCookies?: fabric.ComputedValue<boolean>, prefix?: fabric.ComputedValue<string> }>[];
    readonly origin: fabric.ComputedValue<{ customHeader?: fabric.ComputedValue<{ name: fabric.ComputedValue<string>, value: fabric.ComputedValue<string> }>[], customOriginConfig?: fabric.ComputedValue<{ httpPort: fabric.ComputedValue<number>, httpsPort: fabric.ComputedValue<number>, originKeepaliveTimeout?: fabric.ComputedValue<number>, originProtocolPolicy: fabric.ComputedValue<string>, originReadTimeout?: fabric.ComputedValue<number>, originSslProtocols: fabric.ComputedValue<fabric.ComputedValue<string>>[] }>[], domainName: fabric.ComputedValue<string>, originId: fabric.ComputedValue<string>, originPath?: fabric.ComputedValue<string>, s3OriginConfig?: fabric.ComputedValue<{ originAccessIdentity: fabric.ComputedValue<string> }>[] }>[];
    readonly priceClass?: fabric.ComputedValue<string>;
    readonly restrictions: fabric.ComputedValue<{ geoRestriction: fabric.ComputedValue<{ locations?: fabric.ComputedValue<fabric.ComputedValue<string>>[], restrictionType: fabric.ComputedValue<string> }>[] }>[];
    readonly retainOnDelete?: fabric.ComputedValue<boolean>;
    readonly tags?: fabric.ComputedValue<{[key: string]: any}>;
    readonly viewerCertificate: fabric.ComputedValue<{ acmCertificateArn?: fabric.ComputedValue<string>, cloudfrontDefaultCertificate?: fabric.ComputedValue<boolean>, iamCertificateId?: fabric.ComputedValue<string>, minimumProtocolVersion?: fabric.ComputedValue<string>, sslSupportMethod?: fabric.ComputedValue<string> }>[];
    readonly webAclId?: fabric.ComputedValue<string>;
}

